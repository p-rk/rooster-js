var PiTextEditor = (function (exports) {
    'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends$4(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$k = function() {
        __assign$k = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$k.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __spreadArray$2(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var react = {exports: {}};

    var react_production_min = {};

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };

    /** @license React v16.14.0
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l=objectAssign,n$1="function"===typeof Symbol&&Symbol.for,p=n$1?Symbol.for("react.element"):60103,q=n$1?Symbol.for("react.portal"):60106,r$1=n$1?Symbol.for("react.fragment"):60107,t=n$1?Symbol.for("react.strict_mode"):60108,u$1=n$1?Symbol.for("react.profiler"):60114,v$1=n$1?Symbol.for("react.provider"):60109,w=n$1?Symbol.for("react.context"):60110,x=n$1?Symbol.for("react.forward_ref"):60112,y=n$1?Symbol.for("react.suspense"):60113,z=n$1?Symbol.for("react.memo"):60115,A=n$1?Symbol.for("react.lazy"):
    60116,B="function"===typeof Symbol&&Symbol.iterator;function C$1(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
    var D={isMounted:function(){return !1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E$1={};function F$1(a,b,c){this.props=a;this.context=b;this.refs=E$1;this.updater=c||D;}F$1.prototype.isReactComponent={};F$1.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(C$1(85));this.updater.enqueueSetState(this,a,b,"setState");};F$1.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};
    function G$1(){}G$1.prototype=F$1.prototype;function H$1(a,b,c){this.props=a;this.context=b;this.refs=E$1;this.updater=c||D;}var I$1=H$1.prototype=new G$1;I$1.constructor=H$1;l(I$1,F$1.prototype);I$1.isPureReactComponent=!0;var J$1={current:null},K$1=Object.prototype.hasOwnProperty,L$1={key:!0,ref:!0,__self:!0,__source:!0};
    function M$1(a,b,c){var e,d={},g=null,k=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K$1.call(b,e)&&!L$1.hasOwnProperty(e)&&(d[e]=b[e]);var f=arguments.length-2;if(1===f)d.children=c;else if(1<f){for(var h=Array(f),m=0;m<f;m++)h[m]=arguments[m+2];d.children=h;}if(a&&a.defaultProps)for(e in f=a.defaultProps,f)void 0===d[e]&&(d[e]=f[e]);return {$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J$1.current}}
    function N$1(a,b){return {$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O$1(a){return "object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return "$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P$1=/\/+/g,Q$1=[];function R$1(a,b,c,e){if(Q$1.length){var d=Q$1.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return {result:a,keyPrefix:b,func:c,context:e,count:0}}
    function S$1(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q$1.length&&Q$1.push(a);}
    function T$1(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0;}}if(g)return c(e,a,""===b?"."+U$1(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+U$1(d,k);g+=T$1(d,f,c,e);}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=
    0;!(d=a.next()).done;)d=d.value,f=b+U$1(d,k++),g+=T$1(d,f,c,e);else if("object"===d)throw c=""+a,Error(C$1(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return g}function V$1(a,b,c){return null==a?0:T$1(a,"",b,c)}function U$1(a,b){return "object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function W$1(a,b){a.func.call(a.context,b,a.count++);}
    function aa$1(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X$1(a,e,c,function(a){return a}):null!=a&&(O$1(a)&&(a=N$1(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P$1,"$&/")+"/")+c)),e.push(a));}function X$1(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P$1,"$&/")+"/");b=R$1(b,g,e,d);V$1(a,aa$1,b);S$1(b);}var Y$1={current:null};function Z$1(){var a=Y$1.current;if(null===a)throw Error(C$1(321));return a}
    var ba$1={ReactCurrentDispatcher:Y$1,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J$1,IsSomeRendererActing:{current:!1},assign:l};react_production_min.Children={map:function(a,b,c){if(null==a)return a;var e=[];X$1(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a)return a;b=R$1(null,null,b,c);V$1(a,W$1,b);S$1(b);},count:function(a){return V$1(a,function(){return null},null)},toArray:function(a){var b=[];X$1(a,b,null,function(a){return a});return b},only:function(a){if(!O$1(a))throw Error(C$1(143));return a}};
    react_production_min.Component=F$1;react_production_min.Fragment=r$1;react_production_min.Profiler=u$1;react_production_min.PureComponent=H$1;react_production_min.StrictMode=t;react_production_min.Suspense=y;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba$1;
    react_production_min.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(C$1(267,a));var e=l({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J$1.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)K$1.call(b,h)&&!L$1.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h]);}var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){f=Array(h);for(var m=0;m<h;m++)f[m]=arguments[m+2];e.children=f;}return {$$typeof:p,type:a.type,
    key:d,ref:g,props:e,_owner:k}};react_production_min.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v$1,_context:a};return a.Consumer=a};react_production_min.createElement=M$1;react_production_min.createFactory=function(a){var b=M$1.bind(null,a);b.type=a;return b};react_production_min.createRef=function(){return {current:null}};react_production_min.forwardRef=function(a){return {$$typeof:x,render:a}};react_production_min.isValidElement=O$1;
    react_production_min.lazy=function(a){return {$$typeof:A,_ctor:a,_status:-1,_result:null}};react_production_min.memo=function(a,b){return {$$typeof:z,type:a,compare:void 0===b?null:b}};react_production_min.useCallback=function(a,b){return Z$1().useCallback(a,b)};react_production_min.useContext=function(a,b){return Z$1().useContext(a,b)};react_production_min.useDebugValue=function(){};react_production_min.useEffect=function(a,b){return Z$1().useEffect(a,b)};react_production_min.useImperativeHandle=function(a,b,c){return Z$1().useImperativeHandle(a,b,c)};
    react_production_min.useLayoutEffect=function(a,b){return Z$1().useLayoutEffect(a,b)};react_production_min.useMemo=function(a,b){return Z$1().useMemo(a,b)};react_production_min.useReducer=function(a,b,c){return Z$1().useReducer(a,b,c)};react_production_min.useRef=function(a){return Z$1().useRef(a)};react_production_min.useState=function(a){return Z$1().useState(a)};react_production_min.version="16.14.0";

    {
      react.exports = react_production_min;
    }

    // A packages cache that makes sure that we don't inject the same packageName twice in the same bundle -
    // this cache is local to the module closure inside this bundle
    var packagesCache = {};
    // Cache access to window to avoid IE11 memory leak.
    var _win = undefined;
    try {
        _win = window;
    }
    catch (e) {
        /* no-op */
    }
    function setVersion(packageName, packageVersion) {
        if (typeof _win !== 'undefined') {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var packages = (_win.__packages__ = _win.__packages__ || {});
            // We allow either the global packages or local packages caches to invalidate so testing can
            // just clear the global to set this state
            if (!packages[packageName] || !packagesCache[packageName]) {
                packagesCache[packageName] = packageVersion;
                var versions = (packages[packageName] = packages[packageName] || []);
                versions.push(packageVersion);
            }
        }
    }

    setVersion('@fluentui/set-version', '6.0.0');

    // Do not modify this file; it is generated as part of publish.
    setVersion('@fluentui/react', '8.56.2');

    var InjectionMode = {
        /**
         * Avoids style injection, use getRules() to read the styles.
         */
        none: 0,
        /**
         * Inserts rules using the insertRule api.
         */
        insertNode: 1,
        /**
         * Appends rules using appendChild.
         */
        appendChild: 2,
    };
    var STYLESHEET_SETTING = '__stylesheet__';
    /**
     * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node
     * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.
     */
    var REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);
    var _global$1 = {};
    // Grab window.
    try {
        // Why the cast?
        // if compiled/type checked in same program with `@fluentui/font-icons-mdl2` which extends `Window` on global
        // ( check packages/font-icons-mdl2/src/index.ts ) the definitions don't match! Thus the need of this extra assertion
        _global$1 = (window || {});
    }
    catch (_a) {
        /* leave as blank object */
    }
    var _stylesheet;
    /**
     * Represents the state of styles registered in the page. Abstracts
     * the surface for adding styles to the stylesheet, exposes helpers
     * for reading the styles registered in server rendered scenarios.
     *
     * @public
     */
    var Stylesheet = /** @class */ (function () {
        function Stylesheet(config, serializedStylesheet) {
            var _a, _b, _c, _d, _e, _f;
            this._rules = [];
            this._preservedRules = [];
            this._counter = 0;
            this._keyToClassName = {};
            this._onInsertRuleCallbacks = [];
            this._onResetCallbacks = [];
            this._classNameToArgs = {};
            this._config = __assign$k({ 
                // If there is no document we won't have an element to inject into.
                injectionMode: typeof document === 'undefined' ? InjectionMode.none : InjectionMode.insertNode, defaultPrefix: 'css', namespace: undefined, cspSettings: undefined }, config);
            this._classNameToArgs = (_a = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.classNameToArgs) !== null && _a !== void 0 ? _a : this._classNameToArgs;
            this._counter = (_b = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.counter) !== null && _b !== void 0 ? _b : this._counter;
            this._keyToClassName = (_d = (_c = this._config.classNameCache) !== null && _c !== void 0 ? _c : serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.keyToClassName) !== null && _d !== void 0 ? _d : this._keyToClassName;
            this._preservedRules = (_e = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.preservedRules) !== null && _e !== void 0 ? _e : this._preservedRules;
            this._rules = (_f = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.rules) !== null && _f !== void 0 ? _f : this._rules;
        }
        /**
         * Gets the singleton instance.
         */
        Stylesheet.getInstance = function () {
            _stylesheet = _global$1[STYLESHEET_SETTING];
            if (!_stylesheet || (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document)) {
                var fabricConfig = (_global$1 === null || _global$1 === void 0 ? void 0 : _global$1.FabricConfig) || {};
                var stylesheet = new Stylesheet(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);
                _stylesheet = stylesheet;
                _global$1[STYLESHEET_SETTING] = stylesheet;
            }
            return _stylesheet;
        };
        /**
         * Serializes the Stylesheet instance into a format which allows rehydration on creation.
         * @returns string representation of `ISerializedStylesheet` interface.
         */
        Stylesheet.prototype.serialize = function () {
            return JSON.stringify({
                classNameToArgs: this._classNameToArgs,
                counter: this._counter,
                keyToClassName: this._keyToClassName,
                preservedRules: this._preservedRules,
                rules: this._rules,
            });
        };
        /**
         * Configures the stylesheet.
         */
        Stylesheet.prototype.setConfig = function (config) {
            this._config = __assign$k(__assign$k({}, this._config), config);
        };
        /**
         * Configures a reset callback.
         *
         * @param callback - A callback which will be called when the Stylesheet is reset.
         * @returns function which when called un-registers provided callback.
         */
        Stylesheet.prototype.onReset = function (callback) {
            var _this = this;
            this._onResetCallbacks.push(callback);
            return function () {
                _this._onResetCallbacks = _this._onResetCallbacks.filter(function (cb) { return cb !== callback; });
            };
        };
        /**
         * Configures an insert rule callback.
         *
         * @param callback - A callback which will be called when a rule is inserted.
         * @returns function which when called un-registers provided callback.
         */
        Stylesheet.prototype.onInsertRule = function (callback) {
            var _this = this;
            this._onInsertRuleCallbacks.push(callback);
            return function () {
                _this._onInsertRuleCallbacks = _this._onInsertRuleCallbacks.filter(function (cb) { return cb !== callback; });
            };
        };
        /**
         * Generates a unique classname.
         *
         * @param displayName - Optional value to use as a prefix.
         */
        Stylesheet.prototype.getClassName = function (displayName) {
            var namespace = this._config.namespace;
            var prefix = displayName || this._config.defaultPrefix;
            return "" + (namespace ? namespace + '-' : '') + prefix + "-" + this._counter++;
        };
        /**
         * Used internally to cache information about a class which was
         * registered with the stylesheet.
         */
        Stylesheet.prototype.cacheClassName = function (className, key, args, rules) {
            this._keyToClassName[key] = className;
            this._classNameToArgs[className] = {
                args: args,
                rules: rules,
            };
        };
        /**
         * Gets the appropriate classname given a key which was previously
         * registered using cacheClassName.
         */
        Stylesheet.prototype.classNameFromKey = function (key) {
            return this._keyToClassName[key];
        };
        /**
         * Gets all classnames cache with the stylesheet.
         */
        Stylesheet.prototype.getClassNameCache = function () {
            return this._keyToClassName;
        };
        /**
         * Gets the arguments associated with a given classname which was
         * previously registered using cacheClassName.
         */
        Stylesheet.prototype.argsFromClassName = function (className) {
            var entry = this._classNameToArgs[className];
            return entry && entry.args;
        };
        /**
         * Gets the rules associated with a given classname which was
         * previously registered using cacheClassName.
         */
        Stylesheet.prototype.insertedRulesFromClassName = function (className) {
            var entry = this._classNameToArgs[className];
            return entry && entry.rules;
        };
        /**
         * Inserts a css rule into the stylesheet.
         * @param preserve - Preserves the rule beyond a reset boundary.
         */
        Stylesheet.prototype.insertRule = function (rule, preserve) {
            var injectionMode = this._config.injectionMode;
            var element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;
            if (preserve) {
                this._preservedRules.push(rule);
            }
            if (element) {
                switch (injectionMode) {
                    case InjectionMode.insertNode:
                        var sheet = element.sheet;
                        try {
                            sheet.insertRule(rule, sheet.cssRules.length);
                        }
                        catch (e) {
                            // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)
                            // We need to swallow the exceptions for this scenario, otherwise we'd need to filter
                            // which could be slower and bulkier.
                        }
                        break;
                    case InjectionMode.appendChild:
                        element.appendChild(document.createTextNode(rule));
                        break;
                }
            }
            else {
                this._rules.push(rule);
            }
            // eslint-disable-next-line deprecation/deprecation
            if (this._config.onInsertRule) {
                // eslint-disable-next-line deprecation/deprecation
                this._config.onInsertRule(rule);
            }
            this._onInsertRuleCallbacks.forEach(function (callback) { return callback(); });
        };
        /**
         * Gets all rules registered with the stylesheet; only valid when
         * using InsertionMode.none.
         */
        Stylesheet.prototype.getRules = function (includePreservedRules) {
            return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('');
        };
        /**
         * Resets the internal state of the stylesheet. Only used in server
         * rendered scenarios where we're using InsertionMode.none.
         */
        Stylesheet.prototype.reset = function () {
            this._rules = [];
            this._counter = 0;
            this._classNameToArgs = {};
            this._keyToClassName = {};
            this._onResetCallbacks.forEach(function (callback) { return callback(); });
        };
        // Forces the regeneration of incoming styles without totally resetting the stylesheet.
        Stylesheet.prototype.resetKeys = function () {
            this._keyToClassName = {};
        };
        Stylesheet.prototype._getStyleElement = function () {
            var _this = this;
            if (!this._styleElement && typeof document !== 'undefined') {
                this._styleElement = this._createStyleElement();
                if (!REUSE_STYLE_NODE) {
                    // Reset the style element on the next frame.
                    window.requestAnimationFrame(function () {
                        _this._styleElement = undefined;
                    });
                }
            }
            return this._styleElement;
        };
        Stylesheet.prototype._createStyleElement = function () {
            var head = document.head;
            var styleElement = document.createElement('style');
            var nodeToInsertBefore = null;
            styleElement.setAttribute('data-merge-styles', 'true');
            var cspSettings = this._config.cspSettings;
            if (cspSettings) {
                if (cspSettings.nonce) {
                    styleElement.setAttribute('nonce', cspSettings.nonce);
                }
            }
            if (this._lastStyleElement) {
                // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.
                // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax
                nodeToInsertBefore = this._lastStyleElement.nextElementSibling;
            }
            else {
                var placeholderStyleTag = this._findPlaceholderStyleTag();
                if (placeholderStyleTag) {
                    nodeToInsertBefore = placeholderStyleTag.nextElementSibling;
                }
                else {
                    nodeToInsertBefore = head.childNodes[0];
                }
            }
            head.insertBefore(styleElement, head.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);
            this._lastStyleElement = styleElement;
            return styleElement;
        };
        Stylesheet.prototype._findPlaceholderStyleTag = function () {
            var head = document.head;
            if (head) {
                return head.querySelector('style[data-merge-styles]');
            }
            return null;
        };
        return Stylesheet;
    }());

    /**
     * Separates the classes and style objects. Any classes that are pre-registered
     * args are auto expanded into objects.
     */
    function extractStyleParts() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var classes = [];
        var objects = [];
        var stylesheet = Stylesheet.getInstance();
        function _processArgs(argsList) {
            for (var _i = 0, argsList_1 = argsList; _i < argsList_1.length; _i++) {
                var arg = argsList_1[_i];
                if (arg) {
                    if (typeof arg === 'string') {
                        if (arg.indexOf(' ') >= 0) {
                            _processArgs(arg.split(' '));
                        }
                        else {
                            var translatedArgs = stylesheet.argsFromClassName(arg);
                            if (translatedArgs) {
                                _processArgs(translatedArgs);
                            }
                            else {
                                // Avoid adding the same class twice.
                                if (classes.indexOf(arg) === -1) {
                                    classes.push(arg);
                                }
                            }
                        }
                    }
                    else if (Array.isArray(arg)) {
                        _processArgs(arg);
                    }
                    else if (typeof arg === 'object') {
                        objects.push(arg);
                    }
                }
            }
        }
        _processArgs(args);
        return {
            classes: classes,
            objects: objects,
        };
    }

    /**
     * Sets the current RTL value.
     */
    function setRTL$1(isRTL) {
        if (_rtl !== isRTL) {
            _rtl = isRTL;
        }
    }
    /**
     * Gets the current RTL value.
     */
    function getRTL$1() {
        if (_rtl === undefined) {
            _rtl =
                typeof document !== 'undefined' &&
                    !!document.documentElement &&
                    document.documentElement.getAttribute('dir') === 'rtl';
        }
        return _rtl;
    }
    // This has been split into 2 lines because it was working in Fabric due to the code being transpiled to es5, so this
    // was converted to var while not working in Fluent that uses babel to transpile the code to be es6-like. Splitting the
    // logic into two lines, however, allows it to work in both scenarios.
    var _rtl;
    _rtl = getRTL$1();
    function getStyleOptions() {
        return {
            rtl: getRTL$1(),
        };
    }

    var rules = {};
    function kebabRules(rulePairs, index) {
        var rule = rulePairs[index];
        if (rule.charAt(0) !== '-') {
            rulePairs[index] = rules[rule] = rules[rule] || rule.replace(/([A-Z])/g, '-$1').toLowerCase();
        }
    }

    var _vendorSettings;
    function getVendorSettings() {
        var _a;
        if (!_vendorSettings) {
            var doc = typeof document !== 'undefined' ? document : undefined;
            var nav = typeof navigator !== 'undefined' ? navigator : undefined;
            var userAgent = (_a = nav === null || nav === void 0 ? void 0 : nav.userAgent) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (!doc) {
                _vendorSettings = {
                    isWebkit: true,
                    isMoz: true,
                    isOpera: true,
                    isMs: true,
                };
            }
            else {
                _vendorSettings = {
                    isWebkit: !!(doc && 'WebkitAppearance' in doc.documentElement.style),
                    isMoz: !!(userAgent && userAgent.indexOf('firefox') > -1),
                    isOpera: !!(userAgent && userAgent.indexOf('opera') > -1),
                    isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\/\d./i.test(navigator.userAgent))),
                };
            }
        }
        return _vendorSettings;
    }

    var autoPrefixNames = {
        'user-select': 1,
    };
    function prefixRules(rulePairs, index) {
        var vendorSettings = getVendorSettings();
        var name = rulePairs[index];
        if (autoPrefixNames[name]) {
            var value = rulePairs[index + 1];
            if (autoPrefixNames[name]) {
                if (vendorSettings.isWebkit) {
                    rulePairs.push('-webkit-' + name, value);
                }
                if (vendorSettings.isMoz) {
                    rulePairs.push('-moz-' + name, value);
                }
                if (vendorSettings.isMs) {
                    rulePairs.push('-ms-' + name, value);
                }
                if (vendorSettings.isOpera) {
                    rulePairs.push('-o-' + name, value);
                }
            }
        }
    }

    var NON_PIXEL_NUMBER_PROPS = [
        'column-count',
        'font-weight',
        'flex',
        'flex-grow',
        'flex-shrink',
        'fill-opacity',
        'opacity',
        'order',
        'z-index',
        'zoom',
    ];
    function provideUnits(rulePairs, index) {
        var name = rulePairs[index];
        var value = rulePairs[index + 1];
        if (typeof value === 'number') {
            var isNonPixelProp = NON_PIXEL_NUMBER_PROPS.indexOf(name) > -1;
            var isVariableOrPrefixed = name.indexOf('--') > -1;
            var unit = isNonPixelProp || isVariableOrPrefixed ? '' : 'px';
            rulePairs[index + 1] = "" + value + unit;
        }
    }

    var _a$b;
    var LEFT = 'left';
    var RIGHT = 'right';
    var NO_FLIP = '@noflip';
    var NAME_REPLACEMENTS = (_a$b = {},
        _a$b[LEFT] = RIGHT,
        _a$b[RIGHT] = LEFT,
        _a$b);
    var VALUE_REPLACEMENTS = {
        'w-resize': 'e-resize',
        'sw-resize': 'se-resize',
        'nw-resize': 'ne-resize',
    };
    /**
     * RTLifies the rulePair in the array at the current index. This mutates the array for performance
     * reasons.
     */
    function rtlifyRules(options, rulePairs, index) {
        if (options.rtl) {
            var name_1 = rulePairs[index];
            if (!name_1) {
                return;
            }
            var value = rulePairs[index + 1];
            if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {
                rulePairs[index + 1] = value.replace(/\s*(?:\/\*\s*)?\@noflip\b(?:\s*\*\/)?\s*?/g, '');
            }
            else if (name_1.indexOf(LEFT) >= 0) {
                rulePairs[index] = name_1.replace(LEFT, RIGHT);
            }
            else if (name_1.indexOf(RIGHT) >= 0) {
                rulePairs[index] = name_1.replace(RIGHT, LEFT);
            }
            else if (String(value).indexOf(LEFT) >= 0) {
                rulePairs[index + 1] = value.replace(LEFT, RIGHT);
            }
            else if (String(value).indexOf(RIGHT) >= 0) {
                rulePairs[index + 1] = value.replace(RIGHT, LEFT);
            }
            else if (NAME_REPLACEMENTS[name_1]) {
                rulePairs[index] = NAME_REPLACEMENTS[name_1];
            }
            else if (VALUE_REPLACEMENTS[value]) {
                rulePairs[index + 1] = VALUE_REPLACEMENTS[value];
            }
            else {
                switch (name_1) {
                    case 'margin':
                    case 'padding':
                        rulePairs[index + 1] = flipQuad(value);
                        break;
                    case 'box-shadow':
                        rulePairs[index + 1] = negateNum(value, 0);
                        break;
                }
            }
        }
    }
    /**
     * Given a string value in a space delimited format (e.g. "1 2 3 4"), negates a particular value.
     */
    function negateNum(value, partIndex) {
        var parts = value.split(' ');
        var numberVal = parseInt(parts[partIndex], 10);
        parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));
        return parts.join(' ');
    }
    /**
     * Given a string quad, flips the left and right values.
     */
    function flipQuad(value) {
        if (typeof value === 'string') {
            var parts = value.split(' ');
            if (parts.length === 4) {
                return parts[0] + " " + parts[3] + " " + parts[2] + " " + parts[1];
            }
        }
        return value;
    }

    /**
     * Split a string into tokens separated by whitespace, except all text within parentheses
     * is treated as a single token (whitespace is ignored within parentheses).
     *
     * Unlike String.split(' '), multiple consecutive space characters are collapsed and
     * removed from the returned array (including leading and trailing spaces).
     *
     * For example:
     * `tokenizeWithParentheses("3px calc(var(--x) / 2) 9px    0 ")`
     *   => `["3px", "calc(var(--x) / 2)", "9px", "0"]`
     *
     * @returns The array of tokens. Returns an empty array if the string was empty or contained only whitespace.
     */
    function tokenizeWithParentheses(value) {
        var parts = [];
        var partStart = 0;
        var parens = 0;
        for (var i = 0; i < value.length; i++) {
            switch (value[i]) {
                case '(':
                    parens++;
                    break;
                case ')':
                    if (parens) {
                        parens--;
                    }
                    break;
                case '\t':
                case ' ':
                    if (!parens) {
                        // Add the new part if it's not an empty string
                        if (i > partStart) {
                            parts.push(value.substring(partStart, i));
                        }
                        partStart = i + 1;
                    }
                    break;
            }
        }
        // Add the last part
        if (partStart < value.length) {
            parts.push(value.substring(partStart));
        }
        return parts;
    }

    var DISPLAY_NAME = 'displayName';
    function getDisplayName(rules) {
        var rootStyle = rules && rules['&'];
        return rootStyle ? rootStyle.displayName : undefined;
    }
    var globalSelectorRegExp = /\:global\((.+?)\)/g;
    /**
     * Finds comma separated selectors in a :global() e.g. ":global(.class1, .class2, .class3)"
     * and wraps them each in their own global ":global(.class1), :global(.class2), :global(.class3)"
     *
     * @param selectorWithGlobals The selector to process
     * @returns The updated selector
     */
    function expandCommaSeparatedGlobals(selectorWithGlobals) {
        // We the selector does not have a :global() we can shortcut
        if (!globalSelectorRegExp.test(selectorWithGlobals)) {
            return selectorWithGlobals;
        }
        var replacementInfo = [];
        var findGlobal = /\:global\((.+?)\)/g;
        var match = null;
        // Create a result list for global selectors so we can replace them.
        while ((match = findGlobal.exec(selectorWithGlobals))) {
            // Only if the found selector is a comma separated list we'll process it.
            if (match[1].indexOf(',') > -1) {
                replacementInfo.push([
                    match.index,
                    match.index + match[0].length,
                    // Wrap each of the found selectors in :global()
                    match[1]
                        .split(',')
                        .map(function (v) { return ":global(" + v.trim() + ")"; })
                        .join(', '),
                ]);
            }
        }
        // Replace the found selectors with their wrapped variants in reverse order
        return replacementInfo
            .reverse()
            .reduce(function (selector, _a) {
            var matchIndex = _a[0], matchEndIndex = _a[1], replacement = _a[2];
            var prefix = selector.slice(0, matchIndex);
            var suffix = selector.slice(matchEndIndex);
            return prefix + replacement + suffix;
        }, selectorWithGlobals);
    }
    function expandSelector(newSelector, currentSelector) {
        if (newSelector.indexOf(':global(') >= 0) {
            return newSelector.replace(globalSelectorRegExp, '$1');
        }
        else if (newSelector.indexOf(':') === 0) {
            return currentSelector + newSelector;
        }
        else if (newSelector.indexOf('&') < 0) {
            return currentSelector + ' ' + newSelector;
        }
        return newSelector;
    }
    function extractSelector(currentSelector, rules, selector, value) {
        if (rules === void 0) { rules = { __order: [] }; }
        if (selector.indexOf('@') === 0) {
            selector = selector + '{' + currentSelector;
            extractRules([value], rules, selector);
        }
        else if (selector.indexOf(',') > -1) {
            expandCommaSeparatedGlobals(selector)
                .split(',')
                .map(function (s) { return s.trim(); })
                .forEach(function (separatedSelector) {
                return extractRules([value], rules, expandSelector(separatedSelector, currentSelector));
            });
        }
        else {
            extractRules([value], rules, expandSelector(selector, currentSelector));
        }
    }
    function extractRules(args, rules, currentSelector) {
        if (rules === void 0) { rules = { __order: [] }; }
        if (currentSelector === void 0) { currentSelector = '&'; }
        var stylesheet = Stylesheet.getInstance();
        var currentRules = rules[currentSelector];
        if (!currentRules) {
            currentRules = {};
            rules[currentSelector] = currentRules;
            rules.__order.push(currentSelector);
        }
        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
            var arg = args_1[_i];
            // If the arg is a string, we need to look up the class map and merge.
            if (typeof arg === 'string') {
                var expandedRules = stylesheet.argsFromClassName(arg);
                if (expandedRules) {
                    extractRules(expandedRules, rules, currentSelector);
                }
                // Else if the arg is an array, we need to recurse in.
            }
            else if (Array.isArray(arg)) {
                extractRules(arg, rules, currentSelector);
            }
            else {
                for (var prop in arg) {
                    if (arg.hasOwnProperty(prop)) {
                        var propValue = arg[prop];
                        if (prop === 'selectors') {
                            // every child is a selector.
                            var selectors = arg.selectors;
                            for (var newSelector in selectors) {
                                if (selectors.hasOwnProperty(newSelector)) {
                                    extractSelector(currentSelector, rules, newSelector, selectors[newSelector]);
                                }
                            }
                        }
                        else if (typeof propValue === 'object') {
                            // prop is a selector.
                            if (propValue !== null) {
                                extractSelector(currentSelector, rules, prop, propValue);
                            }
                        }
                        else {
                            if (propValue !== undefined) {
                                // Else, add the rule to the currentSelector.
                                if (prop === 'margin' || prop === 'padding') {
                                    expandQuads(currentRules, prop, propValue);
                                }
                                else {
                                    currentRules[prop] = propValue;
                                }
                            }
                        }
                    }
                }
            }
        }
        return rules;
    }
    function expandQuads(currentRules, name, value) {
        var parts = typeof value === 'string' ? tokenizeWithParentheses(value) : [value];
        if (parts.length === 0) {
            parts.push(value);
        }
        if (parts[parts.length - 1] === '!important') {
            // Remove !important from parts, and append it to each part individually
            parts = parts.slice(0, -1).map(function (p) { return p + ' !important'; });
        }
        currentRules[name + 'Top'] = parts[0];
        currentRules[name + 'Right'] = parts[1] || parts[0];
        currentRules[name + 'Bottom'] = parts[2] || parts[0];
        currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];
    }
    function getKeyForRules(options, rules) {
        var serialized = [options.rtl ? 'rtl' : 'ltr'];
        var hasProps = false;
        for (var _i = 0, _a = rules.__order; _i < _a.length; _i++) {
            var selector = _a[_i];
            serialized.push(selector);
            var rulesForSelector = rules[selector];
            for (var propName in rulesForSelector) {
                if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {
                    hasProps = true;
                    serialized.push(propName, rulesForSelector[propName]);
                }
            }
        }
        return hasProps ? serialized.join('') : undefined;
    }
    function repeatString(target, count) {
        if (count <= 0) {
            return '';
        }
        if (count === 1) {
            return target;
        }
        return target + repeatString(target, count - 1);
    }
    function serializeRuleEntries(options, ruleEntries) {
        if (!ruleEntries) {
            return '';
        }
        var allEntries = [];
        for (var entry in ruleEntries) {
            if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {
                allEntries.push(entry, ruleEntries[entry]);
            }
        }
        // Apply transforms.
        for (var i = 0; i < allEntries.length; i += 2) {
            kebabRules(allEntries, i);
            provideUnits(allEntries, i);
            rtlifyRules(options, allEntries, i);
            prefixRules(allEntries, i);
        }
        // Apply punctuation.
        for (var i = 1; i < allEntries.length; i += 4) {
            allEntries.splice(i, 1, ':', allEntries[i], ';');
        }
        return allEntries.join('');
    }
    function styleToRegistration(options) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var rules = extractRules(args);
        var key = getKeyForRules(options, rules);
        if (key) {
            var stylesheet = Stylesheet.getInstance();
            var registration = {
                className: stylesheet.classNameFromKey(key),
                key: key,
                args: args,
            };
            if (!registration.className) {
                registration.className = stylesheet.getClassName(getDisplayName(rules));
                var rulesToInsert = [];
                for (var _a = 0, _b = rules.__order; _a < _b.length; _a++) {
                    var selector = _b[_a];
                    rulesToInsert.push(selector, serializeRuleEntries(options, rules[selector]));
                }
                registration.rulesToInsert = rulesToInsert;
            }
            return registration;
        }
        return undefined;
    }
    /**
     * Insert style to stylesheet.
     * @param registration Style registration.
     * @param specificityMultiplier Number of times classname selector is repeated in the css rule.
     * This is to increase css specificity in case it's needed. Default to 1.
     */
    function applyRegistration(registration, specificityMultiplier) {
        if (specificityMultiplier === void 0) { specificityMultiplier = 1; }
        var stylesheet = Stylesheet.getInstance();
        var className = registration.className, key = registration.key, args = registration.args, rulesToInsert = registration.rulesToInsert;
        if (rulesToInsert) {
            // rulesToInsert is an ordered array of selector/rule pairs.
            for (var i = 0; i < rulesToInsert.length; i += 2) {
                var rules = rulesToInsert[i + 1];
                if (rules) {
                    var selector = rulesToInsert[i];
                    selector = selector.replace(/&/g, repeatString("." + registration.className, specificityMultiplier));
                    // Insert. Note if a media query, we must close the query with a final bracket.
                    var processedRule = selector + "{" + rules + "}" + (selector.indexOf('@') === 0 ? '}' : '');
                    stylesheet.insertRule(processedRule);
                }
            }
            stylesheet.cacheClassName(className, key, args, rulesToInsert);
        }
    }
    function styleToClassName(options) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var registration = styleToRegistration.apply(void 0, __spreadArray$2([options], args));
        if (registration) {
            applyRegistration(registration, options.specificityMultiplier);
            return registration.className;
        }
        return '';
    }

    /**
     * Concatenation helper, which can merge class names together. Skips over falsey values.
     *
     * @public
     */
    function mergeStyles() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return mergeCss(args, getStyleOptions());
    }
    /**
     * Concatenation helper, which can merge class names together. Skips over falsey values.
     * Accepts a set of options that will be used when calculating styles.
     *
     * @public
     */
    function mergeCss(args, options) {
        var styleArgs = args instanceof Array ? args : [args];
        var _a = extractStyleParts(styleArgs), classes = _a.classes, objects = _a.objects;
        if (objects.length) {
            classes.push(styleToClassName(options || {}, objects));
        }
        return classes.join(' ');
    }

    /**
     * Combine a set of styles together (but does not register css classes).
     * @param styleSets - One or more stylesets to be merged (each param can also be falsy).
     */
    function concatStyleSets() {
        var styleSets = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            styleSets[_i] = arguments[_i];
        }
        if (styleSets && styleSets.length === 1 && styleSets[0] && !styleSets[0].subComponentStyles) {
            return styleSets[0];
        }
        var mergedSet = {};
        // We process sub component styles in two phases. First we collect them, then we combine them into 1 style function.
        var workingSubcomponentStyles = {};
        for (var _a = 0, styleSets_1 = styleSets; _a < styleSets_1.length; _a++) {
            var currentSet = styleSets_1[_a];
            if (currentSet) {
                for (var prop in currentSet) {
                    if (currentSet.hasOwnProperty(prop)) {
                        if (prop === 'subComponentStyles' && currentSet.subComponentStyles !== undefined) {
                            // subcomponent styles - style functions or objects
                            var currentComponentStyles = currentSet.subComponentStyles;
                            for (var subCompProp in currentComponentStyles) {
                                if (currentComponentStyles.hasOwnProperty(subCompProp)) {
                                    if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {
                                        workingSubcomponentStyles[subCompProp].push(currentComponentStyles[subCompProp]);
                                    }
                                    else {
                                        workingSubcomponentStyles[subCompProp] = [currentComponentStyles[subCompProp]];
                                    }
                                }
                            }
                            continue;
                        }
                        // the as any casts below is a workaround for ts 2.8.
                        // todo: remove cast to any in ts 2.9.
                        var mergedValue = mergedSet[prop];
                        var currentValue = currentSet[prop];
                        if (mergedValue === undefined) {
                            mergedSet[prop] = currentValue;
                        }
                        else {
                            mergedSet[prop] = __spreadArray$2(__spreadArray$2([], (Array.isArray(mergedValue) ? mergedValue : [mergedValue])), (Array.isArray(currentValue) ? currentValue : [currentValue]));
                        }
                    }
                }
            }
        }
        if (Object.keys(workingSubcomponentStyles).length > 0) {
            mergedSet.subComponentStyles = {};
            var mergedSubStyles = mergedSet.subComponentStyles;
            var _loop_1 = function (subCompProp) {
                if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {
                    var workingSet_1 = workingSubcomponentStyles[subCompProp];
                    mergedSubStyles[subCompProp] = function (styleProps) {
                        return concatStyleSets.apply(void 0, workingSet_1.map(function (styleFunctionOrObject) {
                            return typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject;
                        }));
                    };
                }
            };
            // now we process the subcomponent styles if there are any
            for (var subCompProp in workingSubcomponentStyles) {
                _loop_1(subCompProp);
            }
        }
        return mergedSet;
    }

    /**
     * Takes in one or more style set objects, each consisting of a set of areas,
     * each which will produce a class name. Using this is analogous to calling
     * `mergeStyles` for each property in the object, but ensures we maintain the
     * set ordering when multiple style sets are merged.
     *
     * @param styleSets - One or more style sets to be merged.
     */
    function mergeStyleSets() {
        var styleSets = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            styleSets[_i] = arguments[_i];
        }
        return mergeCssSets(styleSets, getStyleOptions());
    }
    /**
     * Takes in one or more style set objects, each1consisting of a set of areas,
     * each which will produce a class name. Using this is analogous to calling
     * `mergeCss` for each property in the object, but ensures the
     * set ordering when multiple style sets are merged.
     *
     * @param styleSets - One or more style sets to be merged.
     * @param options - (optional) Options to use when creating rules.
     */
    function mergeCssSets(styleSets, options) {
        var classNameSet = { subComponentStyles: {} };
        var styleSet = styleSets[0];
        if (!styleSet && styleSets.length <= 1) {
            return { subComponentStyles: {} };
        }
        var concatenatedStyleSet = concatStyleSets.apply(void 0, styleSets);
        var registrations = [];
        for (var styleSetArea in concatenatedStyleSet) {
            if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {
                if (styleSetArea === 'subComponentStyles') {
                    classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};
                    continue;
                }
                var styles = concatenatedStyleSet[styleSetArea];
                var _a = extractStyleParts(styles), classes = _a.classes, objects = _a.objects;
                if (objects === null || objects === void 0 ? void 0 : objects.length) {
                    var registration = styleToRegistration(options || {}, { displayName: styleSetArea }, objects);
                    if (registration) {
                        registrations.push(registration);
                        classNameSet[styleSetArea] = classes.concat([registration.className]).join(' ');
                    }
                }
                else {
                    classNameSet[styleSetArea] = classes.join(' ');
                }
            }
        }
        for (var _i = 0, registrations_1 = registrations; _i < registrations_1.length; _i++) {
            var registration = registrations_1[_i];
            if (registration) {
                applyRegistration(registration, options === null || options === void 0 ? void 0 : options.specificityMultiplier);
            }
        }
        return classNameSet;
    }

    /**
     * Concatenates style sets into one, but resolves functional sets using the given props.
     * @param styleProps - Props used to resolve functional sets.
     * @param allStyles - Style sets, which can be functions or objects.
     */
    function concatStyleSetsWithProps(styleProps) {
        var allStyles = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            allStyles[_i - 1] = arguments[_i];
        }
        var result = [];
        for (var _a = 0, allStyles_1 = allStyles; _a < allStyles_1.length; _a++) {
            var styles = allStyles_1[_a];
            if (styles) {
                result.push(typeof styles === 'function' ? styles(styleProps) : styles);
            }
        }
        if (result.length === 1) {
            return result[0];
        }
        else if (result.length) {
            // cliffkoh: I cannot figure out how to avoid the cast to any here.
            // It is something to do with the use of Omit in IStyleSet.
            // It might not be necessary once  Omit becomes part of lib.d.ts (when we remove our own Omit and rely on
            // the official version).
            return concatStyleSets.apply(void 0, result);
        }
        return {};
    }

    /**
     * Registers a font face.
     * @public
     */
    function fontFace(font) {
        var stylesheet = Stylesheet.getInstance();
        var rule = serializeRuleEntries(getStyleOptions(), font);
        var className = stylesheet.classNameFromKey(rule);
        if (className) {
            return;
        }
        var name = stylesheet.getClassName();
        stylesheet.insertRule("@font-face{" + rule + "}", true);
        stylesheet.cacheClassName(name, rule, [], ['font-face', rule]);
    }

    /**
     * Registers keyframe definitions.
     *
     * @public
     */
    function keyframes(timeline) {
        var stylesheet = Stylesheet.getInstance();
        var rulesArray = [];
        for (var prop in timeline) {
            if (timeline.hasOwnProperty(prop)) {
                rulesArray.push(prop, '{', serializeRuleEntries(getStyleOptions(), timeline[prop]), '}');
            }
        }
        var rules = rulesArray.join('');
        var className = stylesheet.classNameFromKey(rules);
        if (className) {
            return className;
        }
        var name = stylesheet.getClassName();
        stylesheet.insertRule("@keyframes " + name + "{" + rules + "}", true);
        stylesheet.cacheClassName(name, rules, [], ['keyframes', rules]);
        return name;
    }

    /**
     * Builds a class names object from a given map.
     *
     * @param styles - Map of unprocessed styles.
     * @returns Map of property name to class name.
     */
    function buildClassMap(styles) {
        var classes = {};
        var _loop_1 = function (styleName) {
            if (styles.hasOwnProperty(styleName)) {
                var className_1;
                Object.defineProperty(classes, styleName, {
                    get: function () {
                        if (className_1 === undefined) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            className_1 = mergeStyles(styles[styleName]).toString();
                        }
                        return className_1;
                    },
                    enumerable: true,
                    configurable: true,
                });
            }
        };
        for (var styleName in styles) {
            _loop_1(styleName);
        }
        return classes;
    }

    /**
     * Verifies if an application can use DOM.
     */
    function canUseDOM() {
        return (typeof window !== 'undefined' &&
            !!(window.document &&
                // eslint-disable-next-line deprecation/deprecation
                window.document.createElement));
    }

    var _window = undefined;
    // Note: Accessing "window" in IE11 is somewhat expensive, and calling "typeof window"
    // hits a memory leak, whereas aliasing it and calling "typeof _window" does not.
    // Caching the window value at the file scope lets us minimize the impact.
    try {
        _window = window;
    }
    catch (e) {
        /* no-op */
    }
    /**
     * Helper to get the window object. The helper will make sure to use a cached variable
     * of "window", to avoid overhead and memory leaks in IE11. Note that in popup scenarios the
     * window object won't match the "global" window object, and for these scenarios, you should
     * pass in an element hosted within the popup.
     *
     * @public
     */
    function getWindow(rootElement) {
        if (!canUseDOM() || typeof _window === 'undefined') {
            return undefined;
        }
        else {
            var el = rootElement;
            return el && el.ownerDocument && el.ownerDocument.defaultView ? el.ownerDocument.defaultView : _window;
        }
    }

    /**
     * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.
     * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.
     *
     * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a
     * new instance of the class and remember to call dispose() during your code's dispose handler.
     *
     * @public
     */
    var Async = /** @class */ (function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function Async(parent, onError) {
            this._timeoutIds = null;
            this._immediateIds = null;
            this._intervalIds = null;
            this._animationFrameIds = null;
            this._isDisposed = false;
            this._parent = parent || null;
            this._onErrorHandler = onError;
            this._noop = function () {
                /* do nothing */
            };
        }
        /**
         * Dispose function, clears all async operations.
         */
        Async.prototype.dispose = function () {
            var id;
            this._isDisposed = true;
            this._parent = null;
            // Clear timeouts.
            if (this._timeoutIds) {
                for (id in this._timeoutIds) {
                    if (this._timeoutIds.hasOwnProperty(id)) {
                        this.clearTimeout(parseInt(id, 10));
                    }
                }
                this._timeoutIds = null;
            }
            // Clear immediates.
            if (this._immediateIds) {
                for (id in this._immediateIds) {
                    if (this._immediateIds.hasOwnProperty(id)) {
                        this.clearImmediate(parseInt(id, 10));
                    }
                }
                this._immediateIds = null;
            }
            // Clear intervals.
            if (this._intervalIds) {
                for (id in this._intervalIds) {
                    if (this._intervalIds.hasOwnProperty(id)) {
                        this.clearInterval(parseInt(id, 10));
                    }
                }
                this._intervalIds = null;
            }
            // Clear animation frames.
            if (this._animationFrameIds) {
                for (id in this._animationFrameIds) {
                    if (this._animationFrameIds.hasOwnProperty(id)) {
                        this.cancelAnimationFrame(parseInt(id, 10));
                    }
                }
                this._animationFrameIds = null;
            }
        };
        /**
         * SetTimeout override, which will auto cancel the timeout during dispose.
         * @param callback - Callback to execute.
         * @param duration - Duration in milliseconds.
         * @returns The setTimeout id.
         */
        Async.prototype.setTimeout = function (callback, duration) {
            var _this = this;
            var timeoutId = 0;
            if (!this._isDisposed) {
                if (!this._timeoutIds) {
                    this._timeoutIds = {};
                }
                timeoutId = setTimeout(function () {
                    // Time to execute the timeout, enqueue it as a foreground task to be executed.
                    try {
                        // Now delete the record and call the callback.
                        if (_this._timeoutIds) {
                            delete _this._timeoutIds[timeoutId];
                        }
                        callback.apply(_this._parent);
                    }
                    catch (e) {
                        _this._logError(e);
                    }
                }, duration);
                this._timeoutIds[timeoutId] = true;
            }
            return timeoutId;
        };
        /**
         * Clears the timeout.
         * @param id - Id to cancel.
         */
        Async.prototype.clearTimeout = function (id) {
            if (this._timeoutIds && this._timeoutIds[id]) {
                clearTimeout(id);
                delete this._timeoutIds[id];
            }
        };
        /**
         * SetImmediate override, which will auto cancel the immediate during dispose.
         * @param callback - Callback to execute.
         * @param targetElement - Optional target element to use for identifying the correct window.
         * @returns The setTimeout id.
         */
        Async.prototype.setImmediate = function (callback, targetElement) {
            var _this = this;
            var immediateId = 0;
            var win = getWindow(targetElement);
            if (!this._isDisposed) {
                if (!this._immediateIds) {
                    this._immediateIds = {};
                }
                var setImmediateCallback = function () {
                    // Time to execute the timeout, enqueue it as a foreground task to be executed.
                    try {
                        // Now delete the record and call the callback.
                        if (_this._immediateIds) {
                            delete _this._immediateIds[immediateId];
                        }
                        callback.apply(_this._parent);
                    }
                    catch (e) {
                        _this._logError(e);
                    }
                };
                immediateId = win.setTimeout(setImmediateCallback, 0);
                this._immediateIds[immediateId] = true;
            }
            return immediateId;
        };
        /**
         * Clears the immediate.
         * @param id - Id to cancel.
         * @param targetElement - Optional target element to use for identifying the correct window.
         */
        Async.prototype.clearImmediate = function (id, targetElement) {
            var win = getWindow(targetElement);
            if (this._immediateIds && this._immediateIds[id]) {
                win.clearTimeout(id);
                delete this._immediateIds[id];
            }
        };
        /**
         * SetInterval override, which will auto cancel the timeout during dispose.
         * @param callback - Callback to execute.
         * @param duration - Duration in milliseconds.
         * @returns The setTimeout id.
         */
        Async.prototype.setInterval = function (callback, duration) {
            var _this = this;
            var intervalId = 0;
            if (!this._isDisposed) {
                if (!this._intervalIds) {
                    this._intervalIds = {};
                }
                intervalId = setInterval(function () {
                    // Time to execute the interval callback, enqueue it as a foreground task to be executed.
                    try {
                        callback.apply(_this._parent);
                    }
                    catch (e) {
                        _this._logError(e);
                    }
                }, duration);
                this._intervalIds[intervalId] = true;
            }
            return intervalId;
        };
        /**
         * Clears the interval.
         * @param id - Id to cancel.
         */
        Async.prototype.clearInterval = function (id) {
            if (this._intervalIds && this._intervalIds[id]) {
                clearInterval(id);
                delete this._intervalIds[id];
            }
        };
        /**
         * Creates a function that, when executed, will only call the func function at most once per
         * every wait milliseconds. Provide an options object to indicate that func should be invoked
         * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled
         * function will return the result of the last func call.
         *
         * Note: If leading and trailing options are true func will be called on the trailing edge of
         * the timeout only if the throttled function is invoked more than once during the wait timeout.
         *
         * @param func - The function to throttle.
         * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.
         * @param options - The options object.
         * @returns The new throttled function.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Async.prototype.throttle = function (func, wait, options) {
            var _this = this;
            if (this._isDisposed) {
                return this._noop;
            }
            var waitMS = wait || 0;
            var leading = true;
            var trailing = true;
            var lastExecuteTime = 0;
            var lastResult;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var lastArgs;
            var timeoutId = null;
            if (options && typeof options.leading === 'boolean') {
                leading = options.leading;
            }
            if (options && typeof options.trailing === 'boolean') {
                trailing = options.trailing;
            }
            var callback = function (userCall) {
                var now = Date.now();
                var delta = now - lastExecuteTime;
                var waitLength = leading ? waitMS - delta : waitMS;
                if (delta >= waitMS && (!userCall || leading)) {
                    lastExecuteTime = now;
                    if (timeoutId) {
                        _this.clearTimeout(timeoutId);
                        timeoutId = null;
                    }
                    lastResult = func.apply(_this._parent, lastArgs);
                }
                else if (timeoutId === null && trailing) {
                    timeoutId = _this.setTimeout(callback, waitLength);
                }
                return lastResult;
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var resultFunction = (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                lastArgs = args;
                return callback(true);
            });
            return resultFunction;
        };
        /**
         * Creates a function that will delay the execution of func until after wait milliseconds have
         * elapsed since the last time it was invoked. Provide an options object to indicate that func
         * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls
         * to the debounced function will return the result of the last func call.
         *
         * Note: If leading and trailing options are true func will be called on the trailing edge of
         * the timeout only if the debounced function is invoked more than once during the wait
         * timeout.
         *
         * @param func - The function to debounce.
         * @param wait - The number of milliseconds to delay.
         * @param options - The options object.
         * @returns The new debounced function.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Async.prototype.debounce = function (func, wait, options) {
            var _this = this;
            if (this._isDisposed) {
                var noOpFunction = (function () {
                    /** Do nothing */
                });
                noOpFunction.cancel = function () {
                    return;
                };
                noOpFunction.flush = (function () { return null; });
                noOpFunction.pending = function () { return false; };
                return noOpFunction;
            }
            var waitMS = wait || 0;
            var leading = false;
            var trailing = true;
            var maxWait = null;
            var lastCallTime = 0;
            var lastExecuteTime = Date.now();
            var lastResult;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var lastArgs;
            var timeoutId = null;
            if (options && typeof options.leading === 'boolean') {
                leading = options.leading;
            }
            if (options && typeof options.trailing === 'boolean') {
                trailing = options.trailing;
            }
            if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {
                maxWait = options.maxWait;
            }
            var markExecuted = function (time) {
                if (timeoutId) {
                    _this.clearTimeout(timeoutId);
                    timeoutId = null;
                }
                lastExecuteTime = time;
            };
            var invokeFunction = function (time) {
                markExecuted(time);
                lastResult = func.apply(_this._parent, lastArgs);
            };
            var callback = function (userCall) {
                var now = Date.now();
                var executeImmediately = false;
                if (userCall) {
                    if (leading && now - lastCallTime >= waitMS) {
                        executeImmediately = true;
                    }
                    lastCallTime = now;
                }
                var delta = now - lastCallTime;
                var waitLength = waitMS - delta;
                var maxWaitDelta = now - lastExecuteTime;
                var maxWaitExpired = false;
                if (maxWait !== null) {
                    // maxWait only matters when there is a pending callback
                    if (maxWaitDelta >= maxWait && timeoutId) {
                        maxWaitExpired = true;
                    }
                    else {
                        waitLength = Math.min(waitLength, maxWait - maxWaitDelta);
                    }
                }
                if (delta >= waitMS || maxWaitExpired || executeImmediately) {
                    invokeFunction(now);
                }
                else if ((timeoutId === null || !userCall) && trailing) {
                    timeoutId = _this.setTimeout(callback, waitLength);
                }
                return lastResult;
            };
            var pending = function () {
                return !!timeoutId;
            };
            var cancel = function () {
                if (pending()) {
                    // Mark the debounced function as having executed
                    markExecuted(Date.now());
                }
            };
            var flush = function () {
                if (pending()) {
                    invokeFunction(Date.now());
                }
                return lastResult;
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var resultFunction = (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                lastArgs = args;
                return callback(true);
            });
            resultFunction.cancel = cancel;
            resultFunction.flush = flush;
            resultFunction.pending = pending;
            return resultFunction;
        };
        Async.prototype.requestAnimationFrame = function (callback, targetElement) {
            var _this = this;
            var animationFrameId = 0;
            var win = getWindow(targetElement);
            if (!this._isDisposed) {
                if (!this._animationFrameIds) {
                    this._animationFrameIds = {};
                }
                var animationFrameCallback = function () {
                    try {
                        // Now delete the record and call the callback.
                        if (_this._animationFrameIds) {
                            delete _this._animationFrameIds[animationFrameId];
                        }
                        callback.apply(_this._parent);
                    }
                    catch (e) {
                        _this._logError(e);
                    }
                };
                animationFrameId = win.requestAnimationFrame
                    ? win.requestAnimationFrame(animationFrameCallback)
                    : win.setTimeout(animationFrameCallback, 0);
                this._animationFrameIds[animationFrameId] = true;
            }
            return animationFrameId;
        };
        Async.prototype.cancelAnimationFrame = function (id, targetElement) {
            var win = getWindow(targetElement);
            if (this._animationFrameIds && this._animationFrameIds[id]) {
                win.cancelAnimationFrame ? win.cancelAnimationFrame(id) : win.clearTimeout(id);
                delete this._animationFrameIds[id];
            }
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Async.prototype._logError = function (e) {
            if (this._onErrorHandler) {
                this._onErrorHandler(e);
            }
        };
        return Async;
    }());

    /**
     * Compares a to b and b to a.
     *
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function shallowCompare(a, b) {
        if (!a || !b) {
            // only return true if both a and b are falsy
            return !a && !b;
        }
        for (var propName in a) {
            if (a.hasOwnProperty(propName)) {
                if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {
                    return false;
                }
            }
        }
        for (var propName in b) {
            if (b.hasOwnProperty(propName)) {
                if (!a.hasOwnProperty(propName)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more
     * objects as arguments and they will be merged sequentially into the target. Note that this will
     * shallow merge; it will not create new cloned values for target members.
     *
     * @public
     * @param target - Target object to merge following object arguments into.
     * @param args - One or more objects that will be mixed into the target in the order they are provided.
     * @returns Resulting merged target.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function assign(target) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return filteredAssign.apply(this, [null, target].concat(args));
    }
    /**
     * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter
     * the resulting merges. This allows for scenarios where you want to merge "everything except that one thing"
     * or "properties that start with data-". Note that this will shallow merge; it will not create new cloned
     * values for target members.
     *
     * @public
     * @param isAllowed - Callback to determine if the given propName is allowed in the result.
     * @param target - Target object to merge following object arguments into.
     * @param args - One or more objects that will be mixed into the target in the order they are provided.
     * @returns Resulting merged target.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function filteredAssign(isAllowed, target) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        target = target || {};
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var sourceObject = args_1[_a];
            if (sourceObject) {
                for (var propName in sourceObject) {
                    if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {
                        target[propName] = sourceObject[propName];
                    }
                }
            }
        }
        return target;
    }
    /**
     * Takes an enum and iterates over each value of the enum (as a string), running the callback on each,
     * returning a mapped array.
     * @param theEnum - Enum to iterate over
     * @param callback - The first parameter the name of the entry, and the second parameter is the value
     * of that entry, which is the value you'd normally use when using the enum (usually a number).
     */
    function mapEnumByName(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    theEnum, callback) {
        // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call
        return Object.keys(theEnum)
            .map(function (p) {
            // map on each property name as a string
            if (String(Number(p)) !== p) {
                // if the property is not just a number (because enums in TypeScript will map both ways)
                return callback(p, theEnum[p]);
            }
            return undefined;
        })
            .filter(function (v) { return !!v; }); // only return elements with values
    }
    /**
     * Get all values in an object dictionary
     *
     * @param obj - The dictionary to get values for
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function values(obj) {
        return Object.keys(obj).reduce(function (arr, key) {
            arr.push(obj[key]);
            return arr;
        }, []);
    }
    /**
     * Tiny helper to do the minimal amount of work in duplicating an object but omitting some
     * props. This ends up faster than using object ...rest or reduce to filter.
     *
     * This behaves very much like filteredAssign, but does not merge many objects together,
     * uses an exclusion object map, and avoids spreads all for optimal performance.
     *
     * See perf test for background:
     * https://jsperf.com/omit-vs-rest-vs-reduce/1
     *
     * @param obj - The object to clone
     * @param exclusions - The array of keys to exclude
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function omit(obj, exclusions) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var result = {};
        for (var key in obj) {
            if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {
                result[key] = obj[key];
            }
        }
        return result;
    }

    /** An instance of EventGroup allows anything with a handle to it to trigger events on it.
     *  If the target is an HTMLElement, the event will be attached to the element and can be
     *  triggered as usual (like clicking for onClick).
     *  The event can be triggered by calling EventGroup.raise() here. If the target is an
     *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets
     *  handled here in EventGroup, and the handler is called in the context of the parent
     *  (which is passed in in the constructor).
     *
     * @public
     * {@docCategory EventGroup}
     */
    var EventGroup = /** @class */ (function () {
        /** parent: the context in which events attached to non-HTMLElements are called */
        function EventGroup(parent) {
            this._id = EventGroup._uniqueId++;
            this._parent = parent;
            this._eventRecords = [];
        }
        /** For IE8, bubbleEvent is ignored here and must be dealt with by the handler.
         *  Events raised here by default have bubbling set to false and cancelable set to true.
         *  This applies also to built-in events being raised manually here on HTMLElements,
         *  which may lead to unexpected behavior if it differs from the defaults.
         *
         */
        EventGroup.raise = function (target, eventName, eventArgs, bubbleEvent) {
            var retVal;
            if (EventGroup._isElement(target)) {
                if (typeof document !== 'undefined' && document.createEvent) {
                    var ev = document.createEvent('HTMLEvents');
                    ev.initEvent(eventName, bubbleEvent || false, true);
                    assign(ev, eventArgs);
                    retVal = target.dispatchEvent(ev);
                }
                else if (typeof document !== 'undefined' && document.createEventObject) {
                    // IE8
                    var evObj = document.createEventObject(eventArgs);
                    // cannot set cancelBubble on evObj, fireEvent will overwrite it
                    target.fireEvent('on' + eventName, evObj);
                }
            }
            else {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore  -- FIXME: strictBindCallApply error - https://github.com/microsoft/fluentui/issues/17331
                while (target && retVal !== false) {
                    var events = target.__events__;
                    var eventRecords = events ? events[eventName] : null;
                    if (eventRecords) {
                        for (var id in eventRecords) {
                            if (eventRecords.hasOwnProperty(id)) {
                                var eventRecordList = eventRecords[id];
                                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                                // @ts-ignore  -- FIXME: strictBindCallApply error - https://github.com/microsoft/fluentui/issues/17331
                                for (var listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {
                                    var record = eventRecordList[listIndex];
                                    if (record.objectCallback) {
                                        retVal = record.objectCallback.call(record.parent, eventArgs);
                                    }
                                }
                            }
                        }
                    }
                    // If the target has a parent, bubble the event up.
                    target = bubbleEvent ? target.parent : null;
                }
            }
            return retVal;
        };
        EventGroup.isObserved = function (target, eventName) {
            var events = target && target.__events__;
            return !!events && !!events[eventName];
        };
        /** Check to see if the target has declared support of the given event. */
        EventGroup.isDeclared = function (target, eventName) {
            var declaredEvents = target && target.__declaredEvents;
            return !!declaredEvents && !!declaredEvents[eventName];
        };
        EventGroup.stopPropagation = function (event) {
            if (event.stopPropagation) {
                event.stopPropagation();
            }
            else {
                // IE8
                event.cancelBubble = true;
            }
        };
        EventGroup._isElement = function (target) {
            return (!!target && (!!target.addEventListener || (typeof HTMLElement !== 'undefined' && target instanceof HTMLElement)));
        };
        EventGroup.prototype.dispose = function () {
            if (!this._isDisposed) {
                this._isDisposed = true;
                this.off();
                this._parent = null;
            }
        };
        /** On the target, attach a set of events, where the events object is a name to function mapping. */
        EventGroup.prototype.onAll = function (target, events, useCapture) {
            for (var eventName in events) {
                if (events.hasOwnProperty(eventName)) {
                    this.on(target, eventName, events[eventName], useCapture);
                }
            }
        };
        /**
         * On the target, attach an event whose handler will be called in the context of the parent
         * of this instance of EventGroup.
         */
        EventGroup.prototype.on = function (target, eventName, callback, options) {
            var _this = this;
            if (eventName.indexOf(',') > -1) {
                var events = eventName.split(/[ ,]+/);
                for (var i = 0; i < events.length; i++) {
                    this.on(target, events[i], callback, options);
                }
            }
            else {
                var parent_1 = this._parent;
                var eventRecord = {
                    target: target,
                    eventName: eventName,
                    parent: parent_1,
                    callback: callback,
                    options: options,
                };
                // Initialize and wire up the record on the target, so that it can call the callback if the event fires.
                var events = (target.__events__ = target.__events__ || {});
                events[eventName] =
                    events[eventName] ||
                        {
                            count: 0,
                        };
                events[eventName][this._id] = events[eventName][this._id] || [];
                events[eventName][this._id].push(eventRecord);
                events[eventName].count++;
                if (EventGroup._isElement(target)) {
                    var processElementEvent = function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        if (_this._isDisposed) {
                            return;
                        }
                        var result;
                        try {
                            result = callback.apply(parent_1, args);
                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                            // @ts-ignore  -- FIXME: strictBindCallApply error - https://github.com/microsoft/fluentui/issues/17331
                            if (result === false && args[0]) {
                                var e = args[0];
                                if (e.preventDefault) {
                                    e.preventDefault();
                                }
                                if (e.stopPropagation) {
                                    e.stopPropagation();
                                }
                                e.cancelBubble = true;
                            }
                        }
                        catch (e) {
                            // ignore
                        }
                        return result;
                    };
                    eventRecord.elementCallback = processElementEvent;
                    if (target.addEventListener) {
                        target.addEventListener(eventName, processElementEvent, options);
                    }
                    else if (target.attachEvent) {
                        // IE8
                        target.attachEvent('on' + eventName, processElementEvent);
                    }
                }
                else {
                    var processObjectEvent = function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        if (_this._isDisposed) {
                            return;
                        }
                        return callback.apply(parent_1, args);
                    };
                    eventRecord.objectCallback = processObjectEvent;
                }
                // Remember the record locally, so that it can be removed.
                this._eventRecords.push(eventRecord);
            }
        };
        EventGroup.prototype.off = function (target, eventName, callback, options) {
            for (var i = 0; i < this._eventRecords.length; i++) {
                var eventRecord = this._eventRecords[i];
                if ((!target || target === eventRecord.target) &&
                    (!eventName || eventName === eventRecord.eventName) &&
                    (!callback || callback === eventRecord.callback) &&
                    (typeof options !== 'boolean' || options === eventRecord.options)) {
                    var events = eventRecord.target.__events__;
                    var targetArrayLookup = events[eventRecord.eventName];
                    var targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null;
                    // We may have already target's entries, so check for null.
                    if (targetArray) {
                        if (targetArray.length === 1 || !callback) {
                            targetArrayLookup.count -= targetArray.length;
                            delete events[eventRecord.eventName][this._id];
                        }
                        else {
                            targetArrayLookup.count--;
                            targetArray.splice(targetArray.indexOf(eventRecord), 1);
                        }
                        if (!targetArrayLookup.count) {
                            delete events[eventRecord.eventName];
                        }
                    }
                    if (eventRecord.elementCallback) {
                        if (eventRecord.target.removeEventListener) {
                            eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.options);
                        }
                        else if (eventRecord.target.detachEvent) {
                            // IE8
                            eventRecord.target.detachEvent('on' + eventRecord.eventName, eventRecord.elementCallback);
                        }
                    }
                    this._eventRecords.splice(i--, 1);
                }
            }
        };
        /** Trigger the given event in the context of this instance of EventGroup. */
        EventGroup.prototype.raise = function (eventName, eventArgs, bubbleEvent) {
            return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent);
        };
        /** Declare an event as being supported by this instance of EventGroup. */
        EventGroup.prototype.declare = function (event) {
            var declaredEvents = (this._parent.__declaredEvents = this._parent.__declaredEvents || {});
            if (typeof event === 'string') {
                declaredEvents[event] = true;
            }
            else {
                for (var i = 0; i < event.length; i++) {
                    declaredEvents[event[i]] = true;
                }
            }
        };
        EventGroup._uniqueId = 0;
        return EventGroup;
    }());

    /**
     * Helper to get the document object. Note that in popup window cases, document
     * might be the wrong document, which is why we look at ownerDocument for the
     * truth.
     *
     * @public
     */
    function getDocument(rootElement) {
        if (!canUseDOM() || typeof document === 'undefined') {
            return undefined;
        }
        else {
            var el = rootElement;
            return el && el.ownerDocument ? el.ownerDocument : document;
        }
    }

    var _scrollbarWidth;
    var _bodyScrollDisabledCount = 0;
    var DisabledScrollClassName = mergeStyles({
        overflow: 'hidden !important',
    });
    /**
     * Placing this attribute on scrollable divs optimizes detection to know
     * if the div is scrollable or not (given we can avoid expensive operations
     * like getComputedStyle.)
     *
     * @public
     */
    var DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';
    /**
     * Allows the user to scroll within a element,
     * while preventing the user from scrolling the body
     */
    var allowScrollOnElement = function (element, events) {
        if (!element) {
            return;
        }
        var _previousClientY = 0;
        var _element = null;
        // remember the clientY for future calls of _preventOverscrolling
        var _saveClientY = function (event) {
            if (event.targetTouches.length === 1) {
                _previousClientY = event.targetTouches[0].clientY;
            }
        };
        // prevent the body from scrolling when the user attempts
        // to scroll past the top or bottom of the element
        var _preventOverscrolling = function (event) {
            // only respond to a single-finger touch
            if (event.targetTouches.length !== 1) {
                return;
            }
            // prevent the body touchmove handler from firing
            // so that scrolling is allowed within the element
            event.stopPropagation();
            if (!_element) {
                return;
            }
            var clientY = event.targetTouches[0].clientY - _previousClientY;
            var scrollableParent = findScrollableParent(event.target);
            if (scrollableParent) {
                _element = scrollableParent;
            }
            // if the element is scrolled to the top,
            // prevent the user from scrolling up
            if (_element.scrollTop === 0 && clientY > 0) {
                event.preventDefault();
            }
            // if the element is scrolled to the bottom,
            // prevent the user from scrolling down
            if (_element.scrollHeight - Math.ceil(_element.scrollTop) <= _element.clientHeight && clientY < 0) {
                event.preventDefault();
            }
        };
        events.on(element, 'touchstart', _saveClientY, { passive: false });
        events.on(element, 'touchmove', _preventOverscrolling, { passive: false });
        _element = element;
    };
    /**
     * Same as allowScrollOnElement but does not prevent overscrolling.
     */
    var allowOverscrollOnElement = function (element, events) {
        if (!element) {
            return;
        }
        var _allowElementScroll = function (event) {
            event.stopPropagation();
        };
        events.on(element, 'touchmove', _allowElementScroll, { passive: false });
    };
    var _disableIosBodyScroll = function (event) {
        event.preventDefault();
    };
    /**
     * Disables the body scrolling.
     *
     * @public
     */
    function disableBodyScroll() {
        var doc = getDocument();
        if (doc && doc.body && !_bodyScrollDisabledCount) {
            doc.body.classList.add(DisabledScrollClassName);
            doc.body.addEventListener('touchmove', _disableIosBodyScroll, { passive: false, capture: false });
        }
        _bodyScrollDisabledCount++;
    }
    /**
     * Enables the body scrolling.
     *
     * @public
     */
    function enableBodyScroll() {
        if (_bodyScrollDisabledCount > 0) {
            var doc = getDocument();
            if (doc && doc.body && _bodyScrollDisabledCount === 1) {
                doc.body.classList.remove(DisabledScrollClassName);
                doc.body.removeEventListener('touchmove', _disableIosBodyScroll);
            }
            _bodyScrollDisabledCount--;
        }
    }
    /**
     * Calculates the width of a scrollbar for the browser/os.
     *
     * @public
     */
    function getScrollbarWidth() {
        if (_scrollbarWidth === undefined) {
            var scrollDiv = document.createElement('div');
            scrollDiv.style.setProperty('width', '100px');
            scrollDiv.style.setProperty('height', '100px');
            scrollDiv.style.setProperty('overflow', 'scroll');
            scrollDiv.style.setProperty('position', 'absolute');
            scrollDiv.style.setProperty('top', '-9999px');
            document.body.appendChild(scrollDiv);
            // Get the scrollbar width
            _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
            // Delete the DIV
            document.body.removeChild(scrollDiv);
        }
        return _scrollbarWidth;
    }
    /**
     * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns
     * document.body.
     *
     * @public
     */
    function findScrollableParent(startingElement) {
        var el = startingElement;
        var doc = getDocument(startingElement);
        // First do a quick scan for the scrollable attribute.
        while (el && el !== doc.body) {
            if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {
                return el;
            }
            el = el.parentElement;
        }
        // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.
        el = startingElement;
        while (el && el !== doc.body) {
            if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {
                var computedStyles = getComputedStyle(el);
                var overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : '';
                if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {
                    return el;
                }
            }
            el = el.parentElement;
        }
        // Fall back to window scroll.
        if (!el || el === doc.body) {
            el = getWindow(startingElement);
        }
        return el;
    }

    /**
     * Helper to get bounding client rect. Passing in window will get the window size.
     *
     * @public
     */
    function getRect(element) {
        var rect;
        if (element) {
            if (element === window) {
                rect = {
                    left: 0,
                    top: 0,
                    width: window.innerWidth,
                    height: window.innerHeight,
                    right: window.innerWidth,
                    bottom: window.innerHeight,
                };
            }
            else if (element.getBoundingClientRect) {
                rect = element.getBoundingClientRect();
            }
        }
        return rect;
    }

    var SCROLL_ITERATION_DELAY = 16;
    var SCROLL_GUTTER = 100;
    var MAX_SCROLL_VELOCITY = 15;
    /**
     * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container
     * up/down depending on how close the mouse is to the top/bottom of the container.
     *
     * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.
     *
     * @public
     * {@docCategory AutoScroll}
     */
    var AutoScroll = /** @class */ (function () {
        function AutoScroll(element) {
            this._events = new EventGroup(this);
            this._scrollableParent = findScrollableParent(element);
            this._incrementScroll = this._incrementScroll.bind(this);
            this._scrollRect = getRect(this._scrollableParent);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (this._scrollableParent === window) {
                this._scrollableParent = document.body;
            }
            if (this._scrollableParent) {
                this._events.on(window, 'mousemove', this._onMouseMove, true);
                this._events.on(window, 'touchmove', this._onTouchMove, true);
            }
        }
        AutoScroll.prototype.dispose = function () {
            this._events.dispose();
            this._stopScroll();
        };
        AutoScroll.prototype._onMouseMove = function (ev) {
            this._computeScrollVelocity(ev);
        };
        AutoScroll.prototype._onTouchMove = function (ev) {
            if (ev.touches.length > 0) {
                this._computeScrollVelocity(ev);
            }
        };
        AutoScroll.prototype._computeScrollVelocity = function (ev) {
            if (!this._scrollRect) {
                return;
            }
            var clientX;
            var clientY;
            if ('clientX' in ev) {
                clientX = ev.clientX;
                clientY = ev.clientY;
            }
            else {
                clientX = ev.touches[0].clientX;
                clientY = ev.touches[0].clientY;
            }
            var scrollRectTop = this._scrollRect.top;
            var scrollRectLeft = this._scrollRect.left;
            var scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER;
            var scrollClientRight = scrollRectLeft + this._scrollRect.width - SCROLL_GUTTER;
            // variables to use for alternating scroll direction
            var scrollRect;
            var clientDirection;
            var scrollClient;
            // if either of these conditions are met we are scrolling vertically else horizontally
            if (clientY < scrollRectTop + SCROLL_GUTTER || clientY > scrollClientBottom) {
                clientDirection = clientY;
                scrollRect = scrollRectTop;
                scrollClient = scrollClientBottom;
                this._isVerticalScroll = true;
            }
            else {
                clientDirection = clientX;
                scrollRect = scrollRectLeft;
                scrollClient = scrollClientRight;
                this._isVerticalScroll = false;
            }
            // calculate scroll velocity and direction
            if (clientDirection < scrollRect + SCROLL_GUTTER) {
                this._scrollVelocity = Math.max(-MAX_SCROLL_VELOCITY, -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER - (clientDirection - scrollRect)) / SCROLL_GUTTER));
            }
            else if (clientDirection > scrollClient) {
                this._scrollVelocity = Math.min(MAX_SCROLL_VELOCITY, MAX_SCROLL_VELOCITY * ((clientDirection - scrollClient) / SCROLL_GUTTER));
            }
            else {
                this._scrollVelocity = 0;
            }
            if (this._scrollVelocity) {
                this._startScroll();
            }
            else {
                this._stopScroll();
            }
        };
        AutoScroll.prototype._startScroll = function () {
            if (!this._timeoutId) {
                this._incrementScroll();
            }
        };
        AutoScroll.prototype._incrementScroll = function () {
            if (this._scrollableParent) {
                if (this._isVerticalScroll) {
                    this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);
                }
                else {
                    this._scrollableParent.scrollLeft += Math.round(this._scrollVelocity);
                }
            }
            this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);
        };
        AutoScroll.prototype._stopScroll = function () {
            if (this._timeoutId) {
                clearTimeout(this._timeoutId);
                delete this._timeoutId;
            }
        };
        return AutoScroll;
    }());

    /* eslint-disable no-console */
    var _warningCallback = undefined;
    /**
     * Sends a warning to console, if the api is present.
     *
     * @public
     * @param message - Warning message.
     */
    function warn(message) {
        if (_warningCallback && "production" !== 'production') {
            _warningCallback(message);
        }
        else if (console && console.warn) {
            console.warn(message);
        }
    }
    /**
     * Configures the warning callback. Passing in undefined will reset it to use the default
     * console.warn function.
     *
     * @public
     * @param warningCallback - Callback to override the generated warnings.
     */
    function setWarningCallback(warningCallback) {
        _warningCallback = warningCallback;
    }

    /**
     * Warns when props are required if a condition is met.
     *
     * @public
     * @param componentName - The name of the component being used.
     * @param props - The props passed into the component.
     * @param requiredProps - The name of the props that are required when the condition is met.
     * @param conditionalPropName - The name of the prop that the condition is based on.
     * @param condition - Whether the condition is met.
     */
    function warnConditionallyRequiredProps(componentName, props, requiredProps, conditionalPropName, condition) {
        if (condition === true && "production" !== 'production') {
            for (var _i = 0, requiredProps_1 = requiredProps; _i < requiredProps_1.length; _i++) {
                var requiredPropName = requiredProps_1[_i];
                if (!(requiredPropName in props)) {
                    warn(componentName + " property '" + requiredPropName + "' is required when '" + conditionalPropName + "' is used.'");
                }
            }
        }
    }

    /**
     * Warns when two props which are mutually exclusive are both being used.
     *
     * @public
     * @param componentName - The name of the component being used.
     * @param props - The props passed into the component.
     * @param exclusiveMap - A map where the key is a parameter, and the value is the other parameter.
     */
    function warnMutuallyExclusive(componentName, props, exclusiveMap) {
    }

    /**
     * Warns when a deprecated props are being used.
     *
     * @public
     * @param componentName - The name of the component being used.
     * @param props - The props passed into the component.
     * @param deprecationMap - The map of deprecations, where key is the prop name and the value is
     * either null or a replacement prop name.
     */
    function warnDeprecations(componentName, props, deprecationMap) {
    }

    /**
     * BaseComponent class, which provides basic helpers for all components.
     *
     * @public
     * {@docCategory BaseComponent}
     *
     * @deprecated Do not use. We are moving away from class component.
     */
    var BaseComponent = /** @class */ (function (_super) {
        __extends$4(BaseComponent, _super);
        /**
         * BaseComponent constructor
         * @param props - The props for the component.
         * @param context - The context for the component.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function BaseComponent(props, context) {
            var _this = _super.call(this, props, context) || this;
            // eslint-disable-next-line deprecation/deprecation
            _makeAllSafe(_this, BaseComponent.prototype, [
                'componentDidMount',
                'shouldComponentUpdate',
                'getSnapshotBeforeUpdate',
                'render',
                'componentDidUpdate',
                'componentWillUnmount',
            ]);
            return _this;
        }
        /**
         * When the component receives props, make sure the componentRef is updated.
         */
        BaseComponent.prototype.componentDidUpdate = function (prevProps, prevState) {
            this._updateComponentRef(prevProps, this.props);
        };
        /**
         * When the component has mounted, update the componentRef.
         */
        BaseComponent.prototype.componentDidMount = function () {
            this._setComponentRef(this.props.componentRef, this);
        };
        /**
         * If we have disposables, dispose them automatically on unmount.
         */
        BaseComponent.prototype.componentWillUnmount = function () {
            this._setComponentRef(this.props.componentRef, null);
            if (this.__disposables) {
                for (var i = 0, len = this._disposables.length; i < len; i++) {
                    var disposable = this.__disposables[i];
                    if (disposable.dispose) {
                        disposable.dispose();
                    }
                }
                this.__disposables = null;
            }
        };
        Object.defineProperty(BaseComponent.prototype, "className", {
            /**
             * Gets the object's class name.
             */
            get: function () {
                if (!this.__className) {
                    var funcNameRegex = /function (.{1,})\(/;
                    var results = funcNameRegex.exec(this.constructor.toString());
                    this.__className = results && results.length > 1 ? results[1] : '';
                }
                return this.__className;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "_disposables", {
            /**
             * Allows subclasses to push things to this._disposables to be auto disposed.
             */
            get: function () {
                if (!this.__disposables) {
                    this.__disposables = [];
                }
                return this.__disposables;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "_async", {
            /**
             * Gets the async instance associated with the component, created on demand. The async instance gives
             * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks
             * will be cleared/ignored automatically after unmounting. The helpers within the async object also
             * preserve the this pointer so that you don't need to "bind" the callbacks.
             */
            get: function () {
                if (!this.__async) {
                    this.__async = new Async(this);
                    this._disposables.push(this.__async);
                }
                return this.__async;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "_events", {
            /**
             * Gets the event group instance assocaited with the component, created on demand. The event instance
             * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks
             * will be automatically disconnected after unmounting. The helpers within the events object also
             * preserve the this reference so that you don't need to "bind" the callbacks.
             */
            get: function () {
                if (!this.__events) {
                    this.__events = new EventGroup(this);
                    this._disposables.push(this.__events);
                }
                return this.__events;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Helper to return a memoized ref resolver function.
         * @param refName - Name of the member to assign the ref to.
         * @returns A function instance keyed from the given refname.
         * @deprecated Use `createRef` from React.createRef.
         */
        BaseComponent.prototype._resolveRef = function (refName) {
            var _this = this;
            if (!this.__resolves) {
                this.__resolves = {};
            }
            if (!this.__resolves[refName]) {
                this.__resolves[refName] = function (ref) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    return (_this[refName] = ref);
                };
            }
            return this.__resolves[refName];
        };
        /**
         * Updates the componentRef (by calling it with "this" when necessary.)
         */
        BaseComponent.prototype._updateComponentRef = function (currentProps, newProps) {
            if (newProps === void 0) { newProps = {}; }
            // currentProps *should* always be defined, but verify that just in case a subclass is manually
            // calling a lifecycle method with no parameters (which has happened) or other odd usage.
            if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {
                this._setComponentRef(currentProps.componentRef, null);
                this._setComponentRef(newProps.componentRef, this);
            }
        };
        /**
         * Warns when a deprecated props are being used.
         *
         * @param deprecationMap - The map of deprecations, where key is the prop name and the value is
         * either null or a replacement prop name.
         */
        BaseComponent.prototype._warnDeprecations = function (deprecationMap) {
            warnDeprecations(this.className, this.props);
        };
        /**
         * Warns when props which are mutually exclusive with each other are both used.
         *
         * @param mutuallyExclusiveMap - The map of mutually exclusive props.
         */
        BaseComponent.prototype._warnMutuallyExclusive = function (mutuallyExclusiveMap) {
            warnMutuallyExclusive(this.className, this.props);
        };
        /**
         * Warns when props are required if a condition is met.
         *
         * @param requiredProps - The name of the props that are required when the condition is met.
         * @param conditionalPropName - The name of the prop that the condition is based on.
         * @param condition - Whether the condition is met.
         */
        BaseComponent.prototype._warnConditionallyRequiredProps = function (requiredProps, conditionalPropName, condition) {
            warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);
        };
        BaseComponent.prototype._setComponentRef = function (ref, value) {
            if (!this._skipComponentRefResolution && ref) {
                if (typeof ref === 'function') {
                    ref(value);
                }
                if (typeof ref === 'object') {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    ref.current = value;
                }
            }
        };
        return BaseComponent;
    }(react.exports.Component));
    /**
     * Helper to override a given method with a wrapper method that can try/catch the original, but also
     * ensures that the BaseComponent's methods are called before the subclass's. This ensures that
     * componentWillUnmount in the base is called and that things in the _disposables array are disposed.
     */
    // eslint-disable-next-line deprecation/deprecation
    function _makeAllSafe(obj, prototype, methodNames) {
        for (var i = 0, len = methodNames.length; i < len; i++) {
            _makeSafe(obj, prototype, methodNames[i]);
        }
    }
    // eslint-disable-next-line deprecation/deprecation
    function _makeSafe(obj, prototype, methodName) {
        /* eslint-disable @typescript-eslint/no-explicit-any */
        var classMethod = obj[methodName];
        var prototypeMethod = prototype[methodName];
        if (classMethod || prototypeMethod) {
            obj[methodName] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                /* eslint-enable @typescript-eslint/no-explicit-any */
                var retVal;
                if (prototypeMethod) {
                    retVal = prototypeMethod.apply(this, args);
                }
                if (classMethod !== prototypeMethod) {
                    retVal = classMethod.apply(this, args);
                }
                return retVal;
            };
        }
    }
    /**
     * Simple constant function for returning null, used to render empty templates in JSX.
     *
     * @public
     */
    function nullRender() {
        return null;
    }

    /**
     * Utility component for delaying the render of a child component after a given delay. This component
     * requires a single child component; don't pass in many components. Wrap multiple components in a DIV
     * if necessary.
     *
     * @public
     * {@docCategory DelayedRender}
     */
    var DelayedRender = /** @class */ (function (_super) {
        __extends$4(DelayedRender, _super);
        function DelayedRender(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                isRendered: getWindow() === undefined,
            };
            return _this;
        }
        DelayedRender.prototype.componentDidMount = function () {
            var _this = this;
            var delay = this.props.delay;
            this._timeoutId = window.setTimeout(function () {
                _this.setState({
                    isRendered: true,
                });
            }, delay);
        };
        DelayedRender.prototype.componentWillUnmount = function () {
            if (this._timeoutId) {
                clearTimeout(this._timeoutId);
            }
        };
        DelayedRender.prototype.render = function () {
            return this.state.isRendered ? react.exports.Children.only(this.props.children) : null;
        };
        DelayedRender.defaultProps = {
            delay: 0,
        };
        return DelayedRender;
    }(react.exports.Component));

    var now = function () {
        return typeof performance !== 'undefined' && !!performance.now ? performance.now() : Date.now();
    };
    var RESET_INTERVAL = 3 * 60 * 1000; // auto reset every 3 minutes
    /**
     * Performance helper class for measuring things.
     *
     * @public
     * {@docCategory FabricPerformance}
     */
    var FabricPerformance = /** @class */ (function () {
        function FabricPerformance() {
        }
        /**
         * Measures execution time of the given syncronous function. If the same logic is executed multiple times,
         * each individual measurement will be collected as well the overall numbers.
         * @param name - The name of this measurement
         * @param func - The logic to be measured for execution time
         */
        FabricPerformance.measure = function (name, func) {
            if (FabricPerformance._timeoutId) {
                FabricPerformance.setPeriodicReset();
            }
            var start = now();
            func();
            var end = now();
            var measurement = FabricPerformance.summary[name] || {
                totalDuration: 0,
                count: 0,
                all: [],
            };
            var duration = end - start;
            measurement.totalDuration += duration;
            measurement.count++;
            measurement.all.push({
                duration: duration,
                timeStamp: end,
            });
            FabricPerformance.summary[name] = measurement;
        };
        FabricPerformance.reset = function () {
            FabricPerformance.summary = {};
            clearTimeout(FabricPerformance._timeoutId);
            FabricPerformance._timeoutId = NaN;
        };
        FabricPerformance.setPeriodicReset = function () {
            FabricPerformance._timeoutId = setTimeout(function () { return FabricPerformance.reset(); }, RESET_INTERVAL);
        };
        FabricPerformance.summary = {};
        return FabricPerformance;
    }());

    /**
     * Storing global state in local module variables has issues when more than one copy
     * if the module gets loaded on the page (due to a bundling error or simply by consuming
     * a prebundled script.)
     *
     * This file contains helpers to deal with the getting and setting local state, and allows
     * callers to get called back when it mutates.
     */
    var GLOBAL_SETTINGS_PROP_NAME = '__globalSettings__';
    var CALLBACK_STATE_PROP_NAME = '__callbacks__';
    var _counter = 0;
    /**
     * Global settings helper, which stores settings in the global (window) namespace.
     * If window is not provided, it will store settings in module scope. Provides a
     * way to observe changes as well when their values change.
     *
     * @public
     * {@docCategory GlobalSettings}
     */
    var GlobalSettings = /** @class */ (function () {
        function GlobalSettings() {
        }
        GlobalSettings.getValue = function (key, defaultValue) {
            var globalSettings = _getGlobalSettings();
            if (globalSettings[key] === undefined) {
                globalSettings[key] = typeof defaultValue === 'function' ? defaultValue() : defaultValue;
            }
            return globalSettings[key];
        };
        GlobalSettings.setValue = function (key, value) {
            var globalSettings = _getGlobalSettings();
            var callbacks = globalSettings[CALLBACK_STATE_PROP_NAME];
            var oldValue = globalSettings[key];
            if (value !== oldValue) {
                globalSettings[key] = value;
                var changeDescription = {
                    oldValue: oldValue,
                    value: value,
                    key: key,
                };
                for (var id in callbacks) {
                    if (callbacks.hasOwnProperty(id)) {
                        callbacks[id](changeDescription);
                    }
                }
            }
            return value;
        };
        GlobalSettings.addChangeListener = function (cb) {
            // Note: we use generated ids on the callbacks to create a map of the callbacks, which optimizes removal.
            // (It's faster to delete a key than it is to look up the index of an object and splice an array.)
            var id = cb.__id__;
            var callbacks = _getCallbacks();
            if (!id) {
                id = cb.__id__ = String(_counter++);
            }
            callbacks[id] = cb;
        };
        GlobalSettings.removeChangeListener = function (cb) {
            var callbacks = _getCallbacks();
            delete callbacks[cb.__id__];
        };
        return GlobalSettings;
    }());
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _getGlobalSettings() {
        var _a;
        var win = getWindow();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var globalObj = win || {};
        if (!globalObj[GLOBAL_SETTINGS_PROP_NAME]) {
            globalObj[GLOBAL_SETTINGS_PROP_NAME] = (_a = {},
                _a[CALLBACK_STATE_PROP_NAME] = {},
                _a);
        }
        return globalObj[GLOBAL_SETTINGS_PROP_NAME];
    }
    function _getCallbacks() {
        var globalSettings = _getGlobalSettings();
        return globalSettings[CALLBACK_STATE_PROP_NAME];
    }

    /**
     * Simulated enum for keycodes. These will get inlined by uglify when used much like an enum
     *
     * @public
     * {@docCategory KeyCodes}
     */
    var KeyCodes = {
        backspace: 8,
        tab: 9,
        enter: 13,
        shift: 16,
        ctrl: 17,
        alt: 18,
        pauseBreak: 19,
        capslock: 20,
        escape: 27,
        space: 32,
        pageUp: 33,
        pageDown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        insert: 45,
        del: 46,
        zero: 48,
        one: 49,
        two: 50,
        three: 51,
        four: 52,
        five: 53,
        six: 54,
        seven: 55,
        eight: 56,
        nine: 57,
        colon: 58,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        leftWindow: 91,
        rightWindow: 92,
        select: 93,
        /* eslint-disable @typescript-eslint/naming-convention */
        zero_numpad: 96,
        one_numpad: 97,
        two_numpad: 98,
        three_numpad: 99,
        four_numpad: 100,
        five_numpad: 101,
        six_numpad: 102,
        seven_numpad: 103,
        eight_numpad: 104,
        nine_numpad: 105,
        /* eslint-enable @typescript-eslint/naming-convention */
        multiply: 106,
        add: 107,
        subtract: 109,
        decimalPoint: 110,
        divide: 111,
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123,
        numlock: 144,
        scrollLock: 145,
        semicolon: 186,
        equalSign: 187,
        comma: 188,
        dash: 189,
        period: 190,
        forwardSlash: 191,
        graveAccent: 192,
        openBracket: 219,
        backSlash: 220,
        closeBracket: 221,
        singleQuote: 222,
    };

    /**
     * Rectangle helper class.
     *
     * @public
     * {@docCategory Rectangle}
     */
    var Rectangle = /** @class */ (function () {
        function Rectangle(left, right, top, bottom) {
            if (left === void 0) { left = 0; }
            if (right === void 0) { right = 0; }
            if (top === void 0) { top = 0; }
            if (bottom === void 0) { bottom = 0; }
            this.top = top;
            this.bottom = bottom;
            this.left = left;
            this.right = right;
        }
        Object.defineProperty(Rectangle.prototype, "width", {
            /**
             * Calculated automatically by subtracting the right from left
             */
            get: function () {
                return this.right - this.left;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "height", {
            /**
             * Calculated automatically by subtracting the bottom from top.
             */
            get: function () {
                return this.bottom - this.top;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Tests if another rect is approximately equal to this rect (within 4 decimal places.)
         */
        Rectangle.prototype.equals = function (rect) {
            // Fixing to 4 decimal places because it allows enough precision and will handle cases when something
            // should be rounded, like .999999 should round to 1.
            return (parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) &&
                parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) &&
                parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) &&
                parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4)));
        };
        return Rectangle;
    }());

    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * Returns a single function which will call each of the given functions in the context of the
     * parent.
     */
    function appendFunction(parent) {
        var functions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            functions[_i - 1] = arguments[_i];
        }
        if (functions.length < 2) {
            return functions[0];
        }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            functions.forEach(function (f) { return f && f.apply(parent, args); });
        };
    }

    /**
     * ARIA helper to concatenate attributes, returning undefined if all attributes
     * are undefined. (Empty strings are not a valid ARIA attribute value.)
     *
     * @param ariaAttributes - ARIA attributes to merge
     */
    function mergeAriaAttributeValues() {
        var ariaAttributes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            ariaAttributes[_i] = arguments[_i];
        }
        var mergedAttribute = ariaAttributes
            .filter(function (arg) { return arg; })
            .join(' ')
            .trim();
        return mergedAttribute === '' ? undefined : mergedAttribute;
    }

    /**
     * Helper to find the index of an item within an array, using a callback to
     * determine the match.
     *
     * @public
     * @param array - Array to search.
     * @param cb - Callback which returns true on matches.
     * @param fromIndex - Optional index to start from (defaults to 0)
     */
    function findIndex(array, cb, fromIndex) {
        if (fromIndex === void 0) { fromIndex = 0; }
        var index = -1;
        for (var i = fromIndex; array && i < array.length; i++) {
            if (cb(array[i], i)) {
                index = i;
                break;
            }
        }
        return index;
    }
    /**
     * Helper to find the first item within an array that satisfies the callback.
     * @param array - Array to search
     * @param cb - Callback which returns true on matches
     */
    function find(array, cb) {
        var index = findIndex(array, cb);
        if (index < 0) {
            return undefined;
        }
        return array[index];
    }
    /**
     * Creates an array of a given size and helper method to populate.
     *
     * @public
     * @param size - Size of array.
     * @param getItem - Callback to populate given cell index.
     */
    function createArray(size, getItem) {
        var array = [];
        for (var i = 0; i < size; i++) {
            array.push(getItem(i));
        }
        return array;
    }
    /**
     * Convert the given array to a matrix with columnCount number
     * of columns.
     *
     * @public
     * @param items - The array to convert
     * @param columnCount - The number of columns for the resulting matrix
     * @returns A matrix of items
     */
    function toMatrix(items, columnCount) {
        return items.reduce(function (rows, currentValue, index) {
            if (index % columnCount === 0) {
                rows.push([currentValue]);
            }
            else {
                rows[rows.length - 1].push(currentValue);
            }
            return rows;
        }, []);
    }
    /**
     * Given an array, it returns a new array that does not contain the item at the given index.
     * @param array - The array to operate on
     * @param index - The index of the element to remove
     */
    function removeIndex(array, index) {
        return array.filter(function (_, i) { return index !== i; });
    }
    /**
     * Given an array, this function returns a new array where the element at a given index has been replaced.
     * @param array - The array to operate on
     * @param newElement - The element that will be placed in the new array
     * @param index - The index of the element that should be replaced
     */
    function replaceElement(array, newElement, index) {
        var copy = array.slice();
        copy[index] = newElement;
        return copy;
    }
    /**
     * Given an array, this function returns a new array where an element has been inserted at the given index.
     * @param array - The array to operate on
     * @param index - The index where an element should be inserted
     * @param itemToAdd - The element to insert
     */
    function addElementAtIndex(array, index, itemToAdd) {
        var copy = array.slice();
        copy.splice(index, 0, itemToAdd);
        return copy;
    }
    /**
     * Given an array where each element is of type T or T[], flatten it into an array of T
     * @param array - The array where each element can optionally also be an array
     */
    function flatten(array) {
        var result = [];
        array.forEach(function (item) { return (result = result.concat(item)); });
        return result;
    }
    /**
     * Returns a boolean indicating if the two given arrays are equal in length and values.
     *
     * @param array1 - First array to compare
     * @param array2 - Second array to compare
     * @returns True if the arrays are the same length and have the same values in the same positions, false otherwise.
     */
    function arraysEqual(array1, array2) {
        if (array1.length !== array2.length) {
            return false;
        }
        for (var i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * asAsync - a HOC for async loading components.
     *
     * Usage:
     *
     * const AsyncDialog = asAsync({
     *   load: () => import('Dialog').then(result => result.default),
     * });
     *
     * React.render(domElement, <AsyncDialog asyncPlaceholder={ () => <Spinner/> } { ...dialogProps } />);
     *
     * Note the `asyncPlaceholder` prop will be respected when rendering the async component and it hasn't
     * been loaded yet.
     */
    /**
     * If possible, use a WeakMap to maintain a cache of loaded components.
     * This can be used to synchronously render components that have already been loaded,
     * rather than having to wait for at least one async tick.
     */
    var _syncModuleCache = typeof WeakMap !== 'undefined'
        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
            new WeakMap()
        : undefined;
    /**
     * Produces a component which internally loads the target component before first mount.
     * The component passes all props through to the loaded component.
     *
     * This overload accepts a module with a default export for the component.
     */
    function asAsync(options) {
        var Async = /** @class */ (function (_super) {
            __extends$4(Async, _super);
            function Async() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.state = {
                    Component: _syncModuleCache ? _syncModuleCache.get(options.load) : undefined,
                };
                return _this;
            }
            Async.prototype.render = function () {
                // Typescript issue: the rest can't be pulled without the any cast, as TypeScript fails with rest on generics.
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var _a = this.props, forwardedRef = _a.forwardedRef, Placeholder = _a.asyncPlaceholder, rest = __rest(_a, ["forwardedRef", "asyncPlaceholder"]);
                var Component = this.state.Component;
                return Component ? (react.exports.createElement(Component, __assign$k(__assign$k({}, rest), { ref: forwardedRef }))) : Placeholder ? (react.exports.createElement(Placeholder, null)) : null;
            };
            Async.prototype.componentDidMount = function () {
                var _this = this;
                var Component = this.state.Component;
                if (!Component) {
                    options
                        .load()
                        .then(function (LoadedComponent) {
                        if (LoadedComponent) {
                            // Cache component for future reference.
                            _syncModuleCache && _syncModuleCache.set(options.load, LoadedComponent);
                            // Set state.
                            _this.setState({
                                Component: LoadedComponent,
                            }, options.onLoad);
                        }
                    })
                        .catch(options.onError);
                }
            };
            return Async;
        }(react.exports.Component));
        return react.exports.forwardRef(function (props, ref) { return react.exports.createElement(Async, __assign$k({}, props, { forwardedRef: ref })); });
    }

    /**
     * AssertNever is a utility function that can be used for exhaustiveness checks in switch statements.
     *
     * @public
     */
    function assertNever(x) {
        throw new Error('Unexpected object: ' + x);
    }

    /**
     * Fetches an item from session storage without throwing an exception
     * @param key The key of the item to fetch from session storage
     */
    function getItem$1(key) {
        var result = null;
        try {
            var win = getWindow();
            result = win ? win.sessionStorage.getItem(key) : null;
        }
        catch (e) {
            /* Eat the exception */
        }
        return result;
    }
    /**
     * Inserts an item into session storage without throwing an exception
     * @param key The key of the item to add to session storage
     * @param data The data to put into session storage
     */
    function setItem$1(key, data) {
        var _a;
        try {
            (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.sessionStorage.setItem(key, data);
        }
        catch (e) {
            /* Eat the exception */
        }
    }

    var RTL_LOCAL_STORAGE_KEY = 'isRTL';
    // Default to undefined so that we initialize on first read.
    var _isRTL;
    /**
     * Gets the rtl state of the page (returns true if in rtl.)
     */
    function getRTL(theme) {
        if (theme === void 0) { theme = {}; }
        if (theme.rtl !== undefined) {
            return theme.rtl;
        }
        if (_isRTL === undefined) {
            // Fabric supports persisting the RTL setting between page refreshes via session storage
            var savedRTL = getItem$1(RTL_LOCAL_STORAGE_KEY);
            if (savedRTL !== null) {
                _isRTL = savedRTL === '1';
                setRTL(_isRTL);
            }
            var doc = getDocument();
            if (_isRTL === undefined && doc) {
                _isRTL = ((doc.body && doc.body.getAttribute('dir')) || doc.documentElement.getAttribute('dir')) === 'rtl';
                setRTL$1(_isRTL);
            }
        }
        return !!_isRTL;
    }
    /**
     * Sets the rtl state of the page (by adjusting the dir attribute of the html element.)
     */
    function setRTL(isRTL, persistSetting) {
        if (persistSetting === void 0) { persistSetting = false; }
        var doc = getDocument();
        if (doc) {
            doc.documentElement.setAttribute('dir', isRTL ? 'rtl' : 'ltr');
        }
        if (persistSetting) {
            setItem$1(RTL_LOCAL_STORAGE_KEY, isRTL ? '1' : '0');
        }
        _isRTL = isRTL;
        setRTL$1(_isRTL);
    }
    /**
     * Returns the given key, but flips right/left arrows if necessary.
     */
    function getRTLSafeKeyCode(key, theme) {
        if (theme === void 0) { theme = {}; }
        if (getRTL(theme)) {
            if (key === KeyCodes.left) {
                key = KeyCodes.right;
            }
            else if (key === KeyCodes.right) {
                key = KeyCodes.left;
            }
        }
        return key;
    }

    /**
     * Determines whether or not an element has the virtual hierarchy extension.
     *
     * @public
     */
    function isVirtualElement(element) {
        return element && !!element._virtual;
    }

    /**
     * Gets the virtual parent given the child element, if it exists.
     *
     * @public
     */
    function getVirtualParent(child) {
        var parent;
        if (child && isVirtualElement(child)) {
            parent = child._virtual.parent;
        }
        return parent;
    }

    /**
     * Gets the element which is the parent of a given element.
     * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over
     * real DOM parent when present.
     *
     * @public
     */
    function getParent(child, allowVirtualParents) {
        if (allowVirtualParents === void 0) { allowVirtualParents = true; }
        return (child &&
            ((allowVirtualParents && getVirtualParent(child)) || (child.parentNode && child.parentNode)));
    }

    /**
     * Determines whether or not a parent element contains a given child element.
     * If `allowVirtualParents` is true, this method may return `true` if the child
     * has the parent in its virtual element hierarchy.
     *
     * @public
     */
    function elementContains(parent, child, allowVirtualParents) {
        if (allowVirtualParents === void 0) { allowVirtualParents = true; }
        var isContained = false;
        if (parent && child) {
            if (allowVirtualParents) {
                if (parent === child) {
                    isContained = true;
                }
                else {
                    isContained = false;
                    while (child) {
                        var nextParent = getParent(child);
                        if (nextParent === parent) {
                            isContained = true;
                            break;
                        }
                        child = nextParent;
                    }
                }
            }
            else if (parent.contains) {
                isContained = parent.contains(child);
            }
        }
        return isContained;
    }

    /**
     * Finds the first parent element where the matchFunction returns true
     * @param element - element to start searching at
     * @param matchFunction - the function that determines if the element is a match
     * @returns the matched element or null no match was found
     */
    function findElementRecursive(element, matchFunction) {
        if (!element || element === document.body) {
            return null;
        }
        return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction);
    }

    /**
     * Determines if an element, or any of its ancestors, contain the given attribute
     * @param element - element to start searching at
     * @param attribute - the attribute to search for
     * @returns the value of the first instance found
     */
    function elementContainsAttribute(element, attribute) {
        var elementMatch = findElementRecursive(element, function (testElement) { return testElement.hasAttribute(attribute); });
        return elementMatch && elementMatch.getAttribute(attribute);
    }

    /**
     * Gets the elements which are child elements of the given element.
     * If `allowVirtualChildren` is `true`, this method enumerates virtual child elements
     * after the original children.
     * @param parent - The element to get the children of.
     * @param allowVirtualChildren - true if the method should enumerate virtual child elements.
     */
    function getChildren(parent, allowVirtualChildren) {
        if (allowVirtualChildren === void 0) { allowVirtualChildren = true; }
        var children = [];
        if (parent) {
            for (var i = 0; i < parent.children.length; i++) {
                children.push(parent.children.item(i));
            }
            if (allowVirtualChildren && isVirtualElement(parent)) {
                children.push.apply(children, parent._virtual.children);
            }
        }
        return children;
    }

    var DATA_PORTAL_ATTRIBUTE = 'data-portal-element';
    /**
     * Identify element as a portal by setting an attribute.
     * @param element - Element to mark as a portal.
     */
    function setPortalAttribute(element) {
        element.setAttribute(DATA_PORTAL_ATTRIBUTE, 'true');
    }

    /**
     * Determine whether a target is within a portal from perspective of root or optional parent.
     * This function only works against portal components that use the setPortalAttribute function.
     * If both parent and child are within the same portal this function will return false.
     * @param target - Element to query portal containment status of.
     * @param parent - Optional parent perspective. Search for containing portal stops at parent
     * (or root if parent is undefined or invalid.)
     */
    function portalContainsElement(target, parent) {
        var elementMatch = findElementRecursive(target, function (testElement) { return parent === testElement || testElement.hasAttribute(DATA_PORTAL_ATTRIBUTE); });
        return elementMatch !== null && elementMatch.hasAttribute(DATA_PORTAL_ATTRIBUTE);
    }

    /**
     * Sets the virtual parent of an element.
     * Pass `undefined` as the `parent` to clear the virtual parent.
     *
     * @public
     */
    function setVirtualParent(child, parent) {
        var virtualChild = child;
        var virtualParent = parent;
        if (!virtualChild._virtual) {
            virtualChild._virtual = {
                children: [],
            };
        }
        var oldParent = virtualChild._virtual.parent;
        if (oldParent && oldParent !== parent) {
            // Remove the child from its old parent.
            var index = oldParent._virtual.children.indexOf(virtualChild);
            if (index > -1) {
                oldParent._virtual.children.splice(index, 1);
            }
        }
        virtualChild._virtual.parent = virtualParent || undefined;
        if (virtualParent) {
            if (!virtualParent._virtual) {
                virtualParent._virtual = {
                    children: [],
                };
            }
            virtualParent._virtual.children.push(virtualChild);
        }
    }

    var IS_FOCUSABLE_ATTRIBUTE$1 = 'data-is-focusable';
    var IS_VISIBLE_ATTRIBUTE = 'data-is-visible';
    var FOCUSZONE_ID_ATTRIBUTE$1 = 'data-focuszone-id';
    var FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';
    /**
     * Gets the first focusable element.
     *
     * @public
     */
    function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {
        return getNextElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, false /*suppressChildTraversal*/, includeElementsInFocusZones);
    }
    /**
     * Gets the last focusable element.
     *
     * @public
     */
    function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {
        return getPreviousElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, true /*traverseChildren*/, includeElementsInFocusZones);
    }
    /**
     * Gets the first tabbable element. (The difference between focusable and tabbable is that tabbable elements are
     * focusable elements that also have tabIndex != -1.)
     * @param rootElement - The parent element to search beneath.
     * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,
     * and iteration continues forward.  Typical use passes rootElement.firstChild.
     * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.
     * @param checkNode - Include currentElement in search when true. Defaults to true.
     * @public
     */
    function getFirstTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {
        if (checkNode === void 0) { checkNode = true; }
        return getNextElement(rootElement, currentElement, checkNode, false /*suppressParentTraversal*/, false /*suppressChildTraversal*/, includeElementsInFocusZones, false /*allowFocusRoot*/, true /*tabbable*/);
    }
    /**
     * Gets the last tabbable element. (The difference between focusable and tabbable is that tabbable elements are
     * focusable elements that also have tabIndex != -1.)
     * @param rootElement - The parent element to search beneath.
     * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,
     * and iteration continues in reverse.  Typical use passes rootElement.lastChild.
     * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.
     * @param checkNode - Include currentElement in search when true. Defaults to true.
     * @public
     */
    function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {
        if (checkNode === void 0) { checkNode = true; }
        return getPreviousElement(rootElement, currentElement, checkNode, false /*suppressParentTraversal*/, true /*traverseChildren*/, includeElementsInFocusZones, false /*allowFocusRoot*/, true /*tabbable*/);
    }
    /**
     * Attempts to focus the first focusable element that is a child or child's child of the rootElement.
     *
     * @public
     * @param rootElement - Element to start the search for a focusable child.
     * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.
     * @returns True if focus was set, false if it was not.
     */
    function focusFirstChild(rootElement, bypassHiddenElements) {
        var element = getNextElement(rootElement, rootElement, true, false, false, true, undefined, undefined, bypassHiddenElements);
        if (element) {
            focusAsync(element);
            return true;
        }
        return false;
    }
    /**
     * Traverse to find the previous element.
     * If tabbable is true, the element must have tabIndex != -1.
     *
     * @public
     */
    function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable) {
        if (!currentElement || (!allowFocusRoot && currentElement === rootElement)) {
            return null;
        }
        var isCurrentElementVisible = isElementVisible(currentElement);
        // Check its children.
        if (traverseChildren &&
            isCurrentElementVisible &&
            (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
            var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
            if (childMatch) {
                if ((tabbable && isElementTabbable(childMatch, true)) || !tabbable) {
                    return childMatch;
                }
                var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
                if (childMatchSiblingMatch) {
                    return childMatchSiblingMatch;
                }
                var childMatchParent = childMatch.parentElement;
                // At this point if we have not found any potential matches
                // start looking at the rest of the subtree under the currentParent.
                // NOTE: We do not want to recurse here because doing so could
                // cause elements to get skipped.
                while (childMatchParent && childMatchParent !== currentElement) {
                    var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
                    if (childMatchParentMatch) {
                        return childMatchParentMatch;
                    }
                    childMatchParent = childMatchParent.parentElement;
                }
            }
        }
        // Check the current node, if it's not the first traversal.
        if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {
            return currentElement;
        }
        // Check its previous sibling.
        var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
        if (siblingMatch) {
            return siblingMatch;
        }
        // Check its parent.
        if (!suppressParentTraversal) {
            return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
        }
        return null;
    }
    /**
     * Traverse to find the next focusable element.
     * If tabbable is true, the element must have tabIndex != -1.
     *
     * @public
     * @param checkNode - Include currentElement in search when true.
     */
    function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements) {
        if (!currentElement || (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {
            return null;
        }
        var checkElementVisibility = bypassHiddenElements ? isElementVisibleAndNotHidden : isElementVisible;
        var isCurrentElementVisible = checkElementVisibility(currentElement);
        // Check the current node, if it's not the first traversal.
        if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {
            return currentElement;
        }
        // Check its children.
        if (!suppressChildTraversal &&
            isCurrentElementVisible &&
            (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
            var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements);
            if (childMatch) {
                return childMatch;
            }
        }
        if (currentElement === rootElement) {
            return null;
        }
        // Check its sibling.
        var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements);
        if (siblingMatch) {
            return siblingMatch;
        }
        if (!suppressParentTraversal) {
            return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements);
        }
        return null;
    }
    /**
     * Determines if an element is visible.
     *
     * @public
     */
    function isElementVisible(element) {
        // If the element is not valid, return false.
        if (!element || !element.getAttribute) {
            return false;
        }
        var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);
        // If the element is explicitly marked with the visibility attribute, return that value as boolean.
        if (visibilityAttribute !== null && visibilityAttribute !== undefined) {
            return visibilityAttribute === 'true';
        }
        // Fallback to other methods of determining actual visibility.
        return (element.offsetHeight !== 0 ||
            element.offsetParent !== null ||
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            element.isVisible === true); // used as a workaround for testing.
    }
    /**
     * Determines if an element is visible and not hidden
     * @param element - Element to check
     * @returns Returns true if the given element is visible and not hidden
     *
     * @public
     */
    function isElementVisibleAndNotHidden(element) {
        return (!!element &&
            isElementVisible(element) &&
            !element.hidden &&
            window.getComputedStyle(element).visibility !== 'hidden');
    }
    /**
     * Determines if an element can receive focus programmatically or via a mouse click.
     * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key,
     * meaning tabIndex != -1.
     *
     * @public
     */
    function isElementTabbable(element, checkTabIndex) {
        // If this element is null or is disabled, it is not considered tabbable.
        if (!element || element.disabled) {
            return false;
        }
        var tabIndex = 0;
        var tabIndexAttributeValue = null;
        if (element && element.getAttribute) {
            tabIndexAttributeValue = element.getAttribute('tabIndex');
            if (tabIndexAttributeValue) {
                tabIndex = parseInt(tabIndexAttributeValue, 10);
            }
        }
        var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE$1) : null;
        var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;
        var result = !!element &&
            isFocusableAttribute !== 'false' &&
            (element.tagName === 'A' ||
                element.tagName === 'BUTTON' ||
                element.tagName === 'INPUT' ||
                element.tagName === 'TEXTAREA' ||
                element.tagName === 'SELECT' ||
                isFocusableAttribute === 'true' ||
                isTabIndexSet);
        return checkTabIndex ? tabIndex !== -1 && result : result;
    }
    /**
     * Determines if a given element is a focus zone.
     *
     * @public
     */
    function isElementFocusZone(element) {
        return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE$1));
    }
    /**
     * Determines if a given element is a focus sub zone.
     *
     * @public
     */
    function isElementFocusSubZone(element) {
        return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');
    }
    /**
     * Determines if an element, or any of its children, contain focus.
     *
     * @public
     */
    function doesElementContainFocus(element) {
        var document = getDocument(element);
        var currentActiveElement = document && document.activeElement;
        if (currentActiveElement && elementContains(element, currentActiveElement)) {
            return true;
        }
        return false;
    }
    /**
     * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap
     * @param element - element to start searching from
     * @param noWrapDataAttribute - the no wrap data attribute to match (either)
     * @returns true if focus should wrap, false otherwise
     */
    function shouldWrapFocus(element, noWrapDataAttribute) {
        return elementContainsAttribute(element, noWrapDataAttribute) === 'true' ? false : true;
    }
    var targetToFocusOnNextRepaint = undefined;
    /**
     * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,
     * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,
     * only the latest called focusAsync element will actually be focused
     * @param element - The element to focus
     */
    function focusAsync(element) {
        if (element) {
            // An element was already queued to be focused, so replace that one with the new element
            if (targetToFocusOnNextRepaint) {
                targetToFocusOnNextRepaint = element;
                return;
            }
            targetToFocusOnNextRepaint = element;
            var win = getWindow(element);
            if (win) {
                // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe
                win.requestAnimationFrame(function () {
                    targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus();
                    // We are done focusing for this frame, so reset the queued focus element
                    targetToFocusOnNextRepaint = undefined;
                });
            }
        }
    }
    /**
     * Finds the closest focusable element via an index path from a parent. See
     * `getElementIndexPath` for getting an index path from an element to a child.
     */
    function getFocusableByIndexPath(parent, path) {
        var element = parent;
        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
            var index = path_1[_i];
            var nextChild = element.children[Math.min(index, element.children.length - 1)];
            if (!nextChild) {
                break;
            }
            element = nextChild;
        }
        element =
            isElementTabbable(element) && isElementVisible(element)
                ? element
                : getNextElement(parent, element, true) || getPreviousElement(parent, element);
        return element;
    }
    /**
     * Finds the element index path from a parent element to a child element.
     *
     * If you had this node structure: "A has children [B, C] and C has child D",
     * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.
     */
    function getElementIndexPath(fromElement, toElement) {
        var path = [];
        while (toElement && fromElement && toElement !== fromElement) {
            var parent_1 = getParent(toElement, true);
            if (parent_1 === null) {
                return [];
            }
            path.unshift(Array.prototype.indexOf.call(parent_1.children, toElement));
            toElement = parent_1;
        }
        return path;
    }

    /**
     * Gets the first visible element that matches the given selector
     * @param selector - The selector to use to find potential visible elements
     * @returns The first visible element that matches the selector, otherwise undefined
     *
     * @public
     */
    function getFirstVisibleElementFromSelector(selector) {
        var elements = getDocument().querySelectorAll(selector);
        // Iterate across the elements that match the selector and return the first visible/non-hidden element
        return Array.from(elements).find(function (element) { return isElementVisibleAndNotHidden(element); });
    }

    function on(element, eventName, callback, options) {
        element.addEventListener(eventName, callback, options);
        return function () { return element.removeEventListener(eventName, callback, options); };
    }

    /** Raises a click event.
     * @deprecated Moved to `FocusZone` component since it was the only place internally using this function.
     */
    function raiseClick(target) {
        var event = createNewEvent('MouseEvents');
        event.initEvent('click', true, true);
        target.dispatchEvent(event);
    }
    function createNewEvent(eventName) {
        var event;
        if (typeof Event === 'function') {
            // Chrome, Opera, Firefox
            event = new Event(eventName);
        }
        else {
            // IE
            event = document.createEvent('Event');
            event.initEvent(eventName, true, true);
        }
        return event;
    }

    var MAX_CACHE_COUNT = 50;
    var DEFAULT_SPECIFICITY_MULTIPLIER = 5;
    var _memoizedClassNames = 0;
    var stylesheet$1 = Stylesheet.getInstance();
    if (stylesheet$1 && stylesheet$1.onReset) {
        stylesheet$1.onReset(function () { return _memoizedClassNames++; });
    }
    // Note that because of the caching nature within the classNames memoization,
    // I've disabled this rule to simply be able to work with any types.
    /* eslint-disable @typescript-eslint/no-explicit-any */
    // This represents a prop we attach to each Map to indicate the cached return value
    // associated with the graph node.
    var retVal = '__retval__';
    /**
     * Creates a getClassNames function which calls getStyles given the props, and injects them
     * into mergeStyleSets.
     *
     * Note that the props you pass in on every render should be in the same order and
     * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating
     * these will cause extra recalcs to occur.
     */
    function classNamesFunction(options) {
        // We build a trie where each node is a Map. The map entry key represents an argument
        // value, and the entry value is another node (Map). Each node has a `__retval__`
        // property which is used to hold the cached response.
        if (options === void 0) { options = {}; }
        // To derive the response, we can simply ensure the arguments are added or already
        // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise
        // we call the `getStyles` api to evaluate, cache on the property, and return that.
        var map = new Map();
        var styleCalcCount = 0;
        var getClassNamesCount = 0;
        var currentMemoizedClassNames = _memoizedClassNames;
        var getClassNames = function (styleFunctionOrObject, styleProps) {
            var _a;
            if (styleProps === void 0) { styleProps = {}; }
            // If useStaticStyles is true, styleFunctionOrObject returns slot to classname mappings.
            // If there is also no style overrides, we can skip merge styles completely and
            // simply return the result from the style funcion.
            if (options.useStaticStyles &&
                typeof styleFunctionOrObject === 'function' &&
                styleFunctionOrObject.__noStyleOverride__) {
                return styleFunctionOrObject(styleProps);
            }
            getClassNamesCount++;
            var current = map;
            var theme = styleProps.theme;
            var rtl = theme && theme.rtl !== undefined ? theme.rtl : getRTL();
            var disableCaching = options.disableCaching;
            // On reset of our stylesheet, reset memoized cache.
            if (currentMemoizedClassNames !== _memoizedClassNames) {
                currentMemoizedClassNames = _memoizedClassNames;
                map = new Map();
                styleCalcCount = 0;
            }
            if (!options.disableCaching) {
                current = _traverseMap(map, styleFunctionOrObject);
                current = _traverseMap(current, styleProps);
            }
            if (disableCaching || !current[retVal]) {
                if (styleFunctionOrObject === undefined) {
                    current[retVal] = {};
                }
                else {
                    current[retVal] = mergeCssSets([
                        (typeof styleFunctionOrObject === 'function'
                            ? styleFunctionOrObject(styleProps)
                            : styleFunctionOrObject),
                    ], { rtl: !!rtl, specificityMultiplier: options.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : undefined });
                }
                if (!disableCaching) {
                    styleCalcCount++;
                }
            }
            if (styleCalcCount > (options.cacheSize || MAX_CACHE_COUNT)) {
                var win = getWindow();
                if ((_a = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _a === void 0 ? void 0 : _a.enableClassNameCacheFullWarning) {
                    // eslint-disable-next-line no-console
                    console.warn("Styles are being recalculated too frequently. Cache miss rate is " + styleCalcCount + "/" + getClassNamesCount + ".");
                    // eslint-disable-next-line no-console
                    console.trace();
                }
                map.clear();
                styleCalcCount = 0;
                // Mutate the options passed in, that's all we can do.
                options.disableCaching = true;
            }
            // Note: the retVal is an attached property on the Map; not a key in the Map. We use this attached property to
            // cache the return value for this branch of the graph.
            return current[retVal];
        };
        return getClassNames;
    }
    function _traverseEdge(current, value) {
        value = _normalizeValue(value);
        if (!current.has(value)) {
            current.set(value, new Map());
        }
        return current.get(value);
    }
    function _traverseMap(current, inputs) {
        if (typeof inputs === 'function') {
            var cachedInputsFromStyled = inputs.__cachedInputs__;
            if (cachedInputsFromStyled) {
                // The styled helper will generate the styles function and will attach the cached
                // inputs (consisting of the default styles, customzied styles, and user provided styles.)
                // These should be used as cache keys for deriving the memoized value.
                for (var _i = 0, _a = inputs.__cachedInputs__; _i < _a.length; _i++) {
                    var input = _a[_i];
                    current = _traverseEdge(current, input);
                }
            }
            else {
                current = _traverseEdge(current, inputs);
            }
        }
        else if (typeof inputs === 'object') {
            for (var propName in inputs) {
                if (inputs.hasOwnProperty(propName)) {
                    current = _traverseEdge(current, inputs[propName]);
                }
            }
        }
        return current;
    }
    function _normalizeValue(value) {
        switch (value) {
            case undefined:
                return '__undefined__';
            case null:
                return '__null__';
            default:
                return value;
        }
    }

    var _initializedStylesheetResets$1 = false;
    var _resetCounter = 0;
    var _emptyObject = { empty: true };
    var _dictionary = {};
    var _weakMap = typeof WeakMap === 'undefined' ? null : WeakMap;
    /**
     *  Test utility for providing a custom weakmap.
     *
     * @internal
     * */
    function setMemoizeWeakMap(weakMap) {
        _weakMap = weakMap;
    }
    /**
     * Reset memoizations.
     */
    function resetMemoizations() {
        _resetCounter++;
    }
    /**
     * Memoize decorator to be used on class methods. WARNING: the `this` reference
     * will be inaccessible within a memoized method, given that a cached method's `this`
     * would not be instance-specific.
     *
     * @public
     */
    function memoize(_target, _key, descriptor) {
        // We bind to "null" to prevent people from inadvertently pulling values from "this",
        // rather than passing them in as input values which can be memoized.
        var fn = memoizeFunction(descriptor.value && descriptor.value.bind(null));
        return {
            configurable: true,
            get: function () {
                return fn;
            },
        };
    }
    /**
     * Memoizes a function; when you pass in the same parameters multiple times, it returns a cached result.
     * Be careful when passing in objects, you need to pass in the same INSTANCE for caching to work. Otherwise
     * it will grow the cache unnecessarily. Also avoid using default values that evaluate functions; passing in
     * undefined for a value and relying on a default function will execute it the first time, but will not
     * re-evaluate subsequent times which may have been unexpected.
     *
     * By default, the cache will reset after 100 permutations, to avoid abuse cases where the function is
     * unintendedly called with unique objects. Without a reset, the cache could grow infinitely, so we safeguard
     * by resetting. To override this behavior, pass a value of 0 to the maxCacheSize parameter.
     *
     * @public
     * @param cb - The function to memoize.
     * @param maxCacheSize - Max results to cache. If the cache exceeds this value, it will reset on the next call.
     * @param ignoreNullOrUndefinedResult - Flag to decide whether to cache callback result if it is undefined/null.
     * If the flag is set to true, the callback result is recomputed every time till the callback result is
     * not undefined/null for the first time, and then the non-undefined/null version gets cached.
     * @returns A memoized version of the function.
     */
    function memoizeFunction(cb, maxCacheSize, ignoreNullOrUndefinedResult) {
        if (maxCacheSize === void 0) { maxCacheSize = 100; }
        if (ignoreNullOrUndefinedResult === void 0) { ignoreNullOrUndefinedResult = false; }
        // Avoid breaking scenarios which don't have weak map.
        if (!_weakMap) {
            return cb;
        }
        if (!_initializedStylesheetResets$1) {
            var stylesheet = Stylesheet.getInstance();
            if (stylesheet && stylesheet.onReset) {
                Stylesheet.getInstance().onReset(resetMemoizations);
            }
            _initializedStylesheetResets$1 = true;
        }
        var rootNode;
        var cacheSize = 0;
        var localResetCounter = _resetCounter;
        return function memoizedFunction() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var currentNode = rootNode;
            if (rootNode === undefined ||
                localResetCounter !== _resetCounter ||
                (maxCacheSize > 0 && cacheSize > maxCacheSize)) {
                rootNode = _createNode();
                cacheSize = 0;
                localResetCounter = _resetCounter;
            }
            currentNode = rootNode;
            // Traverse the tree until we find the match.
            for (var i = 0; i < args.length; i++) {
                var arg = _normalizeArg(args[i]);
                if (!currentNode.map.has(arg)) {
                    currentNode.map.set(arg, _createNode());
                }
                currentNode = currentNode.map.get(arg);
            }
            if (!currentNode.hasOwnProperty('value')) {
                currentNode.value = cb.apply(void 0, args);
                cacheSize++;
            }
            if (ignoreNullOrUndefinedResult && (currentNode.value === null || currentNode.value === undefined)) {
                currentNode.value = cb.apply(void 0, args);
            }
            return currentNode.value;
        };
    }
    /**
     * Creates a memoizer for a single-value function, backed by a WeakMap.
     * With a WeakMap, the memoized values are only kept as long as the source objects,
     * ensuring that there is no memory leak.
     *
     * This function assumes that the input values passed to the wrapped function will be
     * `function` or `object` types. To memoize functions which accept other inputs, use
     * `memoizeFunction`, which memoizes against arbitrary inputs using a lookup cache.
     *
     * @public
     */
    function createMemoizer(getValue) {
        if (!_weakMap) {
            // Without a `WeakMap` implementation, memoization is not possible.
            return getValue;
        }
        var cache = new _weakMap();
        function memoizedGetValue(input) {
            if (!input || (typeof input !== 'function' && typeof input !== 'object')) {
                // A WeakMap can only be used to test against reference values, i.e. 'function' and 'object'.
                // All other inputs cannot be memoized against in this manner.
                return getValue(input);
            }
            if (cache.has(input)) {
                return cache.get(input);
            }
            var value = getValue(input);
            cache.set(input, value);
            return value;
        }
        return memoizedGetValue;
    }
    function _normalizeArg(val) {
        if (!val) {
            return _emptyObject;
        }
        else if (typeof val === 'object' || typeof val === 'function') {
            return val;
        }
        else if (!_dictionary[val]) {
            _dictionary[val] = { val: val };
        }
        return _dictionary[val];
    }
    function _createNode() {
        return {
            map: _weakMap ? new _weakMap() : null,
        };
    }

    function createComposedComponent(outer) {
        var Outer = outer;
        var outerMemoizer = createMemoizer(function (inner) {
            if (outer === inner) {
                throw new Error('Attempted to compose a component with itself.');
            }
            var Inner = inner;
            var innerMemoizer = createMemoizer(function (defaultRender) {
                var InnerWithDefaultRender = function (innerProps) {
                    return react.exports.createElement(Inner, __assign$k({}, innerProps, { defaultRender: defaultRender }));
                };
                return InnerWithDefaultRender;
            });
            var OuterWithDefaultRender = function (outerProps) {
                var defaultRender = outerProps.defaultRender;
                return react.exports.createElement(Outer, __assign$k({}, outerProps, { defaultRender: defaultRender ? innerMemoizer(defaultRender) : Inner }));
            };
            return OuterWithDefaultRender;
        });
        return outerMemoizer;
    }
    var componentAsMemoizer = createMemoizer(createComposedComponent);
    /**
     * Composes two components which conform to the `IComponentAs` specification; that is, two
     * components which accept a `defaultRender` prop, which is a 'default' implementation of
     * a component which accepts the same overall props.
     *
     * @public
     */
    function composeComponentAs(outer, inner) {
        return componentAsMemoizer(outer)(inner);
    }

    /**
     * Determines whether a component is controlled.
     * @param props - Component props
     * @param valueProp - Prop containing the controlled value
     * @returns true if controlled, false if uncontrolled
     */
    function isControlled(props, valueProp) {
        // React's built-in <input> considers a prop to be provided if its value is non-null/undefined.
        // Mirror that behavior here (rather than checking for just undefined).
        return props[valueProp] !== undefined && props[valueProp] !== null;
    }

    /**
     * Concatination helper, which can merge class names together. Skips over falsey values.
     *
     * @public
     */
    function css() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var classes = [];
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var arg = args_1[_a];
            if (arg) {
                if (typeof arg === 'string') {
                    classes.push(arg);
                }
                else if (arg.hasOwnProperty('toString') && typeof arg.toString === 'function') {
                    classes.push(arg.toString());
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    for (var key in arg) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        if (arg[key]) {
                            classes.push(key);
                        }
                    }
                }
            }
        }
        return classes.join(' ');
    }

    var CustomizationsGlobalKey = 'customizations';
    var NO_CUSTOMIZATIONS = { settings: {}, scopedSettings: {}, inCustomizerContext: false };
    var _allSettings = GlobalSettings.getValue(CustomizationsGlobalKey, {
        settings: {},
        scopedSettings: {},
        inCustomizerContext: false,
    });
    var _events = [];
    var Customizations = /** @class */ (function () {
        function Customizations() {
        }
        Customizations.reset = function () {
            _allSettings.settings = {};
            _allSettings.scopedSettings = {};
        };
        /** Apply global Customization settings.
         * @example Customizations.applySettings(\{ theme: \{...\} \});
         */
        Customizations.applySettings = function (settings) {
            _allSettings.settings = __assign$k(__assign$k({}, _allSettings.settings), settings);
            Customizations._raiseChange();
        };
        /** Apply Customizations to a particular named scope, like a component.
         * @example Customizations.applyScopedSettings('Nav', \{ styles: () =\> \{\} \});
         */
        Customizations.applyScopedSettings = function (scopeName, settings) {
            _allSettings.scopedSettings[scopeName] = __assign$k(__assign$k({}, _allSettings.scopedSettings[scopeName]), settings);
            Customizations._raiseChange();
        };
        Customizations.getSettings = function (properties, scopeName, localSettings) {
            if (localSettings === void 0) { localSettings = NO_CUSTOMIZATIONS; }
            var settings = {};
            var localScopedSettings = (scopeName && localSettings.scopedSettings[scopeName]) || {};
            var globalScopedSettings = (scopeName && _allSettings.scopedSettings[scopeName]) || {};
            for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
                var property = properties_1[_i];
                settings[property] =
                    localScopedSettings[property] ||
                        localSettings.settings[property] ||
                        globalScopedSettings[property] ||
                        _allSettings.settings[property];
            }
            return settings;
        };
        /** Used to run some code that sets Customizations without triggering an update until the end.
         * Useful for applying Customizations that don't affect anything currently rendered, or for
         * applying many customizations at once.
         * @param suppressUpdate - Do not raise the change event at the end, preventing all updates
         */
        Customizations.applyBatchedUpdates = function (code, suppressUpdate) {
            Customizations._suppressUpdates = true;
            try {
                code();
            }
            catch (_a) {
                /* do nothing */
            }
            Customizations._suppressUpdates = false;
            if (!suppressUpdate) {
                Customizations._raiseChange();
            }
        };
        Customizations.observe = function (onChange) {
            _events.push(onChange);
        };
        Customizations.unobserve = function (onChange) {
            _events = _events.filter(function (cb) { return cb !== onChange; });
        };
        Customizations._raiseChange = function () {
            if (!Customizations._suppressUpdates) {
                _events.forEach(function (cb) { return cb(); });
            }
        };
        return Customizations;
    }());

    var CustomizerContext = react.exports.createContext({
        customizations: {
            inCustomizerContext: false,
            settings: {},
            scopedSettings: {},
        },
    });

    /**
     * Merge new and old settings, giving priority to new settings.
     * New settings is optional in which case oldSettings is returned as-is.
     * @param oldSettings - Old settings to fall back to.
     * @param newSettings - New settings that will be merged over oldSettings.
     * @returns Merged settings.
     */
    function mergeSettings(oldSettings, newSettings) {
        if (oldSettings === void 0) { oldSettings = {}; }
        var mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _settingsMergeWith(newSettings);
        return mergeSettingsWith(oldSettings);
    }
    function mergeScopedSettings(oldSettings, newSettings) {
        if (oldSettings === void 0) { oldSettings = {}; }
        var mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _scopedSettingsMergeWith(newSettings);
        return mergeSettingsWith(oldSettings);
    }
    function _isSettingsFunction(settings) {
        return typeof settings === 'function';
    }
    function _settingsMergeWith(newSettings) {
        return function (settings) { return (newSettings ? __assign$k(__assign$k({}, settings), newSettings) : settings); };
    }
    function _scopedSettingsMergeWith(scopedSettingsFromProps) {
        if (scopedSettingsFromProps === void 0) { scopedSettingsFromProps = {}; }
        return function (oldScopedSettings) {
            var newScopedSettings = __assign$k({}, oldScopedSettings);
            for (var scopeName in scopedSettingsFromProps) {
                if (scopedSettingsFromProps.hasOwnProperty(scopeName)) {
                    newScopedSettings[scopeName] = __assign$k(__assign$k({}, oldScopedSettings[scopeName]), scopedSettingsFromProps[scopeName]);
                }
            }
            return newScopedSettings;
        };
    }

    /**
     * Merge props and customizations giving priority to props over context.
     * NOTE: This function will always perform multiple merge operations. Use with caution.
     * @param props - New settings to merge in.
     * @param parentContext - Context containing current settings.
     * @returns Merged customizations.
     */
    function mergeCustomizations(props, parentContext) {
        var _a = (parentContext || {}).customizations, customizations = _a === void 0 ? { settings: {}, scopedSettings: {} } : _a;
        return {
            customizations: {
                settings: mergeSettings(customizations.settings, props.settings),
                scopedSettings: mergeScopedSettings(customizations.scopedSettings, props.scopedSettings),
                inCustomizerContext: true,
            },
        };
    }

    /**
     * The Customizer component allows for default props to be mixed into components which
     * are decorated with the customizable() decorator, or use the styled HOC. This enables
     * injection scenarios like:
     *
     * 1. render svg icons instead of the icon font within all buttons
     * 2. inject a custom theme object into a component
     *
     * Props are provided via the settings prop which should be one of the following:
     * - A json map which contains 1 or more name/value pairs representing injectable props.
     * - A function that receives the current settings and returns the new ones that apply to the scope
     *
     * @public
     *
     * @deprecated This component is deprecated for purpose of applying theme to components
     * as of `@fluentui/react` version 8. Use `ThemeProvider` for applying theme instead.
     */
    var Customizer = /** @class */ (function (_super) {
        __extends$4(Customizer, _super);
        function Customizer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._onCustomizationChange = function () { return _this.forceUpdate(); };
            return _this;
        }
        Customizer.prototype.componentDidMount = function () {
            Customizations.observe(this._onCustomizationChange);
        };
        Customizer.prototype.componentWillUnmount = function () {
            Customizations.unobserve(this._onCustomizationChange);
        };
        Customizer.prototype.render = function () {
            var _this = this;
            var contextTransform = this.props.contextTransform;
            return (react.exports.createElement(CustomizerContext.Consumer, null, function (parentContext) {
                var newContext = mergeCustomizations(_this.props, parentContext);
                if (contextTransform) {
                    newContext = contextTransform(newContext);
                }
                return react.exports.createElement(CustomizerContext.Provider, { value: newContext }, _this.props.children);
            }));
        };
        return Customizer;
    }(react.exports.Component));

    /**
     * Allows you to hoist static functions in components.
     * Created for the purpose of fixing broken static functions in classes
     * that utilize decorators.
     *
     * @public
     * @param source - The object where the methods are hoisted from.
     * @param dest - The object to hoist the methods onto.
     * @returns The dest object with methods added
     */
    function hoistStatics(source, dest) {
        for (var name_1 in source) {
            if (source.hasOwnProperty(name_1)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                dest[name_1] = source[name_1];
            }
        }
        return dest;
    }

    function customizable(scope, fields, concatStyles) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return function customizableFactory(ComposedComponent) {
            var _a;
            var resultClass = (_a = /** @class */ (function (_super) {
                    __extends$4(ComponentWithInjectedProps, _super);
                    function ComponentWithInjectedProps(props) {
                        var _this = _super.call(this, props) || this;
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        _this._styleCache = {};
                        _this._onSettingChanged = _this._onSettingChanged.bind(_this);
                        return _this;
                    }
                    ComponentWithInjectedProps.prototype.componentDidMount = function () {
                        Customizations.observe(this._onSettingChanged);
                    };
                    ComponentWithInjectedProps.prototype.componentWillUnmount = function () {
                        Customizations.unobserve(this._onSettingChanged);
                    };
                    ComponentWithInjectedProps.prototype.render = function () {
                        var _this = this;
                        return (react.exports.createElement(CustomizerContext.Consumer, null, function (context) {
                            var defaultProps = Customizations.getSettings(fields, scope, context.customizations);
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            var componentProps = _this.props;
                            // If defaultProps.styles is a function, evaluate it before calling concatStyleSets
                            if (defaultProps.styles && typeof defaultProps.styles === 'function') {
                                defaultProps.styles = defaultProps.styles(__assign$k(__assign$k({}, defaultProps), componentProps));
                            }
                            // If concatStyles is true and custom styles have been defined compute those styles
                            if (concatStyles && defaultProps.styles) {
                                if (_this._styleCache.default !== defaultProps.styles ||
                                    _this._styleCache.component !== componentProps.styles) {
                                    var mergedStyles = concatStyleSets(defaultProps.styles, componentProps.styles);
                                    _this._styleCache.default = defaultProps.styles;
                                    _this._styleCache.component = componentProps.styles;
                                    _this._styleCache.merged = mergedStyles;
                                }
                                return react.exports.createElement(ComposedComponent, __assign$k({}, defaultProps, componentProps, { styles: _this._styleCache.merged }));
                            }
                            return react.exports.createElement(ComposedComponent, __assign$k({}, defaultProps, componentProps));
                        }));
                    };
                    ComponentWithInjectedProps.prototype._onSettingChanged = function () {
                        this.forceUpdate();
                    };
                    return ComponentWithInjectedProps;
                }(react.exports.Component)),
                _a.displayName = 'Customized' + scope,
                _a);
            return hoistStatics(ComposedComponent, resultClass);
        };
    }

    /**
     * Hook to get Customizations settings from Customizations singleton or CustomizerContext.
     * It will trigger component state update on settings change observed.
     */
    function useCustomizationSettings(properties, scopeName) {
        var forceUpdate = useForceUpdate();
        var customizations = react.exports.useContext(CustomizerContext).customizations;
        var inCustomizerContext = customizations.inCustomizerContext;
        react.exports.useEffect(function () {
            if (!inCustomizerContext) {
                Customizations.observe(forceUpdate);
            }
            return function () {
                if (!inCustomizerContext) {
                    Customizations.unobserve(forceUpdate);
                }
            };
            // eslint-disable-next-line react-hooks/exhaustive-deps -- exclude forceUpdate
        }, [inCustomizerContext]);
        return Customizations.getSettings(properties, scopeName, customizations);
    }
    function useForceUpdate() {
        var _a = react.exports.useState(0), setValue = _a[1];
        return function () { return setValue(function (value) { return ++value; }); };
    }

    /**
     * Extends a component's lifetime methods by appending new functions to the existing lifetime functions.
     */
    function extendComponent(parent, methods) {
        for (var name_1 in methods) {
            if (methods.hasOwnProperty(name_1)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                parent[name_1] = appendFunction(parent, parent[name_1], methods[name_1]);
            }
        }
    }

    // Initialize global window id.
    var CURRENT_ID_PROPERTY = '__currentId__';
    var DEFAULT_ID_STRING = 'id__';
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var _global = getWindow() || {};
    if (_global[CURRENT_ID_PROPERTY] === undefined) {
        _global[CURRENT_ID_PROPERTY] = 0;
    }
    var _initializedStylesheetResets = false;
    /**
     * Generates a unique id in the global scope (this spans across duplicate copies of the same library.)
     *
     * @public
     */
    function getId(prefix) {
        if (!_initializedStylesheetResets) {
            // Configure ids to reset on stylesheet resets.
            var stylesheet = Stylesheet.getInstance();
            if (stylesheet && stylesheet.onReset) {
                stylesheet.onReset(resetIds);
            }
            _initializedStylesheetResets = true;
        }
        var index = _global[CURRENT_ID_PROPERTY]++;
        return (prefix === undefined ? DEFAULT_ID_STRING : prefix) + index;
    }
    /**
     * Resets id counter to an (optional) number.
     *
     * @public
     */
    function resetIds(counter) {
        if (counter === void 0) { counter = 0; }
        _global[CURRENT_ID_PROPERTY] = counter;
    }

    var toObjectMap = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        var result = {};
        for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {
            var item = items_1[_a];
            var keys = Array.isArray(item) ? item : Object.keys(item);
            for (var _b = 0, keys_1 = keys; _b < keys_1.length; _b++) {
                var key = keys_1[_b];
                result[key] = 1;
            }
        }
        return result;
    };
    /**
     * An array of events that are allowed on every html element type.
     *
     * @public
     */
    var baseElementEvents = toObjectMap([
        'onCopy',
        'onCut',
        'onPaste',
        'onCompositionEnd',
        'onCompositionStart',
        'onCompositionUpdate',
        'onFocus',
        'onFocusCapture',
        'onBlur',
        'onBlurCapture',
        'onChange',
        'onInput',
        'onSubmit',
        'onLoad',
        'onError',
        'onKeyDown',
        'onKeyDownCapture',
        'onKeyPress',
        'onKeyUp',
        'onAbort',
        'onCanPlay',
        'onCanPlayThrough',
        'onDurationChange',
        'onEmptied',
        'onEncrypted',
        'onEnded',
        'onLoadedData',
        'onLoadedMetadata',
        'onLoadStart',
        'onPause',
        'onPlay',
        'onPlaying',
        'onProgress',
        'onRateChange',
        'onSeeked',
        'onSeeking',
        'onStalled',
        'onSuspend',
        'onTimeUpdate',
        'onVolumeChange',
        'onWaiting',
        'onClick',
        'onClickCapture',
        'onContextMenu',
        'onDoubleClick',
        'onDrag',
        'onDragEnd',
        'onDragEnter',
        'onDragExit',
        'onDragLeave',
        'onDragOver',
        'onDragStart',
        'onDrop',
        'onMouseDown',
        'onMouseDownCapture',
        'onMouseEnter',
        'onMouseLeave',
        'onMouseMove',
        'onMouseOut',
        'onMouseOver',
        'onMouseUp',
        'onMouseUpCapture',
        'onSelect',
        'onTouchCancel',
        'onTouchEnd',
        'onTouchMove',
        'onTouchStart',
        'onScroll',
        'onWheel',
        'onPointerCancel',
        'onPointerDown',
        'onPointerEnter',
        'onPointerLeave',
        'onPointerMove',
        'onPointerOut',
        'onPointerOver',
        'onPointerUp',
        'onGotPointerCapture',
        'onLostPointerCapture',
    ]);
    /**
     * An array of element attributes which are allowed on every html element type.
     *
     * @public
     */
    var baseElementProperties = toObjectMap([
        'accessKey',
        'children',
        'className',
        'contentEditable',
        'dir',
        'draggable',
        'hidden',
        'htmlFor',
        'id',
        'lang',
        'ref',
        'role',
        'style',
        'tabIndex',
        'title',
        'translate',
        'spellCheck',
        'name', // global
    ]);
    /**
     * An array of HTML element properties and events.
     *
     * @public
     */
    var htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents);
    /**
     * An array of LABEL tag properties and events.
     *
     * @public
     */
    var labelProperties = toObjectMap(htmlElementProperties, [
        'form', // button, fieldset, input, label, meter, object, output, select, textarea
    ]);
    /**
     * An array of AUDIO tag properties and events.

     * @public
     */
    var audioProperties = toObjectMap(htmlElementProperties, [
        'height',
        'loop',
        'muted',
        'preload',
        'src',
        'width', // canvas, embed, iframe, img, input, object, video
    ]);
    /**
     * An array of VIDEO tag properties and events.
     *
     * @public
     */
    var videoProperties = toObjectMap(audioProperties, [
        'poster', // video
    ]);
    /**
     * An array of OL tag properties and events.
     *
     * @public
     */
    var olProperties = toObjectMap(htmlElementProperties, [
        'start', // ol
    ]);
    /**
     * An array of LI tag properties and events.
     *
     * @public
     */
    var liProperties = toObjectMap(htmlElementProperties, [
        'value', // button, input, li, option, meter, progress, param
    ]);
    /**
     * An array of A tag properties and events.
     *
     * @public
     */
    var anchorProperties = toObjectMap(htmlElementProperties, [
        'download',
        'href',
        'hrefLang',
        'media',
        'rel',
        'target',
        'type', // a, button, input, link, menu, object, script, source, style
    ]);
    /**
     * An array of BUTTON tag properties and events.
     *
     * @public
     */
    var buttonProperties = toObjectMap(htmlElementProperties, [
        'autoFocus',
        'disabled',
        'form',
        'formAction',
        'formEncType',
        'formMethod',
        'formNoValidate',
        'formTarget',
        'type',
        'value', // button, input, li, option, meter, progress, param,
    ]);
    /**
     * An array of INPUT tag properties and events.
     *
     * @public
     */
    var inputProperties = toObjectMap(buttonProperties, [
        'accept',
        'alt',
        'autoCapitalize',
        'autoComplete',
        'checked',
        'dirname',
        'form',
        'height',
        'inputMode',
        'list',
        'max',
        'maxLength',
        'min',
        'minLength',
        'multiple',
        'pattern',
        'placeholder',
        'readOnly',
        'required',
        'src',
        'step',
        'size',
        'type',
        'value',
        'width', // canvas, embed, iframe, img, input, object, video
    ]);
    /**
     * An array of TEXTAREA tag properties and events.
     *
     * @public
     */
    var textAreaProperties = toObjectMap(buttonProperties, [
        'autoCapitalize',
        'cols',
        'dirname',
        'form',
        'maxLength',
        'minLength',
        'placeholder',
        'readOnly',
        'required',
        'rows',
        'wrap', // textarea
    ]);
    /**
     * An array of SELECT tag properties and events.
     *
     * @public
     */
    var selectProperties = toObjectMap(buttonProperties, [
        'form',
        'multiple',
        'required', // input, select, textarea
    ]);
    var optionProperties = toObjectMap(htmlElementProperties, [
        'selected',
        'value', // button, input, li, option, meter, progress, param
    ]);
    /**
     * An array of TABLE tag properties and events.
     *
     * @public
     */
    var tableProperties = toObjectMap(htmlElementProperties, [
        'cellPadding',
        'cellSpacing', // table
    ]);
    /**
     * An array of TR tag properties and events.
     *
     * @public
     */
    var trProperties = htmlElementProperties;
    /**
     * An array of TH tag properties and events.
     *
     * @public
     */
    var thProperties = toObjectMap(htmlElementProperties, [
        'rowSpan',
        'scope', // th
    ]);
    /**
     * An array of TD tag properties and events.
     *
     * @public
     */
    var tdProperties = toObjectMap(htmlElementProperties, [
        'colSpan',
        'headers',
        'rowSpan',
        'scope', // th
    ]);
    var colGroupProperties = toObjectMap(htmlElementProperties, [
        'span', // col, colgroup
    ]);
    var colProperties = toObjectMap(htmlElementProperties, [
        'span', // col, colgroup
    ]);
    /**
     * An array of FORM tag properties and events.
     *
     * @public
     */
    var formProperties = toObjectMap(htmlElementProperties, [
        'acceptCharset',
        'action',
        'encType',
        'encType',
        'method',
        'noValidate',
        'target', // form
    ]);
    /**
     * An array of IFRAME tag properties and events.
     *
     * @public
     */
    var iframeProperties = toObjectMap(htmlElementProperties, [
        'allow',
        'allowFullScreen',
        'allowPaymentRequest',
        'allowTransparency',
        'csp',
        'height',
        'importance',
        'referrerPolicy',
        'sandbox',
        'src',
        'srcDoc',
        'width', // canvas, embed, iframe, img, input, object, video,
    ]);
    /**
     * An array of IMAGE tag properties and events.
     *
     * @public
     */
    var imgProperties = toObjectMap(htmlElementProperties, [
        'alt',
        'crossOrigin',
        'height',
        'src',
        'srcSet',
        'useMap',
        'width', // canvas, embed, iframe, img, input, object, video
    ]);
    /**
     * @deprecated Use imgProperties for img elements.
     */
    var imageProperties = imgProperties;
    /**
     * An array of DIV tag properties and events.
     *
     * @public
     */
    var divProperties = htmlElementProperties;
    /**
     * Gets native supported props for an html element provided the allowance set. Use one of the property
     * sets defined (divProperties, buttonPropertes, etc) to filter out supported properties from a given
     * props set. Note that all data- and aria- prefixed attributes will be allowed.
     * NOTE: getNativeProps should always be applied first when adding props to a react component. The
     * non-native props should be applied second. This will prevent getNativeProps from overriding your custom props.
     * For example, if props passed to getNativeProps has an onClick function and getNativeProps is added to
     * the component after an onClick function is added, then the getNativeProps onClick will override it.
     *
     * @public
     * @param props - The unfiltered input props
     * @param allowedPropsNames - The array or record of allowed prop names.
     * @returns The filtered props
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function getNativeProps(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    props, allowedPropNames, excludedPropNames) {
        // It'd be great to properly type this while allowing 'aria-` and 'data-' attributes like TypeScript does for
        // JSX attributes, but that ability is hardcoded into the TS compiler with no analog in TypeScript typings.
        // Then we'd be able to enforce props extends native props (including aria- and data- attributes), and then
        // return native props.
        // We should be able to do this once this PR is merged: https://github.com/microsoft/TypeScript/pull/26797
        var isArray = Array.isArray(allowedPropNames);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var result = {};
        var keys = Object.keys(props);
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
            var key = keys_2[_i];
            var isNativeProp = (!isArray && allowedPropNames[key]) ||
                (isArray && allowedPropNames.indexOf(key) >= 0) ||
                key.indexOf('data-') === 0 ||
                key.indexOf('aria-') === 0;
            if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                result[key] = props[key];
            }
        }
        return result;
    }

    var nativeElementMap = {
        label: labelProperties,
        audio: audioProperties,
        video: videoProperties,
        ol: olProperties,
        li: liProperties,
        a: anchorProperties,
        button: buttonProperties,
        input: inputProperties,
        textarea: textAreaProperties,
        select: selectProperties,
        option: optionProperties,
        table: tableProperties,
        tr: trProperties,
        th: thProperties,
        td: tdProperties,
        colGroup: colGroupProperties,
        col: colProperties,
        form: formProperties,
        iframe: iframeProperties,
        img: imgProperties,
    };
    /**
     * Given an element tagname and user props, filters the props to only allowed props for the given
     * element type.
     * @param tagName - Tag name (e.g. "div")
     * @param props - Props object
     * @param excludedPropNames - List of props to disallow
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function getNativeElementProps(tagName, props, excludedPropNames) {
        var allowedPropNames = (tagName && nativeElementMap[tagName]) || htmlElementProperties;
        return getNativeProps(props, allowedPropNames, excludedPropNames);
    }

    var REACT_LIFECYCLE_EXCLUSIONS = [
        'setState',
        'render',
        'componentWillMount',
        'UNSAFE_componentWillMount',
        'componentDidMount',
        'componentWillReceiveProps',
        'UNSAFE_componentWillReceiveProps',
        'shouldComponentUpdate',
        'componentWillUpdate',
        'getSnapshotBeforeUpdate',
        'UNSAFE_componentWillUpdate',
        'componentDidUpdate',
        'componentWillUnmount',
    ];
    /**
     * Allows you to hoist methods, except those in an exclusion set from a source object into a destination object.
     *
     * @public
     * @param destination - The instance of the object to hoist the methods onto.
     * @param source - The instance of the object where the methods are hoisted from.
     * @param exclusions - (Optional) What methods to exclude from being hoisted.
     * @returns An array of names of methods that were hoisted.
     */
    function hoistMethods(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    destination, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    source, exclusions) {
        if (exclusions === void 0) { exclusions = REACT_LIFECYCLE_EXCLUSIONS; }
        var hoisted = [];
        var _loop_1 = function (methodName) {
            if (typeof source[methodName] === 'function' &&
                destination[methodName] === undefined &&
                (!exclusions || exclusions.indexOf(methodName) === -1)) {
                hoisted.push(methodName);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                destination[methodName] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    source[methodName].apply(source, args);
                };
            }
        };
        for (var methodName in source) {
            _loop_1(methodName);
        }
        return hoisted;
    }
    /**
     * Provides a method for convenience to unhoist hoisted methods.
     *
     * @public
     * @param source - The source object upon which methods were hoisted.
     * @param methodNames - An array of method names to unhoist.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function unhoistMethods(source, methodNames) {
        methodNames.forEach(function (methodName) { return delete source[methodName]; });
    }

    /**
     * Helper to manage componentRef resolution. Internally appends logic to
     * lifetime methods to resolve componentRef to the passed in object.
     *
     * Usage: call initializeComponentRef(this) in the constructor,
     */
    function initializeComponentRef(obj) {
        extendComponent(obj, {
            componentDidMount: _onMount,
            componentDidUpdate: _onUpdate,
            componentWillUnmount: _onUnmount,
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _onMount() {
        _setComponentRef(this.props.componentRef, this);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _onUpdate(prevProps) {
        if (prevProps.componentRef !== this.props.componentRef) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            _setComponentRef(prevProps.componentRef, null);
            _setComponentRef(this.props.componentRef, this);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _onUnmount() {
        _setComponentRef(this.props.componentRef, null);
    }
    function _setComponentRef(componentRef, value) {
        if (componentRef) {
            if (typeof componentRef === 'object') {
                componentRef.current = value;
            }
            else if (typeof componentRef === 'function') {
                componentRef(value);
            }
        }
    }

    var _a$a;
    var DirectionalKeyCodes = (_a$a = {},
        _a$a[KeyCodes.up] = 1,
        _a$a[KeyCodes.down] = 1,
        _a$a[KeyCodes.left] = 1,
        _a$a[KeyCodes.right] = 1,
        _a$a[KeyCodes.home] = 1,
        _a$a[KeyCodes.end] = 1,
        _a$a[KeyCodes.tab] = 1,
        _a$a[KeyCodes.pageUp] = 1,
        _a$a[KeyCodes.pageDown] = 1,
        _a$a);
    /**
     * Returns true if the keycode is a directional keyboard key.
     */
    function isDirectionalKeyCode(which) {
        return !!DirectionalKeyCodes[which];
    }
    /**
     * Adds a keycode to the list of keys that, when pressed, should cause the focus outlines to be visible.
     * This can be used to add global shortcut keys that directionally move from section to section within
     * an app or between focus trap zones.
     */
    function addDirectionalKeyCode(which) {
        DirectionalKeyCodes[which] = 1;
    }

    var IsFocusVisibleClassName = 'ms-Fabric--isFocusVisible';
    var IsFocusHiddenClassName = 'ms-Fabric--isFocusHidden';
    function updateClassList(el, enabled) {
        if (el) {
            el.classList.add(enabled ? IsFocusVisibleClassName : IsFocusHiddenClassName);
            el.classList.remove(enabled ? IsFocusHiddenClassName : IsFocusVisibleClassName);
        }
    }
    /**
     * Sets the visibility of focus styling.
     *
     * By default, focus styles (the box surrounding a focused Button, for example) only show up when navigational
     * keypresses occur (through Tab, arrows, PgUp/PgDn, Home and End), and are hidden when mouse interactions occur.
     * This API provides an imperative way to turn them on/off.
     *
     * A use case might be when you have a keypress like ctrl-f6 navigate to a particular region on the page,
     * and want focus to show up.
     *
     * @param enabled - Whether to turn focus visibility on or off.
     * @param target - Optional target from which to get window in case no `providerElem` has been specified.
     * @param registeredProviders - Array of provider refs that are associated with a FocusRectsProvider. If no array
     *                              is passed in, the classnames are attached to the document body that contains `target`.
     */
    function setFocusVisibility(enabled, target, registeredProviders) {
        var _a;
        if (registeredProviders) {
            registeredProviders.forEach(function (ref) { return updateClassList(ref.current, enabled); });
        }
        else {
            updateClassList((_a = getWindow(target)) === null || _a === void 0 ? void 0 : _a.document.body, enabled);
        }
    }

    /**
     * Initializes the logic which:
     *
     * 1. Subscribes keydown and mousedown events. (It will only do it once per window,
     *    so it's safe to call this method multiple times.)
     * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname
     *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.
     * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the
     *    document body, removes the 'ms-Fabric--isFocusVisible' classname.
     *
     * This logic allows components on the page to conditionally render focus treatments based on
     * the existence of global classnames, which simplifies logic overall.
     *
     * @param window - the window used to add the event listeners
     * @deprecated Use useFocusRects hook or FocusRects component instead.
     */
    function initializeFocusRects(window) {
        var _a;
        var win = (window || getWindow());
        if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {
            return;
        }
        if (!win.__hasInitializeFocusRects__) {
            win.__hasInitializeFocusRects__ = true;
            win.addEventListener('mousedown', _onMouseDown$1, true);
            win.addEventListener('pointerdown', _onPointerDown$1, true);
            win.addEventListener('keydown', _onKeyDown$1, true);
        }
    }
    function _onMouseDown$1(ev) {
        setFocusVisibility(false, ev.target);
    }
    function _onPointerDown$1(ev) {
        if (ev.pointerType !== 'mouse') {
            setFocusVisibility(false, ev.target);
        }
    }
    function _onKeyDown$1(ev) {
        // eslint-disable-next-line deprecation/deprecation
        isDirectionalKeyCode(ev.which) && setFocusVisibility(true, ev.target);
    }

    var mountCounters = new WeakMap();
    var callbackMap = new WeakMap();
    function setMountCounters(key, delta) {
        var newValue;
        var currValue = mountCounters.get(key);
        if (currValue) {
            newValue = currValue + delta;
        }
        else {
            newValue = 1;
        }
        mountCounters.set(key, newValue);
        return newValue;
    }
    function setCallbackMap(context) {
        var callbacks = callbackMap.get(context);
        if (callbacks) {
            return callbacks;
        }
        var onMouseDown = function (ev) { return _onMouseDown(ev, context.registeredProviders); };
        var onPointerDown = function (ev) { return _onPointerDown(ev, context.registeredProviders); };
        var onKeyDown = function (ev) { return _onKeyDown(ev, context.registeredProviders); };
        var onKeyUp = function (ev) { return _onKeyUp(ev, context.registeredProviders); };
        callbacks = { onMouseDown: onMouseDown, onPointerDown: onPointerDown, onKeyDown: onKeyDown, onKeyUp: onKeyUp };
        callbackMap.set(context, callbacks);
        return callbacks;
    }
    var FocusRectsContext = react.exports.createContext(undefined);
    /**
     * Initializes the logic which:
     *
     * 1. Subscribes keydown, keyup, mousedown and pointerdown events. (It will only do it once for the current element of
     *    the FocusRectsContext providerRef or once per window if no such element is provided via context, so it's safe to
     *    call this method multiple times.)
     * 2. When the user presses triggers a keydown or keyup event via directional keyboard keys, adds the
     *    'ms-Fabric--isFocusVisible' classname to the current element of the FocusRectsContext providerRef or the document
     *    body if no such element is provided via context, and removes the 'ms-Fabric-isFocusHidden' classname.
     * 3. When the user triggers a mousedown or pointerdown event, adds the 'ms-Fabric-isFocusHidden' classname to the
     *    current element of the FocusRectsContext providerRef or the document body if no such element is provided via
     *    context, and removes the 'ms-Fabric--isFocusVisible' classname.
     *
     * This logic allows components on the page to conditionally render focus treatments based on
     * the existence of global classnames, which simplifies logic overall.
     *
     * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.
     */
    function useFocusRects(rootRef) {
        var context = react.exports.useContext(FocusRectsContext);
        react.exports.useEffect(function () {
            var _a, _b;
            var win = getWindow(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);
            if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {
                return undefined;
            }
            var el = win;
            var onMouseDown;
            var onPointerDown;
            var onKeyDown;
            var onKeyUp;
            if ((_b = context === null || context === void 0 ? void 0 : context.providerRef) === null || _b === void 0 ? void 0 : _b.current) {
                el = context.providerRef.current;
                var callbacks = setCallbackMap(context);
                onMouseDown = callbacks.onMouseDown;
                onPointerDown = callbacks.onPointerDown;
                onKeyDown = callbacks.onKeyDown;
                onKeyUp = callbacks.onKeyUp;
            }
            else {
                onMouseDown = _onMouseDown;
                onPointerDown = _onPointerDown;
                onKeyDown = _onKeyDown;
                onKeyUp = _onKeyUp;
            }
            var count = setMountCounters(el, 1);
            if (count <= 1) {
                el.addEventListener('mousedown', onMouseDown, true);
                el.addEventListener('pointerdown', onPointerDown, true);
                el.addEventListener('keydown', onKeyDown, true);
                el.addEventListener('keyup', onKeyUp, true);
            }
            return function () {
                var _a;
                if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {
                    return;
                }
                count = setMountCounters(el, -1);
                if (count === 0) {
                    el.removeEventListener('mousedown', onMouseDown, true);
                    el.removeEventListener('pointerdown', onPointerDown, true);
                    el.removeEventListener('keydown', onKeyDown, true);
                    el.removeEventListener('keyup', onKeyUp, true);
                }
            };
        }, [context, rootRef]);
    }
    /**
     * Function Component wrapper which enables calling `useFocusRects` hook.
     * Renders nothing.
     */
    var FocusRects = function (props) {
        useFocusRects(props.rootRef);
        return null;
    };
    function _onMouseDown(ev, registeredProviders) {
        setFocusVisibility(false, ev.target, registeredProviders);
    }
    function _onPointerDown(ev, registeredProviders) {
        if (ev.pointerType !== 'mouse') {
            setFocusVisibility(false, ev.target, registeredProviders);
        }
    }
    // You need both a keydown and a keyup listener that sets focus visibility to true to handle two distinct scenarios when
    // attaching the listeners and classnames to the provider instead of the document body.
    // If you only have a keydown listener, then the focus rectangles will not show when moving from outside of the provider
    // to inside it. That is why a keyup listener is needed, since it will always trigger after the focus event is fired.
    // If you only have a keyup listener, then the focus rectangles will not show moving between different tabbable elements
    // if the tab key is pressed without being released. That's is why we need a keydown listener, since it will trigger for
    // every element that is being tabbed into.
    // This works because `classList.add` is smart and will not duplicate a classname that already exists on the classList
    // when focus visibility is turned on.
    function _onKeyDown(ev, registeredProviders) {
        // eslint-disable-next-line deprecation/deprecation
        if (isDirectionalKeyCode(ev.which)) {
            setFocusVisibility(true, ev.target, registeredProviders);
        }
    }
    function _onKeyUp(ev, registeredProviders) {
        // eslint-disable-next-line deprecation/deprecation
        if (isDirectionalKeyCode(ev.which)) {
            setFocusVisibility(true, ev.target, registeredProviders);
        }
    }

    /**
     * Regular expressions matching characters to ignore when calculating the initials.
     */
    /**
     * Regular expression matching characters within various types of enclosures, including the enclosures themselves
     *  so for example, (xyz) [xyz] {xyz} <xyz> all would be ignored
     */
    var UNWANTED_ENCLOSURES_REGEX = /[\(\[\{\<][^\)\]\}\>]*[\)\]\}\>]/g;
    /**
     * Regular expression matching special ASCII characters except space, plus some unicode special characters.
     * Applies after unwanted enclosures have been removed
     */
    var UNWANTED_CHARS_REGEX = /[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
    /**
     * Regular expression matching phone numbers. Applied after chars matching UNWANTED_CHARS_REGEX have been removed
     * and number has been trimmed for whitespaces
     */
    var PHONENUMBER_REGEX = /^\d+[\d\s]*(:?ext|x|)\s*\d+$/i;
    /** Regular expression matching one or more spaces. */
    var MULTIPLE_WHITESPACES_REGEX = /\s+/g;
    /**
     * Regular expression matching languages for which we currently don't support initials.
     * Arabic:   Arabic, Arabic Supplement, Arabic Extended-A.
     * Korean:   Hangul Jamo, Hangul Compatibility Jamo, Hangul Jamo Extended-A, Hangul Syllables, Hangul Jamo Extended-B.
     * Japanese: Hiragana, Katakana.
     * CJK:      CJK Unified Ideographs Extension A, CJK Unified Ideographs, CJK Compatibility Ideographs,
     *             CJK Unified Ideographs Extension B
     */
    var UNSUPPORTED_TEXT_REGEX = 
    // eslint-disable-next-line @fluentui/max-len
    /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
    function getInitialsLatin(displayName, isRtl) {
        var initials = '';
        var splits = displayName.split(' ');
        if (splits.length === 2) {
            initials += splits[0].charAt(0).toUpperCase();
            initials += splits[1].charAt(0).toUpperCase();
        }
        else if (splits.length === 3) {
            initials += splits[0].charAt(0).toUpperCase();
            initials += splits[2].charAt(0).toUpperCase();
        }
        else if (splits.length !== 0) {
            initials += splits[0].charAt(0).toUpperCase();
        }
        if (isRtl && initials.length > 1) {
            return initials.charAt(1) + initials.charAt(0);
        }
        return initials;
    }
    function cleanupDisplayName(displayName) {
        displayName = displayName.replace(UNWANTED_ENCLOSURES_REGEX, '');
        displayName = displayName.replace(UNWANTED_CHARS_REGEX, '');
        displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, ' ');
        displayName = displayName.trim();
        return displayName;
    }
    /**
     * Get (up to 2 characters) initials based on display name of the persona.
     *
     * @public
     */
    function getInitials(displayName, isRtl, allowPhoneInitials) {
        if (!displayName) {
            return '';
        }
        displayName = cleanupDisplayName(displayName);
        // For names containing CJK characters, and phone numbers, we don't display initials
        if (UNSUPPORTED_TEXT_REGEX.test(displayName) || (!allowPhoneInitials && PHONENUMBER_REGEX.test(displayName))) {
            return '';
        }
        return getInitialsLatin(displayName, isRtl);
    }

    /**
     * Fetches an item from local storage without throwing an exception
     * @param key The key of the item to fetch from local storage
     */
    function getItem(key) {
        var result = null;
        try {
            var win = getWindow();
            result = win ? win.localStorage.getItem(key) : null;
        }
        catch (e) {
            /* Eat the exception */
        }
        return result;
    }
    /**
     * Inserts an item into local storage without throwing an exception
     * @param key The key of the item to add to local storage
     * @param data The data to put into local storage
     */
    function setItem(key, data) {
        try {
            var win = getWindow();
            win && win.localStorage.setItem(key, data);
        }
        catch (e) {
            /* Eat the exception */
        }
    }

    // Default to undefined so that we initialize on first read.
    var _language;
    var STORAGE_KEY = 'language';
    /**
     * Gets the language set for the page.
     * @param persistenceType - Where to persist the value. Default is `sessionStorage` if available.
     */
    function getLanguage(persistenceType) {
        if (persistenceType === void 0) { persistenceType = 'sessionStorage'; }
        if (_language === undefined) {
            var doc = getDocument();
            var savedLanguage = persistenceType === 'localStorage'
                ? getItem(STORAGE_KEY)
                : persistenceType === 'sessionStorage'
                    ? getItem$1(STORAGE_KEY)
                    : undefined;
            if (savedLanguage) {
                _language = savedLanguage;
            }
            if (_language === undefined && doc) {
                _language = doc.documentElement.getAttribute('lang');
            }
            if (_language === undefined) {
                _language = 'en';
            }
        }
        return _language;
    }
    function setLanguage(language, persistenceParam) {
        var doc = getDocument();
        if (doc) {
            doc.documentElement.setAttribute('lang', language);
        }
        var persistenceType = persistenceParam === true ? 'none' : !persistenceParam ? 'sessionStorage' : persistenceParam;
        if (persistenceType === 'localStorage') {
            setItem(STORAGE_KEY, language);
        }
        else if (persistenceType === 'sessionStorage') {
            setItem$1(STORAGE_KEY, language);
        }
        _language = language;
    }

    /**
     * Determines the distance between two points.
     *
     * @public
     */
    /* eslint-disable deprecation/deprecation */
    function getDistanceBetweenPoints(point1, point2) {
        var left1 = point1.left || point1.x || 0;
        var top1 = point1.top || point1.y || 0;
        var left2 = point2.left || point2.x || 0;
        var top2 = point2.top || point2.y || 0;
        /* eslint-enable deprecation/deprecation */
        var distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));
        return distance;
    }
    /**
     * Produces a proportionally-scaled version of an input content size when fit to a bounding size.
     * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally
     * using either `contain` or `cover` fit behaviors.
     * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.
     * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.
     * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.
     * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.
     *
     * @param options - the options for the bounds fit operation
     */
    function fitContentToBounds(options) {
        var contentSize = options.contentSize, boundsSize = options.boundsSize, _a = options.mode, mode = _a === void 0 ? 'contain' : _a, _b = options.maxScale, maxScale = _b === void 0 ? 1 : _b;
        var contentAspectRatio = contentSize.width / contentSize.height;
        var boundsAspectRatio = boundsSize.width / boundsSize.height;
        var scale;
        if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {
            scale = boundsSize.width / contentSize.width;
        }
        else {
            scale = boundsSize.height / contentSize.height;
        }
        var finalScale = Math.min(maxScale, scale);
        return {
            width: contentSize.width * finalScale,
            height: contentSize.height * finalScale,
        };
    }
    /**
     * Calculates a number's precision based on the number of trailing
     * zeros if the number does not have a decimal indicated by a negative
     * precision. Otherwise, it calculates the number of digits after
     * the decimal point indicated by a positive precision.
     * @param value - the value to determine the precision of
     */
    function calculatePrecision(value) {
        /**
         * Group 1:
         * [1-9]([0]+$) matches trailing zeros
         * Group 2:
         * \.([0-9]*) matches all digits after a decimal point.
         */
        var groups = /[1-9]([0]+$)|\.([0-9]*)/.exec(String(value));
        if (!groups) {
            return 0;
        }
        if (groups[1]) {
            return -groups[1].length;
        }
        if (groups[2]) {
            return groups[2].length;
        }
        return 0;
    }
    /**
     * Rounds a number to a certain level of precision. Accepts negative precision.
     * @param value - The value that is being rounded.
     * @param precision - The number of decimal places to round the number to
     */
    function precisionRound(value, precision, base) {
        if (base === void 0) { base = 10; }
        var exp = Math.pow(base, precision);
        return Math.round(value * exp) / exp;
    }

    /**
     * Simple deep merge function. Takes all arguments and returns a deep copy of the objects merged
     * together in the order provided. If an object creates a circular reference, it will assign the
     * original reference.
     */
    function merge(target) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var arg = args_1[_a];
            _merge(target || {}, arg);
        }
        return target;
    }
    /**
     * The _merge helper iterates through all props on source and assigns them to target.
     * When the value is an object, we will create a deep clone of the object. However if
     * there is a circular reference, the value will not be deep cloned and will persist
     * the reference.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _merge(target, source, circularReferences) {
        if (circularReferences === void 0) { circularReferences = []; }
        circularReferences.push(source);
        for (var name_1 in source) {
            if (source.hasOwnProperty(name_1)) {
                if (name_1 !== '__proto__' && name_1 !== 'constructor' && name_1 !== 'prototype') {
                    var value = source[name_1];
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        var isCircularReference = circularReferences.indexOf(value) > -1;
                        target[name_1] = (isCircularReference ? value : _merge(target[name_1] || {}, value, circularReferences));
                    }
                    else {
                        target[name_1] = value;
                    }
                }
            }
        }
        circularReferences.pop();
        return target;
    }

    /**
     * Returns true if and only if the user is on a iOS device.
     * Used to determine whether iOS-specific behavior should be applied.
     */
    var isIOS = function () {
        if (!window || !window.navigator || !window.navigator.userAgent) {
            return false;
        }
        return /iPad|iPhone|iPod/i.test(window.navigator.userAgent);
    };

    /**
     * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements
     * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).
     * That way, all other elements on the page are hidden to the screen reader.
     */
    /** Tag names to ignore when modalizing */
    var tagsToIgnore = ['TEMPLATE', 'STYLE', 'SCRIPT'];
    /**
     * Call this on a target element to make it modal to screen readers.
     * Returns a function that undoes the changes it made.
     */
    function modalize(target) {
        var targetDocument = getDocument(target);
        if (!targetDocument) {
            // can't do this in SSR
            return function () { return undefined; };
        }
        var affectedNodes = [];
        // start at target, then recurse and do the same for parent, until we reach <body>
        while (target !== targetDocument.body && target.parentElement) {
            // grab all siblings of current element
            for (var _i = 0, _a = target.parentElement.children; _i < _a.length; _i++) {
                var sibling = _a[_i];
                // but ignore elements that are already aria-hidden
                var ariaHidden = sibling.getAttribute('aria-hidden');
                if (sibling !== target && (ariaHidden === null || ariaHidden === void 0 ? void 0 : ariaHidden.toLowerCase()) !== 'true' && tagsToIgnore.indexOf(sibling.tagName) === -1) {
                    affectedNodes.push([sibling, ariaHidden]);
                }
            }
            target = target.parentElement;
        }
        // take all those elements and set aria-hidden=true on them
        affectedNodes.forEach(function (_a) {
            var node = _a[0];
            node.setAttribute('aria-hidden', 'true');
        });
        return function () {
            unmodalize(affectedNodes);
            affectedNodes = []; // dispose
        };
    }
    /**
     * Undoes the changes that modalize() did.
     */
    function unmodalize(affectedNodes) {
        affectedNodes.forEach(function (_a) {
            var node = _a[0], originalValue = _a[1];
            // Restore the original value (false or unset)
            if (originalValue) {
                node.setAttribute('aria-hidden', originalValue);
            }
            else {
                node.removeAttribute('aria-hidden');
            }
        });
    }

    var isMacResult;
    /**
     * Returns true if the user is on a Mac. Caches the result value.
     * @param reset - Reset the cached result value (mainly for testing).
     */
    function isMac(reset) {
        var _a;
        if (typeof isMacResult === 'undefined' || reset) {
            var win = getWindow();
            // In certain SSR frameworks, `window` will be defined even on the server but `navigator` will be undefined
            var userAgent = (_a = win === null || win === void 0 ? void 0 : win.navigator) === null || _a === void 0 ? void 0 : _a.userAgent;
            isMacResult = !!userAgent && userAgent.indexOf('Macintosh') !== -1;
        }
        return !!isMacResult;
    }

    /**
     * Detects whether an element's content has horizontal overflow
     *
     * @public
     * @param element - Element to check for overflow
     * @returns True if element's content overflows
     */
    function hasHorizontalOverflow(element) {
        return element.clientWidth < element.scrollWidth;
    }
    /**
     * Detects whether an element's content has vertical overflow
     *
     * @public
     * @param element - Element to check for overflow
     * @returns True if element's content overflows
     */
    function hasVerticalOverflow(element) {
        return element.clientHeight < element.scrollHeight;
    }
    /**
     * Detects whether an element's content has overflow in any direction
     *
     * @public
     * @param element - Element to check for overflow
     * @returns True if element's content overflows
     */
    function hasOverflow(element) {
        return hasHorizontalOverflow(element) || hasVerticalOverflow(element);
    }

    function createComposedRenderFunction(outer) {
        var outerMemoizer = createMemoizer(function (inner) {
            var innerMemoizer = createMemoizer(function (defaultRender) {
                return function (innerProps) {
                    return inner(innerProps, defaultRender);
                };
            });
            return function (outerProps, defaultRender) {
                return outer(outerProps, defaultRender ? innerMemoizer(defaultRender) : inner);
            };
        });
        return outerMemoizer;
    }
    var memoizer = createMemoizer(createComposedRenderFunction);
    /**
     * Composes two 'render functions' to produce a final render function that renders
     * the outer function, passing the inner function as 'default render'. The inner function
     * is then passed the original 'default render' prop.
     * @public
     */
    function composeRenderFunction(outer, inner) {
        return memoizer(outer)(inner);
    }

    var _baseUrl = '';
    /**
     * @deprecated Unused as of version 8
     */
    function getResourceUrl(url) {
        return _baseUrl + url;
    }
    /**
     * @deprecated Unused as of version 8
     */
    function setBaseUrl(baseUrl) {
        _baseUrl = baseUrl;
    }

    /**
     * Generates a function to be attached to a React component, which can be called
     * as a replacement to RAF. In-flight async calls will be auto canceled if the component
     * is unmounting before the async code is executed, preventing bugs where code
     * accesses things within the component after being unmounted.
     */
    var safeRequestAnimationFrame = function (component) {
        var activeTimeouts;
        return function (cb) {
            if (!activeTimeouts) {
                activeTimeouts = new Set();
                extendComponent(component, {
                    componentWillUnmount: function () {
                        activeTimeouts.forEach(function (id) { return cancelAnimationFrame(id); });
                    },
                });
            }
            var timeoutId = requestAnimationFrame(function () {
                activeTimeouts.delete(timeoutId);
                cb();
            });
            activeTimeouts.add(timeoutId);
        };
    };

    /**
     * Generates a function to be attached to a React component, which can be called
     * as a replacement to setTimeout. In-flight async calls will be auto canceled if the component
     * is unmounting before the async code is executed, preventing bugs where code
     * accesses things within the component after being unmounted.
     */
    var safeSetTimeout = function (component) {
        var activeTimeouts;
        return function (cb, duration) {
            if (!activeTimeouts) {
                activeTimeouts = new Set();
                extendComponent(component, {
                    componentWillUnmount: function () {
                        activeTimeouts.forEach(function (id) { return clearTimeout(id); });
                    },
                });
            }
            var timeoutId = setTimeout(function () {
                activeTimeouts.delete(timeoutId);
                cb();
            }, duration);
            activeTimeouts.add(timeoutId);
        };
    };

    var SELECTION_CHANGE = 'change';
    var SELECTION_ITEMS_CHANGE = 'items-change';
    /**
     * {@docCategory Selection}
     */
    var SelectionMode;
    (function (SelectionMode) {
        SelectionMode[SelectionMode["none"] = 0] = "none";
        SelectionMode[SelectionMode["single"] = 1] = "single";
        SelectionMode[SelectionMode["multiple"] = 2] = "multiple";
    })(SelectionMode || (SelectionMode = {}));
    /**
     * {@docCategory Selection}
     */
    var SelectionDirection;
    (function (SelectionDirection) {
        SelectionDirection[SelectionDirection["horizontal"] = 0] = "horizontal";
        SelectionDirection[SelectionDirection["vertical"] = 1] = "vertical";
    })(SelectionDirection || (SelectionDirection = {}));

    /**
     * {@docCategory Selection}
     */
    var Selection = /** @class */ (function () {
        /**
         * Create a new Selection. If `TItem` does not have a `key` property, you must provide an options
         * object with a `getKey` implementation. Providing options is optional otherwise.
         * (At most one `options` object is accepted.)
         */
        function Selection() {
            var options = []; // Otherwise, arguments require options with `getKey`.
            for (var _i = 0 // Otherwise, arguments require options with `getKey`.
            ; _i < arguments.length // Otherwise, arguments require options with `getKey`.
            ; _i++ // Otherwise, arguments require options with `getKey`.
            ) {
                options[_i] = arguments[_i]; // Otherwise, arguments require options with `getKey`.
            }
            var _a = options[0] || {}, onSelectionChanged = _a.onSelectionChanged, onItemsChanged = _a.onItemsChanged, getKey = _a.getKey, _b = _a.canSelectItem, canSelectItem = _b === void 0 ? function () { return true; } : _b, items = _a.items, _c = _a.selectionMode, selectionMode = _c === void 0 ? SelectionMode.multiple : _c;
            this.mode = selectionMode;
            this._getKey = getKey || defaultGetKey;
            this._changeEventSuppressionCount = 0;
            this._exemptedCount = 0;
            this._anchoredIndex = 0;
            this._unselectableCount = 0;
            this._onSelectionChanged = onSelectionChanged;
            this._onItemsChanged = onItemsChanged;
            this._canSelectItem = canSelectItem;
            this._keyToIndexMap = {};
            this._isModal = false;
            this.setItems(items || [], true);
            this.count = this.getSelectedCount();
        }
        Selection.prototype.canSelectItem = function (item, index) {
            if (typeof index === 'number' && index < 0) {
                return false;
            }
            return this._canSelectItem(item, index);
        };
        Selection.prototype.getKey = function (item, index) {
            var key = this._getKey(item, index);
            return typeof key === 'number' || key ? "" + key : '';
        };
        Selection.prototype.setChangeEvents = function (isEnabled, suppressChange) {
            this._changeEventSuppressionCount += isEnabled ? -1 : 1;
            if (this._changeEventSuppressionCount === 0 && this._hasChanged) {
                this._hasChanged = false;
                if (!suppressChange) {
                    this._change();
                }
            }
        };
        Selection.prototype.isModal = function () {
            return this._isModal;
        };
        Selection.prototype.setModal = function (isModal) {
            if (this._isModal !== isModal) {
                this.setChangeEvents(false);
                this._isModal = isModal;
                if (!isModal) {
                    this.setAllSelected(false);
                }
                this._change();
                this.setChangeEvents(true);
            }
        };
        /**
         * Selection needs the items, call this method to set them. If the set
         * of items is the same, this will re-evaluate selection and index maps.
         * Otherwise, shouldClear should be set to true, so that selection is
         * cleared.
         */
        Selection.prototype.setItems = function (items, shouldClear) {
            if (shouldClear === void 0) { shouldClear = true; }
            var newKeyToIndexMap = {};
            var newUnselectableIndices = {};
            var hasSelectionChanged = false;
            this.setChangeEvents(false);
            // Reset the unselectable count.
            this._unselectableCount = 0;
            var haveItemsChanged = false;
            // Build lookup table for quick selection evaluation.
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (item) {
                    var key = this.getKey(item, i);
                    if (key) {
                        if (!haveItemsChanged && (!(key in this._keyToIndexMap) || this._keyToIndexMap[key] !== i)) {
                            haveItemsChanged = true;
                        }
                        newKeyToIndexMap[key] = i;
                    }
                }
                newUnselectableIndices[i] = item && !this.canSelectItem(item);
                if (newUnselectableIndices[i]) {
                    this._unselectableCount++;
                }
            }
            if (shouldClear || items.length === 0) {
                this._setAllSelected(false, true);
            }
            // Check the exemption list for discrepencies.
            var newExemptedIndicies = {};
            var newExemptedCount = 0;
            for (var indexProperty in this._exemptedIndices) {
                if (this._exemptedIndices.hasOwnProperty(indexProperty)) {
                    var index = Number(indexProperty);
                    var item = this._items[index];
                    var exemptKey = item ? this.getKey(item, Number(index)) : undefined;
                    var newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;
                    if (newIndex === undefined) {
                        // The item has likely been replaced or removed.
                        hasSelectionChanged = true;
                    }
                    else {
                        // We know the new index of the item. update the existing exemption table.
                        newExemptedIndicies[newIndex] = true;
                        newExemptedCount++;
                        hasSelectionChanged = hasSelectionChanged || newIndex !== index;
                    }
                }
            }
            if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {
                // If everything was selected but the number of items has changed, selection has changed.
                hasSelectionChanged = true;
            }
            if (!haveItemsChanged) {
                for (var _i = 0, _a = Object.keys(this._keyToIndexMap); _i < _a.length; _i++) {
                    var key = _a[_i];
                    if (!(key in newKeyToIndexMap)) {
                        haveItemsChanged = true;
                        break;
                    }
                }
            }
            this._exemptedIndices = newExemptedIndicies;
            this._exemptedCount = newExemptedCount;
            this._keyToIndexMap = newKeyToIndexMap;
            this._unselectableIndices = newUnselectableIndices;
            this._items = items;
            this._selectedItems = null;
            if (hasSelectionChanged) {
                this._updateCount();
            }
            if (haveItemsChanged) {
                EventGroup.raise(this, SELECTION_ITEMS_CHANGE);
                if (this._onItemsChanged) {
                    this._onItemsChanged();
                }
            }
            if (hasSelectionChanged) {
                this._change();
            }
            this.setChangeEvents(true);
        };
        Selection.prototype.getItems = function () {
            return this._items;
        };
        Selection.prototype.getSelection = function () {
            if (!this._selectedItems) {
                this._selectedItems = [];
                var items = this._items;
                if (items) {
                    for (var i = 0; i < items.length; i++) {
                        if (this.isIndexSelected(i)) {
                            this._selectedItems.push(items[i]);
                        }
                    }
                }
            }
            return this._selectedItems;
        };
        Selection.prototype.getSelectedCount = function () {
            return this._isAllSelected
                ? this._items.length - this._exemptedCount - this._unselectableCount
                : this._exemptedCount;
        };
        Selection.prototype.getSelectedIndices = function () {
            if (!this._selectedIndices) {
                this._selectedIndices = [];
                var items = this._items;
                if (items) {
                    for (var i = 0; i < items.length; i++) {
                        if (this.isIndexSelected(i)) {
                            this._selectedIndices.push(i);
                        }
                    }
                }
            }
            return this._selectedIndices;
        };
        Selection.prototype.getItemIndex = function (key) {
            var index = this._keyToIndexMap[key];
            return index !== null && index !== void 0 ? index : -1;
        };
        Selection.prototype.isRangeSelected = function (fromIndex, count) {
            if (count === 0) {
                return false;
            }
            var endIndex = fromIndex + count;
            for (var i = fromIndex; i < endIndex; i++) {
                if (!this.isIndexSelected(i)) {
                    return false;
                }
            }
            return true;
        };
        Selection.prototype.isAllSelected = function () {
            var selectableCount = this._items.length - this._unselectableCount;
            // In single mode, we can only have a max of 1 item.
            if (this.mode === SelectionMode.single) {
                selectableCount = Math.min(selectableCount, 1);
            }
            return ((this.count > 0 && this._isAllSelected && this._exemptedCount === 0) ||
                (!this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0));
        };
        Selection.prototype.isKeySelected = function (key) {
            var index = this._keyToIndexMap[key];
            return this.isIndexSelected(index);
        };
        Selection.prototype.isIndexSelected = function (index) {
            return !!((this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index]) ||
                (!this._isAllSelected && this._exemptedIndices[index]));
        };
        Selection.prototype.setAllSelected = function (isAllSelected) {
            if (isAllSelected && this.mode !== SelectionMode.multiple) {
                return;
            }
            var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;
            this.setChangeEvents(false);
            if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {
                this._exemptedIndices = {};
                if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {
                    this._exemptedCount = 0;
                    this._isAllSelected = isAllSelected;
                    this._change();
                }
                this._updateCount();
            }
            this.setChangeEvents(true);
        };
        Selection.prototype.setKeySelected = function (key, isSelected, shouldAnchor) {
            var index = this._keyToIndexMap[key];
            if (index >= 0) {
                this.setIndexSelected(index, isSelected, shouldAnchor);
            }
        };
        Selection.prototype.setIndexSelected = function (index, isSelected, shouldAnchor) {
            if (this.mode === SelectionMode.none) {
                return;
            }
            // Clamp the index.
            index = Math.min(Math.max(0, index), this._items.length - 1);
            // No-op on out of bounds selections.
            if (index < 0 || index >= this._items.length) {
                return;
            }
            this.setChangeEvents(false);
            var isExempt = this._exemptedIndices[index];
            var canSelect = !this._unselectableIndices[index];
            if (canSelect) {
                if (isSelected && this.mode === SelectionMode.single) {
                    // If this is single-select, the previous selection should be removed.
                    this._setAllSelected(false, true);
                }
                // Determine if we need to remove the exemption.
                if (isExempt && ((isSelected && this._isAllSelected) || (!isSelected && !this._isAllSelected))) {
                    delete this._exemptedIndices[index];
                    this._exemptedCount--;
                }
                // Determine if we need to add the exemption.
                if (!isExempt && ((isSelected && !this._isAllSelected) || (!isSelected && this._isAllSelected))) {
                    this._exemptedIndices[index] = true;
                    this._exemptedCount++;
                }
                if (shouldAnchor) {
                    this._anchoredIndex = index;
                }
            }
            this._updateCount();
            this.setChangeEvents(true);
        };
        Selection.prototype.setRangeSelected = function (fromIndex, count, isSelected, shouldAnchor) {
            if (this.mode === SelectionMode.none) {
                return;
            }
            // Clamp the index.
            fromIndex = Math.min(Math.max(0, fromIndex), this._items.length - 1);
            // Clamp the range.
            count = Math.min(Math.max(0, count), this._items.length - fromIndex);
            // No-op on out of bounds selections.
            if (fromIndex < 0 || fromIndex >= this._items.length || count === 0) {
                return;
            }
            this.setChangeEvents(false);
            var anchorIndex = this._anchoredIndex || 0;
            var startIndex = fromIndex;
            var endIndex = fromIndex + count - 1;
            var newAnchorIndex = anchorIndex >= endIndex ? startIndex : endIndex;
            for (; startIndex <= endIndex; startIndex++) {
                this.setIndexSelected(startIndex, isSelected, shouldAnchor ? startIndex === newAnchorIndex : false);
            }
            this.setChangeEvents(true);
        };
        Selection.prototype.selectToKey = function (key, clearSelection) {
            this.selectToIndex(this._keyToIndexMap[key], clearSelection);
        };
        Selection.prototype.selectToRange = function (fromIndex, count, clearSelection) {
            if (this.mode === SelectionMode.none) {
                return;
            }
            if (this.mode === SelectionMode.single) {
                if (count === 1) {
                    this.setIndexSelected(fromIndex, true, true);
                }
                return;
            }
            var anchorIndex = this._anchoredIndex || 0;
            var startIndex = Math.min(fromIndex, anchorIndex);
            var endIndex = Math.max(fromIndex + count - 1, anchorIndex);
            this.setChangeEvents(false);
            if (clearSelection) {
                this._setAllSelected(false, true);
            }
            for (; startIndex <= endIndex; startIndex++) {
                this.setIndexSelected(startIndex, true, false);
            }
            this.setChangeEvents(true);
        };
        Selection.prototype.selectToIndex = function (index, clearSelection) {
            if (this.mode === SelectionMode.none) {
                return;
            }
            if (this.mode === SelectionMode.single) {
                this.setIndexSelected(index, true, true);
                return;
            }
            var anchorIndex = this._anchoredIndex || 0;
            var startIndex = Math.min(index, anchorIndex);
            var endIndex = Math.max(index, anchorIndex);
            this.setChangeEvents(false);
            if (clearSelection) {
                this._setAllSelected(false, true);
            }
            for (; startIndex <= endIndex; startIndex++) {
                this.setIndexSelected(startIndex, true, false);
            }
            this.setChangeEvents(true);
        };
        Selection.prototype.toggleAllSelected = function () {
            this.setAllSelected(!this.isAllSelected());
        };
        Selection.prototype.toggleKeySelected = function (key) {
            this.setKeySelected(key, !this.isKeySelected(key), true);
        };
        Selection.prototype.toggleIndexSelected = function (index) {
            this.setIndexSelected(index, !this.isIndexSelected(index), true);
        };
        Selection.prototype.toggleRangeSelected = function (fromIndex, count) {
            if (this.mode === SelectionMode.none) {
                return;
            }
            var isRangeSelected = this.isRangeSelected(fromIndex, count);
            var endIndex = fromIndex + count;
            if (this.mode === SelectionMode.single && count > 1) {
                return;
            }
            this.setChangeEvents(false);
            for (var i = fromIndex; i < endIndex; i++) {
                this.setIndexSelected(i, !isRangeSelected, false);
            }
            this.setChangeEvents(true);
        };
        Selection.prototype._updateCount = function (preserveModalState) {
            if (preserveModalState === void 0) { preserveModalState = false; }
            var count = this.getSelectedCount();
            if (count !== this.count) {
                this.count = count;
                this._change();
            }
            if (!this.count && !preserveModalState) {
                this.setModal(false);
            }
        };
        Selection.prototype._setAllSelected = function (isAllSelected, preserveModalState) {
            if (preserveModalState === void 0) { preserveModalState = false; }
            if (isAllSelected && this.mode !== SelectionMode.multiple) {
                return;
            }
            var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;
            this.setChangeEvents(false);
            if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {
                this._exemptedIndices = {};
                if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {
                    this._exemptedCount = 0;
                    this._isAllSelected = isAllSelected;
                    this._change();
                }
                this._updateCount(preserveModalState);
            }
            this.setChangeEvents(true);
        };
        Selection.prototype._change = function () {
            if (this._changeEventSuppressionCount === 0) {
                this._selectedItems = null;
                this._selectedIndices = undefined;
                EventGroup.raise(this, SELECTION_CHANGE);
                if (this._onSelectionChanged) {
                    this._onSelectionChanged();
                }
            }
            else {
                this._hasChanged = true;
            }
        };
        return Selection;
    }());
    function defaultGetKey(item, index) {
        // 0 may be used as a key
        var _a = (item || {}).key, key = _a === void 0 ? "" + index : _a;
        return key;
    }

    // Regex that finds { and } so they can be removed on a lookup for string format
    var FORMAT_ARGS_REGEX = /[\{\}]/g;
    // Regex that finds {#} so it can be replaced by the arguments in string format
    var FORMAT_REGEX = /\{\d+\}/g;
    /**
     * String format method, used for scenarios where at runtime you
     * need to evaluate a formatted string given a tokenized string. This
     * usually only is needed in localization scenarios.

     * @example
     * ```tsx
     * "I love {0} every {1}".format("CXP")
     * ```
     * will result in a Debug Exception.
     *
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function format(s) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        var args = values;
        // Callback match function
        function replaceFunc(match) {
            // looks up in the args
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var replacement = args[match.replace(FORMAT_ARGS_REGEX, '')];
            // catches undefined in nondebug and null in debug and nondebug
            if (replacement === null || replacement === undefined) {
                replacement = '';
            }
            return replacement;
        }
        return s.replace(FORMAT_REGEX, replaceFunc);
    }

    var DefaultFields = ['theme', 'styles'];
    function styled(Component, baseStyles, getProps, customizable, pure) {
        customizable = customizable || { scope: '', fields: undefined };
        var scope = customizable.scope, _a = customizable.fields, fields = _a === void 0 ? DefaultFields : _a;
        var Wrapped = react.exports.forwardRef(function (props, forwardedRef) {
            var styles = react.exports.useRef();
            var settings = useCustomizationSettings(fields, scope);
            var customizedStyles = settings.styles; settings.dir; var rest = __rest(settings, ["styles", "dir"]);
            var additionalProps = getProps ? getProps(props) : undefined;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var cache = (styles.current && styles.current.__cachedInputs__) || [];
            var propStyles = props.styles;
            if (!styles.current || customizedStyles !== cache[1] || propStyles !== cache[2]) {
                // Using styled components as the Component arg will result in nested styling arrays.
                // The function can be cached and in order to prevent the props from being retained within it's closure
                // we pass in just the styles and not the entire props
                var concatenatedStyles = function (styleProps) {
                    return concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, propStyles);
                };
                // The __cachedInputs__ array is attached to the function and consumed by the
                // classNamesFunction as a list of keys to include for memoizing classnames.
                concatenatedStyles.__cachedInputs__ = [
                    baseStyles,
                    customizedStyles,
                    propStyles,
                ];
                concatenatedStyles.__noStyleOverride__ =
                    !customizedStyles && !propStyles;
                styles.current = concatenatedStyles;
            }
            return react.exports.createElement(Component, __assign$k({ ref: forwardedRef }, rest, additionalProps, props, { styles: styles.current }));
        });
        // Function.prototype.name is an ES6 feature, so the cast to any is required until we're
        // able to drop IE 11 support and compile with ES6 libs
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Wrapped.displayName = "Styled" + (Component.displayName || Component.name);
        // This preserves backwards compatibility.
        var pureComponent = pure ? react.exports.memo(Wrapped) : Wrapped;
        // Check if the wrapper has a displayName after it has been memoized. Then assign it to the pure component.
        if (Wrapped.displayName) {
            pureComponent.displayName = Wrapped.displayName;
        }
        return pureComponent;
    }

    /** Reset controlled usage warnings for testing purposes. */
    function resetControlledWarnings() {
    }
    /**
     * Check for and warn on the following error conditions with a form component:
     * - A value prop is provided (indicated it's being used as controlled) without a change handler,
     *    and the component is not read-only
     * - Both the value and defaultValue props are provided
     * - The component is attempting to switch between controlled and uncontrolled
     *
     * The messages mimic the warnings React gives for these error conditions on input elements.
     * The warning will only be displayed once per component ID.
     */
    function warnControlledUsage(params) {
    }

    var isIE11 = function () {
        var _a;
        var win = getWindow();
        if (!((_a = win === null || win === void 0 ? void 0 : win.navigator) === null || _a === void 0 ? void 0 : _a.userAgent)) {
            return false;
        }
        return win.navigator.userAgent.indexOf('rv:11.0') > -1;
    };

    /**
     * Function to apply default values to a component props object. This function is intended for function components,
     * to maintain parity with the `defaultProps` feature of class components. It accounts for properties that are
     * specified, but undefined.
     * @param defaultProps- An object with default values for various properties
     * @param propsWithoutDefaults- The props object passed into the component
     */
    function getPropsWithDefaults(defaultProps, propsWithoutDefaults) {
        var props = __assign$k({}, propsWithoutDefaults);
        for (var _i = 0, _a = Object.keys(defaultProps); _i < _a.length; _i++) {
            var key = _a[_i];
            if (props[key] === undefined) {
                props[key] = defaultProps[key];
            }
        }
        return props;
    }

    /**
     * @deprecated Use `canUseDOM` from `@fluentui/utilities` instead.
     */
    /**
     * Helper to set ssr mode to simulate no window object returned from getWindow helper.
     *
     * @deprecated Use `canUseDOM` from `@fluentui/utilities` instead.
     */
    function setSSR(isEnabled) {
        throw new Error('setSSR has been deprecated and is not used in any utilities anymore.' +
            ' Use canUseDOM from @fluentui/utilities instead.');
    }

    /**
     * Set up a ref resolver function given internal state managed for the ref.
     * @param local Set
     */
    var createResolver = function (local) {
        return function (newValue) {
            for (var _i = 0, _a = local.refs; _i < _a.length; _i++) {
                var ref = _a[_i];
                if (typeof ref === 'function') {
                    ref(newValue);
                }
                else if (ref) {
                    // work around the immutability of the React.Ref type
                    ref.current = newValue;
                }
            }
        };
    };
    /**
     * Helper to merge refs from within class components.
     */
    var createMergedRef = function (value) {
        var local = {
            refs: [],
        };
        return function () {
            var newRefs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newRefs[_i] = arguments[_i];
            }
            if (!local.resolver || !arraysEqual(local.refs, newRefs)) {
                local.resolver = createResolver(local);
            }
            local.refs = newRefs;
            return local.resolver;
        };
    };

    /**
     * React currently throws a warning when using `useLayoutEffect` on the server. To get around it,
     * this hook calls `useEffect` on the server (no-op) and `useLayoutEffect` in the browser.
     *
     * Prefer `useEffect` unless you have a specific need to do something after mount and before paint,
     * such as to avoid a render flash for certain operations.
     *
     * Server-side rendering is detected based on `canUseDOM` from `@fluentui/utilities`.
     *
     * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
     * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js
     */
    // eslint-disable-next-line no-restricted-properties
    var useIsomorphicLayoutEffect = canUseDOM() ? react.exports.useLayoutEffect : react.exports.useEffect;

    var ICON_SETTING_NAME = 'icons';
    var _iconSettings = GlobalSettings.getValue(ICON_SETTING_NAME, {
        __options: {
            disableWarnings: false,
            warnOnMissingIcons: true,
        },
        __remapped: {},
    });
    // Reset icon registration on stylesheet resets.
    var stylesheet = Stylesheet.getInstance();
    if (stylesheet && stylesheet.onReset) {
        stylesheet.onReset(function () {
            for (var name_1 in _iconSettings) {
                if (_iconSettings.hasOwnProperty(name_1) && !!_iconSettings[name_1].subset) {
                    _iconSettings[name_1].subset.className = undefined;
                }
            }
        });
    }
    /**
     * Normalizes an icon name for consistent mapping.
     * Current implementation is to convert the icon name to lower case.
     *
     * @param name - Icon name to normalize.
     * @returns {string} Normalized icon name to use for indexing and mapping.
     */
    var normalizeIconName = function (name) { return name.toLowerCase(); };
    /**
     * Registers a given subset of icons.
     *
     * @param iconSubset - the icon subset definition.
     */
    function registerIcons(iconSubset, options) {
        var subset = __assign$k(__assign$k({}, iconSubset), { isRegistered: false, className: undefined });
        var icons = iconSubset.icons;
        // Grab options, optionally mix user provided ones on top.
        options = options ? __assign$k(__assign$k({}, _iconSettings.__options), options) : _iconSettings.__options;
        for (var iconName in icons) {
            if (icons.hasOwnProperty(iconName)) {
                var code = icons[iconName];
                var normalizedIconName = normalizeIconName(iconName);
                if (_iconSettings[normalizedIconName]) {
                    _warnDuplicateIcon(iconName);
                }
                else {
                    _iconSettings[normalizedIconName] = {
                        code: code,
                        subset: subset,
                    };
                }
            }
        }
    }
    /**
     * Unregisters icons by name.
     *
     * @param iconNames - List of icons to unregister.
     */
    function unregisterIcons(iconNames) {
        var options = _iconSettings.__options;
        var _loop_1 = function (iconName) {
            var normalizedIconName = normalizeIconName(iconName);
            if (_iconSettings[normalizedIconName]) {
                delete _iconSettings[normalizedIconName];
            }
            else {
                // Warn that we are trying to delete an icon that doesn't exist
                if (!options.disableWarnings) {
                    warn("The icon \"" + iconName + "\" tried to unregister but was not registered.");
                }
            }
            // Delete any aliases for this iconName
            if (_iconSettings.__remapped[normalizedIconName]) {
                delete _iconSettings.__remapped[normalizedIconName];
            }
            // Delete any items that were an alias for this iconName
            Object.keys(_iconSettings.__remapped).forEach(function (key) {
                if (_iconSettings.__remapped[key] === normalizedIconName) {
                    delete _iconSettings.__remapped[key];
                }
            });
        };
        for (var _i = 0, iconNames_1 = iconNames; _i < iconNames_1.length; _i++) {
            var iconName = iconNames_1[_i];
            _loop_1(iconName);
        }
    }
    /**
     * Remaps one icon name to another.
     */
    function registerIconAlias(iconName, mappedToName) {
        _iconSettings.__remapped[normalizeIconName(iconName)] = normalizeIconName(mappedToName);
    }
    /**
     * Gets an icon definition. If an icon is requested but the subset has yet to be registered,
     * it will get registered immediately.
     *
     * @public
     * @param name - Name of icon.
     */
    function getIcon(name) {
        var icon = undefined;
        var options = _iconSettings.__options;
        name = name ? normalizeIconName(name) : '';
        name = _iconSettings.__remapped[name] || name;
        if (name) {
            icon = _iconSettings[name];
            if (icon) {
                var subset = icon.subset;
                if (subset && subset.fontFace) {
                    if (!subset.isRegistered) {
                        fontFace(subset.fontFace);
                        subset.isRegistered = true;
                    }
                    if (!subset.className) {
                        subset.className = mergeStyles(subset.style, {
                            fontFamily: subset.fontFace.fontFamily,
                            fontWeight: subset.fontFace.fontWeight || 'normal',
                            fontStyle: subset.fontFace.fontStyle || 'normal',
                        });
                    }
                }
            }
            else {
                // eslint-disable-next-line deprecation/deprecation
                if (!options.disableWarnings && options.warnOnMissingIcons) {
                    warn("The icon \"" + name + "\" was used but not registered. See https://github.com/microsoft/fluentui/wiki/Using-icons for more information.");
                }
            }
        }
        return icon;
    }
    /**
     * Sets the icon options.
     *
     * @public
     */
    function setIconOptions(options) {
        _iconSettings.__options = __assign$k(__assign$k({}, _iconSettings.__options), options);
    }
    var _missingIcons = [];
    var _missingIconsTimer = undefined;
    function _warnDuplicateIcon(iconName) {
        var options = _iconSettings.__options;
        var warningDelay = 2000;
        var maxIconsInMessage = 10;
        if (!options.disableWarnings) {
            _missingIcons.push(iconName);
            if (_missingIconsTimer === undefined) {
                _missingIconsTimer = setTimeout(function () {
                    warn("Some icons were re-registered. Applications should only call registerIcons for any given " +
                        "icon once. Redefining what an icon is may have unintended consequences. Duplicates " +
                        "include: \n" +
                        _missingIcons.slice(0, maxIconsInMessage).join(', ') +
                        (_missingIcons.length > maxIconsInMessage ? " (+ " + (_missingIcons.length - maxIconsInMessage) + " more)" : ''));
                    _missingIconsTimer = undefined;
                    _missingIcons = [];
                }, warningDelay);
            }
        }
    }

    var defaultIconStyles = {
        display: 'inline-block',
    };
    /**
     * Gets an icon classname. You should be able to add this classname to an I tag with no
     * additional classnames, and render the icon.
     *
     * @public
     */
    function getIconClassName(name) {
        var className = '';
        var icon = getIcon(name);
        if (icon) {
            className = mergeStyles(icon.subset.className, defaultIconStyles, {
                selectors: {
                    '::before': {
                        content: "\"" + icon.code + "\"",
                    },
                },
            });
        }
        return className;
    }

    /** Generates all the semantic slot colors based on the theme so far
     * We'll use these as fallbacks for semantic slots that the passed in theme did not define.
     * The caller must still mix in the customized semantic slots at the end.
     */
    function makeSemanticColors(p, e, s, isInverted, depComments) {
        if (depComments === void 0) { depComments = false; }
        var semanticColors = __assign$k({ primaryButtonBorder: 'transparent', errorText: !isInverted ? '#a4262c' : '#F1707B', messageText: !isInverted ? '#323130' : '#F3F2F1', messageLink: !isInverted ? '#005A9E' : '#6CB8F6', messageLinkHovered: !isInverted ? '#004578' : '#82C7FF', infoIcon: !isInverted ? '#605e5c' : '#C8C6C4', errorIcon: !isInverted ? '#A80000' : '#F1707B', blockingIcon: !isInverted ? '#FDE7E9' : '#442726', warningIcon: !isInverted ? '#797775' : '#C8C6C4', severeWarningIcon: !isInverted ? '#D83B01' : '#FCE100', successIcon: !isInverted ? '#107C10' : '#92C353', infoBackground: !isInverted ? '#f3f2f1' : '#323130', errorBackground: !isInverted ? '#FDE7E9' : '#442726', blockingBackground: !isInverted ? '#FDE7E9' : '#442726', warningBackground: !isInverted ? '#FFF4CE' : '#433519', severeWarningBackground: !isInverted ? '#FED9CC' : '#4F2A0F', successBackground: !isInverted ? '#DFF6DD' : '#393D1B', 
            // deprecated
            warningHighlight: !isInverted ? '#ffb900' : '#fff100', successText: !isInverted ? '#107C10' : '#92c353' }, s);
        var fullSemanticColors = getSemanticColors(p, e, semanticColors, isInverted);
        return _fixDeprecatedSlots(fullSemanticColors, depComments);
    }
    /**
     * Map partial platte and effects to partial semantic colors.
     */
    function getSemanticColors(p, e, s, isInverted, depComments) {
        var result = {};
        // map palette
        var _a = p || {}, white = _a.white, black = _a.black, themePrimary = _a.themePrimary, themeDark = _a.themeDark, themeDarker = _a.themeDarker, themeDarkAlt = _a.themeDarkAlt, themeLighter = _a.themeLighter, neutralLight = _a.neutralLight, neutralLighter = _a.neutralLighter, neutralDark = _a.neutralDark, neutralQuaternary = _a.neutralQuaternary, neutralQuaternaryAlt = _a.neutralQuaternaryAlt, neutralPrimary = _a.neutralPrimary, neutralSecondary = _a.neutralSecondary, neutralSecondaryAlt = _a.neutralSecondaryAlt, neutralTertiary = _a.neutralTertiary, neutralTertiaryAlt = _a.neutralTertiaryAlt, neutralLighterAlt = _a.neutralLighterAlt, accent = _a.accent;
        if (white) {
            result.bodyBackground = white;
            result.bodyFrameBackground = white;
            result.accentButtonText = white;
            result.buttonBackground = white;
            result.primaryButtonText = white;
            result.primaryButtonTextHovered = white;
            result.primaryButtonTextPressed = white;
            result.inputBackground = white;
            result.inputForegroundChecked = white;
            result.listBackground = white;
            result.menuBackground = white;
            result.cardStandoutBackground = white;
        }
        if (black) {
            result.bodyTextChecked = black;
            result.buttonTextCheckedHovered = black;
        }
        if (themePrimary) {
            result.link = themePrimary;
            result.primaryButtonBackground = themePrimary;
            result.inputBackgroundChecked = themePrimary;
            result.inputIcon = themePrimary;
            result.inputFocusBorderAlt = themePrimary;
            result.menuIcon = themePrimary;
            result.menuHeader = themePrimary;
            result.accentButtonBackground = themePrimary;
        }
        if (themeDark) {
            result.primaryButtonBackgroundPressed = themeDark;
            result.inputBackgroundCheckedHovered = themeDark;
            result.inputIconHovered = themeDark;
        }
        if (themeDarker) {
            result.linkHovered = themeDarker;
        }
        if (themeDarkAlt) {
            result.primaryButtonBackgroundHovered = themeDarkAlt;
        }
        if (themeLighter) {
            result.inputPlaceholderBackgroundChecked = themeLighter;
        }
        if (neutralLight) {
            result.bodyBackgroundChecked = neutralLight;
            result.bodyFrameDivider = neutralLight;
            result.bodyDivider = neutralLight;
            result.variantBorder = neutralLight;
            result.buttonBackgroundCheckedHovered = neutralLight;
            result.buttonBackgroundPressed = neutralLight;
            result.listItemBackgroundChecked = neutralLight;
            result.listHeaderBackgroundPressed = neutralLight;
            result.menuItemBackgroundPressed = neutralLight;
            // eslint-disable-next-line deprecation/deprecation
            result.menuItemBackgroundChecked = neutralLight;
        }
        if (neutralLighter) {
            result.bodyBackgroundHovered = neutralLighter;
            result.buttonBackgroundHovered = neutralLighter;
            result.buttonBackgroundDisabled = neutralLighter;
            result.buttonBorderDisabled = neutralLighter;
            result.primaryButtonBackgroundDisabled = neutralLighter;
            result.disabledBackground = neutralLighter;
            result.listItemBackgroundHovered = neutralLighter;
            result.listHeaderBackgroundHovered = neutralLighter;
            result.menuItemBackgroundHovered = neutralLighter;
        }
        if (neutralQuaternary) {
            result.primaryButtonTextDisabled = neutralQuaternary;
            result.disabledSubtext = neutralQuaternary;
        }
        if (neutralQuaternaryAlt) {
            result.listItemBackgroundCheckedHovered = neutralQuaternaryAlt;
        }
        if (neutralTertiary) {
            result.disabledBodyText = neutralTertiary;
            result.variantBorderHovered = (s === null || s === void 0 ? void 0 : s.variantBorderHovered) || neutralTertiary;
            result.buttonTextDisabled = neutralTertiary;
            result.inputIconDisabled = neutralTertiary;
            result.disabledText = neutralTertiary;
        }
        if (neutralPrimary) {
            result.bodyText = neutralPrimary;
            result.actionLink = neutralPrimary;
            result.buttonText = neutralPrimary;
            result.inputBorderHovered = neutralPrimary;
            result.inputText = neutralPrimary;
            result.listText = neutralPrimary;
            result.menuItemText = neutralPrimary;
        }
        if (neutralLighterAlt) {
            result.bodyStandoutBackground = neutralLighterAlt;
            result.defaultStateBackground = neutralLighterAlt;
        }
        if (neutralDark) {
            result.actionLinkHovered = neutralDark;
            result.buttonTextHovered = neutralDark;
            result.buttonTextChecked = neutralDark;
            result.buttonTextPressed = neutralDark;
            result.inputTextHovered = neutralDark;
            result.menuItemTextHovered = neutralDark;
        }
        if (neutralSecondary) {
            result.bodySubtext = neutralSecondary;
            result.focusBorder = neutralSecondary;
            result.inputBorder = neutralSecondary;
            result.smallInputBorder = neutralSecondary;
            result.inputPlaceholderText = neutralSecondary;
        }
        if (neutralSecondaryAlt) {
            result.buttonBorder = neutralSecondaryAlt;
        }
        if (neutralTertiaryAlt) {
            result.disabledBodySubtext = neutralTertiaryAlt;
            result.disabledBorder = neutralTertiaryAlt;
            result.buttonBackgroundChecked = neutralTertiaryAlt;
            result.menuDivider = neutralTertiaryAlt;
        }
        if (accent) {
            result.accentButtonBackground = accent;
        }
        // map effects
        if (e === null || e === void 0 ? void 0 : e.elevation4) {
            result.cardShadow = e.elevation4;
        }
        if (!isInverted && (e === null || e === void 0 ? void 0 : e.elevation8)) {
            result.cardShadowHovered = e.elevation8;
        }
        else if (result.variantBorderHovered) {
            result.cardShadowHovered = '0 0 1px ' + result.variantBorderHovered;
        }
        result = __assign$k(__assign$k({}, result), s);
        return result;
    }
    function _fixDeprecatedSlots(s, depComments) {
        // Add @deprecated tag as comment if enabled
        var dep = '';
        if (depComments === true) {
            dep = ' /* @deprecated */';
        }
        /* eslint-disable deprecation/deprecation */
        s.listTextColor = s.listText + dep;
        s.menuItemBackgroundChecked += dep;
        s.warningHighlight += dep;
        s.warningText = s.messageText + dep;
        s.successText += dep;
        /* eslint-enable deprecation/deprecation */
        return s;
    }

    /**
     * Merge a partial/full theme into a full theme and returns a merged full theme.
     */
    function mergeThemes(theme, partialTheme) {
        var _a, _b, _c;
        if (partialTheme === void 0) { partialTheme = {}; }
        var mergedTheme = merge({}, theme, partialTheme, {
            semanticColors: getSemanticColors(partialTheme.palette, partialTheme.effects, partialTheme.semanticColors, partialTheme.isInverted === undefined ? theme.isInverted : partialTheme.isInverted),
        });
        if (((_a = partialTheme.palette) === null || _a === void 0 ? void 0 : _a.themePrimary) && !((_b = partialTheme.palette) === null || _b === void 0 ? void 0 : _b.accent)) {
            mergedTheme.palette.accent = partialTheme.palette.themePrimary;
        }
        if (partialTheme.defaultFontStyle) {
            for (var _i = 0, _d = Object.keys(mergedTheme.fonts); _i < _d.length; _i++) {
                var fontStyle = _d[_i];
                mergedTheme.fonts[fontStyle] = merge(mergedTheme.fonts[fontStyle], partialTheme.defaultFontStyle, (_c = partialTheme === null || partialTheme === void 0 ? void 0 : partialTheme.fonts) === null || _c === void 0 ? void 0 : _c[fontStyle]);
            }
        }
        return mergedTheme;
    }

    var CommunicationColors;
    (function (CommunicationColors) {
        CommunicationColors.shade30 = '#004578';
        CommunicationColors.shade20 = '#005a9e';
        CommunicationColors.shade10 = '#106ebe';
        CommunicationColors.primary = '#0078d4';
        CommunicationColors.tint10 = '#2b88d8';
        CommunicationColors.tint20 = '#c7e0f4';
        CommunicationColors.tint30 = '#deecf9';
        CommunicationColors.tint40 = '#eff6fc';
    })(CommunicationColors || (CommunicationColors = {}));
    var NeutralColors;
    (function (NeutralColors) {
        NeutralColors.black = '#000000';
        NeutralColors.gray220 = '#11100f';
        NeutralColors.gray210 = '#161514';
        NeutralColors.gray200 = '#1b1a19';
        NeutralColors.gray190 = '#201f1e';
        NeutralColors.gray180 = '#252423';
        NeutralColors.gray170 = '#292827';
        NeutralColors.gray160 = '#323130';
        NeutralColors.gray150 = '#3b3a39';
        NeutralColors.gray140 = '#484644';
        NeutralColors.gray130 = '#605e5c';
        NeutralColors.gray120 = '#797775';
        NeutralColors.gray110 = '#8a8886';
        NeutralColors.gray100 = '#979593';
        NeutralColors.gray90 = '#a19f9d';
        NeutralColors.gray80 = '#b3b0ad';
        NeutralColors.gray70 = '#bebbb8';
        NeutralColors.gray60 = '#c8c6c4';
        NeutralColors.gray50 = '#d2d0ce';
        NeutralColors.gray40 = '#e1dfdd';
        NeutralColors.gray30 = '#edebe9';
        NeutralColors.gray20 = '#f3f2f1';
        NeutralColors.gray10 = '#faf9f8';
        NeutralColors.white = '#ffffff';
    })(NeutralColors || (NeutralColors = {}));
    var SharedColors;
    (function (SharedColors) {
        SharedColors.pinkRed10 = '#750b1c';
        SharedColors.red20 = '#a4262c';
        SharedColors.red10 = '#d13438';
        SharedColors.redOrange20 = '#603d30';
        SharedColors.redOrange10 = '#da3b01';
        SharedColors.orange30 = '#8e562e';
        SharedColors.orange20 = '#ca5010';
        SharedColors.orange10 = '#ffaa44';
        SharedColors.yellow10 = '#fce100';
        SharedColors.orangeYellow20 = '#986f0b';
        SharedColors.orangeYellow10 = '#c19c00';
        SharedColors.yellowGreen10 = '#8cbd18';
        SharedColors.green20 = '#0b6a0b';
        SharedColors.green10 = '#498205';
        SharedColors.greenCyan10 = '#00ad56';
        SharedColors.cyan40 = '#005e50';
        SharedColors.cyan30 = '#005b70';
        SharedColors.cyan20 = '#038387';
        SharedColors.cyan10 = '#00b7c3';
        SharedColors.cyanBlue20 = '#004e8c';
        SharedColors.cyanBlue10 = '#0078d4';
        SharedColors.blue10 = '#4f6bed';
        SharedColors.blueMagenta40 = '#373277';
        SharedColors.blueMagenta30 = '#5c2e91';
        SharedColors.blueMagenta20 = '#8764b8';
        SharedColors.blueMagenta10 = '#8378de';
        SharedColors.magenta20 = '#881798';
        SharedColors.magenta10 = '#c239b3';
        SharedColors.magentaPink20 = '#9b0062';
        SharedColors.magentaPink10 = '#e3008c';
        SharedColors.gray40 = '#393939';
        SharedColors.gray30 = '#7a7574';
        SharedColors.gray20 = '#69797e';
        SharedColors.gray10 = '#a0aeb2';
    })(SharedColors || (SharedColors = {}));

    // When adding or removing a color, make sure you keep this consistent with IColorClassNames
    // by adding the color variants.
    var DefaultPalette = {
        themeDarker: '#004578',
        themeDark: '#005a9e',
        themeDarkAlt: '#106ebe',
        themePrimary: '#0078d4',
        themeSecondary: '#2b88d8',
        themeTertiary: '#71afe5',
        themeLight: '#c7e0f4',
        themeLighter: '#deecf9',
        themeLighterAlt: '#eff6fc',
        black: '#000000',
        blackTranslucent40: 'rgba(0,0,0,.4)',
        neutralDark: '#201f1e',
        neutralPrimary: '#323130',
        neutralPrimaryAlt: '#3b3a39',
        neutralSecondary: '#605e5c',
        neutralSecondaryAlt: '#8a8886',
        neutralTertiary: '#a19f9d',
        neutralTertiaryAlt: '#c8c6c4',
        neutralQuaternary: '#d2d0ce',
        neutralQuaternaryAlt: '#e1dfdd',
        neutralLight: '#edebe9',
        neutralLighter: '#f3f2f1',
        neutralLighterAlt: '#faf9f8',
        accent: '#0078d4',
        white: '#ffffff',
        whiteTranslucent40: 'rgba(255,255,255,.4)',
        yellowDark: '#d29200',
        yellow: '#ffb900',
        yellowLight: '#fff100',
        orange: '#d83b01',
        orangeLight: '#ea4300',
        orangeLighter: '#ff8c00',
        redDark: '#a4262c',
        red: '#e81123',
        magentaDark: '#5c005c',
        magenta: '#b4009e',
        magentaLight: '#e3008c',
        purpleDark: '#32145a',
        purple: '#5c2d91',
        purpleLight: '#b4a0ff',
        blueDark: '#002050',
        blueMid: '#00188f',
        blue: '#0078d4',
        blueLight: '#00bcf2',
        tealDark: '#004b50',
        teal: '#008272',
        tealLight: '#00b294',
        greenDark: '#004b1c',
        green: '#107c10',
        greenLight: '#bad80a',
    };

    var Depths;
    (function (Depths) {
        Depths.depth0 = '0 0 0 0 transparent';
        Depths.depth4 = '0 1.6px 3.6px 0 rgba(0, 0, 0, 0.132), 0 0.3px 0.9px 0 rgba(0, 0, 0, 0.108)';
        Depths.depth8 = '0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132), 0 0.6px 1.8px 0 rgba(0, 0, 0, 0.108)';
        Depths.depth16 = '0 6.4px 14.4px 0 rgba(0, 0, 0, 0.132), 0 1.2px 3.6px 0 rgba(0, 0, 0, 0.108)';
        Depths.depth64 = '0 25.6px 57.6px 0 rgba(0, 0, 0, 0.22), 0 4.8px 14.4px 0 rgba(0, 0, 0, 0.18)';
    })(Depths || (Depths = {}));

    var DefaultEffects = {
        elevation4: Depths.depth4,
        elevation8: Depths.depth8,
        elevation16: Depths.depth16,
        elevation64: Depths.depth64,
        roundedCorner2: '2px',
        roundedCorner4: '4px',
        roundedCorner6: '6px',
    };

    var DefaultSpacing = {
        s2: '4px',
        s1: '8px',
        m: '16px',
        l1: '20px',
        l2: '32px',
    };

    var fadeInAnimationName = keyframes({
        from: { opacity: 0 },
        to: { opacity: 1 },
    });
    var fadeOutAnimationName = keyframes({
        from: { opacity: 1 },
        to: { opacity: 0 },
    });
    var scaleDownInAnimationName = keyframes({
        from: { transform: 'scale3d(1.15, 1.15, 1)' },
        to: { transform: 'scale3d(1, 1, 1)' },
    });
    var scaleDownOutAnimationName = keyframes({
        from: { transform: 'scale3d(1, 1, 1)' },
        to: { transform: 'scale3d(0.9, 0.9, 1)' },
    });
    var slideLeftOutAnimationName = keyframes({
        from: { transform: 'translate3d(0, 0, 0)' },
        to: { transform: 'translate3d(-48px, 0, 0)' },
    });
    var slideRightOutAnimationName = keyframes({
        from: { transform: 'translate3d(0, 0, 0)' },
        to: { transform: 'translate3d(48px, 0, 0)' },
    });
    var slideLeftInAnimationName = keyframes({
        from: { transform: 'translate3d(48px, 0, 0)' },
        to: { transform: 'translate3d(0, 0, 0)' },
    });
    var slideRightInAnimationName = keyframes({
        from: { transform: 'translate3d(-48px, 0, 0)' },
        to: { transform: 'translate3d(0, 0, 0)' },
    });
    var slideUpOutAnimationName = keyframes({
        from: { transform: 'translate3d(0, 0, 0)' },
        to: { transform: 'translate3d(0, -48px, 0)' },
    });
    var slideDownOutAnimationName = keyframes({
        from: { transform: 'translate3d(0, 0, 0)' },
        to: { transform: 'translate3d(0, 48px, 0)' },
    });
    var slideUpInAnimationName = keyframes({
        from: { transform: 'translate3d(0, 48px, 0)' },
        to: { transform: 'translate3d(0, 0, 0)' },
    });
    var slideDownInAnimationName = keyframes({
        from: { transform: 'translate3d(0, -48px, 0)' },
        to: { transform: 'translate3d(0, 0, 0)' },
    });
    var MotionDurations;
    (function (MotionDurations) {
        MotionDurations.duration1 = '100ms';
        MotionDurations.duration2 = '200ms';
        MotionDurations.duration3 = '300ms';
        MotionDurations.duration4 = '400ms';
    })(MotionDurations || (MotionDurations = {}));
    var MotionTimings;
    (function (MotionTimings) {
        MotionTimings.accelerate = 'cubic-bezier(0.9, 0.1, 1, 0.2)';
        MotionTimings.decelerate = 'cubic-bezier(0.1, 0.9, 0.2, 1)';
        MotionTimings.linear = 'cubic-bezier(0, 0, 1, 1)';
        MotionTimings.standard = 'cubic-bezier(0.8, 0, 0.2, 1)';
    })(MotionTimings || (MotionTimings = {}));
    function _createAnimation$1(animationName, animationDuration, animationTimingFunction) {
        return animationName + " " + animationDuration + " " + animationTimingFunction;
    }
    var MotionAnimations;
    (function (MotionAnimations) {
        MotionAnimations.fadeIn = _createAnimation$1(fadeInAnimationName, MotionDurations.duration1, MotionTimings.linear);
        MotionAnimations.fadeOut = _createAnimation$1(fadeOutAnimationName, MotionDurations.duration1, MotionTimings.linear);
        MotionAnimations.scaleDownIn = _createAnimation$1(scaleDownInAnimationName, MotionDurations.duration3, MotionTimings.decelerate);
        MotionAnimations.scaleDownOut = _createAnimation$1(scaleDownOutAnimationName, MotionDurations.duration3, MotionTimings.decelerate);
        MotionAnimations.slideLeftOut = _createAnimation$1(slideLeftOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
        MotionAnimations.slideRightOut = _createAnimation$1(slideRightOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
        MotionAnimations.slideLeftIn = _createAnimation$1(slideLeftInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
        MotionAnimations.slideRightIn = _createAnimation$1(slideRightInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
        MotionAnimations.slideUpOut = _createAnimation$1(slideUpOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
        MotionAnimations.slideDownOut = _createAnimation$1(slideDownOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
        MotionAnimations.slideUpIn = _createAnimation$1(slideUpInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
        MotionAnimations.slideDownIn = _createAnimation$1(slideDownInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
    })(MotionAnimations || (MotionAnimations = {}));

    /* Register the keyframes */
    var EASING_FUNCTION_1 = 'cubic-bezier(.1,.9,.2,1)';
    var EASING_FUNCTION_2 = 'cubic-bezier(.1,.25,.75,.9)';
    var DURATION_1 = '0.167s';
    var DURATION_2 = '0.267s';
    var DURATION_3 = '0.367s';
    var DURATION_4 = '0.467s';
    var FADE_IN = keyframes({
        from: { opacity: 0 },
        to: { opacity: 1 },
    });
    var FADE_OUT = keyframes({
        from: { opacity: 1 },
        to: { opacity: 0, visibility: 'hidden' },
    });
    var SLIDE_RIGHT_IN10 = _createSlideInX(-10);
    var SLIDE_RIGHT_IN20 = _createSlideInX(-20);
    var SLIDE_RIGHT_IN40 = _createSlideInX(-40);
    var SLIDE_RIGHT_IN400 = _createSlideInX(-400);
    var SLIDE_LEFT_IN10 = _createSlideInX(10);
    var SLIDE_LEFT_IN20 = _createSlideInX(20);
    var SLIDE_LEFT_IN40 = _createSlideInX(40);
    var SLIDE_LEFT_IN400 = _createSlideInX(400);
    var SLIDE_UP_IN10 = _createSlideInY(10);
    var SLIDE_UP_IN20 = _createSlideInY(20);
    var SLIDE_DOWN_IN10 = _createSlideInY(-10);
    var SLIDE_DOWN_IN20 = _createSlideInY(-20);
    var SLIDE_RIGHT_OUT10 = _createSlideOutX(10);
    var SLIDE_RIGHT_OUT20 = _createSlideOutX(20);
    var SLIDE_RIGHT_OUT40 = _createSlideOutX(40);
    var SLIDE_RIGHT_OUT400 = _createSlideOutX(400);
    var SLIDE_LEFT_OUT10 = _createSlideOutX(-10);
    var SLIDE_LEFT_OUT20 = _createSlideOutX(-20);
    var SLIDE_LEFT_OUT40 = _createSlideOutX(-40);
    var SLIDE_LEFT_OUT400 = _createSlideOutX(-400);
    var SLIDE_UP_OUT10 = _createSlideOutY(-10);
    var SLIDE_UP_OUT20 = _createSlideOutY(-20);
    var SLIDE_DOWN_OUT10 = _createSlideOutY(10);
    var SLIDE_DOWN_OUT20 = _createSlideOutY(20);
    var SCALE_UP100 = keyframes({
        from: { transform: 'scale3d(.98,.98,1)' },
        to: { transform: 'scale3d(1,1,1)' },
    });
    var SCALE_DOWN98 = keyframes({
        from: { transform: 'scale3d(1,1,1)' },
        to: { transform: 'scale3d(.98,.98,1)' },
    });
    var SCALE_DOWN100 = keyframes({
        from: { transform: 'scale3d(1.03,1.03,1)' },
        to: { transform: 'scale3d(1,1,1)' },
    });
    var SCALE_UP103 = keyframes({
        from: { transform: 'scale3d(1,1,1)' },
        to: { transform: 'scale3d(1.03,1.03,1)' },
    });
    var ROTATE90 = keyframes({
        from: { transform: 'rotateZ(0deg)' },
        to: { transform: 'rotateZ(90deg)' },
    });
    var ROTATE_N90 = keyframes({
        from: { transform: 'rotateZ(0deg)' },
        to: { transform: 'rotateZ(-90deg)' },
    });
    /**
     * Exporting raw duraction values and easing functions to be used in custom animations
     */
    var AnimationVariables = {
        easeFunction1: EASING_FUNCTION_1,
        easeFunction2: EASING_FUNCTION_2,
        durationValue1: DURATION_1,
        durationValue2: DURATION_2,
        durationValue3: DURATION_3,
        durationValue4: DURATION_4,
    };
    /**
     * All Fabric standard animations, exposed as json objects referencing predefined
     * keyframes. These objects can be mixed in with other class definitions.
     */
    var AnimationStyles = {
        slideRightIn10: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN10, DURATION_3, EASING_FUNCTION_1),
        slideRightIn20: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN20, DURATION_3, EASING_FUNCTION_1),
        slideRightIn40: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN40, DURATION_3, EASING_FUNCTION_1),
        slideRightIn400: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN400, DURATION_3, EASING_FUNCTION_1),
        slideLeftIn10: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN10, DURATION_3, EASING_FUNCTION_1),
        slideLeftIn20: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN20, DURATION_3, EASING_FUNCTION_1),
        slideLeftIn40: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN40, DURATION_3, EASING_FUNCTION_1),
        slideLeftIn400: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN400, DURATION_3, EASING_FUNCTION_1),
        slideUpIn10: _createAnimation(FADE_IN + "," + SLIDE_UP_IN10, DURATION_3, EASING_FUNCTION_1),
        slideUpIn20: _createAnimation(FADE_IN + "," + SLIDE_UP_IN20, DURATION_3, EASING_FUNCTION_1),
        slideDownIn10: _createAnimation(FADE_IN + "," + SLIDE_DOWN_IN10, DURATION_3, EASING_FUNCTION_1),
        slideDownIn20: _createAnimation(FADE_IN + "," + SLIDE_DOWN_IN20, DURATION_3, EASING_FUNCTION_1),
        slideRightOut10: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT10, DURATION_3, EASING_FUNCTION_1),
        slideRightOut20: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT20, DURATION_3, EASING_FUNCTION_1),
        slideRightOut40: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT40, DURATION_3, EASING_FUNCTION_1),
        slideRightOut400: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT400, DURATION_3, EASING_FUNCTION_1),
        slideLeftOut10: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT10, DURATION_3, EASING_FUNCTION_1),
        slideLeftOut20: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT20, DURATION_3, EASING_FUNCTION_1),
        slideLeftOut40: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT40, DURATION_3, EASING_FUNCTION_1),
        slideLeftOut400: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT400, DURATION_3, EASING_FUNCTION_1),
        slideUpOut10: _createAnimation(FADE_OUT + "," + SLIDE_UP_OUT10, DURATION_3, EASING_FUNCTION_1),
        slideUpOut20: _createAnimation(FADE_OUT + "," + SLIDE_UP_OUT20, DURATION_3, EASING_FUNCTION_1),
        slideDownOut10: _createAnimation(FADE_OUT + "," + SLIDE_DOWN_OUT10, DURATION_3, EASING_FUNCTION_1),
        slideDownOut20: _createAnimation(FADE_OUT + "," + SLIDE_DOWN_OUT20, DURATION_3, EASING_FUNCTION_1),
        scaleUpIn100: _createAnimation(FADE_IN + "," + SCALE_UP100, DURATION_3, EASING_FUNCTION_1),
        scaleDownIn100: _createAnimation(FADE_IN + "," + SCALE_DOWN100, DURATION_3, EASING_FUNCTION_1),
        scaleUpOut103: _createAnimation(FADE_OUT + "," + SCALE_UP103, DURATION_1, EASING_FUNCTION_2),
        scaleDownOut98: _createAnimation(FADE_OUT + "," + SCALE_DOWN98, DURATION_1, EASING_FUNCTION_2),
        fadeIn100: _createAnimation(FADE_IN, DURATION_1, EASING_FUNCTION_2),
        fadeIn200: _createAnimation(FADE_IN, DURATION_2, EASING_FUNCTION_2),
        fadeIn400: _createAnimation(FADE_IN, DURATION_3, EASING_FUNCTION_2),
        fadeIn500: _createAnimation(FADE_IN, DURATION_4, EASING_FUNCTION_2),
        fadeOut100: _createAnimation(FADE_OUT, DURATION_1, EASING_FUNCTION_2),
        fadeOut200: _createAnimation(FADE_OUT, DURATION_2, EASING_FUNCTION_2),
        fadeOut400: _createAnimation(FADE_OUT, DURATION_3, EASING_FUNCTION_2),
        fadeOut500: _createAnimation(FADE_OUT, DURATION_4, EASING_FUNCTION_2),
        rotate90deg: _createAnimation(ROTATE90, '0.1s', EASING_FUNCTION_2),
        rotateN90deg: _createAnimation(ROTATE_N90, '0.1s', EASING_FUNCTION_2),
        // expandCollapse 100/200/400, delay 100/200
    };
    function _createAnimation(animationName, animationDuration, animationTimingFunction) {
        return {
            animationName: animationName,
            animationDuration: animationDuration,
            animationTimingFunction: animationTimingFunction,
            animationFillMode: 'both',
        };
    }
    function _createSlideInX(fromX) {
        return keyframes({
            from: { transform: "translate3d(" + fromX + "px,0,0)", pointerEvents: 'none' },
            to: { transform: "translate3d(0,0,0)", pointerEvents: 'auto' },
        });
    }
    function _createSlideInY(fromY) {
        return keyframes({
            from: { transform: "translate3d(0," + fromY + "px,0)", pointerEvents: 'none' },
            to: { transform: "translate3d(0,0,0)", pointerEvents: 'auto' },
        });
    }
    function _createSlideOutX(toX) {
        return keyframes({
            from: { transform: "translate3d(0,0,0)" },
            to: { transform: "translate3d(" + toX + "px,0,0)" },
        });
    }
    function _createSlideOutY(toY) {
        return keyframes({
            from: { transform: "translate3d(0,0,0)" },
            to: { transform: "translate3d(0," + toY + "px,0)" },
        });
    }

    // Font face names to be registered.
    var LocalizedFontNames;
    (function (LocalizedFontNames) {
        LocalizedFontNames.Arabic = 'Segoe UI Web (Arabic)';
        LocalizedFontNames.Cyrillic = 'Segoe UI Web (Cyrillic)';
        LocalizedFontNames.EastEuropean = 'Segoe UI Web (East European)';
        LocalizedFontNames.Greek = 'Segoe UI Web (Greek)';
        LocalizedFontNames.Hebrew = 'Segoe UI Web (Hebrew)';
        LocalizedFontNames.Thai = 'Leelawadee UI Web';
        LocalizedFontNames.Vietnamese = 'Segoe UI Web (Vietnamese)';
        LocalizedFontNames.WestEuropean = 'Segoe UI Web (West European)';
        LocalizedFontNames.Selawik = 'Selawik Web';
        LocalizedFontNames.Armenian = 'Segoe UI Web (Armenian)';
        LocalizedFontNames.Georgian = 'Segoe UI Web (Georgian)';
    })(LocalizedFontNames || (LocalizedFontNames = {}));
    // Font families with fallbacks, for the general regions.
    var LocalizedFontFamilies;
    (function (LocalizedFontFamilies) {
        LocalizedFontFamilies.Arabic = "'" + LocalizedFontNames.Arabic + "'";
        LocalizedFontFamilies.ChineseSimplified = "'Microsoft Yahei UI', Verdana, Simsun";
        LocalizedFontFamilies.ChineseTraditional = "'Microsoft Jhenghei UI', Pmingliu";
        LocalizedFontFamilies.Cyrillic = "'" + LocalizedFontNames.Cyrillic + "'";
        LocalizedFontFamilies.EastEuropean = "'" + LocalizedFontNames.EastEuropean + "'";
        LocalizedFontFamilies.Greek = "'" + LocalizedFontNames.Greek + "'";
        LocalizedFontFamilies.Hebrew = "'" + LocalizedFontNames.Hebrew + "'";
        LocalizedFontFamilies.Hindi = "'Nirmala UI'";
        LocalizedFontFamilies.Japanese = "'Yu Gothic UI', 'Meiryo UI', Meiryo, 'MS Pgothic', Osaka";
        LocalizedFontFamilies.Korean = "'Malgun Gothic', Gulim";
        LocalizedFontFamilies.Selawik = "'" + LocalizedFontNames.Selawik + "'";
        LocalizedFontFamilies.Thai = "'Leelawadee UI Web', 'Kmer UI'";
        LocalizedFontFamilies.Vietnamese = "'" + LocalizedFontNames.Vietnamese + "'";
        LocalizedFontFamilies.WestEuropean = "'" + LocalizedFontNames.WestEuropean + "'";
        LocalizedFontFamilies.Armenian = "'" + LocalizedFontNames.Armenian + "'";
        LocalizedFontFamilies.Georgian = "'" + LocalizedFontNames.Georgian + "'";
    })(LocalizedFontFamilies || (LocalizedFontFamilies = {}));
    // Standard font sizes.
    var FontSizes;
    (function (FontSizes) {
        FontSizes.size10 = '10px';
        FontSizes.size12 = '12px';
        FontSizes.size14 = '14px';
        FontSizes.size16 = '16px';
        FontSizes.size18 = '18px';
        FontSizes.size20 = '20px';
        FontSizes.size24 = '24px';
        FontSizes.size28 = '28px';
        FontSizes.size32 = '32px';
        FontSizes.size42 = '42px';
        FontSizes.size68 = '68px';
        FontSizes.mini = '10px';
        FontSizes.xSmall = '10px';
        FontSizes.small = '12px';
        FontSizes.smallPlus = '12px';
        FontSizes.medium = '14px';
        FontSizes.mediumPlus = '16px';
        FontSizes.icon = '16px';
        FontSizes.large = '18px';
        FontSizes.xLarge = '20px';
        FontSizes.xLargePlus = '24px';
        FontSizes.xxLarge = '28px';
        FontSizes.xxLargePlus = '32px';
        FontSizes.superLarge = '42px';
        FontSizes.mega = '68px';
    })(FontSizes || (FontSizes = {}));
    // Standard font weights.
    var FontWeights;
    (function (FontWeights) {
        FontWeights.light = 100;
        FontWeights.semilight = 300;
        FontWeights.regular = 400;
        FontWeights.semibold = 600;
        FontWeights.bold = 700;
    })(FontWeights || (FontWeights = {}));
    // Standard Icon Sizes.
    var IconFontSizes;
    (function (IconFontSizes) {
        IconFontSizes.xSmall = '10px';
        IconFontSizes.small = '12px';
        IconFontSizes.medium = '16px';
        IconFontSizes.large = '20px';
    })(IconFontSizes || (IconFontSizes = {}));

    // Fallback fonts, if specified system or web fonts are unavailable.
    var FontFamilyFallbacks = "'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', sans-serif";
    // By default, we favor system fonts for the default.
    // All localized fonts use a web font and never use the system font.
    var defaultFontFamily = "'Segoe UI', '" + LocalizedFontNames.WestEuropean + "'";
    // Mapping of language prefix to to font family.
    var LanguageToFontMap = {
        ar: LocalizedFontFamilies.Arabic,
        bg: LocalizedFontFamilies.Cyrillic,
        cs: LocalizedFontFamilies.EastEuropean,
        el: LocalizedFontFamilies.Greek,
        et: LocalizedFontFamilies.EastEuropean,
        he: LocalizedFontFamilies.Hebrew,
        hi: LocalizedFontFamilies.Hindi,
        hr: LocalizedFontFamilies.EastEuropean,
        hu: LocalizedFontFamilies.EastEuropean,
        ja: LocalizedFontFamilies.Japanese,
        kk: LocalizedFontFamilies.EastEuropean,
        ko: LocalizedFontFamilies.Korean,
        lt: LocalizedFontFamilies.EastEuropean,
        lv: LocalizedFontFamilies.EastEuropean,
        pl: LocalizedFontFamilies.EastEuropean,
        ru: LocalizedFontFamilies.Cyrillic,
        sk: LocalizedFontFamilies.EastEuropean,
        'sr-latn': LocalizedFontFamilies.EastEuropean,
        th: LocalizedFontFamilies.Thai,
        tr: LocalizedFontFamilies.EastEuropean,
        uk: LocalizedFontFamilies.Cyrillic,
        vi: LocalizedFontFamilies.Vietnamese,
        'zh-hans': LocalizedFontFamilies.ChineseSimplified,
        'zh-hant': LocalizedFontFamilies.ChineseTraditional,
        hy: LocalizedFontFamilies.Armenian,
        ka: LocalizedFontFamilies.Georgian,
    };
    function _fontFamilyWithFallbacks(fontFamily) {
        return fontFamily + ", " + FontFamilyFallbacks;
    }
    /**
     * If there is a localized font for this language, return that.
     * Returns undefined if there is no localized font for that language.
     */
    function _getLocalizedFontFamily(language) {
        for (var lang in LanguageToFontMap) {
            if (LanguageToFontMap.hasOwnProperty(lang) && language && lang.indexOf(language) === 0) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return LanguageToFontMap[lang];
            }
        }
        return defaultFontFamily;
    }
    function _createFont(size, weight, fontFamily) {
        return {
            fontFamily: fontFamily,
            MozOsxFontSmoothing: 'grayscale',
            WebkitFontSmoothing: 'antialiased',
            fontSize: size,
            fontWeight: weight,
        };
    }
    function createFontStyles(localeCode) {
        var localizedFont = _getLocalizedFontFamily(localeCode);
        var fontFamilyWithFallback = _fontFamilyWithFallbacks(localizedFont);
        var fontStyles = {
            tiny: _createFont(FontSizes.mini, FontWeights.regular, fontFamilyWithFallback),
            xSmall: _createFont(FontSizes.xSmall, FontWeights.regular, fontFamilyWithFallback),
            small: _createFont(FontSizes.small, FontWeights.regular, fontFamilyWithFallback),
            smallPlus: _createFont(FontSizes.smallPlus, FontWeights.regular, fontFamilyWithFallback),
            medium: _createFont(FontSizes.medium, FontWeights.regular, fontFamilyWithFallback),
            mediumPlus: _createFont(FontSizes.mediumPlus, FontWeights.regular, fontFamilyWithFallback),
            large: _createFont(FontSizes.large, FontWeights.regular, fontFamilyWithFallback),
            xLarge: _createFont(FontSizes.xLarge, FontWeights.semibold, fontFamilyWithFallback),
            xLargePlus: _createFont(FontSizes.xLargePlus, FontWeights.semibold, fontFamilyWithFallback),
            xxLarge: _createFont(FontSizes.xxLarge, FontWeights.semibold, fontFamilyWithFallback),
            xxLargePlus: _createFont(FontSizes.xxLargePlus, FontWeights.semibold, fontFamilyWithFallback),
            superLarge: _createFont(FontSizes.superLarge, FontWeights.semibold, fontFamilyWithFallback),
            mega: _createFont(FontSizes.mega, FontWeights.semibold, fontFamilyWithFallback),
        };
        return fontStyles;
    }

    // Default urls.
    var DefaultBaseUrl = 'https://res-1.cdn.office.net/files/fabric-cdn-prod_20221209.001/assets';
    // Standard font styling.
    var DefaultFontStyles = createFontStyles(getLanguage());
    function _registerFontFace(fontFamily, url, fontWeight, localFontName) {
        fontFamily = "'" + fontFamily + "'";
        var localFontSrc = localFontName !== undefined ? "local('" + localFontName + "')," : '';
        fontFace({
            fontFamily: fontFamily,
            src: localFontSrc + ("url('" + url + ".woff2') format('woff2'),") + ("url('" + url + ".woff') format('woff')"),
            fontWeight: fontWeight,
            fontStyle: 'normal',
            fontDisplay: 'swap',
        });
    }
    function _registerFontFaceSet(baseUrl, fontFamily, cdnFolder, cdnFontName, localFontName) {
        if (cdnFontName === void 0) { cdnFontName = 'segoeui'; }
        var urlBase = baseUrl + "/" + cdnFolder + "/" + cdnFontName;
        _registerFontFace(fontFamily, urlBase + '-light', FontWeights.light, localFontName && localFontName + ' Light');
        _registerFontFace(fontFamily, urlBase + '-semilight', FontWeights.semilight, localFontName && localFontName + ' SemiLight');
        _registerFontFace(fontFamily, urlBase + '-regular', FontWeights.regular, localFontName);
        _registerFontFace(fontFamily, urlBase + '-semibold', FontWeights.semibold, localFontName && localFontName + ' SemiBold');
        _registerFontFace(fontFamily, urlBase + '-bold', FontWeights.bold, localFontName && localFontName + ' Bold');
    }
    function registerDefaultFontFaces(baseUrl) {
        if (baseUrl) {
            var fontUrl = baseUrl + "/fonts";
            // Produce @font-face definitions for all supported web fonts.
            _registerFontFaceSet(fontUrl, LocalizedFontNames.Thai, 'leelawadeeui-thai', 'leelawadeeui');
            _registerFontFaceSet(fontUrl, LocalizedFontNames.Arabic, 'segoeui-arabic');
            _registerFontFaceSet(fontUrl, LocalizedFontNames.Cyrillic, 'segoeui-cyrillic');
            _registerFontFaceSet(fontUrl, LocalizedFontNames.EastEuropean, 'segoeui-easteuropean');
            _registerFontFaceSet(fontUrl, LocalizedFontNames.Greek, 'segoeui-greek');
            _registerFontFaceSet(fontUrl, LocalizedFontNames.Hebrew, 'segoeui-hebrew');
            _registerFontFaceSet(fontUrl, LocalizedFontNames.Vietnamese, 'segoeui-vietnamese');
            _registerFontFaceSet(fontUrl, LocalizedFontNames.WestEuropean, 'segoeui-westeuropean', 'segoeui', 'Segoe UI');
            _registerFontFaceSet(fontUrl, LocalizedFontFamilies.Selawik, 'selawik', 'selawik');
            _registerFontFaceSet(fontUrl, LocalizedFontNames.Armenian, 'segoeui-armenian');
            _registerFontFaceSet(fontUrl, LocalizedFontNames.Georgian, 'segoeui-georgian');
            // Leelawadee UI (Thai) does not have a 'light' weight, so we override
            // the font-face generated above to use the 'semilight' weight instead.
            _registerFontFace('Leelawadee UI Web', fontUrl + "/leelawadeeui-thai/leelawadeeui-semilight", FontWeights.light);
            // Leelawadee UI (Thai) does not have a 'semibold' weight, so we override
            // the font-face generated above to use the 'bold' weight instead.
            _registerFontFace('Leelawadee UI Web', fontUrl + "/leelawadeeui-thai/leelawadeeui-bold", FontWeights.semibold);
        }
    }
    /**
     * Reads the fontBaseUrl from window.FabricConfig.fontBaseUrl or falls back to a default.
     */
    function _getFontBaseUrl() {
        var _a, _b;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var fabricConfig = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.FabricConfig;
        return (_b = fabricConfig === null || fabricConfig === void 0 ? void 0 : fabricConfig.fontBaseUrl) !== null && _b !== void 0 ? _b : DefaultBaseUrl;
    }
    /**
     * Register the font faces.
     */
    registerDefaultFontFaces(_getFontBaseUrl());

    /**
     * Creates a custom theme definition.
     * @param theme - Partial theme object.
     * @param depComments - Whether to include deprecated tags as comments for deprecated slots.
     */
    function createTheme(theme, depComments) {
        if (theme === void 0) { theme = {}; }
        if (depComments === void 0) { depComments = false; }
        var isInverted = !!theme.isInverted;
        var baseTheme = {
            palette: DefaultPalette,
            effects: DefaultEffects,
            fonts: DefaultFontStyles,
            spacing: DefaultSpacing,
            isInverted: isInverted,
            disableGlobalClassNames: false,
            semanticColors: makeSemanticColors(DefaultPalette, DefaultEffects, undefined, isInverted, depComments),
            rtl: undefined,
        };
        return mergeThemes(baseTheme, theme);
    }

    var FluentTheme = createTheme({});

    var HighContrastSelector = '@media screen and (-ms-high-contrast: active), screen and (forced-colors: active)';
    var HighContrastSelectorWhite = 
    // eslint-disable-next-line @fluentui/max-len
    '@media screen and (-ms-high-contrast: black-on-white), screen and (forced-colors: active) and (prefers-color-scheme: light)';
    var HighContrastSelectorBlack = 
    // eslint-disable-next-line @fluentui/max-len
    '@media screen and (-ms-high-contrast: white-on-black), screen and (forced-colors: active) and (prefers-color-scheme: dark)';
    /**
     * @deprecated Use `HighContrastSelector`
     */
    var EdgeChromiumHighContrastSelector = '@media screen and (-ms-high-contrast: active), screen and (forced-colors: active)';
    var ScreenWidthMinSmall = 320;
    var ScreenWidthMinMedium = 480;
    var ScreenWidthMinLarge = 640;
    var ScreenWidthMinXLarge = 1024;
    var ScreenWidthMinXXLarge = 1366;
    var ScreenWidthMinXXXLarge = 1920;
    var ScreenWidthMaxSmall = ScreenWidthMinMedium - 1;
    var ScreenWidthMaxMedium = ScreenWidthMinLarge - 1;
    var ScreenWidthMaxLarge = ScreenWidthMinXLarge - 1;
    var ScreenWidthMaxXLarge = ScreenWidthMinXXLarge - 1;
    var ScreenWidthMaxXXLarge = ScreenWidthMinXXXLarge - 1;
    var ScreenWidthMinUhfMobile = 768;
    function getScreenSelector(min, max) {
        var minSelector = typeof min === 'number' ? " and (min-width: " + min + "px)" : '';
        var maxSelector = typeof max === 'number' ? " and (max-width: " + max + "px)" : '';
        return "@media only screen" + minSelector + maxSelector;
    }
    /**
     * The style which turns off high contrast adjustment in browsers.
     */
    function getHighContrastNoAdjustStyle() {
        return {
            forcedColorAdjust: 'none',
            MsHighContrastAdjust: 'none',
        };
    }
    /**
     * The style which turns off high contrast adjustment in (only) Edge Chromium browser.
     *  @deprecated Use `getHighContrastNoAdjustStyle`
     */
    // eslint-disable-next-line deprecation/deprecation
    function getEdgeChromiumNoHighContrastAdjustSelector() {
        var _a;
        return _a = {},
            // eslint-disable-next-line deprecation/deprecation
            _a[EdgeChromiumHighContrastSelector] = {
                forcedColorAdjust: 'none',
                MsHighContrastAdjust: 'none',
            },
            _a;
    }

    var ZIndexes;
    (function (ZIndexes) {
        ZIndexes.Nav = 1;
        /**
         * @deprecated Do not use
         */
        ZIndexes.ScrollablePane = 1;
        ZIndexes.FocusStyle = 1;
        ZIndexes.Coachmark = 1000;
        ZIndexes.Layer = 1000000;
        ZIndexes.KeytipLayer = 1000001;
    })(ZIndexes || (ZIndexes = {}));

    function getFocusStyle(theme, insetOrOptions, position, highContrastStyle, borderColor, outlineColor, isFocusedOnly, borderRadius) {
        if (typeof insetOrOptions === 'number' || !insetOrOptions) {
            return _getFocusStyleInternal(theme, {
                inset: insetOrOptions,
                position: position,
                highContrastStyle: highContrastStyle,
                borderColor: borderColor,
                outlineColor: outlineColor,
                isFocusedOnly: isFocusedOnly,
                borderRadius: borderRadius,
            });
        }
        else {
            return _getFocusStyleInternal(theme, insetOrOptions);
        }
    }
    function _getFocusStyleInternal(theme, options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        var borderRadius = options.borderRadius, _c = options.inset, inset = _c === void 0 ? 0 : _c, _d = options.width, width = _d === void 0 ? 1 : _d, _e = options.position, position = _e === void 0 ? 'relative' : _e, highContrastStyle = options.highContrastStyle, _f = options.borderColor, borderColor = _f === void 0 ? theme.palette.white : _f, _g = options.outlineColor, outlineColor = _g === void 0 ? theme.palette.neutralSecondary : _g, _h = options.isFocusedOnly, isFocusedOnly = _h === void 0 ? true : _h, pointerEvents = options.pointerEvents;
        return {
            // Clear browser-specific focus styles and use 'transparent' as placeholder for focus style.
            outline: 'transparent',
            // Requirement because pseudo-element is absolutely positioned.
            position: position,
            selectors: (_a = {
                    // Clear the focus border in Firefox.
                    // Reference: http://stackoverflow.com/a/199319/1436671
                    '::-moz-focus-inner': {
                        border: '0',
                    }
                },
                // When the element that uses this mixin is in a :focus state, add a pseudo-element to
                // create a border.
                _a["." + IsFocusVisibleClassName + " &" + (isFocusedOnly ? ':focus' : '') + ":after"] = {
                    content: '""',
                    position: 'absolute',
                    pointerEvents: pointerEvents,
                    left: inset + 1,
                    top: inset + 1,
                    bottom: inset + 1,
                    right: inset + 1,
                    border: width + "px solid " + borderColor,
                    outline: width + "px solid " + outlineColor,
                    zIndex: ZIndexes.FocusStyle,
                    borderRadius: borderRadius,
                    selectors: (_b = {},
                        _b[HighContrastSelector] = highContrastStyle,
                        _b),
                },
                _a),
        };
    }
    /**
     * Generates style to clear browser specific focus styles.
     */
    function focusClear() {
        return {
            selectors: {
                '&::-moz-focus-inner': {
                    // Clear the focus border in Firefox. Reference: http://stackoverflow.com/a/199319/1436671
                    border: 0,
                },
                '&': {
                    // Clear browser specific focus styles and use transparent as placeholder for focus style
                    outline: 'transparent',
                },
            },
        };
    }
    /**
     * Generates a style which can be used to set a border on focus.
     *
     * @param theme - The theme object to use.
     * @param inset - The number of pixels to inset the border (default 0)
     * @param width - The border width in pixels (default 1)
     * @param color - Color of the outline (default `theme.palette.neutralSecondary`)
     * @returns The style object.
     */
    function getFocusOutlineStyle(theme, inset, width, color) {
        var _a;
        if (inset === void 0) { inset = 0; }
        if (width === void 0) { width = 1; }
        return {
            selectors: (_a = {},
                _a[":global(" + IsFocusVisibleClassName + ") &:focus"] = {
                    outline: width + " solid " + (color || theme.palette.neutralSecondary),
                    outlineOffset: -inset + "px",
                },
                _a),
        };
    }
    /**
     * Generates text input border styles on focus.
     *
     * @param borderColor - Color of the border.
     * @param borderRadius - Radius of the border.
     * @param borderType - Type of the border.
     * @param borderPosition - Position of the border relative to the input element (default to -1
     * as it's the most common border width of the input element)
     * @returns The style object.
     */
    var getInputFocusStyle = function (borderColor, borderRadius, borderType, borderPosition) {
        var _a, _b, _c;
        if (borderType === void 0) { borderType = 'border'; }
        if (borderPosition === void 0) { borderPosition = -1; }
        var isBorderBottom = borderType === 'borderBottom';
        return {
            borderColor: borderColor,
            selectors: {
                ':after': (_a = {
                        pointerEvents: 'none',
                        content: "''",
                        position: 'absolute',
                        left: isBorderBottom ? 0 : borderPosition,
                        top: borderPosition,
                        bottom: borderPosition,
                        right: isBorderBottom ? 0 : borderPosition
                    },
                    _a[borderType] = "2px solid " + borderColor,
                    _a.borderRadius = borderRadius,
                    _a.width = borderType === 'borderBottom' ? '100%' : undefined,
                    _a.selectors = (_b = {},
                        _b[HighContrastSelector] = (_c = {},
                            _c[borderType === 'border' ? 'borderColor' : 'borderBottomColor'] = 'Highlight',
                            _c),
                        _b),
                    _a),
            },
        };
    };

    var hiddenContentStyle = {
        position: 'absolute',
        width: 1,
        height: 1,
        margin: -1,
        padding: 0,
        border: 0,
        overflow: 'hidden',
        whiteSpace: 'nowrap',
    };

    var DEFAULT_DURATION = '14s';
    var DEFAULT_DELAY = '2s';
    var DEFAULT_ITERATION_COUNT = '1';
    function _continuousPulseStepOne(beaconColorOne, innerDimension) {
        return {
            borderColor: beaconColorOne,
            borderWidth: '0px',
            width: innerDimension,
            height: innerDimension,
        };
    }
    function _continuousPulseStepTwo(borderWidth) {
        return {
            opacity: 1,
            borderWidth: borderWidth,
        };
    }
    function _continuousPulseStepThree() {
        return {
            opacity: 1,
        };
    }
    function _continuousPulseStepFour(beaconColorTwo, outerDimension) {
        return {
            borderWidth: '0',
            width: outerDimension,
            height: outerDimension,
            opacity: 0,
            borderColor: beaconColorTwo,
        };
    }
    function _continuousPulseStepFive(beaconColorOne, innerDimension) {
        return __assign$k(__assign$k({}, _continuousPulseStepOne(beaconColorOne, innerDimension)), {
            opacity: 0,
        });
    }
    function _continuousPulseAnimationDouble(beaconColorOne, beaconColorTwo, innerDimension, outerDimension, borderWidth) {
        return keyframes({
            '0%': _continuousPulseStepOne(beaconColorOne, innerDimension),
            '1.42%': _continuousPulseStepTwo(borderWidth),
            '3.57%': _continuousPulseStepThree(),
            '7.14%': _continuousPulseStepFour(beaconColorTwo, outerDimension),
            '8%': _continuousPulseStepFive(beaconColorOne, innerDimension),
            '29.99%': _continuousPulseStepFive(beaconColorOne, innerDimension),
            '30%': _continuousPulseStepOne(beaconColorOne, innerDimension),
            '31.42%': _continuousPulseStepTwo(borderWidth),
            '33.57%': _continuousPulseStepThree(),
            '37.14%': _continuousPulseStepFour(beaconColorTwo, outerDimension),
            '38%': _continuousPulseStepFive(beaconColorOne, innerDimension),
            '79.42%': _continuousPulseStepFive(beaconColorOne, innerDimension),
            '79.43': _continuousPulseStepOne(beaconColorOne, innerDimension),
            '81.85': _continuousPulseStepTwo(borderWidth),
            '83.42': _continuousPulseStepThree(),
            '87%': _continuousPulseStepFour(beaconColorTwo, outerDimension),
            '100%': {},
        });
    }
    function _continuousPulseAnimationSingle(beaconColorOne, beaconColorTwo, innerDimension, outerDimension, borderWidth) {
        return keyframes({
            '0%': _continuousPulseStepOne(beaconColorOne, innerDimension),
            '14.2%': _continuousPulseStepTwo(borderWidth),
            '35.7%': _continuousPulseStepThree(),
            '71.4%': _continuousPulseStepFour(beaconColorTwo, outerDimension),
            '100%': {},
        });
    }
    function _createDefaultAnimation(animationName, delayLength) {
        return {
            animationName: animationName,
            animationIterationCount: DEFAULT_ITERATION_COUNT,
            animationDuration: DEFAULT_DURATION,
            animationDelay: delayLength || DEFAULT_DELAY,
        };
    }
    var PulsingBeaconAnimationStyles = {
        continuousPulseAnimationDouble: _continuousPulseAnimationDouble,
        continuousPulseAnimationSingle: _continuousPulseAnimationSingle,
        createDefaultAnimation: _createDefaultAnimation,
    };

    /**
     * Internal memoized function which simply takes in the class map and the
     * disable boolean. These immutable values can be memoized.
     */
    var _getGlobalClassNames = memoizeFunction(function (classNames, disableGlobalClassNames) {
        var styleSheet = Stylesheet.getInstance();
        if (disableGlobalClassNames) {
            // disable global classnames
            return Object.keys(classNames).reduce(function (acc, className) {
                acc[className] = styleSheet.getClassName(classNames[className]);
                return acc;
            }, {});
        }
        // use global classnames
        return classNames;
    });
    /**
     * Checks for the `disableGlobalClassNames` property on the `theme` to determine if it should return `classNames`
     * Note that calls to this function are memoized.
     *
     * @param classNames - The collection of global class names that apply when the flag is false. Make sure to pass in
     * the same instance on each call to benefit from memoization.
     * @param theme - The theme to check the flag on
     * @param disableGlobalClassNames - Optional. Explicitly opt in/out of disabling global classnames. Defaults to false.
     */
    function getGlobalClassNames(classNames, theme, disableGlobalClassNames) {
        return _getGlobalClassNames(classNames, disableGlobalClassNames !== undefined ? disableGlobalClassNames : theme.disableGlobalClassNames);
    }

    /**
     * @internal
     * This function is still in experimental phase in support of Foundation experimental development.
     * Its API signature and existence are subject to change.
     *
     * Modify context to activate the specified scheme or theme. For schemes, look in context (if available) and fall back
     * to global Customizations. If both scheme and theme are specified, scheme will be looked up in theme. In this case,
     * scheme must be present in theme arg, otherwise new context will default to theme arg (there is no fallback to
     * settings to look up scheme.)
     *
     * @param context - Context in which to get schemed customizations.
     * @param scheme - Scheme to get customizations for from theme arg (if supplied) OR from context and global settings.
     * @param theme - Theme to merge into context.
     * @returns modified schemed context if scheme is valid and not already applied, unmodified context otherwise.
     */
    function getThemedContext(context, scheme, theme) {
        var newContext = context;
        var newSettings;
        // Only fall back to context and customizations when theme arg is not provided.
        var schemeSource = theme || Customizations.getSettings(['theme'], undefined, context.customizations).theme;
        if (theme) {
            newSettings = { theme: theme };
        }
        var schemeTheme = scheme && schemeSource && schemeSource.schemes && schemeSource.schemes[scheme];
        // These first two checks are logically redundant but TS doesn't infer schemeSource.schemes is defined
        // when schemeTheme is defined.
        if (schemeSource && schemeTheme && schemeSource !== schemeTheme) {
            newSettings = { theme: schemeTheme };
            newSettings.theme.schemes = schemeSource.schemes;
        }
        if (newSettings) {
            newContext = {
                customizations: {
                    settings: mergeSettings(context.customizations.settings, newSettings),
                    scopedSettings: context.customizations.scopedSettings,
                },
            };
        }
        return newContext;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
    // See LICENSE in the project root for license information.
    var __assign$j = (window && window.__assign) || function () {
        __assign$j = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$j.apply(this, arguments);
    };
    // Store the theming state in __themeState__ global scope for reuse in the case of duplicate
    // load-themed-styles hosted on the page.
    var _root = typeof window === 'undefined' ? global : window; // eslint-disable-line @typescript-eslint/no-explicit-any
    // Nonce string to inject into script tag if one provided. This is used in CSP (Content Security Policy).
    var _styleNonce = _root && _root.CSPSettings && _root.CSPSettings.nonce;
    var _themeState = initializeThemeState();
    /**
     * initialize global state object
     */
    function initializeThemeState() {
        var state = _root.__themeState__ || {
            theme: undefined,
            lastStyleElement: undefined,
            registeredStyles: []
        };
        if (!state.runState) {
            state = __assign$j(__assign$j({}, state), { perf: {
                    count: 0,
                    duration: 0
                }, runState: {
                    flushTimer: 0,
                    mode: 0 /* Mode.sync */,
                    buffer: []
                } });
        }
        if (!state.registeredThemableStyles) {
            state = __assign$j(__assign$j({}, state), { registeredThemableStyles: [] });
        }
        _root.__themeState__ = state;
        return state;
    }
    /**
     * Loads a set of style text. If it is registered too early, we will register it when the window.load event
     * is fired.
     * @param {string} styleText Style to register.
     * @param {IStyleRecord} styleRecord Existing style record to re-apply.
     */
    function applyThemableStyles(stylesArray, styleRecord) {
        if (_themeState.loadStyles) {
            _themeState.loadStyles(resolveThemableArray(stylesArray).styleString, stylesArray);
        }
        else {
            registerStyles(stylesArray);
        }
    }
    /**
     * Registers a set theme tokens to find and replace. If styles were already registered, they will be
     * replaced.
     * @param {theme} theme JSON object of theme tokens to values.
     */
    function loadTheme$1(theme) {
        _themeState.theme = theme;
        // reload styles.
        reloadStyles();
    }
    /**
     * Clear already registered style elements and style records in theme_State object
     * @param option - specify which group of registered styles should be cleared.
     * Default to be both themable and non-themable styles will be cleared
     */
    function clearStyles(option) {
        if (option === void 0) { option = 3 /* ClearStyleOptions.all */; }
        if (option === 3 /* ClearStyleOptions.all */ || option === 2 /* ClearStyleOptions.onlyNonThemable */) {
            clearStylesInternal(_themeState.registeredStyles);
            _themeState.registeredStyles = [];
        }
        if (option === 3 /* ClearStyleOptions.all */ || option === 1 /* ClearStyleOptions.onlyThemable */) {
            clearStylesInternal(_themeState.registeredThemableStyles);
            _themeState.registeredThemableStyles = [];
        }
    }
    function clearStylesInternal(records) {
        records.forEach(function (styleRecord) {
            var styleElement = styleRecord && styleRecord.styleElement;
            if (styleElement && styleElement.parentElement) {
                styleElement.parentElement.removeChild(styleElement);
            }
        });
    }
    /**
     * Reloads styles.
     */
    function reloadStyles() {
        if (_themeState.theme) {
            var themableStyles = [];
            for (var _i = 0, _a = _themeState.registeredThemableStyles; _i < _a.length; _i++) {
                var styleRecord = _a[_i];
                themableStyles.push(styleRecord.themableStyle);
            }
            if (themableStyles.length > 0) {
                clearStyles(1 /* ClearStyleOptions.onlyThemable */);
                applyThemableStyles([].concat.apply([], themableStyles));
            }
        }
    }
    /**
     * Resolves ThemingInstruction objects in an array and joins the result into a string.
     * @param {ThemableArray} splitStyleArray ThemableArray to resolve and join.
     */
    function resolveThemableArray(splitStyleArray) {
        var theme = _themeState.theme;
        var themable = false;
        // Resolve the array of theming instructions to an array of strings.
        // Then join the array to produce the final CSS string.
        var resolvedArray = (splitStyleArray || []).map(function (currentValue) {
            var themeSlot = currentValue.theme;
            if (themeSlot) {
                themable = true;
                // A theming annotation. Resolve it.
                var themedValue = theme ? theme[themeSlot] : undefined;
                var defaultValue = currentValue.defaultValue || 'inherit';
                // Warn to console if we hit an unthemed value even when themes are provided, but only if "DEBUG" is true.
                // Allow the themedValue to be undefined to explicitly request the default value.
                if (theme &&
                    !themedValue &&
                    console &&
                    !(themeSlot in theme) &&
                    typeof DEBUG !== 'undefined' &&
                    DEBUG) {
                    console.warn("Theming value not provided for \"".concat(themeSlot, "\". Falling back to \"").concat(defaultValue, "\"."));
                }
                return themedValue || defaultValue;
            }
            else {
                // A non-themable string. Preserve it.
                return currentValue.rawString;
            }
        });
        return {
            styleString: resolvedArray.join(''),
            themable: themable
        };
    }
    /**
     * Registers a set of style text. If it is registered too early, we will register it when the
     * window.load event is fired.
     * @param {ThemableArray} styleArray Array of IThemingInstruction objects to register.
     * @param {IStyleRecord} styleRecord May specify a style Element to update.
     */
    function registerStyles(styleArray) {
        if (typeof document === 'undefined') {
            return;
        }
        var head = document.getElementsByTagName('head')[0];
        var styleElement = document.createElement('style');
        var _a = resolveThemableArray(styleArray), styleString = _a.styleString, themable = _a.themable;
        styleElement.setAttribute('data-load-themed-styles', 'true');
        if (_styleNonce) {
            styleElement.setAttribute('nonce', _styleNonce);
        }
        styleElement.appendChild(document.createTextNode(styleString));
        _themeState.perf.count++;
        head.appendChild(styleElement);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('styleinsert', true /* bubbleEvent */, false /* cancelable */);
        ev.args = {
            newStyle: styleElement
        };
        document.dispatchEvent(ev);
        var record = {
            styleElement: styleElement,
            themableStyle: styleArray
        };
        if (themable) {
            _themeState.registeredThemableStyles.push(record);
        }
        else {
            _themeState.registeredStyles.push(record);
        }
    }

    var _theme = createTheme({});
    var _onThemeChangeCallbacks = [];
    var ThemeSettingName = 'theme';
    function initializeThemeInCustomizations() {
        var _a;
        var _b, _c;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var win = getWindow();
        if ((_b = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _b === void 0 ? void 0 : _b.legacyTheme) {
            // does everything the `else` clause does and more, such as invoke legacy theming
            loadTheme(win.FabricConfig.legacyTheme);
        }
        else if (!Customizations.getSettings([ThemeSettingName]).theme) {
            if ((_c = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _c === void 0 ? void 0 : _c.theme) {
                _theme = createTheme(win.FabricConfig.theme);
            }
            // Set the default theme.
            Customizations.applySettings((_a = {}, _a[ThemeSettingName] = _theme, _a));
        }
    }
    initializeThemeInCustomizations();
    /**
     * Gets the theme object
     * @param depComments - Whether to include deprecated tags as comments for deprecated slots.
     */
    function getTheme(depComments) {
        if (depComments === void 0) { depComments = false; }
        if (depComments === true) {
            _theme = createTheme({}, depComments);
        }
        return _theme;
    }
    /**
     * Registers a callback that gets called whenever the theme changes.
     * This should only be used when the component cannot automatically get theme changes through its state.
     * This will not register duplicate callbacks.
     */
    function registerOnThemeChangeCallback(callback) {
        if (_onThemeChangeCallbacks.indexOf(callback) === -1) {
            _onThemeChangeCallbacks.push(callback);
        }
    }
    /**
     * See registerOnThemeChangeCallback().
     * Removes previously registered callbacks.
     */
    function removeOnThemeChangeCallback(callback) {
        var i = _onThemeChangeCallbacks.indexOf(callback);
        if (i === -1) {
            return;
        }
        _onThemeChangeCallbacks.splice(i, 1);
    }
    /**
     * Applies the theme, while filling in missing slots.
     * @param theme - Partial theme object.
     * @param depComments - Whether to include deprecated tags as comments for deprecated slots.
     */
    function loadTheme(theme, depComments) {
        var _a;
        if (depComments === void 0) { depComments = false; }
        _theme = createTheme(theme, depComments);
        // Invoke the legacy method of theming the page as well.
        loadTheme$1(__assign$k(__assign$k(__assign$k(__assign$k({}, _theme.palette), _theme.semanticColors), _theme.effects), _loadFonts(_theme)));
        Customizations.applySettings((_a = {}, _a[ThemeSettingName] = _theme, _a));
        _onThemeChangeCallbacks.forEach(function (callback) {
            try {
                callback(_theme);
            }
            catch (e) {
                // don't let a bad callback break everything else
            }
        });
        return _theme;
    }
    /**
     * Loads font variables into a JSON object.
     * @param theme - The theme object
     */
    function _loadFonts(theme) {
        var lines = {};
        for (var _i = 0, _a = Object.keys(theme.fonts); _i < _a.length; _i++) {
            var fontName = _a[_i];
            var font = theme.fonts[fontName];
            for (var _b = 0, _c = Object.keys(font); _b < _c.length; _b++) {
                var propName = _c[_b];
                var name_1 = fontName + propName.charAt(0).toUpperCase() + propName.slice(1);
                var value = font[propName];
                if (propName === 'fontSize' && typeof value === 'number') {
                    // if it's a number, convert it to px by default like our theming system does
                    value = value + 'px';
                }
                lines[name_1] = value;
            }
        }
        return lines;
    }

    // This file mimics styles and mixins from _General.Mixins.scss
    var normalize = {
        boxShadow: 'none',
        margin: 0,
        padding: 0,
        boxSizing: 'border-box',
    };
    var noWrap = {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
    };

    var DEFAULT_HEIGHT = '50%';
    var DEFAULT_WIDTH = 20;
    /**
     * - Generates a style used to fade out an overflowing content by defining a style for an :after pseudo element.
     * - Apply it to the :after selector for all combination of states the parent of content might have (normal, hover,
     * selected, focus).
     * - Requires the target to have position set to relative and overflow set to hidden.
     *
     * @example
     * ```tsx
     * // Assuming the following DOM structure and the different background colors coming from
     * // the parent holding the content.
     * <div className={classNames.parent}>
     *   <span className={classNames.content}>Overflown Content</span>
     * </div>
     * ```
     * ```ts
     * // This is how the style set would look in Component.styles.ts
     * const { bodyBackground } = theme.semanticColors;
     * const { neutralLighter } = theme.palette;
     *
     * // The second argument of getFadedOverflowStyle function is a string representing a key of
     * // ISemanticColors or IPalette.
     *
     * const styles = {
     *   parent: [
     *     backgroundColor: bodyBackground,
     *     selectors: {
     *       '&:hover: {
     *         backgroundColor: neutralLighter
     *       },
     *       '$content:after': {
     *         ...getFadedOverflowStyle(theme, 'bodyBackground')
     *       },
     *       '&:hover $content:after': {
     *         ...getFadedOverflowStyle(theme, 'neutralLighter')
     *       }
     *     }
     *   ],
     *   content: [
     *     width: '100%',
     *     display: 'inline-block',
     *     position: 'relative',
     *     overflow: 'hidden'
     *   ]
     * }
     * ```
     * @param theme - The theme object to use.
     * @param color - The background color to fade out to. Accepts only keys of ISemanticColors or IPalette.
     * Defaults to 'bodyBackground'.
     * @param direction - The direction of the overflow. Defaults to horizontal.
     * @param width - The width of the fading overflow. Vertical direction defaults it to 100% vs 20px when horizontal.
     * @param height - The Height of the fading overflow. Vertical direction defaults it to 50% vs 100% when horizontal.
     * @returns The style object.
     */
    function getFadedOverflowStyle(theme, color, direction, width, height) {
        if (color === void 0) { color = 'bodyBackground'; }
        if (direction === void 0) { direction = 'horizontal'; }
        if (width === void 0) { width = getDefaultValue('width', direction); }
        if (height === void 0) { height = getDefaultValue('height', direction); }
        // Get the color value string from the theme semanticColors or palette.
        var colorValue = theme.semanticColors[color] || theme.palette[color];
        // Get the red, green, blue values of the colorValue.
        var rgbColor = color2rgb(colorValue);
        // Apply opacity 0 to serve as a start color of the gradient.
        var rgba = "rgba(" + rgbColor.r + ", " + rgbColor.g + ", " + rgbColor.b + ", 0)";
        // Get the direction of the gradient. (mergeStyles takes care of RTL direction)
        var gradientDirection = direction === 'vertical' ? 'to bottom' : 'to right';
        return {
            content: '""',
            position: 'absolute',
            right: 0,
            bottom: 0,
            width: width,
            height: height,
            pointerEvents: 'none',
            backgroundImage: "linear-gradient(" + gradientDirection + ", " + rgba + " 0%, " + colorValue + " 100%)",
        };
    }
    // TODO consider moving this to a separate module along with some more color functions from OUFR/utilities.
    /**
     * Helper function to convert a string hex color to an RGB object.
     *
     * @param colorValue - Color to be converted from hex to rgba.
     */
    function color2rgb(colorValue) {
        if (colorValue[0] === '#') {
            // If it's a hex code
            return {
                r: parseInt(colorValue.slice(1, 3), 16),
                g: parseInt(colorValue.slice(3, 5), 16),
                b: parseInt(colorValue.slice(5, 7), 16),
            };
        }
        else if (colorValue.indexOf('rgba(') === 0) {
            // If it's an rgba color string
            colorValue = colorValue.match(/rgba\(([^)]+)\)/)[1];
            var parts = colorValue.split(/ *, */).map(Number);
            return {
                r: parts[0],
                g: parts[1],
                b: parts[2],
            };
        }
        // The only remaining possibility is transparent.
        return {
            r: 255,
            g: 255,
            b: 255,
        };
    }
    /**
     * Helper function to get the default values for parameters of main function.
     *
     * @param style - Which style to get the default value for.
     * @param direction - What direction to take into consideration.
     */
    function getDefaultValue(style, direction) {
        if (style === 'width') {
            return direction === 'horizontal' ? DEFAULT_WIDTH : '100%';
        }
        else {
            return direction === 'vertical' ? DEFAULT_HEIGHT : '100%';
        }
    }

    /**
     * Generates placeholder style for each of the browsers supported by `@fluentui/react`.
     * @param styles - The style to use.
     * @returns The placeholder style object for each browser depending on the placeholder directive it uses.
     */
    function getPlaceholderStyles(styles) {
        return {
            selectors: {
                '::placeholder': styles,
                ':-ms-input-placeholder': styles,
                '::-ms-input-placeholder': styles, // Edge
            },
        };
    }

    /**
     * {@docCategory AnimationClassNames}
     */
    var AnimationClassNames = buildClassMap(AnimationStyles);

    /**
     * {@docCategory FontClassNames}
     */
    var FontClassNames = buildClassMap(DefaultFontStyles);

    var ColorClassNames = {};
    for (var colorName in DefaultPalette) {
        if (DefaultPalette.hasOwnProperty(colorName)) {
            // Foreground color
            _defineGetter(ColorClassNames, colorName, '', false, 'color');
            // Hover color
            _defineGetter(ColorClassNames, colorName, 'Hover', true, 'color');
            // Background color
            _defineGetter(ColorClassNames, colorName, 'Background', false, 'background');
            // Background hover
            _defineGetter(ColorClassNames, colorName, 'BackgroundHover', true, 'background');
            // Border color
            _defineGetter(ColorClassNames, colorName, 'Border', false, 'borderColor');
            // Border hover color
            _defineGetter(ColorClassNames, colorName, 'BorderHover', true, 'borderColor');
        }
    }
    /**
     * Defines a getter for the given class configuration.
     */
    function _defineGetter(obj, colorName, suffix, isHover, cssProperty) {
        Object.defineProperty(obj, colorName + suffix, {
            get: function () {
                var _a;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var style = (_a = {}, _a[cssProperty] = getTheme().palette[colorName], _a);
                return mergeStyles(isHover ? { selectors: { ':hover': style } } : style).toString();
            },
            enumerable: true,
            configurable: true,
        });
    }

    var FLUENT_CDN_BASE_URL = 'https://res.cdn.office.net/files/fabric-cdn-prod_20230307.001';

    // Do not modify this file; it is generated as part of publish.
    setVersion('@fluentui/style-utilities', '8.9.6');

    initializeThemeInCustomizations();

    var Styling = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AnimationClassNames: AnimationClassNames,
        AnimationStyles: AnimationStyles,
        AnimationVariables: AnimationVariables,
        ColorClassNames: ColorClassNames,
        DefaultEffects: DefaultEffects,
        DefaultFontStyles: DefaultFontStyles,
        DefaultPalette: DefaultPalette,
        EdgeChromiumHighContrastSelector: EdgeChromiumHighContrastSelector,
        FontClassNames: FontClassNames,
        get FontSizes () { return FontSizes; },
        get FontWeights () { return FontWeights; },
        HighContrastSelector: HighContrastSelector,
        HighContrastSelectorBlack: HighContrastSelectorBlack,
        HighContrastSelectorWhite: HighContrastSelectorWhite,
        get IconFontSizes () { return IconFontSizes; },
        InjectionMode: InjectionMode,
        PulsingBeaconAnimationStyles: PulsingBeaconAnimationStyles,
        ScreenWidthMaxLarge: ScreenWidthMaxLarge,
        ScreenWidthMaxMedium: ScreenWidthMaxMedium,
        ScreenWidthMaxSmall: ScreenWidthMaxSmall,
        ScreenWidthMaxXLarge: ScreenWidthMaxXLarge,
        ScreenWidthMaxXXLarge: ScreenWidthMaxXXLarge,
        ScreenWidthMinLarge: ScreenWidthMinLarge,
        ScreenWidthMinMedium: ScreenWidthMinMedium,
        ScreenWidthMinSmall: ScreenWidthMinSmall,
        ScreenWidthMinUhfMobile: ScreenWidthMinUhfMobile,
        ScreenWidthMinXLarge: ScreenWidthMinXLarge,
        ScreenWidthMinXXLarge: ScreenWidthMinXXLarge,
        ScreenWidthMinXXXLarge: ScreenWidthMinXXXLarge,
        Stylesheet: Stylesheet,
        ThemeSettingName: ThemeSettingName,
        get ZIndexes () { return ZIndexes; },
        buildClassMap: buildClassMap,
        concatStyleSets: concatStyleSets,
        concatStyleSetsWithProps: concatStyleSetsWithProps,
        createFontStyles: createFontStyles,
        focusClear: focusClear,
        fontFace: fontFace,
        getEdgeChromiumNoHighContrastAdjustSelector: getEdgeChromiumNoHighContrastAdjustSelector,
        getFadedOverflowStyle: getFadedOverflowStyle,
        getFocusOutlineStyle: getFocusOutlineStyle,
        getFocusStyle: getFocusStyle,
        getGlobalClassNames: getGlobalClassNames,
        getHighContrastNoAdjustStyle: getHighContrastNoAdjustStyle,
        getIcon: getIcon,
        getIconClassName: getIconClassName,
        getInputFocusStyle: getInputFocusStyle,
        getPlaceholderStyles: getPlaceholderStyles,
        getScreenSelector: getScreenSelector,
        getTheme: getTheme,
        getThemedContext: getThemedContext,
        hiddenContentStyle: hiddenContentStyle,
        keyframes: keyframes,
        loadTheme: loadTheme,
        mergeStyleSets: mergeStyleSets,
        mergeStyles: mergeStyles,
        noWrap: noWrap,
        normalize: normalize,
        registerIconAlias: registerIconAlias,
        registerIcons: registerIcons,
        registerOnThemeChangeCallback: registerOnThemeChangeCallback,
        removeOnThemeChangeCallback: removeOnThemeChangeCallback,
        setIconOptions: setIconOptions,
        unregisterIcons: unregisterIcons,
        createTheme: createTheme,
        registerDefaultFontFaces: registerDefaultFontFaces
    });

    var Utilities = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Async: Async,
        AutoScroll: AutoScroll,
        BaseComponent: BaseComponent,
        Customizations: Customizations,
        Customizer: Customizer,
        CustomizerContext: CustomizerContext,
        DATA_IS_SCROLLABLE_ATTRIBUTE: DATA_IS_SCROLLABLE_ATTRIBUTE,
        DATA_PORTAL_ATTRIBUTE: DATA_PORTAL_ATTRIBUTE,
        DelayedRender: DelayedRender,
        EventGroup: EventGroup,
        FabricPerformance: FabricPerformance,
        FocusRects: FocusRects,
        GlobalSettings: GlobalSettings,
        IsFocusVisibleClassName: IsFocusVisibleClassName,
        KeyCodes: KeyCodes,
        Rectangle: Rectangle,
        SELECTION_CHANGE: SELECTION_CHANGE,
        Selection: Selection,
        get SelectionDirection () { return SelectionDirection; },
        get SelectionMode () { return SelectionMode; },
        addDirectionalKeyCode: addDirectionalKeyCode,
        addElementAtIndex: addElementAtIndex,
        allowOverscrollOnElement: allowOverscrollOnElement,
        allowScrollOnElement: allowScrollOnElement,
        anchorProperties: anchorProperties,
        appendFunction: appendFunction,
        arraysEqual: arraysEqual,
        asAsync: asAsync,
        assertNever: assertNever,
        assign: assign,
        audioProperties: audioProperties,
        baseElementEvents: baseElementEvents,
        baseElementProperties: baseElementProperties,
        buttonProperties: buttonProperties,
        calculatePrecision: calculatePrecision,
        classNamesFunction: classNamesFunction,
        colGroupProperties: colGroupProperties,
        colProperties: colProperties,
        composeComponentAs: composeComponentAs,
        composeRenderFunction: composeRenderFunction,
        createArray: createArray,
        createMemoizer: createMemoizer,
        createMergedRef: createMergedRef,
        css: css,
        customizable: customizable,
        disableBodyScroll: disableBodyScroll,
        divProperties: divProperties,
        doesElementContainFocus: doesElementContainFocus,
        elementContains: elementContains,
        elementContainsAttribute: elementContainsAttribute,
        enableBodyScroll: enableBodyScroll,
        extendComponent: extendComponent,
        filteredAssign: filteredAssign,
        find: find,
        findElementRecursive: findElementRecursive,
        findIndex: findIndex,
        findScrollableParent: findScrollableParent,
        fitContentToBounds: fitContentToBounds,
        flatten: flatten,
        focusAsync: focusAsync,
        focusFirstChild: focusFirstChild,
        formProperties: formProperties,
        format: format,
        getChildren: getChildren,
        getDistanceBetweenPoints: getDistanceBetweenPoints,
        getDocument: getDocument,
        getElementIndexPath: getElementIndexPath,
        getFirstFocusable: getFirstFocusable,
        getFirstTabbable: getFirstTabbable,
        getFirstVisibleElementFromSelector: getFirstVisibleElementFromSelector,
        getFocusableByIndexPath: getFocusableByIndexPath,
        getId: getId,
        getInitials: getInitials,
        getLanguage: getLanguage,
        getLastFocusable: getLastFocusable,
        getLastTabbable: getLastTabbable,
        getNativeElementProps: getNativeElementProps,
        getNativeProps: getNativeProps,
        getNextElement: getNextElement,
        getParent: getParent,
        getPreviousElement: getPreviousElement,
        getPropsWithDefaults: getPropsWithDefaults,
        getRTL: getRTL,
        getRTLSafeKeyCode: getRTLSafeKeyCode,
        getRect: getRect,
        getResourceUrl: getResourceUrl,
        getScrollbarWidth: getScrollbarWidth,
        getVirtualParent: getVirtualParent,
        getWindow: getWindow,
        hasHorizontalOverflow: hasHorizontalOverflow,
        hasOverflow: hasOverflow,
        hasVerticalOverflow: hasVerticalOverflow,
        hoistMethods: hoistMethods,
        hoistStatics: hoistStatics,
        htmlElementProperties: htmlElementProperties,
        iframeProperties: iframeProperties,
        imageProperties: imageProperties,
        imgProperties: imgProperties,
        initializeComponentRef: initializeComponentRef,
        initializeFocusRects: initializeFocusRects,
        inputProperties: inputProperties,
        isControlled: isControlled,
        isDirectionalKeyCode: isDirectionalKeyCode,
        isElementFocusSubZone: isElementFocusSubZone,
        isElementFocusZone: isElementFocusZone,
        isElementTabbable: isElementTabbable,
        isElementVisible: isElementVisible,
        isElementVisibleAndNotHidden: isElementVisibleAndNotHidden,
        isIE11: isIE11,
        isIOS: isIOS,
        isMac: isMac,
        isVirtualElement: isVirtualElement,
        labelProperties: labelProperties,
        liProperties: liProperties,
        mapEnumByName: mapEnumByName,
        memoize: memoize,
        memoizeFunction: memoizeFunction,
        merge: merge,
        mergeAriaAttributeValues: mergeAriaAttributeValues,
        mergeCustomizations: mergeCustomizations,
        mergeScopedSettings: mergeScopedSettings,
        mergeSettings: mergeSettings,
        modalize: modalize,
        nullRender: nullRender,
        olProperties: olProperties,
        omit: omit,
        on: on,
        optionProperties: optionProperties,
        portalContainsElement: portalContainsElement,
        precisionRound: precisionRound,
        raiseClick: raiseClick,
        removeIndex: removeIndex,
        replaceElement: replaceElement,
        resetControlledWarnings: resetControlledWarnings,
        resetIds: resetIds,
        resetMemoizations: resetMemoizations,
        safeRequestAnimationFrame: safeRequestAnimationFrame,
        safeSetTimeout: safeSetTimeout,
        selectProperties: selectProperties,
        setBaseUrl: setBaseUrl,
        setFocusVisibility: setFocusVisibility,
        setLanguage: setLanguage,
        setMemoizeWeakMap: setMemoizeWeakMap,
        setPortalAttribute: setPortalAttribute,
        setRTL: setRTL,
        setSSR: setSSR,
        setVirtualParent: setVirtualParent,
        setWarningCallback: setWarningCallback,
        shallowCompare: shallowCompare,
        shouldWrapFocus: shouldWrapFocus,
        styled: styled,
        tableProperties: tableProperties,
        tdProperties: tdProperties,
        textAreaProperties: textAreaProperties,
        thProperties: thProperties,
        toMatrix: toMatrix,
        trProperties: trProperties,
        unhoistMethods: unhoistMethods,
        useCustomizationSettings: useCustomizationSettings,
        useFocusRects: useFocusRects,
        values: values,
        videoProperties: videoProperties,
        warn: warn,
        warnConditionallyRequiredProps: warnConditionallyRequiredProps,
        warnControlledUsage: warnControlledUsage,
        warnDeprecations: warnDeprecations,
        warnMutuallyExclusive: warnMutuallyExclusive
    });

    var DirectionalHint = {
        /**
         * Appear above the target element, with the left edges of the callout and target aligning.
         */
        topLeftEdge: 0,
        /**
         * Appear above the target element, with the centers of the callout and target aligning.
         */
        topCenter: 1,
        /**
         * Appear above the target element, with the right edges of the callout and target aligning.
         */
        topRightEdge: 2,
        /**
         * Appear above the target element, aligning with the target element such that the callout tends toward
         * the center of the screen.
         */
        topAutoEdge: 3,
        /**
         * Appear below the target element, with the left edges of the callout and target aligning.
         */
        bottomLeftEdge: 4,
        /**
         * Appear below the target element, with the centers of the callout and target aligning.
         */
        bottomCenter: 5,
        /**
         * Appear below the target element, with the right edges of the callout and target aligning.
         */
        bottomRightEdge: 6,
        /**
         * Appear below the target element, aligning with the target element such that the callout tends toward
         * the center of the screen.
         */
        bottomAutoEdge: 7,
        /**
         * Appear to the left of the target element, with the top edges of the callout and target aligning.
         */
        leftTopEdge: 8,
        /**
         * Appear to the left of the target element, with the centers of the callout and target aligning.
         */
        leftCenter: 9,
        /**
         * Appear to the left of the target element, with the bottom edges of the callout and target aligning.
         */
        leftBottomEdge: 10,
        /**
         * Appear to the right of the target element, with the top edges of the callout and target aligning.
         */
        rightTopEdge: 11,
        /**
         * Appear to the right of the target element, with the centers of the callout and target aligning.
         */
        rightCenter: 12,
        /**
         * Appear to the right of the target element, with the bottom edges of the callout and target aligning.
         */
        rightBottomEdge: 13,
    };

    var RectangleEdge;
    (function (RectangleEdge) {
        RectangleEdge[RectangleEdge["top"] = 1] = "top";
        RectangleEdge[RectangleEdge["bottom"] = -1] = "bottom";
        RectangleEdge[RectangleEdge["left"] = 2] = "left";
        RectangleEdge[RectangleEdge["right"] = -2] = "right";
    })(RectangleEdge || (RectangleEdge = {}));
    var Position$2;
    (function (Position) {
        Position[Position["top"] = 0] = "top";
        Position[Position["bottom"] = 1] = "bottom";
        Position[Position["start"] = 2] = "start";
        Position[Position["end"] = 3] = "end";
    })(Position$2 || (Position$2 = {}));

    var _a$9;
    function _createPositionData(targetEdge, alignmentEdge, isAuto) {
        return {
            targetEdge: targetEdge,
            alignmentEdge: alignmentEdge,
            isAuto: isAuto,
        };
    }
    // Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target
    var DirectionalDictionary = (_a$9 = {},
        _a$9[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left),
        _a$9[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top),
        _a$9[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right),
        _a$9[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, undefined, true),
        _a$9[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left),
        _a$9[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom),
        _a$9[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right),
        _a$9[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, undefined, true),
        _a$9[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top),
        _a$9[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left),
        _a$9[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom),
        _a$9[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top),
        _a$9[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right),
        _a$9[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom),
        _a$9);
    function _isRectangleWithinBounds(rect, boundingRect) {
        if (rect.top < boundingRect.top) {
            return false;
        }
        if (rect.bottom > boundingRect.bottom) {
            return false;
        }
        if (rect.left < boundingRect.left) {
            return false;
        }
        if (rect.right > boundingRect.right) {
            return false;
        }
        return true;
    }
    /**
     * Gets all of the edges of a rectangle that are outside of the given bounds.
     * If there are no out of bounds edges it returns an empty array.
     */
    function _getOutOfBoundsEdges(rect, boundingRect) {
        var outOfBounds = [];
        if (rect.top < boundingRect.top) {
            outOfBounds.push(RectangleEdge.top);
        }
        if (rect.bottom > boundingRect.bottom) {
            outOfBounds.push(RectangleEdge.bottom);
        }
        if (rect.left < boundingRect.left) {
            outOfBounds.push(RectangleEdge.left);
        }
        if (rect.right > boundingRect.right) {
            outOfBounds.push(RectangleEdge.right);
        }
        return outOfBounds;
    }
    function _getEdgeValue(rect, edge) {
        return rect[RectangleEdge[edge]];
    }
    function _setEdgeValue(rect, edge, value) {
        rect[RectangleEdge[edge]] = value;
        return rect;
    }
    /**
     * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as
     * the itself already contains the other coordinate.
     * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.
     */
    function _getCenterValue(rect, edge) {
        var edges = _getFlankingEdges(edge);
        return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;
    }
    /**
     * Flips the value depending on the edge.
     * If the edge is a "positive" edge, Top or Left, then the value should stay as it is.
     * If the edge is a "negative" edge, Bottom or Right, then the value should be flipped.
     * This is to account for the fact that the coordinates are effectively reserved in certain cases for the
     * "negative" edges.
     *
     * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:
     * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.
     * If top edge 1 is less than edge 2 then it is out of bounds.
     */
    function _getRelativeEdgeValue(edge, value) {
        if (edge > 0) {
            return value;
        }
        else {
            return value * -1;
        }
    }
    function _getRelativeRectEdgeValue(edge, rect) {
        return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));
    }
    function _getRelativeEdgeDifference(rect, hostRect, edge) {
        var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);
        return _getRelativeEdgeValue(edge, edgeDifference);
    }
    /**
     * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.
     * For example, if it's a bottom edge it will only change y coordinates.
     * if maintainSize is set to false, it will only adjust the specified edge value
     */
    function _moveEdge(rect, edge, newValue, maintainSize) {
        if (maintainSize === void 0) { maintainSize = true; }
        var difference = _getEdgeValue(rect, edge) - newValue;
        var returnRect = _setEdgeValue(rect, edge, newValue);
        if (maintainSize) {
            returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);
        }
        return returnRect;
    }
    /**
     * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.
     */
    function _alignEdges(rect, target, edge, gap) {
        if (gap === void 0) { gap = 0; }
        return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));
    }
    /**
     * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.
     * For instance if targetEdge is bottom, then the rects top will be moved to match it.
     */
    function _alignOppositeEdges(rect, target, targetEdge, gap) {
        if (gap === void 0) { gap = 0; }
        var oppositeEdge = targetEdge * -1;
        var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);
        return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);
    }
    /**
     * Tests to see if the given edge is within the bounds of the given rectangle.
     */
    function _isEdgeInBounds(rect, bounds, edge) {
        var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);
        return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);
    }
    /**
     * Returns a measure of how much a rectangle is out of bounds for a given alignment;
     * this can be used to compare which rectangle is more or less out of bounds.
     * A value of 0 means the rectangle is entirely in bounds
     */
    function _getOutOfBoundsDegree(rect, bounds) {
        var breakingEdges = _getOutOfBoundsEdges(rect, bounds);
        var total = 0;
        for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {
            var edge = breakingEdges_1[_i];
            total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);
        }
        return total;
    }
    /**
     * Attempts to move the rectangle through various sides of the target to find a place to fit.
     * If no fit is found, the least bad option should be returned.
     */
    function _flipToFit(rect, target, bounding, positionData, gap) {
        if (gap === void 0) { gap = 0; }
        var directions = [
            RectangleEdge.left,
            RectangleEdge.right,
            RectangleEdge.bottom,
            RectangleEdge.top,
        ];
        // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.
        if (getRTL()) {
            directions[0] *= -1;
            directions[1] *= -1;
        }
        var currentEstimate = rect;
        var currentEdge = positionData.targetEdge;
        var currentAlignment = positionData.alignmentEdge;
        // keep track of least bad option, in case no sides fit
        var oobDegree;
        var bestEdge = currentEdge;
        var bestAlignment = currentAlignment;
        // Keep switching sides until one is found with enough space.
        // If all sides don't fit then return the unmodified element.
        for (var i = 0; i < 4; i++) {
            if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {
                // update least-bad edges
                var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);
                if (!oobDegree || currentOOBDegree < oobDegree) {
                    oobDegree = currentOOBDegree;
                    bestEdge = currentEdge;
                    bestAlignment = currentAlignment;
                }
                directions.splice(directions.indexOf(currentEdge), 1);
                if (directions.length > 0) {
                    if (directions.indexOf(currentEdge * -1) > -1) {
                        currentEdge = currentEdge * -1;
                    }
                    else {
                        currentAlignment = currentEdge;
                        currentEdge = directions.slice(-1)[0];
                    }
                    currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);
                }
            }
            else {
                return {
                    elementRectangle: currentEstimate,
                    targetEdge: currentEdge,
                    alignmentEdge: currentAlignment,
                };
            }
        }
        // nothing fits, use least-bad option
        currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);
        return {
            elementRectangle: currentEstimate,
            targetEdge: bestEdge,
            alignmentEdge: bestAlignment,
        };
    }
    /**
     * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges
     * into position, when `alignTargetEdge` is specified.
     */
    function _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {
        var alignmentEdge = elementEstimate.alignmentEdge, targetEdge = elementEstimate.targetEdge, elementRectangle = elementEstimate.elementRectangle;
        var oppositeEdge = alignmentEdge * -1;
        var newEstimate = _estimatePosition(elementRectangle, target, { targetEdge: targetEdge, alignmentEdge: oppositeEdge }, gap, coverTarget);
        return {
            elementRectangle: newEstimate,
            targetEdge: targetEdge,
            alignmentEdge: oppositeEdge,
        };
    }
    /**
     * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in
     * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.
     */
    function _adjustFitWithinBounds(element, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
        if (gap === void 0) { gap = 0; }
        var alignmentEdge = positionData.alignmentEdge, alignTargetEdge = positionData.alignTargetEdge;
        var elementEstimate = {
            elementRectangle: element,
            targetEdge: positionData.targetEdge,
            alignmentEdge: alignmentEdge,
        };
        if (!directionalHintFixed && !coverTarget) {
            elementEstimate = _flipToFit(element, target, bounding, positionData, gap);
        }
        var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);
        // if directionalHintFixed is specified, we need to force the target edge to not change
        // we need *-1 because targetEdge refers to the target's edge; the callout edge is the opposite
        var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : undefined;
        if (outOfBounds.length > 0) {
            if (alignTargetEdge) {
                // The edge opposite to the alignment edge might be out of bounds.
                // Flip alignment to see if we can get it within bounds.
                if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {
                    var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);
                    if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {
                        return flippedElementEstimate;
                    }
                    else {
                        // If the flipped elements edges are still out of bounds, try nudging it.
                        elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);
                    }
                }
                else {
                    elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
                }
            }
            else {
                elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
            }
        }
        return elementEstimate;
    }
    /**
     * Iterates through a list of out of bounds edges and tries to nudge and align them.
     * @param outOfBoundsEdges - Array of edges that are out of bounds
     * @param elementEstimate - The current element positioning estimate
     * @param bounding - The current bounds
     * @param preserveEdge - Specify an edge that should not be modified
     */
    function _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {
        for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {
            var direction = outOfBoundsEdges_1[_i];
            var edgeAttempt = void 0;
            // if preserveEdge is specified, do not call _alignEdges, skip directly to _moveEdge
            // this is because _alignEdges will move the opposite edge
            if (preserveEdge && preserveEdge === direction * -1) {
                edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);
                elementEstimate.forcedInBounds = true;
            }
            else {
                edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);
                var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);
                // only update estimate if the attempt didn't break out of the opposite bounding edge
                if (!inBounds) {
                    edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);
                    elementEstimate.forcedInBounds = true;
                }
            }
            elementEstimate.elementRectangle = edgeAttempt;
        }
        return elementEstimate;
    }
    /**
     * Moves the middle point on an edge to the point given.
     * Only moves in one direction. For instance if a bottom edge is passed in, then
     * the bottom edge will be moved in the x axis to match the point.
     */
    function _centerEdgeToPoint(rect, edge, point) {
        var positiveEdge = _getFlankingEdges(edge).positiveEdge;
        var elementMiddle = _getCenterValue(rect, edge);
        var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);
        return _moveEdge(rect, positiveEdge, point - distanceToMiddle);
    }
    /**
     * Moves the element rectangle to be appropriately positioned relative to a given target.
     * Does not flip or adjust the element.
     */
    function _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {
        if (gap === void 0) { gap = 0; }
        var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);
        var alignmentEdge = positionData.alignmentEdge, targetEdge = positionData.targetEdge;
        var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
        estimatedElementPosition = coverTarget
            ? _alignEdges(estimatedElementPosition, target, targetEdge, gap)
            : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);
        // if no alignment edge is provided it's supposed to be centered.
        if (!alignmentEdge) {
            var targetMiddlePoint = _getCenterValue(target, targetEdge);
            estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);
        }
        else {
            estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);
        }
        return estimatedElementPosition;
    }
    /**
     * Returns the non-opposite edges of the target edge.
     * For instance if bottom is passed in then left and right will be returned.
     */
    function _getFlankingEdges(edge) {
        if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {
            return {
                positiveEdge: RectangleEdge.left,
                negativeEdge: RectangleEdge.right,
            };
        }
        else {
            return {
                positiveEdge: RectangleEdge.top,
                negativeEdge: RectangleEdge.bottom,
            };
        }
    }
    /**
     * Retrieve the final value for the return edge of `elementRectangle`. If the `elementRectangle` is closer to one side
     * of the bounds versus the other, the return edge is flipped to grow inward.
     */
    function _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {
        if (bounds &&
            Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) >
                Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {
            return returnEdge * -1;
        }
        return returnEdge;
    }
    /**
     * Whether or not the considered edge of the elementRectangle is lying on the edge of the bounds
     * @param elementRectangle The rectangle whose edge we are considering
     * @param bounds The rectangle marking the bounds
     * @param edge The target edge we're considering
     * @returns If the target edge of the elementRectangle is in the same location as that edge of the bounds
     */
    function _isEdgeOnBounds(elementRectangle, edge, bounds) {
        return bounds !== undefined && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);
    }
    /**
     * Finalizes the element position based on the hostElement. Only returns the
     * rectangle values to position such that they are anchored to the target.
     * This helps prevent resizing from looking very strange.
     * For instance, if the target edge is top and aligned with the left side then
     * the bottom and left values are returned so as the Callout shrinks it shrinks towards that corner.
     */
    function _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge, forceWithinBounds) {
        var returnValue = {};
        var hostRect = _getRectangleFromElement(hostElement);
        var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
        var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
        // If we are finalizing the return edge, choose the edge such that we grow away from the bounds
        // If we are not finalizing the return edge but the opposite edge is flush against the bounds,
        // choose that as the anchor edge so the element rect can grow away from the bounds' edge
        // In this case there will not be a visual difference because there is no more room for the elementRectangle to grow
        // in the usual direction
        if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {
            returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);
        }
        returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);
        returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);
        // if the positioned element will still overflow, return all four edges with in-bounds values
        if (forceWithinBounds) {
            returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);
            returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);
        }
        return returnValue;
    }
    // Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.
    // We still want to position the beak based on it's midpoint which does not change. It will
    // be at (beakwidth / 2, beakwidth / 2)
    function _calculateActualBeakWidthInPixels(beakWidth) {
        return Math.sqrt(beakWidth * beakWidth * 2);
    }
    /**
     * Returns the appropriate IPositionData based on the props altered for RTL.
     * If directionalHintForRTL is passed in that is used if the page is RTL.
     * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be
     * flipped (e.g. bottomLeftEdge would become bottomRightEdge).
     *
     * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.
     */
    function _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {
        if (directionalHint === void 0) { directionalHint = DirectionalHint.bottomAutoEdge; }
        if (previousPositions) {
            return {
                alignmentEdge: previousPositions.alignmentEdge,
                isAuto: previousPositions.isAuto,
                targetEdge: previousPositions.targetEdge,
            };
        }
        var positionInformation = __assign$k({}, DirectionalDictionary[directionalHint]);
        if (getRTL()) {
            // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.
            if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {
                positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;
            }
            return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;
        }
        return positionInformation;
    }
    /**
     * Gets the alignment data for the given information. This only really matters if the positioning is Auto.
     * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to
     * the center of the page.
     */
    function _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {
        if (positionData.isAuto) {
            positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);
        }
        positionData.alignTargetEdge = alignTargetEdge;
        return positionData;
    }
    function getClosestEdge(targetEdge, target, boundingRect) {
        var targetCenter = _getCenterValue(target, targetEdge);
        var boundingCenter = _getCenterValue(boundingRect, targetEdge);
        var _a = _getFlankingEdges(targetEdge), positiveEdge = _a.positiveEdge, negativeEdge = _a.negativeEdge;
        if (targetCenter <= boundingCenter) {
            return positiveEdge;
        }
        else {
            return negativeEdge;
        }
    }
    function _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
        var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);
        if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {
            return {
                elementRectangle: estimatedElementPosition,
                targetEdge: positionData.targetEdge,
                alignmentEdge: positionData.alignmentEdge,
            };
        }
        else {
            return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);
        }
    }
    function _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {
        var targetEdge = elementPosition.targetEdge * -1;
        // The "host" element that we will use to help position the beak.
        var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);
        var returnValue = {};
        var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);
        // only show the beak if the callout is not fully covering the target
        var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);
        var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));
        returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);
        returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);
        return {
            elementPosition: __assign$k({}, returnValue),
            closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),
            targetEdge: targetEdge,
            hideBeak: !showBeak,
        };
    }
    function _positionBeak(beakWidth, elementPosition) {
        var target = elementPosition.targetRectangle;
        /**
         * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and
         * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,
         * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels
         * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.
         */
        var _a = _getFlankingEdges(elementPosition.targetEdge), positiveEdge = _a.positiveEdge, negativeEdge = _a.negativeEdge;
        var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);
        var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);
        var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);
        beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);
        beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));
        if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {
            beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);
        }
        else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {
            beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);
        }
        return beakPosition;
    }
    function _getRectangleFromElement(element) {
        var clientRect = element.getBoundingClientRect();
        return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);
    }
    function _getRectangleFromIRect(rect) {
        return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);
    }
    function _getTargetRect(bounds, target) {
        var targetRectangle;
        if (target) {
            // eslint-disable-next-line no-extra-boolean-cast
            if (!!target.preventDefault) {
                var ev = target;
                targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);
                // eslint-disable-next-line no-extra-boolean-cast
            }
            else if (!!target.getBoundingClientRect) {
                targetRectangle = _getRectangleFromElement(target);
                // HTMLImgElements can have x and y values. The check for it being a point must go last.
            }
            else {
                var rectOrPoint = target;
                // eslint-disable-next-line deprecation/deprecation
                var left = rectOrPoint.left || rectOrPoint.x;
                // eslint-disable-next-line deprecation/deprecation
                var top_1 = rectOrPoint.top || rectOrPoint.y;
                var right = rectOrPoint.right || left;
                var bottom = rectOrPoint.bottom || top_1;
                targetRectangle = new Rectangle(left, right, top_1, bottom);
            }
            if (!_isRectangleWithinBounds(targetRectangle, bounds)) {
                var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);
                for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {
                    var direction = outOfBounds_1[_i];
                    targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];
                }
            }
        }
        else {
            targetRectangle = new Rectangle(0, 0, 0, 0);
        }
        return targetRectangle;
    }
    function _positionElementRelative(props, elementToPosition, boundingRect, previousPositions) {
        var gap = props.gapSpace ? props.gapSpace : 0;
        var targetRect = _getTargetRect(boundingRect, props.target);
        var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);
        var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, props.directionalHintFixed, props.coverTarget);
        return __assign$k(__assign$k({}, positionedElement), { targetRectangle: targetRect });
    }
    function _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {
        var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);
        return {
            elementPosition: finalizedElement,
            targetEdge: positionedElement.targetEdge,
            alignmentEdge: positionedElement.alignmentEdge,
        };
    }
    function _positionCallout(props, hostElement, callout, previousPositions, doNotFinalizeReturnEdge) {
        var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;
        var gap = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);
        var positionProps = props;
        positionProps.gapSpace = gap;
        var boundingRect = props.bounds
            ? _getRectangleFromIRect(props.bounds)
            : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
        var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions);
        var beakPositioned = _positionBeak(beakWidth, positionedElement);
        var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);
        return __assign$k(__assign$k({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), { beakPosition: finalizedBeakPosition });
    }
    function _positionCard(props, hostElement, callout, previousPositions) {
        return _positionCallout(props, hostElement, callout, previousPositions, true);
    }
    function positionCallout(props, hostElement, elementToPosition, previousPositions) {
        return _positionCallout(props, hostElement, elementToPosition, previousPositions);
    }
    function positionCard(props, hostElement, elementToPosition, previousPositions) {
        return _positionCard(props, hostElement, elementToPosition, previousPositions);
    }
    /**
     * Returns the opposite edge of the given RectangleEdge.
     */
    function getOppositeEdge(edge) {
        return edge * -1;
    }
    function _getBoundsFromTargetWindow(target, targetWindow) {
        var segments = undefined;
        if (targetWindow.getWindowSegments) {
            segments = targetWindow.getWindowSegments();
        }
        // Identify if we're dealing with single screen scenarios.
        if (segments === undefined || segments.length <= 1) {
            return {
                top: 0,
                left: 0,
                right: targetWindow.innerWidth,
                bottom: targetWindow.innerHeight,
                width: targetWindow.innerWidth,
                height: targetWindow.innerHeight,
            };
        }
        // Logic for determining dual screen scenarios.
        var x = 0;
        var y = 0;
        // If the target is an Element get coordinates for its center.
        if (target !== null && !!target.getBoundingClientRect) {
            var clientRect = target.getBoundingClientRect();
            x = (clientRect.left + clientRect.right) / 2;
            y = (clientRect.top + clientRect.bottom) / 2;
        }
        // If the target is not null get x-axis and y-axis coordinates directly.
        else if (target !== null) {
            // eslint-disable-next-line deprecation/deprecation
            x = target.left || target.x;
            // eslint-disable-next-line deprecation/deprecation
            y = target.top || target.y;
        }
        var bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };
        // Define which window segment are the coordinates in and calculate bounds based on that.
        for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
            var segment = segments_1[_i];
            if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {
                bounds = {
                    top: segment.top,
                    left: segment.left,
                    right: segment.right,
                    bottom: segment.bottom,
                    width: segment.width,
                    height: segment.height,
                };
            }
        }
        return bounds;
    }
    function getBoundsFromTargetWindow(target, targetWindow) {
        return _getBoundsFromTargetWindow(target, targetWindow);
    }

    /**
     * Hook to provide an Async instance that is automatically cleaned up on dismount.
     */
    function useAsync() {
        var asyncRef = react.exports.useRef();
        if (!asyncRef.current) {
            asyncRef.current = new Async();
        }
        react.exports.useEffect(function () {
            return function () {
                var _a;
                (_a = asyncRef.current) === null || _a === void 0 ? void 0 : _a.dispose();
                asyncRef.current = undefined;
            };
        }, []);
        return asyncRef.current;
    }

    /**
     * Hook to initialize and return a constant value. Unlike `React.useMemo`, this is guaranteed to
     * always return the same value (and if the initializer is a function, only call it once).
     * This is similar to setting a private member in a class constructor.
     *
     * If the value should ever change based on dependencies, use `React.useMemo` instead.
     *
     * @param initialValue - Initial value, or function to get the initial value. Similar to `useState`,
     * only the value/function passed in the first time this is called is respected.
     * @returns The value. The identity of this value will always be the same.
     */
    function useConst(initialValue) {
        // Use useRef to store the value because it's the least expensive built-in hook that works here
        // (we could also use `const [value] = React.useState(initialValue)` but that's more expensive
        // internally due to reducer handling which we don't need)
        var ref = react.exports.useRef();
        if (ref.current === undefined) {
            // Box the value in an object so we can tell if it's initialized even if the initializer
            // returns/is undefined
            ref.current = {
                value: typeof initialValue === 'function' ? initialValue() : initialValue,
            };
        }
        return ref.current.value;
    }

    /**
     * Hook to store a value and generate callbacks for setting the value to true or false.
     * The identity of the callbacks will always stay the same.
     *
     * @param initialState - Initial value
     * @returns Array with the current value and an object containing the updater callbacks.
     */
    function useBoolean(initialState) {
        var _a = react.exports.useState(initialState), value = _a[0], setValue = _a[1];
        var setTrue = useConst(function () { return function () {
            setValue(true);
        }; });
        var setFalse = useConst(function () { return function () {
            setValue(false);
        }; });
        var toggle = useConst(function () { return function () {
            setValue(function (currentValue) { return !currentValue; });
        }; });
        return [value, { setTrue: setTrue, setFalse: setFalse, toggle: toggle }];
    }

    /**
     * Hook to generate a unique ID in the global scope (spanning across duplicate copies of the same library).
     *
     * @param prefix - Optional prefix for the ID
     * @param providedId - Optional id provided by a parent component. Defaults to the provided value if present,
     *  without conditioning the hook call
     * @returns The ID
     */
    function useId(prefix, providedId) {
        // getId should only be called once since it updates the global constant for the next ID value.
        // (While an extra update isn't likely to cause problems in practice, it's better to avoid it.)
        var ref = react.exports.useRef(providedId);
        if (!ref.current) {
            ref.current = getId(prefix);
        }
        return ref.current;
    }

    /**
     * React hook to merge multiple React refs (either MutableRefObjects or ref callbacks) into a single ref callback that
     * updates all provided refs
     * @param refs - Refs to collectively update with one ref value.
     * @returns A function with an attached "current" prop, so that it can be treated like a RefObject.
     */
    function useMergedRefs() {
        var refs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            refs[_i] = arguments[_i];
        }
        var mergedCallback = react.exports.useCallback(function (value) {
            // Update the "current" prop hanging on the function.
            mergedCallback.current = value;
            for (var _i = 0, refs_1 = refs; _i < refs_1.length; _i++) {
                var ref = refs_1[_i];
                if (typeof ref === 'function') {
                    ref(value);
                }
                else if (ref) {
                    // work around the immutability of the React.Ref type
                    ref.current = value;
                }
            }
        }, __spreadArray$2([], refs));
        return mergedCallback;
    }

    /**
     * Hook to attach an event handler on mount and handle cleanup.
     * @param element - Element (or ref to an element) to attach the event handler to
     * @param eventName - The event to attach a handler for
     * @param callback - The handler for the event
     * @param useCapture - Whether or not to attach the handler for the capture phase
     */
    function useOnEvent(element, eventName, callback, useCapture) {
        // Use a ref for the callback to prevent repeatedly attaching/unattaching callbacks that are unstable across renders
        var callbackRef = react.exports.useRef(callback);
        callbackRef.current = callback;
        react.exports.useEffect(function () {
            var actualElement = element && 'current' in element ? element.current : element;
            if (!actualElement) {
                return;
            }
            var dispose = on(actualElement, eventName, function (ev) { return callbackRef.current(ev); }, useCapture);
            return dispose;
        }, [element, eventName, useCapture]);
    }

    /**
     * Hook keeping track of a given value from a previous execution of the component the Hook is used in.
     *
     * See [React Hooks FAQ](https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state)
     */
    function usePrevious(value) {
        var ref = react.exports.useRef();
        react.exports.useEffect(function () {
            ref.current = value;
        });
        return ref.current;
    }

    /**
     *  Returns a wrapper function for `setTimeout` which automatically handles disposal.
     */
    var useSetTimeout = function () {
        var timeoutIds = useConst({});
        // Cleanup function.
        react.exports.useEffect(function () { return function () {
            for (var _i = 0, _a = Object.keys(timeoutIds); _i < _a.length; _i++) {
                var id = _a[_i];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                clearTimeout(id);
            }
        }; }, 
        // useConst ensures this will never change, but react-hooks/exhaustive-deps doesn't know that
        [timeoutIds]);
        // Return wrapper which will auto cleanup.
        return useConst({
            setTimeout: function (func, duration) {
                var id = setTimeout(func, duration);
                timeoutIds[id] = 1;
                return id;
            },
            clearTimeout: function (id) {
                delete timeoutIds[id];
                clearTimeout(id);
            },
        });
    };

    /**
     * Context for providing the window.
     */
    // eslint-disable-next-line @fluentui/no-context-default-value
    var WindowContext = react.exports.createContext({
        window: typeof window === 'object' ? window : undefined,
    });
    /**
     * Hook to access the window object. This can be overridden contextually using the `WindowProvider`.
     */
    var useWindow = function () { return react.exports.useContext(WindowContext).window; };
    /**
     * Hook to access the document object. This can be overridden contextually using the `WindowProvider`.
     */
    var useDocument = function () { var _a; return (_a = react.exports.useContext(WindowContext).window) === null || _a === void 0 ? void 0 : _a.document; };
    /**
     * Component to provide the window object contextually. This is useful when rendering content to an element
     * contained within a child window or iframe element, where event handlers and styling must be projected
     * to an alternative window or document.
     */
    var WindowProvider$1 = function (props) {
        return react.exports.createElement(WindowContext.Provider, { value: props }, props.children);
    };

    /**
     * Hook to calculate and cache the target element specified by the given target attribute,
     * as well as the target element's (or host element's) parent window
     * @param target- Target selector passed to the component as a property, describing the element that
     * the callout should target
     * @param hostElement- The callout's host element, used for determining the parent window.
     */
    function useTarget(target, hostElement) {
        var previousTargetProp = react.exports.useRef();
        var targetRef = react.exports.useRef(null);
        /**
         * Stores an instance of Window, used to check
         * for server side rendering and if focus was lost.
         */
        var targetWindow = useWindow();
        // If the target element changed, find the new one. If we are tracking
        // target with class name, always find element because we do not know if
        // fabric has rendered a new element and disposed the old element.
        if (!target || target !== previousTargetProp.current || typeof target === 'string') {
            var currentElement = hostElement === null || hostElement === void 0 ? void 0 : hostElement.current;
            if (target) {
                if (typeof target === 'string') {
                    var currentDoc = getDocument(currentElement);
                    targetRef.current = currentDoc ? currentDoc.querySelector(target) : null;
                }
                else if ('stopPropagation' in target) {
                    targetRef.current = target;
                }
                else if ('getBoundingClientRect' in target) {
                    targetRef.current = target;
                }
                else if ('current' in target) {
                    targetRef.current = target.current;
                }
                else {
                    targetRef.current = target;
                }
            }
            previousTargetProp.current = target;
        }
        return [targetRef, targetWindow];
    }

    /**
     * Hook which synchronously executes a callback when the component is about to unmount.
     *
     * @param callback - Function to call during unmount.
     */
    var useUnmount = function (callback) {
        var unmountRef = react.exports.useRef(callback);
        unmountRef.current = callback;
        react.exports.useEffect(function () { return function () {
            var _a;
            (_a = unmountRef.current) === null || _a === void 0 ? void 0 : _a.call(unmountRef);
        }; }, []);
    };

    function useScrollbarAsync(props, root) {
        var async = useAsync();
        var _a = react.exports.useState(false), needsVerticalScrollBarState = _a[0], setNeedsVerticalScrollBar = _a[1];
        react.exports.useEffect(function () {
            async.requestAnimationFrame(function () {
                var _a;
                // If overflowY is overridden, don't waste time calculating whether the scrollbar is necessary.
                if (props.style && props.style.overflowY) {
                    return;
                }
                var needsVerticalScrollBar = false;
                if (root && root.current && ((_a = root.current) === null || _a === void 0 ? void 0 : _a.firstElementChild)) {
                    // ClientHeight returns the client height of an element rounded to an
                    // integer. On some browsers at different zoom levels this rounding
                    // can generate different results for the root container and child even
                    // though they are the same height. This causes us to show a scroll bar
                    // when not needed. Ideally we would use BoundingClientRect().height
                    // instead however seems that the API is 90% slower than using ClientHeight.
                    // Therefore instead we will calculate the difference between heights and
                    // allow for a 1px difference to still be considered ok and not show the
                    // scroll bar.
                    var rootHeight = root.current.clientHeight;
                    var firstChildHeight = root.current.firstElementChild.clientHeight;
                    if (rootHeight > 0 && firstChildHeight > rootHeight) {
                        needsVerticalScrollBar = firstChildHeight - rootHeight > 1;
                    }
                }
                if (needsVerticalScrollBarState !== needsVerticalScrollBar) {
                    setNeedsVerticalScrollBar(needsVerticalScrollBar);
                }
            });
            return function () { return async.dispose(); };
        });
        return needsVerticalScrollBarState;
    }
    function defaultFocusRestorer(options) {
        var originalElement = options.originalElement, containsFocus = options.containsFocus;
        if (originalElement && containsFocus && originalElement !== getWindow()) {
            // Make sure that the focus method actually exists
            // In some cases the object might exist but not be a real element.
            // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.
            // This is wrapped in a setTimeout because of a React 16 bug that is resolved in 17.
            // Once we move to 17, the setTimeout should be removed (ref: https://github.com/facebook/react/issues/17894#issuecomment-656094405)
            setTimeout(function () {
                var _a;
                (_a = originalElement.focus) === null || _a === void 0 ? void 0 : _a.call(originalElement);
            }, 0);
        }
    }
    function useRestoreFocus(props, root) {
        var _a = props.onRestoreFocus, onRestoreFocus = _a === void 0 ? defaultFocusRestorer : _a;
        var originalFocusedElement = react.exports.useRef();
        var containsFocus = react.exports.useRef(false);
        react.exports.useEffect(function () {
            originalFocusedElement.current = getDocument().activeElement;
            if (doesElementContainFocus(root.current)) {
                containsFocus.current = true;
            }
            return function () {
                var _a;
                onRestoreFocus === null || onRestoreFocus === void 0 ? void 0 : onRestoreFocus({
                    originalElement: originalFocusedElement.current,
                    containsFocus: containsFocus.current,
                    documentContainsFocus: ((_a = getDocument()) === null || _a === void 0 ? void 0 : _a.hasFocus()) || false,
                });
                // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown
                originalFocusedElement.current = undefined;
            };
            // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render
        }, []);
        useOnEvent(root, 'focus', react.exports.useCallback(function () {
            containsFocus.current = true;
        }, []), true);
        useOnEvent(root, 'blur', react.exports.useCallback(function (ev) {
            /** The popup should update this._containsFocus when:
             * relatedTarget exists AND
             * the relatedTarget is not contained within the popup.
             * If the relatedTarget is within the popup, that means the popup still has focus
             * and focused moved from one element to another within the popup.
             * If relatedTarget is undefined or null that usually means that a
             * keyboard event occurred and focus didn't change
             */
            if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget)) {
                containsFocus.current = false;
            }
            // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render
        }, []), true);
    }
    function useHideSiblingNodes(props, root) {
        // eslint-disable-next-line deprecation/deprecation
        var shouldHideSiblings = String(props['aria-modal']).toLowerCase() === 'true' && props.enableAriaHiddenSiblings;
        react.exports.useEffect(function () {
            if (!(shouldHideSiblings && root.current)) {
                return;
            }
            var unmodalize = modalize(root.current);
            return unmodalize;
        }, [root, shouldHideSiblings]);
    }
    /**
     * This adds accessibility to Dialog and Panel controls
     */
    var Popup = react.exports.forwardRef(function (propsWithoutDefaults, forwardedRef) {
        var props = getPropsWithDefaults({ shouldRestoreFocus: true, enableAriaHiddenSiblings: true }, propsWithoutDefaults);
        var root = react.exports.useRef();
        var mergedRootRef = useMergedRefs(root, forwardedRef);
        useHideSiblingNodes(props, root);
        useRestoreFocus(props, root);
        var role = props.role, className = props.className, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, style = props.style, children = props.children, onDismiss = props.onDismiss;
        var needsVerticalScrollBar = useScrollbarAsync(props, root);
        var onKeyDown = react.exports.useCallback(function (ev) {
            // eslint-disable-next-line deprecation/deprecation
            switch (ev.which) {
                case KeyCodes.escape:
                    if (onDismiss) {
                        onDismiss(ev);
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                    break;
            }
        }, [onDismiss]);
        var win = useWindow();
        useOnEvent(win, 'keydown', onKeyDown);
        return (react.exports.createElement("div", __assign$k({ ref: mergedRootRef }, getNativeProps(props, divProperties), { className: className, role: role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown: onKeyDown, style: __assign$k({ overflowY: needsVerticalScrollBar ? 'scroll' : undefined, outline: 'none' }, style) }), children));
    });
    Popup.displayName = 'Popup';

    var _a$8;
    var COMPONENT_NAME$6 = 'CalloutContentBase';
    var ANIMATIONS = (_a$8 = {},
        _a$8[RectangleEdge.top] = AnimationClassNames.slideUpIn10,
        _a$8[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10,
        _a$8[RectangleEdge.left] = AnimationClassNames.slideLeftIn10,
        _a$8[RectangleEdge.right] = AnimationClassNames.slideRightIn10,
        _a$8);
    var BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
    // Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.
    // To help ensure that edge will respect the offscreen style opacity
    // filter needs to be added as an additional way to set opacity.
    // Also set pointer-events: none so that the callout will not occlude the element it is
    // going to be positioned against
    var OFF_SCREEN_STYLE = {
        opacity: 0,
        filter: 'opacity(0)',
        pointerEvents: 'none',
    };
    // role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element
    // This constant array can be used to filter these out of native props spread on callout root and apply them together on
    // calloutMain (the Popup component within the callout)
    var ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];
    var DEFAULT_PROPS$2 = {
        preventDismissOnLostFocus: false,
        preventDismissOnScroll: false,
        preventDismissOnResize: false,
        isBeakVisible: true,
        beakWidth: 16,
        gapSpace: 0,
        minPagePadding: 8,
        directionalHint: DirectionalHint.bottomAutoEdge,
    };
    var getClassNames$i = classNamesFunction({
        disableCaching: true, // disabling caching because stylesProp.position mutates often
    });
    /**
     * (Hook) to return a function to lazily fetch the bounds of the target element for the callout.
     */
    function useBounds(_a, targetRef, targetWindow) {
        var bounds = _a.bounds, _b = _a.minPagePadding, minPagePadding = _b === void 0 ? DEFAULT_PROPS$2.minPagePadding : _b, target = _a.target;
        var _c = react.exports.useState(false), targetWindowResized = _c[0], setTargetWindowResized = _c[1];
        var cachedBounds = react.exports.useRef();
        var getBounds = react.exports.useCallback(function () {
            if (!cachedBounds.current || targetWindowResized) {
                var currentBounds = typeof bounds === 'function' ? (targetWindow ? bounds(target, targetWindow) : undefined) : bounds;
                if (!currentBounds && targetWindow) {
                    currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);
                    currentBounds = {
                        top: currentBounds.top + minPagePadding,
                        left: currentBounds.left + minPagePadding,
                        right: currentBounds.right - minPagePadding,
                        bottom: currentBounds.bottom - minPagePadding,
                        width: currentBounds.width - minPagePadding * 2,
                        height: currentBounds.height - minPagePadding * 2,
                    };
                }
                cachedBounds.current = currentBounds;
                targetWindowResized && setTargetWindowResized(false);
            }
            return cachedBounds.current;
        }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);
        var async = useAsync();
        useOnEvent(targetWindow, 'resize', async.debounce(function () {
            setTargetWindowResized(true);
        }, 500, { leading: true }));
        return getBounds;
    }
    /**
     * (Hook) to return the maximum available height for the Callout to render into.
     */
    function useMaxHeight(_a, getBounds, positions) {
        var _b;
        var calloutMaxHeight = _a.calloutMaxHeight, finalHeight = _a.finalHeight, directionalHint = _a.directionalHint, directionalHintFixed = _a.directionalHintFixed, hidden = _a.hidden;
        var _c = react.exports.useState(), maxHeight = _c[0], setMaxHeight = _c[1];
        var _d = (_b = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b !== void 0 ? _b : {}, top = _d.top, bottom = _d.bottom;
        react.exports.useEffect(function () {
            var _a;
            var _b = (_a = getBounds()) !== null && _a !== void 0 ? _a : {}, topBounds = _b.top, bottomBounds = _b.bottom;
            if (!calloutMaxHeight && !hidden) {
                if (typeof top === 'number' && bottomBounds) {
                    setMaxHeight(bottomBounds - top);
                }
                else if (typeof bottom === 'number' && typeof topBounds === 'number' && bottomBounds) {
                    setMaxHeight(bottomBounds - topBounds - bottom);
                }
            }
            else if (calloutMaxHeight) {
                setMaxHeight(calloutMaxHeight);
            }
            else {
                setMaxHeight(undefined);
            }
        }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);
        return maxHeight;
    }
    /**
     * (Hook) to find the current position of Callout. If Callout is resized then a new position is calculated.
     */
    function usePositions(props, hostElement, calloutElement, targetRef, getBounds) {
        var _a = react.exports.useState(), positions = _a[0], setPositions = _a[1];
        var positionAttempts = react.exports.useRef(0);
        var previousTarget = react.exports.useRef();
        var async = useAsync();
        var hidden = props.hidden, target = props.target, finalHeight = props.finalHeight, calloutMaxHeight = props.calloutMaxHeight, onPositioned = props.onPositioned, directionalHint = props.directionalHint;
        react.exports.useEffect(function () {
            if (!hidden) {
                var timerId_1 = async.requestAnimationFrame(function () {
                    var _a, _b;
                    if (hostElement.current && calloutElement) {
                        var currentProps = __assign$k(__assign$k({}, props), { target: targetRef.current, bounds: getBounds() });
                        // duplicate calloutElement & remove useMaxHeight's maxHeight for position calc
                        var dupeCalloutElement = calloutElement.cloneNode(true);
                        dupeCalloutElement.style.maxHeight = calloutMaxHeight ? "" + calloutMaxHeight : '';
                        dupeCalloutElement.style.visibility = 'hidden';
                        (_a = calloutElement.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(dupeCalloutElement);
                        var previousPositions = previousTarget.current === target ? positions : undefined;
                        // If there is a finalHeight given then we assume that the user knows and will handle
                        // additional positioning adjustments so we should call positionCard
                        var newPositions = finalHeight
                            ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions)
                            : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions);
                        // clean up duplicate calloutElement
                        (_b = calloutElement.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(dupeCalloutElement);
                        // Set the new position only when the positions do not exist or one of the new callout positions
                        // is different. The position should not change if the position is within 2 decimal places.
                        if ((!positions && newPositions) ||
                            (positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5)) {
                            // We should not reposition the callout more than a few times, if it is then the content is likely resizing
                            // and we should stop trying to reposition to prevent a stack overflow.
                            positionAttempts.current++;
                            setPositions(newPositions);
                        }
                        else if (positionAttempts.current > 0) {
                            // Only call the onPositioned callback if the callout has been re-positioned at least once.
                            positionAttempts.current = 0;
                            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);
                        }
                    }
                }, calloutElement);
                previousTarget.current = target;
                return function () {
                    async.cancelAnimationFrame(timerId_1);
                    previousTarget.current = undefined;
                };
            }
            else {
                // When the callout is hidden, clear position state so that it is not accidentally used next render.
                setPositions(undefined);
                positionAttempts.current = 0;
            }
        }, [
            hidden,
            directionalHint,
            async,
            calloutElement,
            calloutMaxHeight,
            hostElement,
            targetRef,
            finalHeight,
            getBounds,
            onPositioned,
            positions,
            props,
            target,
        ]);
        return positions;
    }
    /**
     * (Hook) to set up behavior to automatically focus the callout when it appears, if indicated by props.
     */
    function useAutoFocus(_a, positions, calloutElement) {
        var hidden = _a.hidden, setInitialFocus = _a.setInitialFocus;
        var async = useAsync();
        var hasPositions = !!positions;
        react.exports.useEffect(function () {
            if (!hidden && setInitialFocus && hasPositions && calloutElement) {
                var timerId_2 = async.requestAnimationFrame(function () { return focusFirstChild(calloutElement); }, calloutElement);
                return function () { return async.cancelAnimationFrame(timerId_2); };
            }
        }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);
    }
    /**
     * (Hook) to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.
     */
    function useDismissHandlers(_a, positions, hostElement, targetRef, targetWindow) {
        var hidden = _a.hidden, onDismiss = _a.onDismiss, 
        // eslint-disable-next-line deprecation/deprecation
        preventDismissOnScroll = _a.preventDismissOnScroll, 
        // eslint-disable-next-line deprecation/deprecation
        preventDismissOnResize = _a.preventDismissOnResize, 
        // eslint-disable-next-line deprecation/deprecation
        preventDismissOnLostFocus = _a.preventDismissOnLostFocus, dismissOnTargetClick = _a.dismissOnTargetClick, shouldDismissOnWindowFocus = _a.shouldDismissOnWindowFocus, preventDismissOnEvent = _a.preventDismissOnEvent;
        var isMouseDownOnPopup = react.exports.useRef(false);
        var async = useAsync();
        var mouseDownHandlers = useConst([
            function () {
                isMouseDownOnPopup.current = true;
            },
            function () {
                isMouseDownOnPopup.current = false;
            },
        ]);
        var positionsExists = !!positions;
        react.exports.useEffect(function () {
            var dismissOnScroll = function (ev) {
                if (positionsExists && !preventDismissOnScroll) {
                    dismissOnClickOrScroll(ev);
                }
            };
            var dismissOnResize = function (ev) {
                if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {
                    onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
                }
            };
            var dismissOnLostFocus = function (ev) {
                if (!preventDismissOnLostFocus) {
                    dismissOnClickOrScroll(ev);
                }
            };
            var dismissOnClickOrScroll = function (ev) {
                var eventPaths = ev.composedPath ? ev.composedPath() : [];
                var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;
                var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);
                // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.
                if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {
                    isMouseDownOnPopup.current = false;
                    return;
                }
                if ((!targetRef.current && isEventTargetOutsideCallout) ||
                    (ev.target !== targetWindow &&
                        isEventTargetOutsideCallout &&
                        (!targetRef.current ||
                            'stopPropagation' in targetRef.current ||
                            dismissOnTargetClick ||
                            (target !== targetRef.current && !elementContains(targetRef.current, target))))) {
                    if (preventDismissOnEvent && preventDismissOnEvent(ev)) {
                        return;
                    }
                    onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
                }
            };
            var dismissOnTargetWindowBlur = function (ev) {
                // Do nothing
                if (!shouldDismissOnWindowFocus) {
                    return;
                }
                if (((preventDismissOnEvent && !preventDismissOnEvent(ev)) ||
                    (!preventDismissOnEvent && !preventDismissOnLostFocus)) &&
                    !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) &&
                    ev.relatedTarget === null) {
                    onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
                }
            };
            // This is added so the callout will dismiss when the window is scrolled
            // but not when something inside the callout is scrolled. The delay seems
            // to be required to avoid React firing an async focus event in IE from
            // the target changing focus quickly prior to rendering the callout.
            var disposablesPromise = new Promise(function (resolve) {
                async.setTimeout(function () {
                    if (!hidden && targetWindow) {
                        var disposables_1 = [
                            on(targetWindow, 'scroll', dismissOnScroll, true),
                            on(targetWindow, 'resize', dismissOnResize, true),
                            on(targetWindow.document.documentElement, 'focus', dismissOnLostFocus, true),
                            on(targetWindow.document.documentElement, 'click', dismissOnLostFocus, true),
                            on(targetWindow, 'blur', dismissOnTargetWindowBlur, true),
                        ];
                        resolve(function () {
                            disposables_1.forEach(function (dispose) { return dispose(); });
                        });
                    }
                }, 0);
            });
            return function () {
                disposablesPromise.then(function (dispose) { return dispose(); });
            };
        }, [
            hidden,
            async,
            hostElement,
            targetRef,
            targetWindow,
            onDismiss,
            shouldDismissOnWindowFocus,
            dismissOnTargetClick,
            preventDismissOnLostFocus,
            preventDismissOnResize,
            preventDismissOnScroll,
            positionsExists,
            preventDismissOnEvent,
        ]);
        return mouseDownHandlers;
    }
    var CalloutContentBase = react.exports.memo(react.exports.forwardRef(function (propsWithoutDefaults, forwardedRef) {
        var props = getPropsWithDefaults(DEFAULT_PROPS$2, propsWithoutDefaults);
        var styles = props.styles, style = props.style, ariaLabel = props.ariaLabel, ariaDescribedBy = props.ariaDescribedBy, ariaLabelledBy = props.ariaLabelledBy, className = props.className, isBeakVisible = props.isBeakVisible, children = props.children, beakWidth = props.beakWidth, calloutWidth = props.calloutWidth, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer, finalHeight = props.finalHeight, _a = props.hideOverflow, hideOverflow = _a === void 0 ? !!finalHeight : _a, backgroundColor = props.backgroundColor, calloutMaxHeight = props.calloutMaxHeight, onScroll = props.onScroll, 
        // eslint-disable-next-line deprecation/deprecation
        _b = props.shouldRestoreFocus, 
        // eslint-disable-next-line deprecation/deprecation
        shouldRestoreFocus = _b === void 0 ? true : _b, target = props.target, hidden = props.hidden, onLayerMounted = props.onLayerMounted;
        var hostElement = react.exports.useRef(null);
        var _c = react.exports.useState(null), calloutElement = _c[0], setCalloutElement = _c[1];
        var calloutCallback = react.exports.useCallback(function (calloutEl) {
            setCalloutElement(calloutEl);
        }, []);
        var rootRef = useMergedRefs(hostElement, forwardedRef);
        var _d = useTarget(props.target, {
            current: calloutElement,
        }), targetRef = _d[0], targetWindow = _d[1];
        var getBounds = useBounds(props, targetRef, targetWindow);
        var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);
        var maxHeight = useMaxHeight(props, getBounds, positions);
        var _e = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow), mouseDownOnPopup = _e[0], mouseUpOnPopup = _e[1];
        // do not set both top and bottom css props from positions
        // instead, use maxHeight
        var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);
        var cssPositions = __assign$k(__assign$k({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), { maxHeight: maxHeight });
        if (isForcedInBounds) {
            cssPositions.bottom = undefined;
        }
        useAutoFocus(props, positions, calloutElement);
        react.exports.useEffect(function () {
            if (!hidden) {
                onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
            }
            // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if hidden changes
        }, [hidden]);
        // If there is no target window then we are likely in server side rendering and we should not render anything.
        if (!targetWindow) {
            return null;
        }
        var overflowYHidden = hideOverflow;
        var beakVisible = isBeakVisible && !!target;
        var classNames = getClassNames$i(styles, {
            theme: props.theme,
            className: className,
            overflowYHidden: overflowYHidden,
            calloutWidth: calloutWidth,
            positions: positions,
            beakWidth: beakWidth,
            backgroundColor: backgroundColor,
            calloutMaxWidth: calloutMaxWidth,
            calloutMinWidth: calloutMinWidth,
            doNotLayer: doNotLayer,
        });
        var overflowStyle = __assign$k(__assign$k({ maxHeight: calloutMaxHeight ? calloutMaxHeight : '100%' }, style), (overflowYHidden && { overflowY: 'hidden' }));
        var visibilityStyle = props.hidden ? { visibility: 'hidden' } : undefined;
        // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.
        return (react.exports.createElement("div", { ref: rootRef, className: classNames.container, style: visibilityStyle },
            react.exports.createElement("div", __assign$k({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), { className: css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]), style: positions ? __assign$k({}, cssPositions) : OFF_SCREEN_STYLE, 
                // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.
                // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
                tabIndex: -1, ref: calloutCallback }),
                beakVisible && react.exports.createElement("div", { className: classNames.beak, style: getBeakPosition(positions) }),
                beakVisible && react.exports.createElement("div", { className: classNames.beakCurtain }),
                react.exports.createElement(Popup
                // don't use getNativeElementProps for role and roledescription because it will also
                // pass through data-* props (resulting in them being used in two places)
                , { 
                    // don't use getNativeElementProps for role and roledescription because it will also
                    // pass through data-* props (resulting in them being used in two places)
                    role: props.role, "aria-roledescription": props['aria-roledescription'], ariaDescribedBy: ariaDescribedBy, ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy, className: classNames.calloutMain, onDismiss: props.onDismiss, onMouseDown: mouseDownOnPopup, onMouseUp: mouseUpOnPopup, onRestoreFocus: props.onRestoreFocus, onScroll: onScroll, shouldRestoreFocus: shouldRestoreFocus, style: overflowStyle }, children))));
    }), function (previousProps, nextProps) {
        if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {
            // Do not update when hidden.
            return true;
        }
        return shallowCompare(previousProps, nextProps);
    });
    /**
     * (Utility) to find and return the current `Callout` Beak position.
     *
     * @param positions
     */
    function getBeakPosition(positions) {
        var _a, _b;
        var beakPositionStyle = __assign$k(__assign$k({}, (_a = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a === void 0 ? void 0 : _a.elementPosition), { display: ((_b = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b === void 0 ? void 0 : _b.hideBeak) ? 'none' : undefined });
        if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {
            beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;
            beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;
        }
        return beakPositionStyle;
    }
    /**
     * (Utility) used to compare two different elementPositions to determine whether they are equal.
     *
     * @param prevElementPositions
     * @param newElementPosition
     */
    function arePositionsEqual(prevElementPositions, newElementPosition) {
        return (comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) &&
            comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition));
    }
    /**
     * (Utility) used in **arePositionsEqual** to compare two different elementPositions.
     *
     * @param prevElementPositions
     * @param newElementPositions
     */
    function comparePositions(prevElementPositions, newElementPositions) {
        for (var key in newElementPositions) {
            if (newElementPositions.hasOwnProperty(key)) {
                var oldPositionEdge = prevElementPositions[key];
                var newPositionEdge = newElementPositions[key];
                if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {
                    if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
        }
        return true;
    }
    CalloutContentBase.displayName = COMPONENT_NAME$6;

    function getBeakStyle(beakWidth) {
        return {
            height: beakWidth,
            width: beakWidth,
        };
    }
    var GlobalClassNames$a = {
        container: 'ms-Callout-container',
        root: 'ms-Callout',
        beak: 'ms-Callout-beak',
        beakCurtain: 'ms-Callout-beakCurtain',
        calloutMain: 'ms-Callout-main',
    };
    var getStyles$r = function (props) {
        var _a;
        var theme = props.theme, className = props.className, overflowYHidden = props.overflowYHidden, calloutWidth = props.calloutWidth, beakWidth = props.beakWidth, backgroundColor = props.backgroundColor, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer;
        var classNames = getGlobalClassNames(GlobalClassNames$a, theme);
        var semanticColors = theme.semanticColors, effects = theme.effects;
        return {
            container: [
                classNames.container,
                {
                    position: 'relative',
                },
            ],
            root: [
                classNames.root,
                theme.fonts.medium,
                {
                    position: 'absolute',
                    display: 'flex',
                    zIndex: doNotLayer ? ZIndexes.Layer : undefined,
                    boxSizing: 'border-box',
                    borderRadius: effects.roundedCorner2,
                    boxShadow: effects.elevation16,
                    selectors: (_a = {},
                        _a[HighContrastSelector] = {
                            borderWidth: 1,
                            borderStyle: 'solid',
                            borderColor: 'WindowText',
                        },
                        _a),
                },
                focusClear(),
                className,
                !!calloutWidth && { width: calloutWidth },
                !!calloutMaxWidth && { maxWidth: calloutMaxWidth },
                !!calloutMinWidth && { minWidth: calloutMinWidth },
            ],
            beak: [
                classNames.beak,
                {
                    position: 'absolute',
                    backgroundColor: semanticColors.menuBackground,
                    boxShadow: 'inherit',
                    border: 'inherit',
                    boxSizing: 'border-box',
                    transform: 'rotate(45deg)',
                },
                getBeakStyle(beakWidth),
                backgroundColor && {
                    backgroundColor: backgroundColor,
                },
            ],
            beakCurtain: [
                classNames.beakCurtain,
                {
                    position: 'absolute',
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0,
                    backgroundColor: semanticColors.menuBackground,
                    borderRadius: effects.roundedCorner2,
                },
            ],
            calloutMain: [
                classNames.calloutMain,
                {
                    backgroundColor: semanticColors.menuBackground,
                    overflowX: 'hidden',
                    overflowY: 'auto',
                    position: 'relative',
                    width: '100%',
                    borderRadius: effects.roundedCorner2,
                },
                overflowYHidden && {
                    overflowY: 'hidden',
                },
                backgroundColor && {
                    backgroundColor: backgroundColor,
                },
            ],
        };
    };

    var CalloutContent = styled(CalloutContentBase, getStyles$r, undefined, {
        scope: 'CalloutContent',
    });

    var reactDom = {exports: {}};

    var reactDom_production_min = {};

    var scheduler = {exports: {}};

    var scheduler_production_min = {};

    /** @license React v0.19.1
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    (function (exports) {
    var f,g,h,k,l;
    if("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,t=function(){if(null!==p)try{var a=exports.unstable_now();p(!0,a);p=null;}catch(b){throw setTimeout(t,0),b;}},u=Date.now();exports.unstable_now=function(){return Date.now()-u};f=function(a){null!==p?setTimeout(f,0,a):(p=a,setTimeout(t,0));};g=function(a,b){q=setTimeout(a,b);};h=function(){clearTimeout(q);};k=function(){return !1};l=exports.unstable_forceFrameRate=function(){};}else {var w=window.performance,x=window.Date,
    y=window.setTimeout,z=window.clearTimeout;if("undefined"!==typeof console){var A=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");"function"!==typeof A&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");}if("object"===
    typeof w&&"function"===typeof w.now)exports.unstable_now=function(){return w.now()};else {var B=x.now();exports.unstable_now=function(){return x.now()-B};}var C=!1,D=null,E=-1,F=5,G=0;k=function(){return exports.unstable_now()>=G};l=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):F=0<a?Math.floor(1E3/a):5;};var H=new MessageChannel,I=H.port2;H.port1.onmessage=
    function(){if(null!==D){var a=exports.unstable_now();G=a+F;try{D(!0,a)?I.postMessage(null):(C=!1,D=null);}catch(b){throw I.postMessage(null),b;}}else C=!1;};f=function(a){D=a;C||(C=!0,I.postMessage(null));};g=function(a,b){E=y(function(){a(exports.unstable_now());},b);};h=function(){z(E);E=-1;};}function J(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<K(e,b))a[d]=b,a[c]=e,c=d;else break a}}function L(a){a=a[0];return void 0===a?null:a}
    function M(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>K(n,c))void 0!==r&&0>K(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>K(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function K(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var N=[],O=[],P=1,Q=null,R=3,S=!1,T=!1,U=!1;
    function V(a){for(var b=L(O);null!==b;){if(null===b.callback)M(O);else if(b.startTime<=a)M(O),b.sortIndex=b.expirationTime,J(N,b);else break;b=L(O);}}function W(a){U=!1;V(a);if(!T)if(null!==L(N))T=!0,f(X);else {var b=L(O);null!==b&&g(W,b.startTime-a);}}
    function X(a,b){T=!1;U&&(U=!1,h());S=!0;var c=R;try{V(b);for(Q=L(N);null!==Q&&(!(Q.expirationTime>b)||a&&!k());){var d=Q.callback;if(null!==d){Q.callback=null;R=Q.priorityLevel;var e=d(Q.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?Q.callback=e:Q===L(N)&&M(N);V(b);}else M(N);Q=L(N);}if(null!==Q)var m=!0;else {var n=L(O);null!==n&&g(W,n.startTime-b);m=!1;}return m}finally{Q=null,R=c,S=!1;}}
    function Y(a){switch(a){case 1:return -1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var Z=l;exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null;};exports.unstable_continueExecution=function(){T||S||(T=!0,f(X));};
    exports.unstable_getCurrentPriorityLevel=function(){return R};exports.unstable_getFirstCallbackNode=function(){return L(N)};exports.unstable_next=function(a){switch(R){case 1:case 2:case 3:var b=3;break;default:b=R;}var c=R;R=b;try{return a()}finally{R=c;}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=Z;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3;}var c=R;R=a;try{return b()}finally{R=c;}};
    exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();if("object"===typeof c&&null!==c){var e=c.delay;e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:Y(a);}else c=Y(a),e=d;c=e+c;a={id:P++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,J(O,a),null===L(N)&&a===L(O)&&(U?h():U=!0,g(W,e-d))):(a.sortIndex=c,J(N,a),T||S||(T=!0,f(X)));return a};
    exports.unstable_shouldYield=function(){var a=exports.unstable_now();V(a);var b=L(N);return b!==Q&&null!==Q&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<Q.expirationTime||k()};exports.unstable_wrapCallback=function(a){var b=R;return function(){var c=R;R=b;try{return a.apply(this,arguments)}finally{R=c;}}};
    }(scheduler_production_min));

    {
      scheduler.exports = scheduler_production_min;
    }

    /** @license React v16.14.0
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa=react.exports,n=objectAssign,r=scheduler.exports;function u(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!aa)throw Error(u(227));
    function ba(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l);}catch(m){this.onError(m);}}var da=!1,ea=null,fa=!1,ha=null,ia={onError:function(a){da=!0;ea=a;}};function ja(a,b,c,d,e,f,g,h,k){da=!1;ea=null;ba.apply(ia,arguments);}function ka(a,b,c,d,e,f,g,h,k){ja.apply(this,arguments);if(da){if(da){var l=ea;da=!1;ea=null;}else throw Error(u(198));fa||(fa=!0,ha=l);}}var la=null,ma=null,na=null;
    function oa(a,b,c){var d=a.type||"unknown-event";a.currentTarget=na(c);ka(d,b,void 0,a);a.currentTarget=null;}var pa=null,qa={};
    function ra(){if(pa)for(var a in qa){var b=qa[a],c=pa.indexOf(a);if(!(-1<c))throw Error(u(96,a));if(!sa[c]){if(!b.extractEvents)throw Error(u(97,a));sa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;if(ta.hasOwnProperty(h))throw Error(u(99,h));ta[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&ua(k[e],g,h);e=!0;}else f.registrationName?(ua(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(u(98,d,a));}}}}
    function ua(a,b,c){if(va[a])throw Error(u(100,a));va[a]=b;wa[a]=b.eventTypes[c].dependencies;}var sa=[],ta={},va={},wa={};function xa(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!qa.hasOwnProperty(c)||qa[c]!==d){if(qa[c])throw Error(u(102,c));qa[c]=d;b=!0;}}b&&ra();}var ya=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),za=null,Aa=null,Ba=null;
    function Ca(a){if(a=ma(a)){if("function"!==typeof za)throw Error(u(280));var b=a.stateNode;b&&(b=la(b),za(a.stateNode,a.type,b));}}function Da(a){Aa?Ba?Ba.push(a):Ba=[a]:Aa=a;}function Ea(){if(Aa){var a=Aa,b=Ba;Ba=Aa=null;Ca(a);if(b)for(a=0;a<b.length;a++)Ca(b[a]);}}function Fa(a,b){return a(b)}function Ga(a,b,c,d,e){return a(b,c,d,e)}function Ha(){}var Ia=Fa,Ja=!1,Ka=!1;function La(){if(null!==Aa||null!==Ba)Ha(),Ea();}
    function Ma(a,b,c){if(Ka)return a(b,c);Ka=!0;try{return Ia(a,b,c)}finally{Ka=!1,La();}}var Na=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Oa=Object.prototype.hasOwnProperty,Pa={},Qa={};
    function Ra(a){if(Oa.call(Qa,a))return !0;if(Oa.call(Pa,a))return !1;if(Na.test(a))return Qa[a]=!0;Pa[a]=!0;return !1}function Sa(a,b,c,d){if(null!==c&&0===c.type)return !1;switch(typeof b){case "function":case "symbol":return !0;case "boolean":if(d)return !1;if(null!==c)return !c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return "data-"!==a&&"aria-"!==a;default:return !1}}
    function Ta(a,b,c,d){if(null===b||"undefined"===typeof b||Sa(a,b,c,d))return !0;if(d)return !1;if(null!==c)switch(c.type){case 3:return !b;case 4:return !1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return !1}function v(a,b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;}var C={};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){C[a]=new v(a,0,!1,a,null,!1);});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];C[b]=new v(b,1,!1,a[1],null,!1);});["contentEditable","draggable","spellCheck","value"].forEach(function(a){C[a]=new v(a,2,!1,a.toLowerCase(),null,!1);});
    ["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){C[a]=new v(a,2,!1,a,null,!1);});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){C[a]=new v(a,3,!1,a.toLowerCase(),null,!1);});
    ["checked","multiple","muted","selected"].forEach(function(a){C[a]=new v(a,3,!0,a,null,!1);});["capture","download"].forEach(function(a){C[a]=new v(a,4,!1,a,null,!1);});["cols","rows","size","span"].forEach(function(a){C[a]=new v(a,6,!1,a,null,!1);});["rowSpan","start"].forEach(function(a){C[a]=new v(a,5,!1,a.toLowerCase(),null,!1);});var Ua=/[\-:]([a-z])/g;function Va(a){return a[1].toUpperCase()}
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(Ua,
    Va);C[b]=new v(b,1,!1,a,null,!1);});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(Ua,Va);C[b]=new v(b,1,!1,a,"http://www.w3.org/1999/xlink",!1);});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(Ua,Va);C[b]=new v(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1);});["tabIndex","crossOrigin"].forEach(function(a){C[a]=new v(a,1,!1,a.toLowerCase(),null,!1);});
    C.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){C[a]=new v(a,1,!1,a.toLowerCase(),null,!0);});var Wa=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;Wa.hasOwnProperty("ReactCurrentDispatcher")||(Wa.ReactCurrentDispatcher={current:null});Wa.hasOwnProperty("ReactCurrentBatchConfig")||(Wa.ReactCurrentBatchConfig={suspense:null});
    function Xa(a,b,c,d){var e=C.hasOwnProperty(b)?C[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(Ta(b,c,e,d)&&(c=null),d||null===e?Ra(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))));}
    var Ya=/^(.*)[\\\/]/,E="function"===typeof Symbol&&Symbol.for,Za=E?Symbol.for("react.element"):60103,$a=E?Symbol.for("react.portal"):60106,ab=E?Symbol.for("react.fragment"):60107,bb=E?Symbol.for("react.strict_mode"):60108,cb=E?Symbol.for("react.profiler"):60114,db=E?Symbol.for("react.provider"):60109,eb=E?Symbol.for("react.context"):60110,fb=E?Symbol.for("react.concurrent_mode"):60111,gb=E?Symbol.for("react.forward_ref"):60112,hb=E?Symbol.for("react.suspense"):60113,ib=E?Symbol.for("react.suspense_list"):
    60120,jb=E?Symbol.for("react.memo"):60115,kb=E?Symbol.for("react.lazy"):60116,lb=E?Symbol.for("react.block"):60121,mb="function"===typeof Symbol&&Symbol.iterator;function nb(a){if(null===a||"object"!==typeof a)return null;a=mb&&a[mb]||a["@@iterator"];return "function"===typeof a?a:null}function ob(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b);},function(b){0===a._status&&(a._status=2,a._result=b);});}}
    function pb(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ab:return "Fragment";case $a:return "Portal";case cb:return "Profiler";case bb:return "StrictMode";case hb:return "Suspense";case ib:return "SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case eb:return "Context.Consumer";case db:return "Context.Provider";case gb:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":
    "ForwardRef");case jb:return pb(a.type);case lb:return pb(a.render);case kb:if(a=1===a._status?a._result:null)return pb(a)}return null}function qb(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=pb(a.type);c=null;d&&(c=pb(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(Ya,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f;}b+=c;a=a.return;}while(a);return b}
    function rb(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return ""}}function sb(a){var b=a.type;return (a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
    function tb(a){var b=sb(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a);}});Object.defineProperty(a,b,{enumerable:c.enumerable});return {getValue:function(){return d},setValue:function(a){d=""+a;},stopTracking:function(){a._valueTracker=
    null;delete a[b];}}}}function xb(a){a._valueTracker||(a._valueTracker=tb(a));}function yb(a){if(!a)return !1;var b=a._valueTracker;if(!b)return !0;var c=b.getValue();var d="";a&&(d=sb(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function zb(a,b){var c=b.checked;return n({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}
    function Ab(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=rb(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value};}function Bb(a,b){b=b.checked;null!=b&&Xa(a,"checked",b,!1);}
    function Cb(a,b){Bb(a,b);var c=rb(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c;}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Db(a,b.type,c):b.hasOwnProperty("defaultValue")&&Db(a,b.type,rb(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked);}
    function Eb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b;}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c);}
    function Db(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c);}function Fb(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a);});return b}function Gb(a,b){a=n({children:void 0},b);if(b=Fb(b.children))a.children=b;return a}
    function Hb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0);}else {c=""+rb(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e]);}null!==b&&(b.selected=!0);}}
    function Ib(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(u(91));return n({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Jb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(u(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(u(93));c=c[0];}b=c;}null==b&&(b="");c=b;}a._wrapperState={initialValue:rb(c)};}
    function Kb(a,b){var c=rb(b.value),d=rb(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d);}function Lb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b);}var Mb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
    function Nb(a){switch(a){case "svg":return "http://www.w3.org/2000/svg";case "math":return "http://www.w3.org/1998/Math/MathML";default:return "http://www.w3.org/1999/xhtml"}}function Ob(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
    var Pb,Qb=function(a){return "undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)});}:a}(function(a,b){if(a.namespaceURI!==Mb.svg||"innerHTML"in a)a.innerHTML=b;else {Pb=Pb||document.createElement("div");Pb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=Pb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild);}});
    function Rb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b;}function Sb(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Tb={animationend:Sb("Animation","AnimationEnd"),animationiteration:Sb("Animation","AnimationIteration"),animationstart:Sb("Animation","AnimationStart"),transitionend:Sb("Transition","TransitionEnd")},Ub={},Vb={};
    ya&&(Vb=document.createElement("div").style,"AnimationEvent"in window||(delete Tb.animationend.animation,delete Tb.animationiteration.animation,delete Tb.animationstart.animation),"TransitionEvent"in window||delete Tb.transitionend.transition);function Wb(a){if(Ub[a])return Ub[a];if(!Tb[a])return a;var b=Tb[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Vb)return Ub[a]=b[c];return a}
    var Xb=Wb("animationend"),Yb=Wb("animationiteration"),Zb=Wb("animationstart"),$b=Wb("transitionend"),ac="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),bc=new ("function"===typeof WeakMap?WeakMap:Map);function cc(a){var b=bc.get(a);void 0===b&&(b=new Map,bc.set(a,b));return b}
    function dc(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else {a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function ec(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function fc(a){if(dc(a)!==a)throw Error(u(188));}
    function gc(a){var b=a.alternate;if(!b){b=dc(a);if(null===b)throw Error(u(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return fc(e),a;if(f===d)return fc(e),b;f=f.sibling;}throw Error(u(188));}if(c.return!==d.return)c=e,d=f;else {for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling;}if(!g){for(h=f.child;h;){if(h===
    c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling;}if(!g)throw Error(u(189));}}if(c.alternate!==d)throw Error(u(190));}if(3!==c.tag)throw Error(u(188));return c.stateNode.current===c?a:b}function hc(a){a=gc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else {if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return;}b.sibling.return=b.return;b=b.sibling;}}return null}
    function ic(a,b){if(null==b)throw Error(u(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function jc(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a);}var kc=null;
    function lc(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)oa(a,b[d],c[d]);else b&&oa(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a);}}function mc(a){null!==a&&(kc=ic(kc,a));a=kc;kc=null;if(a){jc(a,lc);if(kc)throw Error(u(95));if(fa)throw a=ha,fa=!1,ha=null,a;}}
    function nc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function oc(a){if(!ya)return !1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}var pc=[];function qc(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>pc.length&&pc.push(a);}
    function rc(a,b,c,d){if(pc.length){var e=pc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return {topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}
    function sc(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else {for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo;}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=tc(d);}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=nc(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,k=0;k<sa.length;k++){var l=sa[k];l&&(l=l.extractEvents(d,b,f,e,g))&&(h=
    ic(h,l));}mc(h);}}function uc(a,b,c){if(!c.has(a)){switch(a){case "scroll":vc(b,"scroll",!0);break;case "focus":case "blur":vc(b,"focus",!0);vc(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":oc(a)&&vc(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===ac.indexOf(a)&&F(a,b);}c.set(a,null);}}
    var wc,xc,yc,zc=!1,Ac=[],Bc=null,Cc=null,Dc=null,Ec=new Map,Fc=new Map,Gc=[],Hc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),Ic="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" ");
    function Jc(a,b){var c=cc(b);Hc.forEach(function(a){uc(a,b,c);});Ic.forEach(function(a){uc(a,b,c);});}function Kc(a,b,c,d,e){return {blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,container:d}}
    function Lc(a,b){switch(a){case "focus":case "blur":Bc=null;break;case "dragenter":case "dragleave":Cc=null;break;case "mouseover":case "mouseout":Dc=null;break;case "pointerover":case "pointerout":Ec.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fc.delete(b.pointerId);}}function Mc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Kc(b,c,d,e,f),null!==b&&(b=Nc(b),null!==b&&xc(b)),a;a.eventSystemFlags|=d;return a}
    function Oc(a,b,c,d,e){switch(b){case "focus":return Bc=Mc(Bc,a,b,c,d,e),!0;case "dragenter":return Cc=Mc(Cc,a,b,c,d,e),!0;case "mouseover":return Dc=Mc(Dc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Ec.set(f,Mc(Ec.get(f)||null,a,b,c,d,e));return !0;case "gotpointercapture":return f=e.pointerId,Fc.set(f,Mc(Fc.get(f)||null,a,b,c,d,e)),!0}return !1}
    function Pc(a){var b=tc(a.target);if(null!==b){var c=dc(b);if(null!==c)if(b=c.tag,13===b){if(b=ec(c),null!==b){a.blockedOn=b;r.unstable_runWithPriority(a.priority,function(){yc(c);});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null;}function Qc(a){if(null!==a.blockedOn)return !1;var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Nc(b);null!==c&&xc(c);a.blockedOn=b;return !1}return !0}
    function Sc(a,b,c){Qc(a)&&c.delete(b);}function Tc(){for(zc=!1;0<Ac.length;){var a=Ac[0];if(null!==a.blockedOn){a=Nc(a.blockedOn);null!==a&&wc(a);break}var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:Ac.shift();}null!==Bc&&Qc(Bc)&&(Bc=null);null!==Cc&&Qc(Cc)&&(Cc=null);null!==Dc&&Qc(Dc)&&(Dc=null);Ec.forEach(Sc);Fc.forEach(Sc);}function Uc(a,b){a.blockedOn===b&&(a.blockedOn=null,zc||(zc=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Tc)));}
    function Vc(a){function b(b){return Uc(b,a)}if(0<Ac.length){Uc(Ac[0],a);for(var c=1;c<Ac.length;c++){var d=Ac[c];d.blockedOn===a&&(d.blockedOn=null);}}null!==Bc&&Uc(Bc,a);null!==Cc&&Uc(Cc,a);null!==Dc&&Uc(Dc,a);Ec.forEach(b);Fc.forEach(b);for(c=0;c<Gc.length;c++)d=Gc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Gc.length&&(c=Gc[0],null===c.blockedOn);)Pc(c),null===c.blockedOn&&Gc.shift();}
    var Wc={},Yc=new Map,Zc=new Map,$c=["abort","abort",Xb,"animationEnd",Yb,"animationIteration",Zb,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking",
    "seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",$b,"transitionEnd","waiting","waiting"];function ad(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Zc.set(d,b);Yc.set(d,f);Wc[e]=f;}}
    ad("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0);
    ad("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);ad($c,2);for(var bd="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),cd=0;cd<bd.length;cd++)Zc.set(bd[cd],0);
    var dd=r.unstable_UserBlockingPriority,ed=r.unstable_runWithPriority,fd=!0;function F(a,b){vc(b,a,!1);}function vc(a,b,c){var d=Zc.get(b);switch(void 0===d?2:d){case 0:d=gd.bind(null,b,1,a);break;case 1:d=hd.bind(null,b,1,a);break;default:d=id.bind(null,b,1,a);}c?a.addEventListener(b,d,!0):a.addEventListener(b,d,!1);}function gd(a,b,c,d){Ja||Ha();var e=id,f=Ja;Ja=!0;try{Ga(e,a,b,c,d);}finally{(Ja=f)||La();}}function hd(a,b,c,d){ed(dd,id.bind(null,a,b,c,d));}
    function id(a,b,c,d){if(fd)if(0<Ac.length&&-1<Hc.indexOf(a))a=Kc(null,a,b,c,d),Ac.push(a);else {var e=Rc(a,b,c,d);if(null===e)Lc(a,d);else if(-1<Hc.indexOf(a))a=Kc(e,a,b,c,d),Ac.push(a);else if(!Oc(e,a,b,c,d)){Lc(a,d);a=rc(a,d,null,b);try{Ma(sc,a);}finally{qc(a);}}}}
    function Rc(a,b,c,d){c=nc(d);c=tc(c);if(null!==c){var e=dc(c);if(null===e)c=null;else {var f=e.tag;if(13===f){c=ec(e);if(null!==c)return c;c=null;}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null;}else e!==c&&(c=null);}}a=rc(a,d,c,b);try{Ma(sc,a);}finally{qc(a);}return null}
    var jd={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
    floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},kd=["Webkit","ms","Moz","O"];Object.keys(jd).forEach(function(a){kd.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);jd[b]=jd[a];});});function ld(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||jd.hasOwnProperty(a)&&jd[a]?(""+b).trim():b+"px"}
    function md(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ld(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e;}}var nd=n({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
    function od(a,b){if(b){if(nd[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(u(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(u(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(u(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(u(62,""));}}
    function pd(a,b){if(-1===a.indexOf("-"))return "string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return !1;default:return !0}}var qd=Mb.html;function rd(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=cc(a);b=wa[b];for(var d=0;d<b.length;d++)uc(b[d],a,c);}function sd(){}
    function td(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function ud(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function vd(a,b){var c=ud(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return {node:c,offset:b-a};a=d;}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode;}c=void 0;}c=ud(c);}}
    function wd(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?wd(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function xd(){for(var a=window,b=td();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href;}catch(d){c=!1;}if(c)a=b.contentWindow;else break;b=td(a.document);}return b}
    function yd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}var zd="$",Ad="/$",Bd="$?",Cd="$!",Dd=null,Ed=null;function Fd(a,b){switch(a){case "button":case "input":case "select":case "textarea":return !!b.autoFocus}return !1}
    function Gd(a,b){return "textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var Hd="function"===typeof setTimeout?setTimeout:void 0,Id="function"===typeof clearTimeout?clearTimeout:void 0;function Jd(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}
    function Kd(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===zd||c===Cd||c===Bd){if(0===b)return a;b--;}else c===Ad&&b++;}a=a.previousSibling;}return null}var Ld=Math.random().toString(36).slice(2),Md="__reactInternalInstance$"+Ld,Nd="__reactEventHandlers$"+Ld,Od="__reactContainere$"+Ld;
    function tc(a){var b=a[Md];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Od]||c[Md]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Kd(a);null!==a;){if(c=a[Md])return c;a=Kd(a);}return b}a=c;c=a.parentNode;}return null}function Nc(a){a=a[Md]||a[Od];return !a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pd(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(u(33));}function Qd(a){return a[Nd]||null}
    function Rd(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}
    function Sd(a,b){var c=a.stateNode;if(!c)return null;var d=la(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1;}if(a)return null;if(c&&"function"!==typeof c)throw Error(u(231,
    b,typeof c));return c}function Td(a,b,c){if(b=Sd(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a);}function Ud(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=Rd(b);for(b=c.length;0<b--;)Td(c[b],"captured",a);for(b=0;b<c.length;b++)Td(c[b],"bubbled",a);}}
    function Vd(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Sd(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a));}function Wd(a){a&&a.dispatchConfig.registrationName&&Vd(a._targetInst,null,a);}function Xd(a){jc(a,Ud);}var Yd=null,Zd=null,$d=null;
    function ae(){if($d)return $d;var a,b=Zd,c=b.length,d,e="value"in Yd?Yd.value:Yd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return $d=e.slice(a,1<d?1-d:void 0)}function be(){return !0}function ce(){return !1}
    function G(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?be:ce;this.isPropagationStopped=ce;return this}
    n(G.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=be);},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=be);},persist:function(){this.isPersistent=be;},isPersistent:ce,destructor:function(){var a=this.constructor.Interface,
    b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=ce;this._dispatchInstances=this._dispatchListeners=null;}});G.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
    G.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;n(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=n({},d.Interface,a);c.extend=d.extend;de(c);return c};de(G);function ee(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
    function fe(a){if(!(a instanceof this))throw Error(u(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a);}function de(a){a.eventPool=[];a.getPooled=ee;a.release=fe;}var ge=G.extend({data:null}),he=G.extend({data:null}),ie=[9,13,27,32],je=ya&&"CompositionEvent"in window,ke=null;ya&&"documentMode"in document&&(ke=document.documentMode);
    var le=ya&&"TextEvent"in window&&!ke,me=ya&&(!je||ke&&8<ke&&11>=ke),ne=String.fromCharCode(32),oe={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
    captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},pe=!1;
    function qe(a,b){switch(a){case "keyup":return -1!==ie.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return !0;default:return !1}}function re(a){a=a.detail;return "object"===typeof a&&"data"in a?a.data:null}var se=!1;function te(a,b){switch(a){case "compositionend":return re(b);case "keypress":if(32!==b.which)return null;pe=!0;return ne;case "textInput":return a=b.data,a===ne&&pe?null:a;default:return null}}
    function ue(a,b){if(se)return "compositionend"===a||!je&&qe(a,b)?(a=ae(),$d=Zd=Yd=null,se=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return me&&"ko"!==b.locale?null:b.data;default:return null}}
    var ve={eventTypes:oe,extractEvents:function(a,b,c,d){var e;if(je)b:{switch(a){case "compositionstart":var f=oe.compositionStart;break b;case "compositionend":f=oe.compositionEnd;break b;case "compositionupdate":f=oe.compositionUpdate;break b}f=void 0;}else se?qe(a,c)&&(f=oe.compositionEnd):"keydown"===a&&229===c.keyCode&&(f=oe.compositionStart);f?(me&&"ko"!==c.locale&&(se||f!==oe.compositionStart?f===oe.compositionEnd&&se&&(e=ae()):(Yd=d,Zd="value"in Yd?Yd.value:Yd.textContent,se=!0)),f=ge.getPooled(f,
    b,c,d),e?f.data=e:(e=re(c),null!==e&&(f.data=e)),Xd(f),e=f):e=null;(a=le?te(a,c):ue(a,c))?(b=he.getPooled(oe.beforeInput,b,c,d),b.data=a,Xd(b)):b=null;return null===e?b:null===b?e:[e,b]}},we={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function xe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return "input"===b?!!we[a.type]:"textarea"===b?!0:!1}
    var ye={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function ze(a,b,c){a=G.getPooled(ye.change,a,b,c);a.type="change";Da(c);Xd(a);return a}var Ae=null,Be=null;function Ce(a){mc(a);}function De(a){var b=Pd(a);if(yb(b))return a}function Ee(a,b){if("change"===a)return b}var Fe=!1;ya&&(Fe=oc("input")&&(!document.documentMode||9<document.documentMode));
    function Ge(){Ae&&(Ae.detachEvent("onpropertychange",He),Be=Ae=null);}function He(a){if("value"===a.propertyName&&De(Be))if(a=ze(Be,a,nc(a)),Ja)mc(a);else {Ja=!0;try{Fa(Ce,a);}finally{Ja=!1,La();}}}function Ie(a,b,c){"focus"===a?(Ge(),Ae=b,Be=c,Ae.attachEvent("onpropertychange",He)):"blur"===a&&Ge();}function Je(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return De(Be)}function Ke(a,b){if("click"===a)return De(b)}function Le(a,b){if("input"===a||"change"===a)return De(b)}
    var Me={eventTypes:ye,_isInputEventSupported:Fe,extractEvents:function(a,b,c,d){var e=b?Pd(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Ee;else if(xe(e))if(Fe)g=Le;else {g=Je;var h=Ie;}else (f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Ke);if(g&&(g=g(a,b)))return ze(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Db(e,"number",e.value);}},Ne=G.extend({view:null,detail:null}),
    Oe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pe(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Oe[a])?!!b[a]:!1}function Qe(){return Pe}
    var Re=0,Se=0,Te=!1,Ue=!1,Ve=Ne.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Qe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=Re;Re=a.screenX;return Te?"mousemove"===a.type?a.screenX-b:0:(Te=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;
    var b=Se;Se=a.screenY;return Ue?"mousemove"===a.type?a.screenY-b:0:(Ue=!0,0)}}),We=Ve.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),Xe={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",
    dependencies:["pointerout","pointerover"]}},Ye={eventTypes:Xe,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?tc(b):null,null!==b){var h=dc(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null;}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===
    a){var k=Ve;var l=Xe.mouseLeave;var m=Xe.mouseEnter;var p="mouse";}else if("pointerout"===a||"pointerover"===a)k=We,l=Xe.pointerLeave,m=Xe.pointerEnter,p="pointer";a=null==g?f:Pd(g);f=null==b?f:Pd(b);l=k.getPooled(l,g,c,d);l.type=p+"leave";l.target=a;l.relatedTarget=f;c=k.getPooled(m,b,c,d);c.type=p+"enter";c.target=f;c.relatedTarget=a;d=g;p=b;if(d&&p)a:{k=d;m=p;g=0;for(a=k;a;a=Rd(a))g++;a=0;for(b=m;b;b=Rd(b))a++;for(;0<g-a;)k=Rd(k),g--;for(;0<a-g;)m=Rd(m),a--;for(;g--;){if(k===m||k===m.alternate)break a;
    k=Rd(k);m=Rd(m);}k=null;}else k=null;m=k;for(k=[];d&&d!==m;){g=d.alternate;if(null!==g&&g===m)break;k.push(d);d=Rd(d);}for(d=[];p&&p!==m;){g=p.alternate;if(null!==g&&g===m)break;d.push(p);p=Rd(p);}for(p=0;p<k.length;p++)Vd(k[p],"bubbled",l);for(p=d.length;0<p--;)Vd(d[p],"captured",c);return 0===(e&64)?[l]:[l,c]}};function Ze(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var $e="function"===typeof Object.is?Object.is:Ze,af=Object.prototype.hasOwnProperty;
    function bf(a,b){if($e(a,b))return !0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return !1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return !1;for(d=0;d<c.length;d++)if(!af.call(b,c[d])||!$e(a[c[d]],b[c[d]]))return !1;return !0}
    var cf=ya&&"documentMode"in document&&11>=document.documentMode,df={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},ef=null,ff=null,gf=null,hf=!1;
    function jf(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(hf||null==ef||ef!==td(c))return null;c=ef;"selectionStart"in c&&yd(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return gf&&bf(gf,c)?null:(gf=c,a=G.getPooled(df.select,ff,a,b),a.type="select",a.target=ef,Xd(a),a)}
    var kf={eventTypes:df,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=cc(e);f=wa.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0;}f=!e;}if(f)return null;e=b?Pd(b):window;switch(a){case "focus":if(xe(e)||"true"===e.contentEditable)ef=e,ff=b,gf=null;break;case "blur":gf=ff=ef=null;break;case "mousedown":hf=!0;break;case "contextmenu":case "mouseup":case "dragend":return hf=!1,jf(c,d);case "selectionchange":if(cf)break;
    case "keydown":case "keyup":return jf(c,d)}return null}},lf=G.extend({animationName:null,elapsedTime:null,pseudoElement:null}),mf=G.extend({clipboardData:function(a){return "clipboardData"in a?a.clipboardData:window.clipboardData}}),nf=Ne.extend({relatedTarget:null});function of(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}
    var pf={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},qf={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
    116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},rf=Ne.extend({key:function(a){if(a.key){var b=pf[a.key]||a.key;if("Unidentified"!==b)return b}return "keypress"===a.type?(a=of(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?qf[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Qe,charCode:function(a){return "keypress"===
    a.type?of(a):0},keyCode:function(a){return "keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return "keypress"===a.type?of(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),sf=Ve.extend({dataTransfer:null}),tf=Ne.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Qe}),uf=G.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),vf=Ve.extend({deltaX:function(a){return "deltaX"in a?a.deltaX:"wheelDeltaX"in
    a?-a.wheelDeltaX:0},deltaY:function(a){return "deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),wf={eventTypes:Wc,extractEvents:function(a,b,c,d){var e=Yc.get(a);if(!e)return null;switch(a){case "keypress":if(0===of(c))return null;case "keydown":case "keyup":a=rf;break;case "blur":case "focus":a=nf;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=
    Ve;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=sf;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=tf;break;case Xb:case Yb:case Zb:a=lf;break;case $b:a=uf;break;case "scroll":a=Ne;break;case "wheel":a=vf;break;case "copy":case "cut":case "paste":a=mf;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=
    We;break;default:a=G;}b=a.getPooled(e,b,c,d);Xd(b);return b}};if(pa)throw Error(u(101));pa=Array.prototype.slice.call("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));ra();var xf=Nc;la=Qd;ma=xf;na=Pd;xa({SimpleEventPlugin:wf,EnterLeaveEventPlugin:Ye,ChangeEventPlugin:Me,SelectEventPlugin:kf,BeforeInputEventPlugin:ve});var yf=[],zf=-1;function H(a){0>zf||(a.current=yf[zf],yf[zf]=null,zf--);}
    function I(a,b){zf++;yf[zf]=a.current;a.current=b;}var Af={},J={current:Af},K={current:!1},Bf=Af;function Cf(a,b){var c=a.type.contextTypes;if(!c)return Af;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function L(a){a=a.childContextTypes;return null!==a&&void 0!==a}
    function Df(){H(K);H(J);}function Ef(a,b,c){if(J.current!==Af)throw Error(u(168));I(J,b);I(K,c);}function Ff(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(u(108,pb(b)||"Unknown",e));return n({},c,{},d)}function Gf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Af;Bf=J.current;I(J,a);I(K,K.current);return !0}
    function Hf(a,b,c){var d=a.stateNode;if(!d)throw Error(u(169));c?(a=Ff(a,b,Bf),d.__reactInternalMemoizedMergedChildContext=a,H(K),H(J),I(J,a)):H(K);I(K,c);}
    var If=r.unstable_runWithPriority,Jf=r.unstable_scheduleCallback,Kf=r.unstable_cancelCallback,Lf=r.unstable_requestPaint,Mf=r.unstable_now,Nf=r.unstable_getCurrentPriorityLevel,Of=r.unstable_ImmediatePriority,Pf=r.unstable_UserBlockingPriority,Qf=r.unstable_NormalPriority,Rf=r.unstable_LowPriority,Sf=r.unstable_IdlePriority,Tf={},Uf=r.unstable_shouldYield,Vf=void 0!==Lf?Lf:function(){},Wf=null,Xf=null,Yf=!1,Zf=Mf(),$f=1E4>Zf?Mf:function(){return Mf()-Zf};
    function ag(){switch(Nf()){case Of:return 99;case Pf:return 98;case Qf:return 97;case Rf:return 96;case Sf:return 95;default:throw Error(u(332));}}function bg(a){switch(a){case 99:return Of;case 98:return Pf;case 97:return Qf;case 96:return Rf;case 95:return Sf;default:throw Error(u(332));}}function cg(a,b){a=bg(a);return If(a,b)}function dg(a,b,c){a=bg(a);return Jf(a,b,c)}function eg(a){null===Wf?(Wf=[a],Xf=Jf(Of,fg)):Wf.push(a);return Tf}function gg(){if(null!==Xf){var a=Xf;Xf=null;Kf(a);}fg();}
    function fg(){if(!Yf&&null!==Wf){Yf=!0;var a=0;try{var b=Wf;cg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});Wf=null;}catch(c){throw null!==Wf&&(Wf=Wf.slice(a+1)),Jf(Of,gg),c;}finally{Yf=!1;}}}function hg(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function ig(a,b){if(a&&a.defaultProps){b=n({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);}return b}var jg={current:null},kg=null,lg=null,mg=null;function ng(){mg=lg=kg=null;}
    function og(a){var b=jg.current;H(jg);a.type._context._currentValue=b;}function pg(a,b){for(;null!==a;){var c=a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return;}}function qg(a,b){kg=a;mg=lg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(rg=!0),a.firstContext=null);}
    function sg(a,b){if(mg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)mg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===lg){if(null===kg)throw Error(u(308));lg=b;kg.dependencies={expirationTime:0,firstContext:b,responders:null};}else lg=lg.next=b;}return a._currentValue}var tg=!1;function ug(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null};}
    function vg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects});}function wg(a,b){a={expirationTime:a,suspenseConfig:b,tag:0,payload:null,callback:null,next:null};return a.next=a}function xg(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b;}}
    function yg(a,b){var c=a.alternate;null!==c&&vg(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b);}
    function zg(a,b,c,d){var e=a.updateQueue;tg=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h;}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&(h.baseQueue=g));}if(null!==f){h=f.next;var k=e.baseState,l=0,m=null,p=null,x=null;if(null!==h){var z=h;do{g=z.expirationTime;if(g<d){var ca={expirationTime:z.expirationTime,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null};null===x?(p=x=
    ca,m=k):x=x.next=ca;g>l&&(l=g);}else {null!==x&&(x=x.next={expirationTime:1073741823,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null});Ag(g,z.suspenseConfig);a:{var D=a,t=z;g=b;ca=c;switch(t.tag){case 1:D=t.payload;if("function"===typeof D){k=D.call(ca,k,g);break a}k=D;break a;case 3:D.effectTag=D.effectTag&-4097|64;case 0:D=t.payload;g="function"===typeof D?D.call(ca,k,g):D;if(null===g||void 0===g)break a;k=n({},k,g);break a;case 2:tg=!0;}}null!==z.callback&&
    (a.effectTag|=32,g=e.effects,null===g?e.effects=[z]:g.push(z));}z=z.next;if(null===z||z===h)if(g=e.shared.pending,null===g)break;else z=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null;}while(1)}null===x?m=k:x.next=p;e.baseState=m;e.baseQueue=x;Bg(l);a.expirationTime=l;a.memoizedState=k;}}
    function Cg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(u(191,d));d.call(e);}}}var Dg=Wa.ReactCurrentBatchConfig,Eg=(new aa.Component).refs;function Fg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:n({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c);}
    var Jg={isMounted:function(a){return (a=a._reactInternalFiber)?dc(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d);},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d);},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=Gg(),d=Dg.suspense;
    c=Hg(c,a,d);d=wg(c,d);d.tag=2;void 0!==b&&null!==b&&(d.callback=b);xg(a,d);Ig(a,c);}};function Kg(a,b,c,d,e,f,g){a=a.stateNode;return "function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!bf(c,d)||!bf(e,f):!0}
    function Lg(a,b,c){var d=!1,e=Af;var f=b.contextType;"object"===typeof f&&null!==f?f=sg(f):(e=L(b)?Bf:J.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Cf(a,e):Af);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Jg;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
    function Mg(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Jg.enqueueReplaceState(b,b.state,null);}
    function Ng(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Eg;ug(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=sg(f):(f=L(b)?Bf:J.current,e.context=Cf(a,f));zg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Fg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||
    (b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Jg.enqueueReplaceState(e,e.state,null),zg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.effectTag|=4);}var Og=Array.isArray;
    function Pg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(u(309));var d=c.stateNode;}if(!d)throw Error(u(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Eg&&(b=d.refs={});null===a?delete b[e]:b[e]=a;};b._stringRef=e;return b}if("string"!==typeof a)throw Error(u(284));if(!c._owner)throw Error(u(290,a));}return a}
    function Qg(a,b){if("textarea"!==a.type)throw Error(u(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}
    function Rg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8;}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Sg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
    2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Tg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Pg(a,b,c),d.return=a,d;d=Ug(c.type,c.key,c.props,null,a.mode,d);d.ref=Pg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
    c.implementation)return b=Vg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Wg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function p(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Tg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Za:return c=Ug(b.type,b.key,b.props,null,a.mode,c),c.ref=Pg(a,null,b),c.return=a,c;case $a:return b=Vg(b,a.mode,c),b.return=a,b}if(Og(b)||
    nb(b))return b=Wg(b,a.mode,c,null),b.return=a,b;Qg(a,b);}return null}function x(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Za:return c.key===e?c.type===ab?m(a,b,c.props.children,d,e):k(a,b,c,d):null;case $a:return c.key===e?l(a,b,c,d):null}if(Og(c)||nb(c))return null!==e?null:m(a,b,c,d,null);Qg(a,c);}return null}function z(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=
    a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Za:return a=a.get(null===d.key?c:d.key)||null,d.type===ab?m(b,a,d.props.children,e,d.key):k(b,a,d,e);case $a:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Og(d)||nb(d))return a=a.get(c)||null,m(b,a,d,e,null);Qg(b,d);}return null}function ca(e,g,h,k){for(var l=null,t=null,m=g,y=g=0,A=null;null!==m&&y<h.length;y++){m.index>y?(A=m,m=null):A=m.sibling;var q=x(e,m,h[y],k);if(null===q){null===m&&(m=A);break}a&&
    m&&null===q.alternate&&b(e,m);g=f(q,g,y);null===t?l=q:t.sibling=q;t=q;m=A;}if(y===h.length)return c(e,m),l;if(null===m){for(;y<h.length;y++)m=p(e,h[y],k),null!==m&&(g=f(m,g,y),null===t?l=m:t.sibling=m,t=m);return l}for(m=d(e,m);y<h.length;y++)A=z(m,e,y,h[y],k),null!==A&&(a&&null!==A.alternate&&m.delete(null===A.key?y:A.key),g=f(A,g,y),null===t?l=A:t.sibling=A,t=A);a&&m.forEach(function(a){return b(e,a)});return l}function D(e,g,h,l){var k=nb(h);if("function"!==typeof k)throw Error(u(150));h=k.call(h);
    if(null==h)throw Error(u(151));for(var m=k=null,t=g,y=g=0,A=null,q=h.next();null!==t&&!q.done;y++,q=h.next()){t.index>y?(A=t,t=null):A=t.sibling;var D=x(e,t,q.value,l);if(null===D){null===t&&(t=A);break}a&&t&&null===D.alternate&&b(e,t);g=f(D,g,y);null===m?k=D:m.sibling=D;m=D;t=A;}if(q.done)return c(e,t),k;if(null===t){for(;!q.done;y++,q=h.next())q=p(e,q.value,l),null!==q&&(g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);return k}for(t=d(e,t);!q.done;y++,q=h.next())q=z(t,e,y,q.value,l),null!==q&&(a&&null!==
    q.alternate&&t.delete(null===q.key?y:q.key),g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);a&&t.forEach(function(a){return b(e,a)});return k}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ab&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case Za:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ab){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,
    k.sibling);d=e(k,f.props);d.ref=Pg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling;}f.type===ab?(d=Wg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Ug(f.type,f.key,f.props,null,a.mode,h),h.ref=Pg(a,d,f),h.return=a,a=h);}return g(a);case $a:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else {c(a,d);break}else b(a,d);d=
    d.sibling;}d=Vg(f,a.mode,h);d.return=a;a=d;}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Tg(f,a.mode,h),d.return=a,a=d),g(a);if(Og(f))return ca(a,d,f,h);if(nb(f))return D(a,d,f,h);l&&Qg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:throw a=a.type,Error(u(152,a.displayName||a.name||"Component"));}return c(a,d)}}var Xg=Rg(!0),Yg=Rg(!1),Zg={},$g={current:Zg},ah={current:Zg},bh={current:Zg};
    function ch(a){if(a===Zg)throw Error(u(174));return a}function dh(a,b){I(bh,b);I(ah,a);I($g,Zg);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Ob(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Ob(b,a);}H($g);I($g,b);}function eh(){H($g);H(ah);H(bh);}function fh(a){ch(bh.current);var b=ch($g.current);var c=Ob(b,a.type);b!==c&&(I(ah,a),I($g,c));}function gh(a){ah.current===a&&(H($g),H(ah));}var M={current:0};
    function hh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===Bd||c.data===Cd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return;}b.sibling.return=b.return;b=b.sibling;}return null}function ih(a,b){return {responder:a,props:b}}
    var jh=Wa.ReactCurrentDispatcher,kh=Wa.ReactCurrentBatchConfig,lh=0,N=null,O=null,P=null,mh=!1;function Q(){throw Error(u(321));}function nh(a,b){if(null===b)return !1;for(var c=0;c<b.length&&c<a.length;c++)if(!$e(a[c],b[c]))return !1;return !0}
    function oh(a,b,c,d,e,f){lh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;jh.current=null===a||null===a.memoizedState?ph:qh;a=c(d,e);if(b.expirationTime===lh){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(u(301));f+=1;P=O=null;b.updateQueue=null;jh.current=rh;a=c(d,e);}while(b.expirationTime===lh)}jh.current=sh;b=null!==O&&null!==O.next;lh=0;P=O=N=null;mh=!1;if(b)throw Error(u(300));return a}
    function th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function uh(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null;}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else {if(null===a)throw Error(u(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a;}return P}
    function vh(a,b){return "function"===typeof b?b(a):b}
    function wh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g;}d.baseQueue=e=f;c.pending=null;}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.expirationTime;if(l<lh){var m={expirationTime:k.expirationTime,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null};null===h?(g=h=m,f=d):h=h.next=m;l>N.expirationTime&&
    (N.expirationTime=l,Bg(l));}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),Ag(l,k.suspenseConfig),d=k.eagerReducer===a?k.eagerState:a(d,k.action);k=k.next;}while(null!==k&&k!==e);null===h?f=d:h.next=g;$e(d,b.memoizedState)||(rg=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d;}return [b.memoizedState,c.dispatch]}
    function xh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);$e(f,b.memoizedState)||(rg=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f;}return [f,d]}
    function yh(a){var b=th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:vh,lastRenderedState:a};a=a.dispatch=zh.bind(null,N,a);return [b.memoizedState,a]}function Ah(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}
    function Bh(){return uh().memoizedState}function Ch(a,b,c,d){var e=th();N.effectTag|=a;e.memoizedState=Ah(1|b,c,void 0,void 0===d?null:d);}function Dh(a,b,c,d){var e=uh();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&nh(d,g.deps)){Ah(b,c,f,d);return}}N.effectTag|=a;e.memoizedState=Ah(1|b,c,f,d);}function Eh(a,b){return Ch(516,4,a,b)}function Fh(a,b){return Dh(516,4,a,b)}function Gh(a,b){return Dh(4,2,a,b)}
    function Hh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null);};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null;}}function Ih(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Dh(4,2,Hh.bind(null,b,a),c)}function Jh(){}function Kh(a,b){th().memoizedState=[a,void 0===b?null:b];return a}function Lh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
    function Mh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Nh(a,b,c){var d=ag();cg(98>d?98:d,function(){a(!0);});cg(97<d?97:d,function(){var d=kh.suspense;kh.suspense=void 0===b?null:b;try{a(!1),c();}finally{kh.suspense=d;}});}
    function zh(a,b,c){var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===N||null!==f&&f===N)mh=!0,e.expirationTime=lh,N.expirationTime=lh;else {if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.eagerReducer=f;e.eagerState=h;if($e(h,g))return}catch(k){}finally{}Ig(a,
    d);}}
    var sh={readContext:sg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useResponder:Q,useDeferredValue:Q,useTransition:Q},ph={readContext:sg,useCallback:Kh,useContext:sg,useEffect:Eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Ch(4,2,Hh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Ch(4,2,a,b)},useMemo:function(a,b){var c=th();b=void 0===b?null:b;a=a();c.memoizedState=[a,
    b];return a},useReducer:function(a,b,c){var d=th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=zh.bind(null,N,a);return [d.memoizedState,a]},useRef:function(a){var b=th();a={current:a};return b.memoizedState=a},useState:yh,useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=yh(a),d=c[0],e=c[1];Eh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a);}finally{kh.suspense=
    c;}},[a,b]);return d},useTransition:function(a){var b=yh(!1),c=b[0];b=b[1];return [Kh(Nh.bind(null,b,a),[b,a]),c]}},qh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:wh,useRef:Bh,useState:function(){return wh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=wh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a);}finally{kh.suspense=c;}},[a,b]);return d},useTransition:function(a){var b=
    wh(vh),c=b[0];b=b[1];return [Lh(Nh.bind(null,b,a),[b,a]),c]}},rh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:xh,useRef:Bh,useState:function(){return xh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=xh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a);}finally{kh.suspense=c;}},[a,b]);return d},useTransition:function(a){var b=xh(vh),c=b[0];b=b[1];return [Lh(Nh.bind(null,
    b,a),[b,a]),c]}},Oh=null,Ph=null,Qh=!1;function Rh(a,b){var c=Sh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c;}
    function Th(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return !1;default:return !1}}
    function Uh(a){if(Qh){var b=Ph;if(b){var c=b;if(!Th(a,b)){b=Jd(c.nextSibling);if(!b||!Th(a,b)){a.effectTag=a.effectTag&-1025|2;Qh=!1;Oh=a;return}Rh(Oh,c);}Oh=a;Ph=Jd(b.firstChild);}else a.effectTag=a.effectTag&-1025|2,Qh=!1,Oh=a;}}function Vh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;Oh=a;}
    function Wh(a){if(a!==Oh)return !1;if(!Qh)return Vh(a),Qh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!Gd(b,a.memoizedProps))for(b=Ph;b;)Rh(a,b),b=Jd(b.nextSibling);Vh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(u(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===Ad){if(0===b){Ph=Jd(a.nextSibling);break a}b--;}else c!==zd&&c!==Cd&&c!==Bd||b++;}a=a.nextSibling;}Ph=null;}}else Ph=Oh?Jd(a.stateNode.nextSibling):null;return !0}
    function Xh(){Ph=Oh=null;Qh=!1;}var Yh=Wa.ReactCurrentOwner,rg=!1;function R(a,b,c,d){b.child=null===a?Yg(b,null,c,d):Xg(b,a.child,c,d);}function Zh(a,b,c,d,e){c=c.render;var f=b.ref;qg(b,e);d=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R(a,b,d,e);return b.child}
    function ai(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!bi(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ci(a,b,g,d,e,f);a=Ug(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:bf,c(e,d)&&a.ref===b.ref))return $h(a,b,f);b.effectTag|=1;a=Sg(g,d);a.ref=b.ref;a.return=b;return b.child=a}
    function ci(a,b,c,d,e,f){return null!==a&&bf(a.memoizedProps,d)&&a.ref===b.ref&&(rg=!1,e<f)?(b.expirationTime=a.expirationTime,$h(a,b,f)):di(a,b,c,d,f)}function ei(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128;}function di(a,b,c,d,e){var f=L(c)?Bf:J.current;f=Cf(b,f);qg(b,e);c=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R(a,b,c,e);return b.child}
    function fi(a,b,c,d,e){if(L(c)){var f=!0;Gf(b);}else f=!1;qg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Lg(b,c,d),Ng(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=sg(l):(l=L(c)?Bf:J.current,l=Cf(b,l));var m=c.getDerivedStateFromProps,p="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;p||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
    "function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l);tg=!1;var x=b.memoizedState;g.state=x;zg(b,d,g,e);k=b.memoizedState;h!==d||x!==k||K.current||tg?("function"===typeof m&&(Fg(b,c,m,d),k=b.memoizedState),(h=tg||Kg(b,c,h,d,x,k,l))?(p||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===
    typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1);}else g=b.stateNode,vg(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:ig(b.type,h),k=g.context,l=c.contextType,"object"===typeof l&&null!==l?l=sg(l):(l=L(c)?Bf:J.current,l=Cf(b,l)),m=c.getDerivedStateFromProps,(p="function"===typeof m||"function"===
    typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l),tg=!1,k=b.memoizedState,g.state=k,zg(b,d,g,e),x=b.memoizedState,h!==d||k!==x||K.current||tg?("function"===typeof m&&(Fg(b,c,m,d),x=b.memoizedState),(m=tg||Kg(b,c,h,d,k,x,l))?(p||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,
    x,l),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,l)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=l,d=m):
    ("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),d=!1);return gi(a,b,c,d,f,e)}
    function gi(a,b,c,d,e,f){ei(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hf(b,c,!1),$h(a,b,f);d=b.stateNode;Yh.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=Xg(b,a.child,null,f),b.child=Xg(b,null,h,f)):R(a,b,h,f);b.memoizedState=d.state;e&&Hf(b,c,!0);return b.child}function hi(a){var b=a.stateNode;b.pendingContext?Ef(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Ef(a,b.context,!1);dh(a,b.containerInfo);}
    var ii={dehydrated:null,retryTime:0};
    function ji(a,b,c){var d=b.mode,e=b.pendingProps,f=M.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);I(M,f&1);if(null===a){void 0!==e.fallback&&Uh(b);if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=
    b;e.sibling=c;b.memoizedState=ii;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Yg(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;c=Sg(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sg(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=ii;b.child=c;return d}c=Xg(b,a.child,e.children,c);b.memoizedState=null;return b.child=
    c}a=a.child;if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=ii;b.child=e;return c}b.memoizedState=null;return b.child=Xg(b,a,e.children,c)}
    function ki(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);pg(a.return,b);}function li(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f);}
    function mi(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;R(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else {if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&ki(a,c);else if(19===a.tag)ki(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return;}a.sibling.return=a.return;a=a.sibling;}d&=1;}I(M,d);if(0===(b.mode&2))b.memoizedState=
    null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===hh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);li(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===hh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a;}li(b,!0,c,null,f,b.lastEffect);break;case "together":li(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null;}return b.child}
    function $h(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Bg(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(u(153));if(null!==b.child){a=b.child;c=Sg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sg(a,a.pendingProps),c.return=b;c.sibling=null;}return b.child}var ni,oi,pi,qi;
    ni=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;}c.sibling.return=c.return;c=c.sibling;}};oi=function(){};
    pi=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;ch($g.current);a=null;switch(c){case "input":f=zb(g,f);d=zb(g,d);a=[];break;case "option":f=Gb(g,f);d=Gb(g,d);a=[];break;case "select":f=n({},f,{value:void 0});d=n({},d,{value:void 0});a=[];break;case "textarea":f=Ib(g,f);d=Ib(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=sd);}od(c,d);var h,k;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===
    h)for(k in g=f[h],g)g.hasOwnProperty(k)&&(c||(c={}),c[k]="");else "dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(va.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var l=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&l!==g&&(null!=l||null!=g))if("style"===h)if(g){for(k in g)!g.hasOwnProperty(k)||l&&l.hasOwnProperty(k)||(c||(c={}),c[k]="");for(k in l)l.hasOwnProperty(k)&&g[k]!==l[k]&&(c||(c={}),
    c[k]=l[k]);}else c||(a||(a=[]),a.push(h,c)),c=l;else "dangerouslySetInnerHTML"===h?(l=l?l.__html:void 0,g=g?g.__html:void 0,null!=l&&g!==l&&(a=a||[]).push(h,l)):"children"===h?g===l||"string"!==typeof l&&"number"!==typeof l||(a=a||[]).push(h,""+l):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(va.hasOwnProperty(h)?(null!=l&&rd(e,h),a||g===l||(a=[])):(a=a||[]).push(h,l));}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4;}};
    qi=function(a,b,c,d){c!==d&&(b.effectTag|=4);};function ri(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null;}}
    function si(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return L(b.type)&&Df(),null;case 3:return eh(),H(K),H(J),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Wh(b)||(b.effectTag|=4),oi(b),null;case 5:gh(b);c=ch(bh.current);var e=b.type;if(null!==a&&null!=b.stateNode)pi(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else {if(!d){if(null===b.stateNode)throw Error(u(166));
    return null}a=ch($g.current);if(Wh(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Md]=b;d[Nd]=f;switch(e){case "iframe":case "object":case "embed":F("load",d);break;case "video":case "audio":for(a=0;a<ac.length;a++)F(ac[a],d);break;case "source":F("error",d);break;case "img":case "image":case "link":F("error",d);F("load",d);break;case "form":F("reset",d);F("submit",d);break;case "details":F("toggle",d);break;case "input":Ab(d,f);F("invalid",d);rd(c,"onChange");break;case "select":d._wrapperState=
    {wasMultiple:!!f.multiple};F("invalid",d);rd(c,"onChange");break;case "textarea":Jb(d,f),F("invalid",d),rd(c,"onChange");}od(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):va.hasOwnProperty(g)&&null!=h&&rd(c,g);}switch(e){case "input":xb(d);Eb(d,f,!0);break;case "textarea":xb(d);Lb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&
    (d.onclick=sd);}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4);}else {g=9===c.nodeType?c:c.ownerDocument;a===qd&&(a=Nb(e));a===qd?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Md]=b;a[Nd]=d;ni(a,b,!1,!1);b.stateNode=a;g=pd(e,d);switch(e){case "iframe":case "object":case "embed":F("load",
    a);h=d;break;case "video":case "audio":for(h=0;h<ac.length;h++)F(ac[h],a);h=d;break;case "source":F("error",a);h=d;break;case "img":case "image":case "link":F("error",a);F("load",a);h=d;break;case "form":F("reset",a);F("submit",a);h=d;break;case "details":F("toggle",a);h=d;break;case "input":Ab(a,d);h=zb(a,d);F("invalid",a);rd(c,"onChange");break;case "option":h=Gb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=n({},d,{value:void 0});F("invalid",a);rd(c,"onChange");break;case "textarea":Jb(a,
    d);h=Ib(a,d);F("invalid",a);rd(c,"onChange");break;default:h=d;}od(e,h);var k=h;for(f in k)if(k.hasOwnProperty(f)){var l=k[f];"style"===f?md(a,l):"dangerouslySetInnerHTML"===f?(l=l?l.__html:void 0,null!=l&&Qb(a,l)):"children"===f?"string"===typeof l?("textarea"!==e||""!==l)&&Rb(a,l):"number"===typeof l&&Rb(a,""+l):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(va.hasOwnProperty(f)?null!=l&&rd(c,f):null!=l&&Xa(a,f,l,g));}switch(e){case "input":xb(a);Eb(a,d,!1);
    break;case "textarea":xb(a);Lb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+rb(d.value));break;case "select":a.multiple=!!d.multiple;c=d.value;null!=c?Hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&Hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=sd);}Fd(e,d)&&(b.effectTag|=4);}null!==b.ref&&(b.effectTag|=128);}return null;case 6:if(a&&null!=b.stateNode)qi(a,b,a.memoizedProps,d);else {if("string"!==typeof d&&null===b.stateNode)throw Error(u(166));
    c=ch(bh.current);ch($g.current);Wh(b)?(c=b.stateNode,d=b.memoizedProps,c[Md]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),c[Md]=b,b.stateNode=c);}return null;case 13:H(M);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Wh(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=
    e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(M.current&1))S===ti&&(S=ui);else {if(S===ti||S===ui)S=vi;0!==wi&&null!==T&&(xi(T,U),yi(T,wi));}if(c||d)b.effectTag|=4;return null;case 4:return eh(),oi(b),null;case 10:return og(b),null;case 17:return L(b.type)&&Df(),null;case 19:H(M);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)ri(d,!1);else {if(S!==ti||null!==a&&0!==(a.effectTag&
    64))for(f=b.child;null!==f;){a=hh(f);if(null!==a){b.effectTag|=64;ri(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,
    e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;I(M,M.current&1|2);return b.child}f=f.sibling;}}else {if(!e)if(a=hh(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),ri(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=
    b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*$f()-d.renderingStartTime>d.tailExpiration&&1<c&&(b.effectTag|=64,e=!0,ri(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f);}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=$f()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=$f(),c.sibling=null,b=M.current,I(M,e?b&1|2:b&1),c):null}throw Error(u(156,
    b.tag));}function zi(a){switch(a.tag){case 1:L(a.type)&&Df();var b=a.effectTag;return b&4096?(a.effectTag=b&-4097|64,a):null;case 3:eh();H(K);H(J);b=a.effectTag;if(0!==(b&64))throw Error(u(285));a.effectTag=b&-4097|64;return a;case 5:return gh(a),null;case 13:return H(M),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return H(M),null;case 4:return eh(),null;case 10:return og(a),null;default:return null}}function Ai(a,b){return {value:a,source:b,stack:qb(b)}}
    var Bi="function"===typeof WeakSet?WeakSet:Set;function Ci(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=qb(c));null!==c&&pb(c.type);b=b.value;null!==a&&1===a.tag&&pb(a.type);try{console.error(b);}catch(e){setTimeout(function(){throw e;});}}function Di(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount();}catch(c){Ei(a,c);}}function Fi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null);}catch(c){Ei(a,c);}else b.current=null;}
    function Gi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:ig(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b;}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(u(163));}
    function Hi(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d();}c=c.next;}while(c!==b)}}function Ii(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d();}c=c.next;}while(c!==b)}}
    function Ji(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:Ii(3,c);return;case 1:a=c.stateNode;if(c.effectTag&4)if(null===b)a.componentDidMount();else {var d=c.elementType===c.type?b.memoizedProps:ig(c.type,b.memoizedProps);a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate);}b=c.updateQueue;null!==b&&Cg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode;}Cg(c,b,a);}return;
    case 5:a=c.stateNode;null===b&&c.effectTag&4&&Fd(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Vc(c))));return;case 19:case 17:case 20:case 21:return}throw Error(u(163));}
    function Ki(a,b,c){"function"===typeof Li&&Li(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;cg(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c();}catch(h){Ei(g,h);}}a=a.next;}while(a!==d)});}break;case 1:Fi(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&Di(b,c);break;case 5:Fi(b);break;case 4:Mi(a,b,c);}}
    function Ni(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Ni(b);}function Oi(a){return 5===a.tag||3===a.tag||4===a.tag}
    function Pi(a){a:{for(var b=a.return;null!==b;){if(Oi(b)){var c=b;break a}b=b.return;}throw Error(u(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(u(161));}c.effectTag&16&&(Rb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Oi(c.return)){c=null;break a}c=c.return;}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;
    if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child;}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Qi(a,c,b):Ri(a,c,b);}
    function Qi(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=sd));else if(4!==d&&(a=a.child,null!==a))for(Qi(a,b,c),a=a.sibling;null!==a;)Qi(a,b,c),a=a.sibling;}
    function Ri(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Ri(a,b,c),a=a.sibling;null!==a;)Ri(a,b,c),a=a.sibling;}
    function Mi(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(u(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return;}e=!0;}if(5===d.tag||6===d.tag){a:for(var h=a,k=d,l=c,m=k;;)if(Ki(h,m,l),null!==m.child&&4!==m.tag)m.child.return=m,m=m.child;else {if(m===k)break a;for(;null===m.sibling;){if(null===m.return||m.return===k)break a;m=m.return;}m.sibling.return=m.return;m=m.sibling;}g?(h=
    f,k=d.stateNode,8===h.nodeType?h.parentNode.removeChild(k):h.removeChild(k)):f.removeChild(d.stateNode);}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ki(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1);}d.sibling.return=d.return;d=d.sibling;}}
    function Si(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Hi(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[Nd]=d;"input"===a&&"radio"===d.type&&null!=d.name&&Bb(c,d);pd(a,e);b=pd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],h=f[e+1];"style"===g?md(c,h):"dangerouslySetInnerHTML"===g?Qb(c,h):"children"===g?Rb(c,h):Xa(c,g,h,b);}switch(a){case "input":Cb(c,d);break;
    case "textarea":Kb(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?Hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?Hb(c,!!d.multiple,d.defaultValue,!0):Hb(c,!!d.multiple,d.multiple?[]:"",!1));}}}return;case 6:if(null===b.stateNode)throw Error(u(162));b.stateNode.nodeValue=b.memoizedProps;return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,Vc(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?
    d=!1:(d=!0,c=b.child,Ti=$f());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=ld("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=
    f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return;}a.sibling.return=a.return;a=a.sibling;}Ui(b);return;case 19:Ui(b);return;case 17:return}throw Error(u(163));}function Ui(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Bi);b.forEach(function(b){var d=Vi.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d));});}}
    var Wi="function"===typeof WeakMap?WeakMap:Map;function Xi(a,b,c){c=wg(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Yi||(Yi=!0,Zi=d);Ci(a,b);};return c}
    function $i(a,b,c){c=wg(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ci(a,b);return d(e)};}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===aj?aj=new Set([this]):aj.add(this),Ci(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""});});return c}
    var bj=Math.ceil,cj=Wa.ReactCurrentDispatcher,dj=Wa.ReactCurrentOwner,V=0,ej=8,fj=16,gj=32,ti=0,hj=1,ij=2,ui=3,vi=4,jj=5,W=V,T=null,X=null,U=0,S=ti,kj=null,lj=1073741823,mj=1073741823,nj=null,wi=0,oj=!1,Ti=0,pj=500,Y=null,Yi=!1,Zi=null,aj=null,qj=!1,rj=null,sj=90,tj=null,uj=0,vj=null,wj=0;function Gg(){return (W&(fj|gj))!==V?1073741821-($f()/10|0):0!==wj?wj:wj=1073741821-($f()/10|0)}
    function Hg(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=ag();if(0===(b&4))return 99===d?1073741823:1073741822;if((W&fj)!==V)return U;if(null!==c)a=hg(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=hg(a,150,100);break;case 97:case 96:a=hg(a,5E3,250);break;case 95:a=2;break;default:throw Error(u(326));}null!==T&&a===U&&--a;return a}
    function Ig(a,b){if(50<uj)throw uj=0,vj=null,Error(u(185));a=xj(a,b);if(null!==a){var c=ag();1073741823===b?(W&ej)!==V&&(W&(fj|gj))===V?yj(a):(Z(a),W===V&&gg()):Z(a);(W&4)===V||98!==c&&99!==c||(null===tj?tj=new Map([[a,b]]):(c=tj.get(a),(void 0===c||c>b)&&tj.set(a,b)));}}
    function xj(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return;}null!==e&&(T===e&&(Bg(b),S===vi&&xi(e,U)),yi(e,b));return e}
    function zj(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Aj(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}
    function Z(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=eg(yj.bind(null,a));else {var b=zj(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else {var d=Gg();1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Tf&&Kf(c);}a.callbackExpirationTime=
    b;a.callbackPriority=d;b=1073741823===b?eg(yj.bind(null,a)):dg(d,Bj.bind(null,a),{timeout:10*(1073741821-b)-$f()});a.callbackNode=b;}}}
    function Bj(a,b){wj=0;if(b)return b=Gg(),Cj(a,b),Z(a),null;var c=zj(a);if(0!==c){b=a.callbackNode;if((W&(fj|gj))!==V)throw Error(u(327));Dj();a===T&&c===U||Ej(a,c);if(null!==X){var d=W;W|=fj;var e=Fj();do try{Gj();break}catch(h){Hj(a,h);}while(1);ng();W=d;cj.current=e;if(S===hj)throw b=kj,Ej(a,c),xi(a,c),Z(a),b;if(null===X)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=S,T=null,d){case ti:case hj:throw Error(u(345));case ij:Cj(a,2<c?2:c);break;case ui:xi(a,c);d=a.lastSuspendedTime;
    c===d&&(a.nextKnownPendingLevel=Ij(e));if(1073741823===lj&&(e=Ti+pj-$f(),10<e)){if(oj){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=c;Ej(a,c);break}}f=zj(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=Hd(Jj.bind(null,a),e);break}Jj(a);break;case vi:xi(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ij(e));if(oj&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;Ej(a,c);break}e=zj(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=
    d;break}1073741823!==mj?d=10*(1073741821-mj)-$f():1073741823===lj?d=0:(d=10*(1073741821-lj)-5E3,e=$f(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*bj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=Hd(Jj.bind(null,a),d);break}Jj(a);break;case jj:if(1073741823!==lj&&null!==nj){f=lj;var g=nj;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=$f()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){xi(a,c);a.timeoutHandle=
    Hd(Jj.bind(null,a),d);break}}Jj(a);break;default:throw Error(u(329));}Z(a);if(a.callbackNode===b)return Bj.bind(null,a)}}return null}
    function yj(a){var b=a.lastExpiredTime;b=0!==b?b:1073741823;if((W&(fj|gj))!==V)throw Error(u(327));Dj();a===T&&b===U||Ej(a,b);if(null!==X){var c=W;W|=fj;var d=Fj();do try{Kj();break}catch(e){Hj(a,e);}while(1);ng();W=c;cj.current=d;if(S===hj)throw c=kj,Ej(a,b),xi(a,b),Z(a),c;if(null!==X)throw Error(u(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;T=null;Jj(a);Z(a);}return null}function Lj(){if(null!==tj){var a=tj;tj=null;a.forEach(function(a,c){Cj(c,a);Z(c);});gg();}}
    function Mj(a,b){var c=W;W|=1;try{return a(b)}finally{W=c,W===V&&gg();}}function Nj(a,b){var c=W;W&=-2;W|=ej;try{return a(b)}finally{W=c,W===V&&gg();}}
    function Ej(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Id(c));if(null!==X)for(c=X.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Df();break;case 3:eh();H(K);H(J);break;case 5:gh(d);break;case 4:eh();break;case 13:H(M);break;case 19:H(M);break;case 10:og(d);}c=c.return;}T=a;X=Sg(a.current,null);U=b;S=ti;kj=null;mj=lj=1073741823;nj=null;wi=0;oj=!1;}
    function Hj(a,b){do{try{ng();jh.current=sh;if(mh)for(var c=N.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next;}lh=0;P=O=N=null;mh=!1;if(null===X||null===X.return)return S=hj,kj=b,X=null;a:{var e=a,f=X.return,g=X,h=b;b=U;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var k=h;if(0===(g.mode&2)){var l=g.alternate;l?(g.updateQueue=l.updateQueue,g.memoizedState=l.memoizedState,g.expirationTime=l.expirationTime):(g.updateQueue=
    null,g.memoizedState=null);}var m=0!==(M.current&1),p=f;do{var x;if(x=13===p.tag){var z=p.memoizedState;if(null!==z)x=null!==z.dehydrated?!0:!1;else {var ca=p.memoizedProps;x=void 0===ca.fallback?!1:!0!==ca.unstable_avoidThisFallback?!0:m?!1:!0;}}if(x){var D=p.updateQueue;if(null===D){var t=new Set;t.add(k);p.updateQueue=t;}else D.add(k);if(0===(p.mode&2)){p.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else {var y=wg(1073741823,null);y.tag=2;xg(g,y);}g.expirationTime=1073741823;
    break a}h=void 0;g=b;var A=e.pingCache;null===A?(A=e.pingCache=new Wi,h=new Set,A.set(k,h)):(h=A.get(k),void 0===h&&(h=new Set,A.set(k,h)));if(!h.has(g)){h.add(g);var q=Oj.bind(null,e,k,g);k.then(q,q);}p.effectTag|=4096;p.expirationTime=b;break a}p=p.return;}while(null!==p);h=Error((pb(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+qb(g));}S!==
    jj&&(S=ij);h=Ai(h,g);p=f;do{switch(p.tag){case 3:k=h;p.effectTag|=4096;p.expirationTime=b;var B=Xi(p,k,b);yg(p,B);break a;case 1:k=h;var w=p.type,ub=p.stateNode;if(0===(p.effectTag&64)&&("function"===typeof w.getDerivedStateFromError||null!==ub&&"function"===typeof ub.componentDidCatch&&(null===aj||!aj.has(ub)))){p.effectTag|=4096;p.expirationTime=b;var vb=$i(p,k,b);yg(p,vb);break a}}p=p.return;}while(null!==p)}X=Pj(X);}catch(Xc){b=Xc;continue}break}while(1)}
    function Fj(){var a=cj.current;cj.current=sh;return null===a?sh:a}function Ag(a,b){a<lj&&2<a&&(lj=a);null!==b&&a<mj&&2<a&&(mj=a,nj=b);}function Bg(a){a>wi&&(wi=a);}function Kj(){for(;null!==X;)X=Qj(X);}function Gj(){for(;null!==X&&!Uf();)X=Qj(X);}function Qj(a){var b=Rj(a.alternate,a,U);a.memoizedProps=a.pendingProps;null===b&&(b=Pj(a));dj.current=null;return b}
    function Pj(a){X=a;do{var b=X.alternate;a=X.return;if(0===(X.effectTag&2048)){b=si(b,X,U);if(1===U||1!==X.childExpirationTime){for(var c=0,d=X.child;null!==d;){var e=d.expirationTime,f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling;}X.childExpirationTime=c;}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=X.firstEffect),null!==X.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=X.firstEffect),a.lastEffect=X.lastEffect),1<X.effectTag&&(null!==
    a.lastEffect?a.lastEffect.nextEffect=X:a.firstEffect=X,a.lastEffect=X));}else {b=zi(X);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=2048);}b=X.sibling;if(null!==b)return b;X=a;}while(null!==X);S===ti&&(S=jj);return null}function Ij(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function Jj(a){var b=ag();cg(99,Sj.bind(null,a,b));return null}
    function Sj(a,b){do Dj();while(null!==rj);if((W&(fj|gj))!==V)throw Error(u(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(u(177));a.callbackNode=null;a.callbackExpirationTime=0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ij(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=
    d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===T&&(X=T=null,U=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=W;W|=gj;dj.current=null;Dd=fd;var g=xd();if(yd(g)){if("selectionStart"in g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var k=h.getSelection&&h.getSelection();if(k&&0!==k.rangeCount){h=k.anchorNode;var l=k.anchorOffset,
    m=k.focusNode;k=k.focusOffset;try{h.nodeType,m.nodeType;}catch(wb){h=null;break a}var p=0,x=-1,z=-1,ca=0,D=0,t=g,y=null;b:for(;;){for(var A;;){t!==h||0!==l&&3!==t.nodeType||(x=p+l);t!==m||0!==k&&3!==t.nodeType||(z=p+k);3===t.nodeType&&(p+=t.nodeValue.length);if(null===(A=t.firstChild))break;y=t;t=A;}for(;;){if(t===g)break b;y===h&&++ca===l&&(x=p);y===m&&++D===k&&(z=p);if(null!==(A=t.nextSibling))break;t=y;y=t.parentNode;}t=A;}h=-1===x||-1===z?null:{start:x,end:z};}else h=null;}h=h||{start:0,end:0};}else h=
    null;Ed={activeElementDetached:null,focusedElem:g,selectionRange:h};fd=!1;Y=e;do try{Tj();}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect;}while(null!==Y);Y=e;do try{for(g=a,h=b;null!==Y;){var q=Y.effectTag;q&16&&Rb(Y.stateNode,"");if(q&128){var B=Y.alternate;if(null!==B){var w=B.ref;null!==w&&("function"===typeof w?w(null):w.current=null);}}switch(q&1038){case 2:Pi(Y);Y.effectTag&=-3;break;case 6:Pi(Y);Y.effectTag&=-3;Si(Y.alternate,Y);break;case 1024:Y.effectTag&=-1025;break;case 1028:Y.effectTag&=
    -1025;Si(Y.alternate,Y);break;case 4:Si(Y.alternate,Y);break;case 8:l=Y,Mi(g,l,h),Ni(l);}Y=Y.nextEffect;}}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect;}while(null!==Y);w=Ed;B=xd();q=w.focusedElem;h=w.selectionRange;if(B!==q&&q&&q.ownerDocument&&wd(q.ownerDocument.documentElement,q)){null!==h&&yd(q)&&(B=h.start,w=h.end,void 0===w&&(w=B),"selectionStart"in q?(q.selectionStart=B,q.selectionEnd=Math.min(w,q.value.length)):(w=(B=q.ownerDocument||document)&&B.defaultView||window,w.getSelection&&
    (w=w.getSelection(),l=q.textContent.length,g=Math.min(h.start,l),h=void 0===h.end?g:Math.min(h.end,l),!w.extend&&g>h&&(l=h,h=g,g=l),l=vd(q,g),m=vd(q,h),l&&m&&(1!==w.rangeCount||w.anchorNode!==l.node||w.anchorOffset!==l.offset||w.focusNode!==m.node||w.focusOffset!==m.offset)&&(B=B.createRange(),B.setStart(l.node,l.offset),w.removeAllRanges(),g>h?(w.addRange(B),w.extend(m.node,m.offset)):(B.setEnd(m.node,m.offset),w.addRange(B))))));B=[];for(w=q;w=w.parentNode;)1===w.nodeType&&B.push({element:w,left:w.scrollLeft,
    top:w.scrollTop});"function"===typeof q.focus&&q.focus();for(q=0;q<B.length;q++)w=B[q],w.element.scrollLeft=w.left,w.element.scrollTop=w.top;}fd=!!Dd;Ed=Dd=null;a.current=c;Y=e;do try{for(q=a;null!==Y;){var ub=Y.effectTag;ub&36&&Ji(q,Y.alternate,Y);if(ub&128){B=void 0;var vb=Y.ref;if(null!==vb){var Xc=Y.stateNode;switch(Y.tag){case 5:B=Xc;break;default:B=Xc;}"function"===typeof vb?vb(B):vb.current=B;}}Y=Y.nextEffect;}}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect;}while(null!==Y);Y=
    null;Vf();W=f;}else a.current=c;if(qj)qj=!1,rj=a,sj=b;else for(Y=e;null!==Y;)b=Y.nextEffect,Y.nextEffect=null,Y=b;b=a.firstPendingTime;0===b&&(aj=null);1073741823===b?a===vj?uj++:(uj=0,vj=a):uj=0;"function"===typeof Uj&&Uj(c.stateNode,d);Z(a);if(Yi)throw Yi=!1,a=Zi,Zi=null,a;if((W&ej)!==V)return null;gg();return null}function Tj(){for(;null!==Y;){var a=Y.effectTag;0!==(a&256)&&Gi(Y.alternate,Y);0===(a&512)||qj||(qj=!0,dg(97,function(){Dj();return null}));Y=Y.nextEffect;}}
    function Dj(){if(90!==sj){var a=97<sj?97:sj;sj=90;return cg(a,Vj)}}function Vj(){if(null===rj)return !1;var a=rj;rj=null;if((W&(fj|gj))!==V)throw Error(u(331));var b=W;W|=gj;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Hi(5,c),Ii(5,c);}}catch(d){if(null===a)throw Error(u(330));Ei(a,d);}c=a.nextEffect;a.nextEffect=null;a=c;}W=b;gg();return !0}
    function Wj(a,b,c){b=Ai(c,b);b=Xi(a,b,1073741823);xg(a,b);a=xj(a,1073741823);null!==a&&Z(a);}function Ei(a,b){if(3===a.tag)Wj(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Wj(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===aj||!aj.has(d))){a=Ai(b,a);a=$i(c,a,1073741823);xg(c,a);c=xj(c,1073741823);null!==c&&Z(c);break}}c=c.return;}}
    function Oj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);T===a&&U===c?S===vi||S===ui&&1073741823===lj&&$f()-Ti<pj?Ej(a,U):oj=!0:Aj(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,Z(a)));}function Vi(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=Gg(),b=Hg(b,a,null));a=xj(a,b);null!==a&&Z(a);}var Rj;
    Rj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||K.current)rg=!0;else {if(d<c){rg=!1;switch(b.tag){case 3:hi(b);Xh();break;case 5:fh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:L(b.type)&&Gf(b);break;case 4:dh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;I(jg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
    if(0!==d&&d>=c)return ji(a,b,c);I(M,M.current&1);b=$h(a,b,c);return null!==b?b.sibling:null}I(M,M.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return mi(a,b,c);b.effectTag|=64;}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);I(M,M.current);if(!d)return null}return $h(a,b,c)}rg=!1;}}else rg=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Cf(b,J.current);qg(b,c);e=oh(null,
    b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(L(d)){var f=!0;Gf(b);}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ug(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Fg(b,d,g,a);e.updater=Jg;b.stateNode=e;e._reactInternalFiber=b;Ng(b,d,a,c);b=gi(null,b,d,!0,f,c);}else b.tag=0,R(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
    null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ob(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Xj(e);a=ig(e,a);switch(f){case 0:b=di(null,b,e,a,c);break a;case 1:b=fi(null,b,e,a,c);break a;case 11:b=Zh(null,b,e,a,c);break a;case 14:b=ai(null,b,e,ig(e.type,a),d,c);break a}throw Error(u(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),di(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),fi(a,b,d,e,c);
    case 3:hi(b);d=b.updateQueue;if(null===a||null===d)throw Error(u(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;vg(a,b);zg(b,d,null,c);d=b.memoizedState.element;if(d===e)Xh(),b=$h(a,b,c);else {if(e=b.stateNode.hydrate)Ph=Jd(b.stateNode.containerInfo.firstChild),Oh=b,e=Qh=!0;if(e)for(c=Yg(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else R(a,b,d,c),Xh();b=b.child;}return b;case 5:return fh(b),null===a&&Uh(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
    null,g=e.children,Gd(d,e)?g=null:null!==f&&Gd(d,f)&&(b.effectTag|=16),ei(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(R(a,b,g,c),b=b.child),b;case 6:return null===a&&Uh(b),null;case 13:return ji(a,b,c);case 4:return dh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Xg(b,null,d,c):R(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),Zh(a,b,d,e,c);case 7:return R(a,b,b.pendingProps,c),b.child;case 8:return R(a,
    b,b.pendingProps.children,c),b.child;case 12:return R(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I(jg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=$e(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!K.current){b=$h(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==
    k){g=h.child;for(var l=k.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=wg(c,null),l.tag=2,xg(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);pg(h.return,c);k.expirationTime<c&&(k.expirationTime=c);break}l=l.next;}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return;}h=
    g;}R(a,b,e.children,c);b=b.child;}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,qg(b,c),e=sg(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,R(a,b,d,c),b.child;case 14:return e=b.type,f=ig(e,b.pendingProps),f=ig(e.type,f),ai(a,b,e,f,d,c);case 15:return ci(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,L(d)?(a=!0,Gf(b)):a=!1,qg(b,c),Lg(b,d,e),Ng(b,d,e,c),gi(null,
    b,d,!0,a,c);case 19:return mi(a,b,c)}throw Error(u(156,b.tag));};var Uj=null,Li=null;function Yj(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return !1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return !0;try{var c=b.inject(a);Uj=function(a){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64));}catch(e){}};Li=function(a){try{b.onCommitFiberUnmount(c,a);}catch(e){}};}catch(d){}return !0}
    function Zj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null;}function Sh(a,b,c,d){return new Zj(a,b,c,d)}
    function bi(a){a=a.prototype;return !(!a||!a.isReactComponent)}function Xj(a){if("function"===typeof a)return bi(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===gb)return 11;if(a===jb)return 14}return 2}
    function Sg(a,b){var c=a.alternate;null===c?(c=Sh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,
    firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
    function Ug(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)bi(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ab:return Wg(c.children,e,f,b);case fb:g=8;e|=7;break;case bb:g=8;e|=1;break;case cb:return a=Sh(12,c,b,e|8),a.elementType=cb,a.type=cb,a.expirationTime=f,a;case hb:return a=Sh(13,c,b,e),a.type=hb,a.elementType=hb,a.expirationTime=f,a;case ib:return a=Sh(19,c,b,e),a.elementType=ib,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case db:g=
    10;break a;case eb:g=9;break a;case gb:g=11;break a;case jb:g=14;break a;case kb:g=16;d=null;break a;case lb:g=22;break a}throw Error(u(130,null==a?a:typeof a,""));}b=Sh(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Wg(a,b,c,d){a=Sh(7,a,d,b);a.expirationTime=c;return a}function Tg(a,b,c){a=Sh(6,a,null,b);a.expirationTime=c;return a}
    function Vg(a,b,c){b=Sh(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
    function ak(a,b,c){this.tag=b;this.current=null;this.containerInfo=a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0;}
    function Aj(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function xi(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0);}
    function yi(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b));}function Cj(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b;}
    function bk(a,b,c,d){var e=b.current,f=Gg(),g=Dg.suspense;f=Hg(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(dc(c)!==c||1!==c.tag)throw Error(u(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(L(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return;}while(null!==h);throw Error(u(171));}if(1===c.tag){var k=c.type;if(L(k)){c=Ff(c,k,h);break a}}c=h;}else c=Af;null===b.context?b.context=c:b.pendingContext=c;b=wg(f,g);b.payload={element:a};d=void 0===
    d?null:d;null!==d&&(b.callback=d);xg(e,b);Ig(e,f);return f}function ck(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function dk(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b);}function ek(a,b){dk(a,b);(a=a.alternate)&&dk(a,b);}
    function fk(a,b,c){c=null!=c&&!0===c.hydrate;var d=new ak(a,b,c),e=Sh(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ug(e);a[Od]=d.current;c&&0!==b&&Jc(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d;}fk.prototype.render=function(a){bk(a,this._internalRoot,null,null);};fk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;bk(null,a,null,function(){b[Od]=null;});};
    function gk(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function hk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new fk(a,0,b?{hydrate:!0}:void 0)}
    function ik(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=ck(g);h.call(a);};}bk(b,g,a,e);}else {f=c._reactRootContainer=hk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=ck(g);k.call(a);};}Nj(function(){bk(b,g,a,e);});}return ck(g)}function jk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return {$$typeof:$a,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
    wc=function(a){if(13===a.tag){var b=hg(Gg(),150,100);Ig(a,b);ek(a,b);}};xc=function(a){13===a.tag&&(Ig(a,3),ek(a,3));};yc=function(a){if(13===a.tag){var b=Gg();b=Hg(b,a,null);Ig(a,b);ek(a,b);}};
    za=function(a,b,c){switch(b){case "input":Cb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Qd(d);if(!e)throw Error(u(90));yb(d);Cb(d,e);}}}break;case "textarea":Kb(a,c);break;case "select":b=c.value,null!=b&&Hb(a,!!c.multiple,b,!1);}};Fa=Mj;
    Ga=function(a,b,c,d,e){var f=W;W|=4;try{return cg(98,a.bind(null,b,c,d,e))}finally{W=f,W===V&&gg();}};Ha=function(){(W&(1|fj|gj))===V&&(Lj(),Dj());};Ia=function(a,b){var c=W;W|=2;try{return a(b)}finally{W=c,W===V&&gg();}};function kk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!gk(b))throw Error(u(200));return jk(a,b,null,c)}var lk={Events:[Nc,Pd,Qd,xa,ta,Xd,function(a){jc(a,Wd);},Da,Ea,id,mc,Dj,{current:!1}]};
    (function(a){var b=a.findFiberByHostInstance;return Yj(n({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Wa.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=hc(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:tc,bundleType:0,version:"16.14.0",
    rendererPackageName:"react-dom"});reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=lk;reactDom_production_min.createPortal=kk;reactDom_production_min.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===b){if("function"===typeof a.render)throw Error(u(188));throw Error(u(268,Object.keys(a)));}a=hc(b);a=null===a?null:a.stateNode;return a};
    reactDom_production_min.flushSync=function(a,b){if((W&(fj|gj))!==V)throw Error(u(187));var c=W;W|=1;try{return cg(99,a.bind(null,b))}finally{W=c,gg();}};reactDom_production_min.hydrate=function(a,b,c){if(!gk(b))throw Error(u(200));return ik(null,a,b,!0,c)};reactDom_production_min.render=function(a,b,c){if(!gk(b))throw Error(u(200));return ik(null,a,b,!1,c)};
    reactDom_production_min.unmountComponentAtNode=function(a){if(!gk(a))throw Error(u(40));return a._reactRootContainer?(Nj(function(){ik(null,null,a,!1,function(){a._reactRootContainer=null;a[Od]=null;});}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Mj;reactDom_production_min.unstable_createPortal=function(a,b){return kk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};
    reactDom_production_min.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!gk(c))throw Error(u(200));if(null==a||void 0===a._reactInternalFiber)throw Error(u(38));return ik(a,b,c,!1,d)};reactDom_production_min.version="16.14.0";

    var schedulerTracing_production_min = {};

    /** @license React v0.19.1
     * scheduler-tracing.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b=0;schedulerTracing_production_min.__interactionsRef=null;schedulerTracing_production_min.__subscriberRef=null;schedulerTracing_production_min.unstable_clear=function(a){return a()};schedulerTracing_production_min.unstable_getCurrent=function(){return null};schedulerTracing_production_min.unstable_getThreadID=function(){return ++b};schedulerTracing_production_min.unstable_subscribe=function(){};schedulerTracing_production_min.unstable_trace=function(a,d,c){return c()};schedulerTracing_production_min.unstable_unsubscribe=function(){};schedulerTracing_production_min.unstable_wrap=function(a){return a};

    function checkDCE() {
      /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
      if (
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
      ) {
        return;
      }
      try {
        // Verify that the code above has been dead code eliminated (DCE'd).
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        // DevTools shouldn't crash React, no matter what.
        // We should still report in case we break this code.
        console.error(err);
      }
    }

    {
      // DCE check should happen before ReactDOM bundle executes so that
      // DevTools can report bad minification during injection.
      checkDCE();
      reactDom.exports = reactDom_production_min;
    }

    var getClassNames$h = classNamesFunction();
    var getFabricTheme = memoizeFunction(function (theme, isRTL) { return createTheme(__assign$k(__assign$k({}, theme), { rtl: isRTL })); });
    var getDir = function (_a) {
        var theme = _a.theme, dir = _a.dir;
        var contextDir = getRTL(theme) ? 'rtl' : 'ltr';
        var pageDir = getRTL() ? 'rtl' : 'ltr';
        var componentDir = dir ? dir : contextDir;
        return {
            // If Fabric dir !== contextDir
            // Or If contextDir !== pageDir
            // Then we need to set dir of the Fabric root
            rootDir: componentDir !== contextDir || componentDir !== pageDir ? componentDir : dir,
            // If dir !== contextDir || pageDir
            // then set contextual theme around content
            needsTheme: componentDir !== contextDir,
        };
    };
    var FabricBase = react.exports.forwardRef(function (props, ref) {
        var className = props.className, theme = props.theme, applyTheme = props.applyTheme, applyThemeToBody = props.applyThemeToBody, styles = props.styles;
        var classNames = getClassNames$h(styles, {
            theme: theme,
            applyTheme: applyTheme,
            className: className,
        });
        var rootElement = react.exports.useRef(null);
        useApplyThemeToBody(applyThemeToBody, classNames, rootElement);
        useFocusRects(rootElement);
        return react.exports.createElement(react.exports.Fragment, null, useRenderedContent(props, classNames, rootElement, ref));
    });
    FabricBase.displayName = 'FabricBase';
    function useRenderedContent(props, _a, rootElement, ref) {
        var root = _a.root;
        var _b = props.as, Root = _b === void 0 ? 'div' : _b, dir = props.dir, theme = props.theme;
        var divProps = getNativeProps(props, divProperties, ['dir']);
        var _c = getDir(props), rootDir = _c.rootDir, needsTheme = _c.needsTheme;
        var renderedContent = react.exports.createElement(Root, __assign$k({ dir: rootDir }, divProps, { className: root, ref: useMergedRefs(rootElement, ref) }));
        // Create the contextual theme if component direction does not match parent direction.
        if (needsTheme) {
            // Disabling ThemeProvider here because theme doesn't need to be re-provided by ThemeProvider if dir has changed.
            renderedContent = (
            // eslint-disable-next-line deprecation/deprecation
            react.exports.createElement(Customizer, { settings: { theme: getFabricTheme(theme, dir === 'rtl') } }, renderedContent));
        }
        return renderedContent;
    }
    function useApplyThemeToBody(applyThemeToBody, _a, rootElement) {
        var bodyThemed = _a.bodyThemed;
        react.exports.useEffect(function () {
            if (applyThemeToBody) {
                var currentDoc_1 = getDocument(rootElement.current);
                if (currentDoc_1) {
                    currentDoc_1.body.classList.add(bodyThemed);
                    return function () {
                        currentDoc_1.body.classList.remove(bodyThemed);
                    };
                }
            }
        }, [bodyThemed, applyThemeToBody, rootElement]);
        return rootElement;
    }

    var inheritFont = { fontFamily: 'inherit' };
    var GlobalClassNames$9 = {
        root: 'ms-Fabric',
        bodyThemed: 'ms-Fabric-bodyThemed',
    };
    var getStyles$q = function (props) {
        var theme = props.theme, className = props.className, applyTheme = props.applyTheme;
        var classNames = getGlobalClassNames(GlobalClassNames$9, theme);
        return {
            root: [
                classNames.root,
                theme.fonts.medium,
                {
                    color: theme.palette.neutralPrimary,
                    selectors: {
                        '& button': inheritFont,
                        '& input': inheritFont,
                        '& textarea': inheritFont,
                    },
                },
                // apply theme to only if applyTheme is true
                applyTheme && {
                    color: theme.semanticColors.bodyText,
                    backgroundColor: theme.semanticColors.bodyBackground,
                },
                className,
            ],
            bodyThemed: [
                {
                    backgroundColor: theme.semanticColors.bodyBackground,
                },
            ],
        };
    };

    /**
     * @deprecated This component is deprecated as of `@fluentui/react` version 8. Use `ThemeProvider` instead.
     */
    var Fabric = styled(FabricBase, getStyles$q, undefined, {
        scope: 'Fabric',
    });

    var _layersByHostId = {};
    var _defaultHostSelector;
    /**
     * Register a layer for a given host id
     * @param hostId Id of the layer host
     * @param layer Layer instance
     */
    function registerLayer(hostId, callback) {
        if (!_layersByHostId[hostId]) {
            _layersByHostId[hostId] = [];
        }
        _layersByHostId[hostId].push(callback);
    }
    /**
     * Unregister a layer for a given host id
     * @param hostId Id of the layer host
     * @param layer Layer instance
     */
    function unregisterLayer(hostId, callback) {
        if (_layersByHostId[hostId]) {
            var idx = _layersByHostId[hostId].indexOf(callback);
            if (idx >= 0) {
                _layersByHostId[hostId].splice(idx, 1);
                if (_layersByHostId[hostId].length === 0) {
                    delete _layersByHostId[hostId];
                }
            }
        }
    }
    /**
     * Get the default target selector when determining a host
     */
    function getDefaultTarget() {
        return _defaultHostSelector;
    }

    var WindowProvider = /*#__PURE__*/Object.freeze({
        __proto__: null,
        WindowContext: WindowContext,
        WindowProvider: WindowProvider$1,
        useDocument: useDocument,
        useWindow: useWindow
    });

    var getClassNames$g = classNamesFunction();
    var LayerBase = react.exports.forwardRef(function (props, ref) {
        var rootRef = react.exports.useRef(null);
        var mergedRef = useMergedRefs(rootRef, ref);
        var layerRef = react.exports.useRef();
        // Tracks if the layer mount events need to be raised.
        // Required to allow the DOM to render after the layer element is added.
        var _a = react.exports.useState(false), needRaiseLayerMount = _a[0], setNeedRaiseLayerMount = _a[1];
        var doc = useDocument();
        var eventBubblingEnabled = props.eventBubblingEnabled, styles = props.styles, theme = props.theme, className = props.className, children = props.children, hostId = props.hostId, _b = props.onLayerDidMount, onLayerDidMount = _b === void 0 ? function () { return undefined; } : _b, 
        // eslint-disable-next-line deprecation/deprecation
        _c = props.onLayerMounted, 
        // eslint-disable-next-line deprecation/deprecation
        onLayerMounted = _c === void 0 ? function () { return undefined; } : _c, onLayerWillUnmount = props.onLayerWillUnmount, insertFirst = props.insertFirst;
        var classNames = getClassNames$g(styles, {
            theme: theme,
            className: className,
            isNotHost: !hostId,
        });
        // Returns the user provided hostId props element, the default target selector,
        // or undefined if document doesn't exist.
        var getHost = function () {
            if (!doc) {
                return undefined;
            }
            if (hostId) {
                return doc.getElementById(hostId);
            }
            else {
                var defaultHostSelector = getDefaultTarget();
                return defaultHostSelector ? doc.querySelector(defaultHostSelector) : doc.body;
            }
        };
        // Removes the current layer element's parentNode and runs onLayerWillUnmount prop if provided.
        var removeLayerElement = function () {
            onLayerWillUnmount === null || onLayerWillUnmount === void 0 ? void 0 : onLayerWillUnmount();
            var elem = layerRef.current;
            // Clear ref before removing from the DOM
            layerRef.current = undefined;
            if (elem && elem.parentNode) {
                elem.parentNode.removeChild(elem);
            }
        };
        // If a doc or host exists, it will remove and update layer parentNodes.
        var createLayerElement = function () {
            var host = getHost();
            if (!doc || !host) {
                return;
            }
            // Remove and re-create any previous existing layer elements.
            removeLayerElement();
            var el = doc.createElement('div');
            el.className = classNames.root;
            setPortalAttribute(el);
            setVirtualParent(el, rootRef.current);
            insertFirst ? host.insertBefore(el, host.firstChild) : host.appendChild(el);
            layerRef.current = el;
            setNeedRaiseLayerMount(true);
        };
        useIsomorphicLayoutEffect(function () {
            createLayerElement();
            // Check if the user provided a hostId prop and register the layer with the ID.
            if (hostId) {
                registerLayer(hostId, createLayerElement);
            }
            return function () {
                removeLayerElement();
                if (hostId) {
                    unregisterLayer(hostId, createLayerElement);
                }
            };
            // eslint-disable-next-line react-hooks/exhaustive-deps -- should run if the hostId updates.
        }, [hostId]);
        react.exports.useEffect(function () {
            if (layerRef.current && needRaiseLayerMount) {
                onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
                onLayerDidMount === null || onLayerDidMount === void 0 ? void 0 : onLayerDidMount();
                setNeedRaiseLayerMount(false);
            }
        }, [needRaiseLayerMount, onLayerMounted, onLayerDidMount]);
        return (react.exports.createElement("span", { className: "ms-layer", ref: mergedRef }, layerRef.current &&
            reactDom.exports.createPortal(
            /* eslint-disable deprecation/deprecation */
            react.exports.createElement(Fabric, __assign$k({}, (!eventBubblingEnabled && getFilteredEvents()), { className: classNames.content }), children), 
            /* eslint-enable deprecation/deprecation */
            layerRef.current)));
    });
    LayerBase.displayName = 'LayerBase';
    var filteredEventProps;
    var onFilterEvent = function (ev) {
        // We should just be able to check ev.bubble here and only stop events that are bubbling up. However, even though
        // mouseenter and mouseleave do NOT bubble up, they are showing up as bubbling. Therefore we stop events based on
        // event name rather than ev.bubble.
        if (ev.eventPhase === Event.BUBBLING_PHASE &&
            ev.type !== 'mouseenter' &&
            ev.type !== 'mouseleave' &&
            ev.type !== 'touchstart' &&
            ev.type !== 'touchend') {
            ev.stopPropagation();
        }
    };
    function getFilteredEvents() {
        if (!filteredEventProps) {
            filteredEventProps = {};
            [
                'onClick',
                'onContextMenu',
                'onDoubleClick',
                'onDrag',
                'onDragEnd',
                'onDragEnter',
                'onDragExit',
                'onDragLeave',
                'onDragOver',
                'onDragStart',
                'onDrop',
                'onMouseDown',
                'onMouseEnter',
                'onMouseLeave',
                'onMouseMove',
                'onMouseOver',
                'onMouseOut',
                'onMouseUp',
                'onTouchMove',
                'onTouchStart',
                'onTouchCancel',
                'onTouchEnd',
                'onKeyDown',
                'onKeyPress',
                'onKeyUp',
                'onFocus',
                'onBlur',
                'onChange',
                'onInput',
                'onInvalid',
                'onSubmit',
            ].forEach(function (name) { return (filteredEventProps[name] = onFilterEvent); });
        }
        return filteredEventProps;
    }

    var GlobalClassNames$8 = {
        root: 'ms-Layer',
        rootNoHost: 'ms-Layer--fixed',
        content: 'ms-Layer-content',
    };
    var getStyles$p = function (props) {
        var className = props.className, isNotHost = props.isNotHost, theme = props.theme;
        var classNames = getGlobalClassNames(GlobalClassNames$8, theme);
        return {
            root: [
                classNames.root,
                theme.fonts.medium,
                isNotHost && [
                    classNames.rootNoHost,
                    {
                        position: 'fixed',
                        zIndex: ZIndexes.Layer,
                        top: 0,
                        left: 0,
                        bottom: 0,
                        right: 0,
                        visibility: 'hidden',
                    },
                ],
                className,
            ],
            content: [
                classNames.content,
                {
                    visibility: 'visible',
                },
            ],
        };
    };

    var Layer = styled(LayerBase, getStyles$p, undefined, {
        scope: 'Layer',
        fields: ['hostId', 'theme', 'styles'],
    });

    var Callout$1 = react.exports.forwardRef(function (_a, forwardedRef) {
        var layerProps = _a.layerProps, doNotLayer = _a.doNotLayer, rest = __rest(_a, ["layerProps", "doNotLayer"]);
        var content = react.exports.createElement(CalloutContent, __assign$k({}, rest, { doNotLayer: doNotLayer, ref: forwardedRef }));
        return doNotLayer ? content : react.exports.createElement(Layer, __assign$k({}, layerProps), content);
    });
    Callout$1.displayName = 'Callout';

    var COMPONENT_NAME$5 = 'FocusTrapZone';
    var useComponentRef$3 = function (componentRef, previouslyFocusedElement, focus) {
        react.exports.useImperativeHandle(componentRef, function () { return ({
            get previouslyFocusedElement() {
                return previouslyFocusedElement;
            },
            focus: focus,
        }); }, [previouslyFocusedElement, focus]);
    };
    var FocusTrapZone = react.exports.forwardRef(function (props, ref) {
        var root = react.exports.useRef(null);
        var firstBumper = react.exports.useRef(null);
        var lastBumper = react.exports.useRef(null);
        var mergedRootRef = useMergedRefs(root, ref);
        var id = useId(undefined, props.id);
        var doc = useDocument();
        var divProps = getNativeProps(props, divProperties);
        var internalState = useConst(function () { return ({
            previouslyFocusedElementOutsideTrapZone: undefined,
            previouslyFocusedElementInTrapZone: undefined,
            disposeFocusHandler: undefined,
            disposeClickHandler: undefined,
            hasFocus: false,
            unmodalize: undefined,
        }); });
        var ariaLabelledBy = props.ariaLabelledBy, className = props.className, children = props.children, componentRef = props.componentRef, disabled = props.disabled, _a = props.disableFirstFocus, disableFirstFocus = _a === void 0 ? false : _a, _b = props.disabled, currentDisabledValue = _b === void 0 ? false : _b, elementToFocusOnDismiss = props.elementToFocusOnDismiss, _c = props.forceFocusInsideTrap, forceFocusInsideTrap = _c === void 0 ? true : _c, focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement, 
        // eslint-disable-next-line deprecation/deprecation
        firstFocusableSelector = props.firstFocusableSelector, firstFocusableTarget = props.firstFocusableTarget, ignoreExternalFocusing = props.ignoreExternalFocusing, _d = props.isClickableOutsideFocusTrap, isClickableOutsideFocusTrap = _d === void 0 ? false : _d, onFocus = props.onFocus, onBlur = props.onBlur, onFocusCapture = props.onFocusCapture, onBlurCapture = props.onBlurCapture, enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;
        var bumperProps = {
            'aria-hidden': true,
            style: {
                pointerEvents: 'none',
                position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them
            },
            tabIndex: disabled ? -1 : 0,
            'data-is-visible': true,
            'data-is-focus-trap-zone-bumper': true,
        };
        var focus = react.exports.useCallback(function () {
            if (focusPreviouslyFocusedInnerElement &&
                internalState.previouslyFocusedElementInTrapZone &&
                elementContains(root.current, internalState.previouslyFocusedElementInTrapZone)) {
                // focus on the last item that had focus in the zone before we left the zone
                focusAsync(internalState.previouslyFocusedElementInTrapZone);
                return;
            }
            var focusSelector = typeof firstFocusableSelector === 'string'
                ? firstFocusableSelector
                : firstFocusableSelector && firstFocusableSelector();
            var firstFocusableChild = null;
            if (root.current) {
                if (typeof firstFocusableTarget === 'string') {
                    firstFocusableChild = root.current.querySelector(firstFocusableTarget);
                }
                else if (firstFocusableTarget) {
                    firstFocusableChild = firstFocusableTarget(root.current);
                }
                else if (focusSelector) {
                    firstFocusableChild = root.current.querySelector('.' + focusSelector);
                }
                // Fall back to first element if query selector did not match any elements.
                if (!firstFocusableChild) {
                    firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true);
                }
            }
            if (firstFocusableChild) {
                focusAsync(firstFocusableChild);
            }
        }, [firstFocusableSelector, firstFocusableTarget, focusPreviouslyFocusedInnerElement, internalState]);
        var onBumperFocus = react.exports.useCallback(function (isFirstBumper) {
            if (disabled) {
                return;
            }
            var currentBumper = (isFirstBumper === internalState.hasFocus
                ? lastBumper.current
                : firstBumper.current);
            if (root.current) {
                var nextFocusable = isFirstBumper === internalState.hasFocus
                    ? getLastTabbable(root.current, currentBumper, true, false)
                    : getFirstTabbable(root.current, currentBumper, true, false);
                if (nextFocusable) {
                    if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {
                        // This can happen when FTZ contains no tabbable elements.
                        // focus will take care of finding a focusable element in FTZ.
                        focus();
                    }
                    else {
                        nextFocusable.focus();
                    }
                }
            }
        }, [disabled, focus, internalState]);
        var onRootBlurCapture = react.exports.useCallback(function (ev) {
            onBlurCapture === null || onBlurCapture === void 0 ? void 0 : onBlurCapture(ev);
            var relatedTarget = ev.relatedTarget;
            if (ev.relatedTarget === null) {
                // In IE11, due to lack of support, event.relatedTarget is always
                // null making every onBlur call to be "outside" of the root
                // even when it's not. Using document.activeElement is another way
                // for us to be able to get what the relatedTarget without relying
                // on the event
                relatedTarget = doc.activeElement;
            }
            if (!elementContains(root.current, relatedTarget)) {
                internalState.hasFocus = false;
            }
        }, [doc, internalState, onBlurCapture]);
        var onRootFocusCapture = react.exports.useCallback(function (ev) {
            onFocusCapture === null || onFocusCapture === void 0 ? void 0 : onFocusCapture(ev);
            if (ev.target === firstBumper.current) {
                onBumperFocus(true);
            }
            else if (ev.target === lastBumper.current) {
                onBumperFocus(false);
            }
            internalState.hasFocus = true;
            if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {
                // every time focus changes within the trap zone, remember the focused element so that
                // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))
                internalState.previouslyFocusedElementInTrapZone = ev.target;
            }
        }, [onFocusCapture, internalState, onBumperFocus]);
        var returnFocusToInitiator = react.exports.useCallback(function () {
            FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function (value) {
                return id !== value;
            });
            if (doc) {
                var activeElement = doc.activeElement;
                if (!ignoreExternalFocusing &&
                    internalState.previouslyFocusedElementOutsideTrapZone &&
                    typeof internalState.previouslyFocusedElementOutsideTrapZone.focus === 'function' &&
                    (elementContains(root.current, activeElement) || activeElement === doc.body)) {
                    if (!(internalState.previouslyFocusedElementOutsideTrapZone === firstBumper.current ||
                        internalState.previouslyFocusedElementOutsideTrapZone === lastBumper.current)) {
                        focusAsync(internalState.previouslyFocusedElementOutsideTrapZone);
                    }
                }
            }
        }, [doc, id, ignoreExternalFocusing, internalState]);
        var forceFocusInTrap = react.exports.useCallback(function (ev) {
            if (disabled) {
                return;
            }
            if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {
                var focusedElement = ev.target;
                if (!elementContains(root.current, focusedElement)) {
                    focus();
                    internalState.hasFocus = true; // set focus here since we stop event propagation
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        }, [disabled, id, focus, internalState]);
        var forceClickInTrap = react.exports.useCallback(function (ev) {
            if (disabled) {
                return;
            }
            if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {
                var clickedElement = ev.target;
                if (clickedElement && !elementContains(root.current, clickedElement)) {
                    focus();
                    internalState.hasFocus = true; // set focus here since we stop event propagation
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        }, [disabled, id, focus, internalState]);
        var updateEventHandlers = react.exports.useCallback(function () {
            if (forceFocusInsideTrap && !internalState.disposeFocusHandler) {
                internalState.disposeFocusHandler = on(window, 'focus', forceFocusInTrap, true);
            }
            else if (!forceFocusInsideTrap && internalState.disposeFocusHandler) {
                internalState.disposeFocusHandler();
                internalState.disposeFocusHandler = undefined;
            }
            if (!isClickableOutsideFocusTrap && !internalState.disposeClickHandler) {
                internalState.disposeClickHandler = on(window, 'click', forceClickInTrap, true);
            }
            else if (isClickableOutsideFocusTrap && internalState.disposeClickHandler) {
                internalState.disposeClickHandler();
                internalState.disposeClickHandler = undefined;
            }
        }, [forceClickInTrap, forceFocusInTrap, forceFocusInsideTrap, isClickableOutsideFocusTrap, internalState]);
        // Updates eventHandlers and cleans up focusStack when the component unmounts.
        react.exports.useEffect(function () {
            var parentRoot = root.current;
            updateEventHandlers();
            return function () {
                // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone
                if (!disabled || forceFocusInsideTrap || !elementContains(parentRoot, doc === null || doc === void 0 ? void 0 : doc.activeElement)) {
                    returnFocusToInitiator();
                }
            };
            // eslint-disable-next-line react-hooks/exhaustive-deps -- Should only run on mount.
        }, [updateEventHandlers]);
        // Updates focusStack and the previouslyFocusedElementOutsideTrapZone on prop change.
        react.exports.useEffect(function () {
            var newForceFocusInsideTrap = forceFocusInsideTrap !== undefined ? forceFocusInsideTrap : true;
            var newDisabled = disabled !== undefined ? disabled : false;
            // Transition from forceFocusInsideTrap / FTZ disabled to enabled.
            if (!newDisabled || newForceFocusInsideTrap) {
                if (currentDisabledValue) {
                    return;
                }
                FocusTrapZone.focusStack.push(id);
                internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss
                    ? elementToFocusOnDismiss
                    : doc.activeElement;
                if (!disableFirstFocus && !elementContains(root.current, internalState.previouslyFocusedElementOutsideTrapZone)) {
                    focus();
                }
                if (!internalState.unmodalize && root.current && enableAriaHiddenSiblings) {
                    internalState.unmodalize = modalize(root.current);
                }
            }
            else if (!newForceFocusInsideTrap || newDisabled) {
                // Transition from forceFocusInsideTrap / FTZ enabled to disabled.
                returnFocusToInitiator();
                if (internalState.unmodalize) {
                    internalState.unmodalize();
                }
            }
            if (elementToFocusOnDismiss && internalState.previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {
                internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;
            }
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [elementToFocusOnDismiss, forceFocusInsideTrap, disabled]);
        // Cleanup lifecyle method for internalState.
        useUnmount(function () {
            // Dispose of event handlers so their closures can be garbage-collected
            if (internalState.disposeClickHandler) {
                internalState.disposeClickHandler();
                internalState.disposeClickHandler = undefined;
            }
            if (internalState.disposeFocusHandler) {
                internalState.disposeFocusHandler();
                internalState.disposeFocusHandler = undefined;
            }
            if (internalState.unmodalize) {
                internalState.unmodalize();
            }
            // Dispose of element references so the DOM Nodes can be garbage-collected
            delete internalState.previouslyFocusedElementInTrapZone;
            delete internalState.previouslyFocusedElementOutsideTrapZone;
        });
        useComponentRef$3(componentRef, internalState.previouslyFocusedElementInTrapZone, focus);
        return (react.exports.createElement("div", __assign$k({}, divProps, { className: className, ref: mergedRootRef, "aria-labelledby": ariaLabelledBy, onFocusCapture: onRootFocusCapture, onFocus: onFocus, onBlur: onBlur, onBlurCapture: onRootBlurCapture }),
            react.exports.createElement("div", __assign$k({}, bumperProps, { ref: firstBumper })),
            children,
            react.exports.createElement("div", __assign$k({}, bumperProps, { ref: lastBumper }))));
    });
    FocusTrapZone.displayName = COMPONENT_NAME$5;
    FocusTrapZone.focusStack = [];

    /**
     * A special Callout that uses FocusTrapZone to trap focus
     * @param props - Props for the component
     */
    var FocusTrapCallout = function (props) {
        return (react.exports.createElement(Callout$1, __assign$k({}, props),
            react.exports.createElement(FocusTrapZone, __assign$k({ disabled: props.hidden }, props.focusTrapProps), props.children)));
    };

    var Callout = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Callout: Callout$1,
        CalloutContent: CalloutContent,
        CalloutContentBase: CalloutContentBase,
        FocusTrapCallout: FocusTrapCallout,
        DirectionalHint: DirectionalHint
    });

    var getClassNames$f = classNamesFunction();
    var TooltipBase = /** @class */ (function (_super) {
        __extends$4(TooltipBase, _super);
        function TooltipBase() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._onRenderContent = function (props) {
                if (typeof props.content === 'string') {
                    return react.exports.createElement("p", { className: _this._classNames.subText }, props.content);
                }
                else {
                    return react.exports.createElement("div", { className: _this._classNames.subText }, props.content);
                }
            };
            return _this;
        }
        TooltipBase.prototype.render = function () {
            var _a = this.props, className = _a.className, calloutProps = _a.calloutProps, directionalHint = _a.directionalHint, directionalHintForRTL = _a.directionalHintForRTL, styles = _a.styles, id = _a.id, maxWidth = _a.maxWidth, _b = _a.onRenderContent, onRenderContent = _b === void 0 ? this._onRenderContent : _b, targetElement = _a.targetElement, theme = _a.theme;
            this._classNames = getClassNames$f(styles, {
                theme: theme,
                className: className || (calloutProps && calloutProps.className),
                beakWidth: calloutProps && calloutProps.beakWidth,
                gapSpace: calloutProps && calloutProps.gapSpace,
                maxWidth: maxWidth,
            });
            return (react.exports.createElement(Callout$1, __assign$k({ target: targetElement, directionalHint: directionalHint, directionalHintForRTL: directionalHintForRTL }, calloutProps, getNativeProps(this.props, divProperties, ['id']), { className: this._classNames.root }),
                react.exports.createElement("div", { className: this._classNames.content, id: id, onMouseEnter: this.props.onMouseEnter, onMouseLeave: this.props.onMouseLeave }, onRenderContent(this.props, this._onRenderContent))));
        };
        // Specify default props values
        TooltipBase.defaultProps = {
            directionalHint: DirectionalHint.topCenter,
            maxWidth: '364px',
            calloutProps: {
                isBeakVisible: true,
                beakWidth: 16,
                gapSpace: 0,
                setInitialFocus: true,
                doNotLayer: false,
            },
        };
        return TooltipBase;
    }(react.exports.Component));

    var getStyles$o = function (props) {
        var className = props.className, _a = props.beakWidth, beakWidth = _a === void 0 ? 16 : _a, _b = props.gapSpace, gapSpace = _b === void 0 ? 0 : _b, maxWidth = props.maxWidth, theme = props.theme;
        var semanticColors = theme.semanticColors, fonts = theme.fonts, effects = theme.effects;
        // The math here is done to account for the 45 degree rotation of the beak
        // and sub-pixel rounding that differs across browsers, which is more noticeable when
        // the device pixel ratio is larger
        var tooltipGapSpace = -(Math.sqrt((beakWidth * beakWidth) / 2) + gapSpace) + 1 / window.devicePixelRatio;
        return {
            root: [
                'ms-Tooltip',
                theme.fonts.medium,
                AnimationClassNames.fadeIn200,
                {
                    background: semanticColors.menuBackground,
                    boxShadow: effects.elevation8,
                    padding: '8px',
                    maxWidth: maxWidth,
                    selectors: {
                        ':after': {
                            content: "''",
                            position: 'absolute',
                            bottom: tooltipGapSpace,
                            left: tooltipGapSpace,
                            right: tooltipGapSpace,
                            top: tooltipGapSpace,
                            zIndex: 0,
                        },
                    },
                },
                className,
            ],
            content: [
                'ms-Tooltip-content',
                fonts.small,
                {
                    position: 'relative',
                    zIndex: 1,
                    color: semanticColors.menuItemText,
                    wordWrap: 'break-word',
                    overflowWrap: 'break-word',
                    overflow: 'hidden',
                },
            ],
            subText: [
                'ms-Tooltip-subtext',
                {
                    // Using inherit here to avoid unintentional global overrides of the <p> tag.
                    fontSize: 'inherit',
                    fontWeight: 'inherit',
                    color: 'inherit',
                    margin: 0,
                },
            ],
        };
    };

    var Tooltip$1 = styled(TooltipBase, getStyles$o, undefined, {
        scope: 'Tooltip',
    });

    /**
     * {@docCategory Tooltip}
     */
    var TooltipDelay;
    (function (TooltipDelay) {
        TooltipDelay[TooltipDelay["zero"] = 0] = "zero";
        /** 300 ms delay before showing the tooltip */
        TooltipDelay[TooltipDelay["medium"] = 1] = "medium";
        /** 500 ms delay before showing the tooltip */
        TooltipDelay[TooltipDelay["long"] = 2] = "long";
    })(TooltipDelay || (TooltipDelay = {}));

    /**
     * {@docCategory Tooltip}
     */
    var TooltipOverflowMode;
    (function (TooltipOverflowMode) {
        /** Only show tooltip if parent DOM element is overflowing */
        TooltipOverflowMode[TooltipOverflowMode["Parent"] = 0] = "Parent";
        /**
         * Only show tooltip if tooltip host's content is overflowing.
         * Note that this does not check the children for overflow, only the TooltipHost root.
         */
        TooltipOverflowMode[TooltipOverflowMode["Self"] = 1] = "Self";
    })(TooltipOverflowMode || (TooltipOverflowMode = {}));

    var getClassNames$e = classNamesFunction();
    var TooltipHostBase = /** @class */ (function (_super) {
        __extends$4(TooltipHostBase, _super);
        // Constructor
        function TooltipHostBase(props) {
            var _this = _super.call(this, props) || this;
            // The wrapping div that gets the hover events
            _this._tooltipHost = react.exports.createRef();
            _this._defaultTooltipId = getId('tooltip');
            _this.show = function () {
                _this._toggleTooltip(true);
            };
            _this.dismiss = function () {
                _this._hideTooltip();
            };
            _this._getTargetElement = function () {
                if (!_this._tooltipHost.current) {
                    return undefined;
                }
                var overflowMode = _this.props.overflowMode;
                // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative
                // to the parent element, otherwise it might look off.
                if (overflowMode !== undefined) {
                    switch (overflowMode) {
                        case TooltipOverflowMode.Parent:
                            return _this._tooltipHost.current.parentElement;
                        case TooltipOverflowMode.Self:
                            return _this._tooltipHost.current;
                    }
                }
                return _this._tooltipHost.current;
            };
            _this._onTooltipFocus = function (ev) {
                if (_this._ignoreNextFocusEvent) {
                    _this._ignoreNextFocusEvent = false;
                    return;
                }
                _this._onTooltipMouseEnter(ev);
            };
            _this._onTooltipBlur = function (ev) {
                // The focused element gets a blur event when the document loses focus
                // (e.g. switching tabs in the browser), but we don't want to show the
                // tooltip again when the document gets focus back. Handle this case by
                // checking if the blurred element is still the document's activeElement,
                // and ignoring when it next gets focus back.
                // See https://github.com/microsoft/fluentui/issues/13541
                _this._ignoreNextFocusEvent = (document === null || document === void 0 ? void 0 : document.activeElement) === ev.target;
                _this._hideTooltip();
            };
            // Show Tooltip
            _this._onTooltipMouseEnter = function (ev) {
                var _a = _this.props, overflowMode = _a.overflowMode, delay = _a.delay;
                if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== _this) {
                    TooltipHostBase._currentVisibleTooltip.dismiss();
                }
                TooltipHostBase._currentVisibleTooltip = _this;
                if (overflowMode !== undefined) {
                    var overflowElement = _this._getTargetElement();
                    if (overflowElement && !hasOverflow(overflowElement)) {
                        return;
                    }
                }
                if (ev.target && portalContainsElement(ev.target, _this._getTargetElement())) {
                    // Do not show tooltip when target is inside a portal relative to TooltipHost.
                    return;
                }
                _this._clearDismissTimer();
                _this._clearOpenTimer();
                if (delay !== TooltipDelay.zero) {
                    _this.setState({ isAriaPlaceholderRendered: true });
                    var delayTime = _this._getDelayTime(delay); // non-null assertion because we set it in `defaultProps`
                    _this._openTimerId = _this._async.setTimeout(function () {
                        _this._toggleTooltip(true);
                    }, delayTime);
                }
                else {
                    _this._toggleTooltip(true);
                }
            };
            // Hide Tooltip
            _this._onTooltipMouseLeave = function (ev) {
                var closeDelay = _this.props.closeDelay;
                _this._clearDismissTimer();
                _this._clearOpenTimer();
                if (closeDelay) {
                    _this._dismissTimerId = _this._async.setTimeout(function () {
                        _this._toggleTooltip(false);
                    }, closeDelay);
                }
                else {
                    _this._toggleTooltip(false);
                }
                if (TooltipHostBase._currentVisibleTooltip === _this) {
                    TooltipHostBase._currentVisibleTooltip = undefined;
                }
            };
            _this._onTooltipKeyDown = function (ev) {
                // eslint-disable-next-line deprecation/deprecation
                if ((ev.which === KeyCodes.escape || ev.ctrlKey) && _this.state.isTooltipVisible) {
                    _this._hideTooltip();
                    ev.stopPropagation();
                }
            };
            _this._clearDismissTimer = function () {
                _this._async.clearTimeout(_this._dismissTimerId);
            };
            _this._clearOpenTimer = function () {
                _this._async.clearTimeout(_this._openTimerId);
            };
            // Hide Tooltip
            _this._hideTooltip = function () {
                _this._clearOpenTimer();
                _this._clearDismissTimer();
                _this._toggleTooltip(false);
            };
            _this._toggleTooltip = function (isTooltipVisible) {
                if (_this.state.isAriaPlaceholderRendered) {
                    _this.setState({
                        isAriaPlaceholderRendered: false,
                    });
                }
                if (_this.state.isTooltipVisible !== isTooltipVisible) {
                    _this.setState({ isTooltipVisible: isTooltipVisible }, function () { return _this.props.onTooltipToggle && _this.props.onTooltipToggle(isTooltipVisible); });
                }
            };
            _this._getDelayTime = function (delay) {
                switch (delay) {
                    case TooltipDelay.medium:
                        return 300;
                    case TooltipDelay.long:
                        return 500;
                    default:
                        return 0;
                }
            };
            initializeComponentRef(_this);
            _this.state = {
                isAriaPlaceholderRendered: false,
                isTooltipVisible: false,
            };
            _this._async = new Async(_this);
            return _this;
        }
        // Render
        TooltipHostBase.prototype.render = function () {
            var _a = this.props, calloutProps = _a.calloutProps, children = _a.children, content = _a.content, directionalHint = _a.directionalHint, directionalHintForRTL = _a.directionalHintForRTL, className = _a.hostClassName, id = _a.id, 
            // eslint-disable-next-line deprecation/deprecation
            _b = _a.setAriaDescribedBy, 
            // eslint-disable-next-line deprecation/deprecation
            setAriaDescribedBy = _b === void 0 ? true : _b, tooltipProps = _a.tooltipProps, styles = _a.styles, theme = _a.theme;
            this._classNames = getClassNames$e(styles, {
                theme: theme,
                className: className,
            });
            var _c = this.state, isAriaPlaceholderRendered = _c.isAriaPlaceholderRendered, isTooltipVisible = _c.isTooltipVisible;
            var tooltipId = id || this._defaultTooltipId;
            var isContentPresent = !!(content ||
                (tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent()));
            var showTooltip = isTooltipVisible && isContentPresent;
            var ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;
            return (react.exports.createElement("div", __assign$k({ className: this._classNames.root, ref: this._tooltipHost }, { onFocusCapture: this._onTooltipFocus }, { onBlurCapture: this._onTooltipBlur }, { onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave, onKeyDown: this._onTooltipKeyDown, role: "none", "aria-describedby": ariaDescribedBy }),
                children,
                showTooltip && (react.exports.createElement(Tooltip$1, __assign$k({ id: tooltipId, content: content, targetElement: this._getTargetElement(), directionalHint: directionalHint, directionalHintForRTL: directionalHintForRTL, calloutProps: assign({}, calloutProps, {
                        onDismiss: this._hideTooltip,
                        onMouseEnter: this._onTooltipMouseEnter,
                        onMouseLeave: this._onTooltipMouseLeave,
                    }), onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave }, getNativeProps(this.props, divProperties), tooltipProps))),
                isAriaPlaceholderRendered && (react.exports.createElement("div", { id: tooltipId, role: "none", style: hiddenContentStyle }, content))));
        };
        TooltipHostBase.prototype.componentWillUnmount = function () {
            if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {
                TooltipHostBase._currentVisibleTooltip = undefined;
            }
            this._async.dispose();
        };
        TooltipHostBase.defaultProps = {
            delay: TooltipDelay.medium,
        };
        return TooltipHostBase;
    }(react.exports.Component));

    var GlobalClassNames$7 = {
        root: 'ms-TooltipHost',
        ariaPlaceholder: 'ms-TooltipHost-aria-placeholder',
    };
    var getStyles$n = function (props) {
        var className = props.className, theme = props.theme;
        var classNames = getGlobalClassNames(GlobalClassNames$7, theme);
        return {
            root: [
                classNames.root,
                {
                    display: 'inline',
                },
                className,
            ],
        };
    };

    var TooltipHost = styled(TooltipHostBase, getStyles$n, undefined, {
        scope: 'TooltipHost',
    });

    var Tooltip = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Tooltip: Tooltip$1,
        TooltipBase: TooltipBase,
        get TooltipDelay () { return TooltipDelay; },
        TooltipHost: TooltipHost,
        TooltipHostBase: TooltipHostBase,
        get TooltipOverflowMode () { return TooltipOverflowMode; }
    });

    /**
     * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`
     * {@docCategory Icon}
     */
    var IconType;
    (function (IconType) {
        /**
         * Render using the fabric icon font.
         * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`
         */
        IconType[IconType["default"] = 0] = "default";
        /**
         * Render using an image, where imageProps would be used.
         * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`
         */
        IconType[IconType["image"] = 1] = "image";
        /**
         * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`
         */
        IconType[IconType["Default"] = 100000] = "Default";
        /**
         * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`
         */
        IconType[IconType["Image"] = 100001] = "Image";
    })(IconType || (IconType = {}));

    /**
     * The possible methods that can be used to fit the image.
     * {@docCategory Image}
     */
    var ImageFit;
    (function (ImageFit) {
        /**
         * The image is not scaled. The image is centered and cropped within the content box.
         */
        ImageFit[ImageFit["center"] = 0] = "center";
        /**
         * The image is scaled to maintain its aspect ratio while being fully contained within the frame. The image will
         * be centered horizontally and vertically within the frame. The space in the top and bottom or in the sides of
         * the frame will be empty depending on the difference in aspect ratio between the image and the frame.
         */
        ImageFit[ImageFit["contain"] = 1] = "contain";
        /**
         * The image is scaled to maintain its aspect ratio while filling the frame. Portions of the image will be cropped
         * from the top and bottom, or the sides, depending on the difference in aspect ratio between the image and the frame.
         */
        ImageFit[ImageFit["cover"] = 2] = "cover";
        /**
         * Neither the image nor the frame are scaled. If their sizes do not match, the image will either be cropped or the
         * frame will have empty space.
         */
        ImageFit[ImageFit["none"] = 3] = "none";
        /**
         * The image will be centered horizontally and vertically within the frame and maintains its aspect ratio. It will
         * behave as ImageFit.center if the image's natural height or width is less than the Image frame's height or width,
         * but if both natural height and width are larger than the frame it will behave as ImageFit.cover.
         */
        ImageFit[ImageFit["centerCover"] = 4] = "centerCover";
        /**
         * The image will be centered horizontally and vertically within the frame and maintains its aspect ratio. It will
         * behave as ImageFit.center if the image's natural height and width is less than the Image frame's height and width,
         * but if either natural height or width are larger than the frame it will behave as ImageFit.contain.
         */
        ImageFit[ImageFit["centerContain"] = 5] = "centerContain";
    })(ImageFit || (ImageFit = {}));
    /**
     * The cover style to be used on the image
     * {@docCategory Image}
     */
    var ImageCoverStyle;
    (function (ImageCoverStyle) {
        /**
         * The image will be shown at 100% height of container and the width will be scaled accordingly
         */
        ImageCoverStyle[ImageCoverStyle["landscape"] = 0] = "landscape";
        /**
         * The image will be shown at 100% width of container and the height will be scaled accordingly
         */
        ImageCoverStyle[ImageCoverStyle["portrait"] = 1] = "portrait";
    })(ImageCoverStyle || (ImageCoverStyle = {}));
    /**
     * {@docCategory Image}
     */
    var ImageLoadState;
    (function (ImageLoadState) {
        /**
         * The image has not yet been loaded, and there is no error yet.
         */
        ImageLoadState[ImageLoadState["notLoaded"] = 0] = "notLoaded";
        /**
         * The image has been loaded successfully.
         */
        ImageLoadState[ImageLoadState["loaded"] = 1] = "loaded";
        /**
         * An error has been encountered while loading the image.
         */
        ImageLoadState[ImageLoadState["error"] = 2] = "error";
        /**
         * @deprecated Not used. Use `onLoadingStateChange` and re-render the Image with a different src.
         */
        ImageLoadState[ImageLoadState["errorLoaded"] = 3] = "errorLoaded";
    })(ImageLoadState || (ImageLoadState = {}));

    var getClassNames$d = classNamesFunction();
    var SVG_REGEX = /\.svg$/i;
    var KEY_PREFIX = 'fabricImage';
    function useLoadState(props, imageElement) {
        var onLoadingStateChange = props.onLoadingStateChange, onLoad = props.onLoad, onError = props.onError, src = props.src;
        var _a = react.exports.useState(ImageLoadState.notLoaded), loadState = _a[0], setLoadState = _a[1];
        useIsomorphicLayoutEffect(function () {
            // If the src property changes, reset the load state
            // (does nothing if the load state is already notLoaded)
            setLoadState(ImageLoadState.notLoaded);
        }, [src]);
        // eslint-disable-next-line react-hooks/exhaustive-deps -- intended to run every render
        react.exports.useEffect(function () {
            if (loadState === ImageLoadState.notLoaded) {
                // testing if naturalWidth and naturalHeight are greater than zero is better than checking
                // .complete, because .complete will also be set to true if the image breaks. However,
                // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back
                // to checking .complete for these images.
                var isLoaded = imageElement.current
                    ? (src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0) ||
                        (imageElement.current.complete && SVG_REGEX.test(src))
                    : false;
                if (isLoaded) {
                    setLoadState(ImageLoadState.loaded);
                }
            }
        });
        react.exports.useEffect(function () {
            onLoadingStateChange === null || onLoadingStateChange === void 0 ? void 0 : onLoadingStateChange(loadState);
            // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when loadState changes
        }, [loadState]);
        var onImageLoaded = react.exports.useCallback(function (ev) {
            onLoad === null || onLoad === void 0 ? void 0 : onLoad(ev);
            if (src) {
                setLoadState(ImageLoadState.loaded);
            }
        }, [src, onLoad]);
        var onImageError = react.exports.useCallback(function (ev) {
            onError === null || onError === void 0 ? void 0 : onError(ev);
            setLoadState(ImageLoadState.error);
        }, [onError]);
        return [loadState, onImageLoaded, onImageError];
    }
    var ImageBase = react.exports.forwardRef(function (props, forwardedRef) {
        var frameElement = react.exports.useRef();
        var imageElement = react.exports.useRef();
        var _a = useLoadState(props, imageElement), loadState = _a[0], onImageLoaded = _a[1], onImageError = _a[2];
        var imageProps = getNativeProps(props, imgProperties, [
            'width',
            'height',
        ]);
        var src = props.src, alt = props.alt, width = props.width, height = props.height, _b = props.shouldFadeIn, shouldFadeIn = _b === void 0 ? true : _b, shouldStartVisible = props.shouldStartVisible, className = props.className, imageFit = props.imageFit, role = props.role, maximizeFrame = props.maximizeFrame, styles = props.styles, theme = props.theme, loading = props.loading;
        var coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);
        var classNames = getClassNames$d(styles, {
            theme: theme,
            className: className,
            width: width,
            height: height,
            maximizeFrame: maximizeFrame,
            shouldFadeIn: shouldFadeIn,
            shouldStartVisible: shouldStartVisible,
            isLoaded: loadState === ImageLoadState.loaded || (loadState === ImageLoadState.notLoaded && props.shouldStartVisible),
            isLandscape: coverStyle === ImageCoverStyle.landscape,
            isCenter: imageFit === ImageFit.center,
            isCenterContain: imageFit === ImageFit.centerContain,
            isCenterCover: imageFit === ImageFit.centerCover,
            isContain: imageFit === ImageFit.contain,
            isCover: imageFit === ImageFit.cover,
            isNone: imageFit === ImageFit.none,
            isError: loadState === ImageLoadState.error,
            isNotImageFit: imageFit === undefined,
        });
        // If image dimensions aren't specified, the natural size of the image is used.
        return (react.exports.createElement("div", { className: classNames.root, style: { width: width, height: height }, ref: frameElement },
            react.exports.createElement("img", __assign$k({}, imageProps, { onLoad: onImageLoaded, onError: onImageError, key: KEY_PREFIX + props.src || '', className: classNames.image, ref: useMergedRefs(imageElement, forwardedRef), src: src, alt: alt, role: role, loading: loading }))));
    });
    ImageBase.displayName = 'ImageBase';
    function useCoverStyle(props, loadState, imageElement, frameElement) {
        var previousLoadState = react.exports.useRef(loadState);
        var coverStyle = react.exports.useRef();
        if (coverStyle === undefined ||
            (previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded)) {
            coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);
        }
        previousLoadState.current = loadState;
        return coverStyle.current;
    }
    function computeCoverStyle(props, loadState, imageElement, frameElement) {
        var imageFit = props.imageFit, width = props.width, height = props.height;
        // Do not compute cover style if it was already specified in props
        if (props.coverStyle !== undefined) {
            return props.coverStyle;
        }
        else if (loadState === ImageLoadState.loaded &&
            (imageFit === ImageFit.cover ||
                imageFit === ImageFit.contain ||
                imageFit === ImageFit.centerContain ||
                imageFit === ImageFit.centerCover) &&
            imageElement.current &&
            frameElement.current) {
            // Determine the desired ratio using the width and height props.
            // If those props aren't available, measure measure the frame.
            var desiredRatio = void 0;
            if (typeof width === 'number' &&
                typeof height === 'number' &&
                imageFit !== ImageFit.centerContain &&
                imageFit !== ImageFit.centerCover) {
                desiredRatio = width / height;
            }
            else {
                desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;
            }
            // Examine the source image to determine its original ratio.
            var naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;
            // Should we crop from the top or the sides?
            if (naturalRatio > desiredRatio) {
                return ImageCoverStyle.landscape;
            }
        }
        return ImageCoverStyle.portrait;
    }

    var GlobalClassNames$6 = {
        root: 'ms-Image',
        rootMaximizeFrame: 'ms-Image--maximizeFrame',
        image: 'ms-Image-image',
        imageCenter: 'ms-Image-image--center',
        imageContain: 'ms-Image-image--contain',
        imageCover: 'ms-Image-image--cover',
        imageCenterContain: 'ms-Image-image--centerContain',
        imageCenterCover: 'ms-Image-image--centerCover',
        imageNone: 'ms-Image-image--none',
        imageLandscape: 'ms-Image-image--landscape',
        imagePortrait: 'ms-Image-image--portrait',
    };
    var getStyles$m = function (props) {
        var className = props.className, width = props.width, height = props.height, maximizeFrame = props.maximizeFrame, isLoaded = props.isLoaded, shouldFadeIn = props.shouldFadeIn, shouldStartVisible = props.shouldStartVisible, isLandscape = props.isLandscape, isCenter = props.isCenter, isContain = props.isContain, isCover = props.isCover, isCenterContain = props.isCenterContain, isCenterCover = props.isCenterCover, isNone = props.isNone, isError = props.isError, isNotImageFit = props.isNotImageFit, theme = props.theme;
        var classNames = getGlobalClassNames(GlobalClassNames$6, theme);
        var ImageFitStyles = {
            position: 'absolute',
            left: '50% /* @noflip */',
            top: '50%',
            transform: 'translate(-50%,-50%)', // @todo test RTL renders transform: translate(50%,-50%);
        };
        // Cut the mustard using msMaxTouchPoints to detect IE11 which does not support CSS object-fit
        var window = getWindow();
        var supportsObjectFit = window !== undefined && window.navigator.msMaxTouchPoints === undefined;
        var fallbackObjectFitStyles = (isContain && isLandscape) || (isCover && !isLandscape)
            ? { width: '100%', height: 'auto' }
            : { width: 'auto', height: '100%' };
        return {
            root: [
                classNames.root,
                theme.fonts.medium,
                {
                    overflow: 'hidden',
                },
                maximizeFrame && [
                    classNames.rootMaximizeFrame,
                    {
                        height: '100%',
                        width: '100%',
                    },
                ],
                isLoaded && shouldFadeIn && !shouldStartVisible && AnimationClassNames.fadeIn400,
                (isCenter || isContain || isCover || isCenterContain || isCenterCover) && {
                    position: 'relative',
                },
                className,
            ],
            image: [
                classNames.image,
                {
                    display: 'block',
                    opacity: 0,
                },
                isLoaded && [
                    'is-loaded',
                    {
                        opacity: 1,
                    },
                ],
                isCenter && [classNames.imageCenter, ImageFitStyles],
                isContain && [
                    classNames.imageContain,
                    supportsObjectFit && {
                        width: '100%',
                        height: '100%',
                        objectFit: 'contain',
                    },
                    !supportsObjectFit && fallbackObjectFitStyles,
                    !supportsObjectFit && ImageFitStyles,
                ],
                isCover && [
                    classNames.imageCover,
                    supportsObjectFit && {
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                    },
                    !supportsObjectFit && fallbackObjectFitStyles,
                    !supportsObjectFit && ImageFitStyles,
                ],
                isCenterContain && [
                    classNames.imageCenterContain,
                    isLandscape && {
                        maxWidth: '100%',
                    },
                    !isLandscape && {
                        maxHeight: '100%',
                    },
                    ImageFitStyles,
                ],
                isCenterCover && [
                    classNames.imageCenterCover,
                    isLandscape && {
                        maxHeight: '100%',
                    },
                    !isLandscape && {
                        maxWidth: '100%',
                    },
                    ImageFitStyles,
                ],
                isNone && [
                    classNames.imageNone,
                    {
                        width: 'auto',
                        height: 'auto',
                    },
                ],
                isNotImageFit && [
                    !!width &&
                        !height && {
                        height: 'auto',
                        width: '100%',
                    },
                    !width &&
                        !!height && {
                        height: '100%',
                        width: 'auto',
                    },
                    !!width &&
                        !!height && {
                        height: '100%',
                        width: '100%',
                    },
                ],
                isLandscape && classNames.imageLandscape,
                !isLandscape && classNames.imagePortrait,
                !isLoaded && 'is-notLoaded',
                shouldFadeIn && 'is-fadeIn',
                isError && 'is-error',
            ],
        };
    };

    var Image = styled(ImageBase, getStyles$m, undefined, {
        scope: 'Image',
    }, true);
    Image.displayName = 'Image';

    /** Class names used in themeable and non-themeable Icon components */
    var classNames$4 = mergeStyleSets({
        root: {
            display: 'inline-block',
        },
        placeholder: [
            'ms-Icon-placeHolder',
            {
                width: '1em',
            },
        ],
        image: [
            'ms-Icon-imageContainer',
            {
                overflow: 'hidden',
            },
        ],
    });
    /** Class name used only in non-themeable Icon components */
    var MS_ICON = 'ms-Icon';
    var getStyles$l = function (props) {
        var className = props.className, iconClassName = props.iconClassName, isPlaceholder = props.isPlaceholder, isImage = props.isImage, styles = props.styles;
        return {
            root: [
                isPlaceholder && classNames$4.placeholder,
                classNames$4.root,
                isImage && classNames$4.image,
                iconClassName,
                className,
                styles && styles.root,
                // eslint-disable-next-line deprecation/deprecation
                styles && styles.imageContainer,
            ],
        };
    };

    var getIconContent = memoizeFunction(function (iconName) {
        var _a = getIcon(iconName) || {
            subset: {},
            code: undefined,
        }, code = _a.code, subset = _a.subset;
        if (!code) {
            return null;
        }
        return {
            children: code,
            iconClassName: subset.className,
            fontFamily: subset.fontFace && subset.fontFace.fontFamily,
            mergeImageProps: subset.mergeImageProps,
        };
    }, undefined, true /*ignoreNullOrUndefinedResult */);
    /**
     * Fast icon component which only supports font glyphs (not images) and can't be targeted by customizations.
     * To style the icon, use `className` or reference `ms-Icon` in CSS.
     * {@docCategory Icon}
     */
    var FontIcon = function (props) {
        var iconName = props.iconName, className = props.className, _a = props.style, style = _a === void 0 ? {} : _a;
        var iconContent = getIconContent(iconName) || {};
        var iconClassName = iconContent.iconClassName, children = iconContent.children, fontFamily = iconContent.fontFamily, mergeImageProps = iconContent.mergeImageProps;
        var nativeProps = getNativeProps(props, htmlElementProperties);
        var accessibleName = props['aria-label'] || props.title;
        var containerProps = props['aria-label'] || props['aria-labelledby'] || props.title
            ? {
                role: mergeImageProps ? undefined : 'img',
            }
            : {
                'aria-hidden': true,
            };
        var finalChildren = children;
        if (mergeImageProps) {
            if (typeof children === 'object' && typeof children.props === 'object' && accessibleName) {
                finalChildren = react.exports.cloneElement(children, { alt: accessibleName });
            }
        }
        return (react.exports.createElement("i", __assign$k({ "data-icon-name": iconName }, containerProps, nativeProps, (mergeImageProps
            ? {
                title: undefined,
                'aria-label': undefined,
            }
            : {}), { className: css(MS_ICON, classNames$4.root, iconClassName, !iconName && classNames$4.placeholder, className), 
            // Apply the font family this way to ensure it doesn't get overridden by Fabric Core ms-Icon styles
            // https://github.com/microsoft/fluentui/issues/10449
            style: __assign$k({ fontFamily: fontFamily }, style) }), finalChildren));
    };
    /**
     * Memoized helper for rendering a FontIcon.
     * @param iconName - The name of the icon to use from the icon font.
     * @param className - Class name for styling the icon.
     * @param ariaLabel - Label for the icon for the benefit of screen readers.
     * {@docCategory Icon}
     */
    var getFontIcon = memoizeFunction(function (iconName, className, ariaLabel) {
        return FontIcon({ iconName: iconName, className: className, 'aria-label': ariaLabel });
    });

    var getClassNames$c = classNamesFunction({
        // Icon is used a lot by other components.
        // It's likely to see expected cases which pass different className to the Icon.
        // Therefore setting a larger cache size.
        cacheSize: 100,
    });
    var IconBase = /** @class */ (function (_super) {
        __extends$4(IconBase, _super);
        function IconBase(props) {
            var _this = _super.call(this, props) || this;
            _this._onImageLoadingStateChange = function (state) {
                if (_this.props.imageProps && _this.props.imageProps.onLoadingStateChange) {
                    _this.props.imageProps.onLoadingStateChange(state);
                }
                if (state === ImageLoadState.error) {
                    _this.setState({ imageLoadError: true });
                }
            };
            _this.state = {
                imageLoadError: false,
            };
            return _this;
        }
        IconBase.prototype.render = function () {
            var _a = this.props, children = _a.children, className = _a.className, styles = _a.styles, iconName = _a.iconName, imageErrorAs = _a.imageErrorAs, theme = _a.theme;
            var isPlaceholder = typeof iconName === 'string' && iconName.length === 0;
            var isImage = 
            // eslint-disable-next-line deprecation/deprecation
            !!this.props.imageProps || this.props.iconType === IconType.image || this.props.iconType === IconType.Image;
            var iconContent = getIconContent(iconName) || {};
            var iconClassName = iconContent.iconClassName, iconContentChildren = iconContent.children, mergeImageProps = iconContent.mergeImageProps;
            var classNames = getClassNames$c(styles, {
                theme: theme,
                className: className,
                iconClassName: iconClassName,
                isImage: isImage,
                isPlaceholder: isPlaceholder,
            });
            var RootType = isImage ? 'span' : 'i';
            var nativeProps = getNativeProps(this.props, htmlElementProperties, [
                'aria-label',
            ]);
            var imageLoadError = this.state.imageLoadError;
            var imageProps = __assign$k(__assign$k({}, this.props.imageProps), { onLoadingStateChange: this._onImageLoadingStateChange });
            var ImageType = (imageLoadError && imageErrorAs) || Image;
            // eslint-disable-next-line deprecation/deprecation
            var ariaLabel = this.props['aria-label'] || this.props.ariaLabel;
            var accessibleName = imageProps.alt || ariaLabel || this.props.title;
            var hasName = !!(accessibleName ||
                this.props['aria-labelledby'] ||
                imageProps['aria-label'] ||
                imageProps['aria-labelledby']);
            var containerProps = hasName
                ? {
                    role: isImage || mergeImageProps ? undefined : 'img',
                    'aria-label': isImage || mergeImageProps ? undefined : accessibleName,
                }
                : {
                    'aria-hidden': true,
                };
            var finalIconContentChildren = iconContentChildren;
            if (mergeImageProps && iconContentChildren && typeof iconContentChildren === 'object' && accessibleName) {
                finalIconContentChildren = react.exports.cloneElement(iconContentChildren, {
                    alt: accessibleName,
                });
            }
            return (react.exports.createElement(RootType, __assign$k({ "data-icon-name": iconName }, containerProps, nativeProps, (mergeImageProps
                ? {
                    title: undefined,
                    'aria-label': undefined,
                }
                : {}), { className: classNames.root }), isImage ? react.exports.createElement(ImageType, __assign$k({}, imageProps)) : children || finalIconContentChildren));
        };
        return IconBase;
    }(react.exports.Component));

    /**
     * Legacy Icon component which can be targeted by customization. It's recommended to use `FontIcon`
     * or `ImageIcon` instead, especially in scenarios where rendering performance is important.
     * {@docCategory Icon}
     */
    var Icon$1 = styled(IconBase, getStyles$l, undefined, {
        scope: 'Icon',
    }, true);
    Icon$1.displayName = 'Icon';

    /**
     * Fast icon component which only supports images (not font glyphs) and can't be targeted by customizations.
     * To style the icon, use `className` or reference `ms-Icon` in CSS.
     * {@docCategory Icon}
     */
    var ImageIcon = function (props) {
        var className = props.className, imageProps = props.imageProps;
        var nativeProps = getNativeProps(props, htmlElementProperties, [
            'aria-label',
            'aria-labelledby',
            'title',
            'aria-describedby',
        ]);
        var altText = imageProps.alt || props['aria-label'];
        var hasName = altText ||
            props['aria-labelledby'] ||
            props.title ||
            imageProps['aria-label'] ||
            imageProps['aria-labelledby'] ||
            imageProps.title;
        // move naming or describing attributes from the container (where they are invalid) to the image
        var imageNameProps = {
            'aria-labelledby': props['aria-labelledby'],
            'aria-describedby': props['aria-describedby'],
            title: props.title,
        };
        var containerProps = hasName
            ? {}
            : {
                'aria-hidden': true,
            };
        return (react.exports.createElement("div", __assign$k({}, containerProps, nativeProps, { className: css(MS_ICON, classNames$4.root, classNames$4.image, className) }),
            react.exports.createElement(Image, __assign$k({}, imageNameProps, imageProps, { alt: hasName ? altText : '' }))));
    };

    var Icon = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Icon: Icon$1,
        IconBase: IconBase,
        get IconType () { return IconType; },
        getIconContent: getIconContent,
        FontIcon: FontIcon,
        getFontIcon: getFontIcon,
        ImageIcon: ImageIcon
    });

    /**
     * {@docCategory FocusZone}
     */
    var FocusZoneTabbableElements = {
        /** Tabbing is not allowed */
        none: 0,
        /** All tabbing action is allowed */
        all: 1,
        /** Tabbing is allowed only on input elements */
        inputOnly: 2,
    };
    /**
     * {@docCategory FocusZone}
     */
    var FocusZoneDirection;
    (function (FocusZoneDirection) {
        /** Only react to up/down arrows. */
        FocusZoneDirection[FocusZoneDirection["vertical"] = 0] = "vertical";
        /** Only react to left/right arrows. */
        FocusZoneDirection[FocusZoneDirection["horizontal"] = 1] = "horizontal";
        /** React to all arrows. */
        FocusZoneDirection[FocusZoneDirection["bidirectional"] = 2] = "bidirectional";
        /**
         * React to all arrows. Navigate next item in DOM on right/down arrow keys and previous - left/up arrow keys.
         * Right and Left arrow keys are swapped in RTL mode.
         */
        FocusZoneDirection[FocusZoneDirection["domOrder"] = 3] = "domOrder";
    })(FocusZoneDirection || (FocusZoneDirection = {}));

    var IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';
    var IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';
    var FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';
    var TABINDEX = 'tabindex';
    var NO_VERTICAL_WRAP = 'data-no-vertical-wrap';
    var NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';
    var LARGE_DISTANCE_FROM_CENTER = 999999999;
    var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
    var focusZoneStyles;
    var focusZoneClass = 'ms-FocusZone';
    /**
     * Raises a click on a target element based on a keyboard event.
     */
    function raiseClickFromKeyboardEvent(target, ev) {
        var event;
        if (typeof MouseEvent === 'function') {
            event = new MouseEvent('click', {
                ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,
                metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,
                shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,
                altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,
                bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,
                cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable,
            });
        }
        else {
            event = document.createEvent('MouseEvents');
            event.initMouseEvent('click', ev ? ev.bubbles : false, ev ? ev.cancelable : false, window, // not using getWindow() since this can only be run client side
            0, // detail
            0, // screen x
            0, // screen y
            0, // client x
            0, // client y
            ev ? ev.ctrlKey : false, ev ? ev.altKey : false, ev ? ev.shiftKey : false, ev ? ev.metaKey : false, 0, // button
            null);
        }
        target.dispatchEvent(event);
    }
    // Helper function that will return a class for when the root is focused
    function getRootClass() {
        if (!focusZoneStyles) {
            focusZoneStyles = mergeStyles({
                selectors: {
                    ':focus': {
                        outline: 'none',
                    },
                },
            }, focusZoneClass);
        }
        return focusZoneStyles;
    }
    var _allInstances = {};
    var _outerZones = new Set();
    var ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search', 'textarea'];
    var ALLOW_VIRTUAL_ELEMENTS = false;
    var FocusZone$1 = /** @class */ (function (_super) {
        __extends$4(FocusZone, _super);
        function FocusZone(props) {
            var _a, _b, _c, _d;
            var _this = _super.call(this, props) || this;
            _this._root = react.exports.createRef();
            _this._mergedRef = createMergedRef();
            _this._onFocus = function (ev) {
                if (_this._portalContainsElement(ev.target)) {
                    // If the event target is inside a portal do not process the event.
                    return;
                }
                var _a = _this.props, onActiveElementChanged = _a.onActiveElementChanged, 
                // eslint-disable-next-line deprecation/deprecation
                doNotAllowFocusEventToPropagate = _a.doNotAllowFocusEventToPropagate, stopFocusPropagation = _a.stopFocusPropagation, 
                // eslint-disable-next-line deprecation/deprecation
                onFocusNotification = _a.onFocusNotification, onFocus = _a.onFocus, shouldFocusInnerElementWhenReceivedFocus = _a.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _a.defaultTabbableElement;
                var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);
                var newActiveElement;
                if (isImmediateDescendant) {
                    newActiveElement = ev.target;
                }
                else {
                    var parentElement = ev.target;
                    while (parentElement && parentElement !== _this._root.current) {
                        if (isElementTabbable(parentElement) && _this._isImmediateDescendantOfZone(parentElement)) {
                            newActiveElement = parentElement;
                            break;
                        }
                        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
                    }
                }
                // If an inner focusable element should be focused when FocusZone container receives focus
                if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
                    var maybeElementToFocus = defaultTabbableElement &&
                        typeof defaultTabbableElement === 'function' &&
                        _this._root.current &&
                        defaultTabbableElement(_this._root.current);
                    // try to focus defaultTabbable element
                    if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {
                        newActiveElement = maybeElementToFocus;
                        maybeElementToFocus.focus();
                    }
                    else {
                        // force focus on first focusable element
                        _this.focus(true);
                        if (_this._activeElement) {
                            // set to null as new active element was handled in method above
                            newActiveElement = null;
                        }
                    }
                }
                var initialElementFocused = !_this._activeElement;
                // If the new active element is a child of this zone and received focus,
                // update alignment an immediate descendant
                if (newActiveElement && newActiveElement !== _this._activeElement) {
                    if (isImmediateDescendant || initialElementFocused) {
                        _this._setFocusAlignment(newActiveElement, true, true);
                    }
                    _this._activeElement = newActiveElement;
                    if (initialElementFocused) {
                        _this._updateTabIndexes();
                    }
                }
                if (onActiveElementChanged) {
                    onActiveElementChanged(_this._activeElement, ev);
                }
                if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {
                    ev.stopPropagation();
                }
                if (onFocus) {
                    onFocus(ev);
                }
                else if (onFocusNotification) {
                    onFocusNotification();
                }
            };
            _this._onBlur = function () {
                _this._setParkedFocus(false);
            };
            _this._onMouseDown = function (ev) {
                if (_this._portalContainsElement(ev.target)) {
                    // If the event target is inside a portal do not process the event.
                    return;
                }
                var disabled = _this.props.disabled;
                if (disabled) {
                    return;
                }
                var target = ev.target;
                var path = [];
                while (target && target !== _this._root.current) {
                    path.push(target);
                    target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
                }
                while (path.length) {
                    target = path.pop();
                    if (target && isElementTabbable(target)) {
                        _this._setActiveElement(target, true);
                    }
                    if (isElementFocusZone(target)) {
                        // Stop here since the focus zone will take care of its own children.
                        break;
                    }
                }
            };
            /**
             * Handle the keystrokes.
             */
            _this._onKeyDown = function (ev, theme) {
                if (_this._portalContainsElement(ev.target)) {
                    // If the event target is inside a portal do not process the event.
                    return;
                }
                // eslint-disable-next-line deprecation/deprecation
                var _a = _this.props, direction = _a.direction, disabled = _a.disabled, isInnerZoneKeystroke = _a.isInnerZoneKeystroke, pagingSupportDisabled = _a.pagingSupportDisabled, shouldEnterInnerZone = _a.shouldEnterInnerZone;
                if (disabled) {
                    return;
                }
                if (_this.props.onKeyDown) {
                    _this.props.onKeyDown(ev);
                }
                // If the default has been prevented, do not process keyboard events.
                if (ev.isDefaultPrevented()) {
                    return;
                }
                if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {
                    // If this element has focus, it is being controlled by a parent.
                    // Ignore the keystroke.
                    return;
                }
                if (((shouldEnterInnerZone && shouldEnterInnerZone(ev)) || (isInnerZoneKeystroke && isInnerZoneKeystroke(ev))) &&
                    _this._isImmediateDescendantOfZone(ev.target)) {
                    // Try to focus
                    var innerZone = _this._getFirstInnerZone();
                    if (innerZone) {
                        if (!innerZone.focus(true)) {
                            return;
                        }
                    }
                    else if (isElementFocusSubZone(ev.target)) {
                        if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
                            return;
                        }
                    }
                    else {
                        return;
                    }
                }
                else if (ev.altKey) {
                    return;
                }
                else {
                    // eslint-disable-next-line @fluentui/deprecated-keyboard-event-props, deprecation/deprecation
                    switch (ev.which) {
                        case KeyCodes.space:
                            if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                                break;
                            }
                            return;
                        case KeyCodes.left:
                            if (direction !== FocusZoneDirection.vertical) {
                                _this._preventDefaultWhenHandled(ev);
                                if (_this._moveFocusLeft(theme)) {
                                    break;
                                }
                            }
                            return;
                        case KeyCodes.right:
                            if (direction !== FocusZoneDirection.vertical) {
                                _this._preventDefaultWhenHandled(ev);
                                if (_this._moveFocusRight(theme)) {
                                    break;
                                }
                            }
                            return;
                        case KeyCodes.up:
                            if (direction !== FocusZoneDirection.horizontal) {
                                _this._preventDefaultWhenHandled(ev);
                                if (_this._moveFocusUp()) {
                                    break;
                                }
                            }
                            return;
                        case KeyCodes.down:
                            if (direction !== FocusZoneDirection.horizontal) {
                                _this._preventDefaultWhenHandled(ev);
                                if (_this._moveFocusDown()) {
                                    break;
                                }
                            }
                            return;
                        case KeyCodes.pageDown:
                            if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {
                                break;
                            }
                            return;
                        case KeyCodes.pageUp:
                            if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {
                                break;
                            }
                            return;
                        case KeyCodes.tab:
                            if (
                            // eslint-disable-next-line deprecation/deprecation
                            _this.props.allowTabKey ||
                                _this.props.handleTabKey === FocusZoneTabbableElements.all ||
                                (_this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&
                                    _this._isElementInput(ev.target))) {
                                var focusChanged = false;
                                _this._processingTabKey = true;
                                if (direction === FocusZoneDirection.vertical ||
                                    !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                                    focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();
                                }
                                else {
                                    var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;
                                    focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);
                                }
                                _this._processingTabKey = false;
                                if (focusChanged) {
                                    break;
                                }
                                else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
                                    _this._activeElement = null;
                                }
                            }
                            return;
                        case KeyCodes.home:
                            if (_this._isContentEditableElement(ev.target) ||
                                (_this._isElementInput(ev.target) &&
                                    !_this._shouldInputLoseFocus(ev.target, false))) {
                                return false;
                            }
                            var firstChild = _this._root.current && _this._root.current.firstChild;
                            if (_this._root.current &&
                                firstChild &&
                                _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {
                                break;
                            }
                            return;
                        case KeyCodes.end:
                            if (_this._isContentEditableElement(ev.target) ||
                                (_this._isElementInput(ev.target) &&
                                    !_this._shouldInputLoseFocus(ev.target, true))) {
                                return false;
                            }
                            var lastChild = _this._root.current && _this._root.current.lastChild;
                            if (_this._root.current &&
                                _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {
                                break;
                            }
                            return;
                        case KeyCodes.enter:
                            if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                                break;
                            }
                            return;
                        default:
                            return;
                    }
                }
                ev.preventDefault();
                ev.stopPropagation();
            };
            _this._getHorizontalDistanceFromCenter = function (isForward, activeRect, targetRect) {
                // eslint-disable-next-line deprecation/deprecation
                var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;
                // ClientRect values can be floats that differ by very small fractions of a decimal.
                // If the difference between top and bottom are within a pixel then we should treat
                // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
                // but without Math.Floor they will be handled incorrectly.
                var targetRectTop = Math.floor(targetRect.top);
                var activeRectBottom = Math.floor(activeRect.bottom);
                var targetRectBottom = Math.floor(targetRect.bottom);
                var activeRectTop = Math.floor(activeRect.top);
                var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
                var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;
                if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
                    if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                        return 0;
                    }
                    return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
                }
                if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
                    return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                }
                return LARGE_DISTANCE_FROM_CENTER;
            };
            // Manage componentRef resolution.
            initializeComponentRef(_this);
            _this._id = getId('FocusZone');
            _this._focusAlignment = {
                left: 0,
                top: 0,
            };
            _this._processingTabKey = false;
            var shouldRaiseClicksFallback = (_b = (_a = props.shouldRaiseClicks) !== null && _a !== void 0 ? _a : FocusZone.defaultProps.shouldRaiseClicks) !== null && _b !== void 0 ? _b : true;
            _this._shouldRaiseClicksOnEnter = (_c = props.shouldRaiseClicksOnEnter) !== null && _c !== void 0 ? _c : shouldRaiseClicksFallback;
            _this._shouldRaiseClicksOnSpace = (_d = props.shouldRaiseClicksOnSpace) !== null && _d !== void 0 ? _d : shouldRaiseClicksFallback;
            return _this;
        }
        /** Used for testing purposes only. */
        FocusZone.getOuterZones = function () {
            return _outerZones.size;
        };
        /**
         * Handle global tab presses so that we can patch tabindexes on the fly.
         * HEADS UP: This must not be an arrow function in order to be referentially equal among instances
         * for ref counting to work correctly!
         */
        FocusZone._onKeyDownCapture = function (ev) {
            // eslint-disable-next-line deprecation/deprecation, @fluentui/deprecated-keyboard-event-props
            if (ev.which === KeyCodes.tab) {
                _outerZones.forEach(function (zone) { return zone._updateTabIndexes(); });
            }
        };
        FocusZone.prototype.componentDidMount = function () {
            var root = this._root.current;
            _allInstances[this._id] = this;
            if (root) {
                var parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);
                while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {
                    if (isElementFocusZone(parentElement)) {
                        this._isInnerZone = true;
                        break;
                    }
                    parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
                }
                if (!this._isInnerZone) {
                    _outerZones.add(this);
                    this._root.current && this._root.current.addEventListener('keydown', FocusZone._onKeyDownCapture, true);
                }
                this._root.current && this._root.current.addEventListener('blur', this._onBlur, true);
                // Assign initial tab indexes so that we can set initial focus as appropriate.
                this._updateTabIndexes();
                if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {
                    this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);
                    // eslint-disable-next-line deprecation/deprecation
                }
                else if (this.props.defaultActiveElement) {
                    // eslint-disable-next-line deprecation/deprecation
                    this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);
                }
                if (this.props.shouldFocusOnMount) {
                    this.focus();
                }
            }
        };
        FocusZone.prototype.componentDidUpdate = function () {
            var root = this._root.current;
            var doc = this._getDocument();
            // If either _activeElement or _defaultFocusElement are no longer contained by _root,
            // reset those variables (and update tab indexes) to avoid memory leaks
            if ((this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) ||
                (this._defaultFocusElement &&
                    !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS))) {
                this._activeElement = null;
                this._defaultFocusElement = null;
                this._updateTabIndexes();
            }
            if (!this.props.preventFocusRestoration &&
                doc &&
                this._lastIndexPath &&
                (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)) {
                // The element has been removed after the render, attempt to restore focus.
                var elementToFocus = getFocusableByIndexPath(root, this._lastIndexPath);
                if (elementToFocus) {
                    this._setActiveElement(elementToFocus, true);
                    elementToFocus.focus();
                    this._setParkedFocus(false);
                }
                else {
                    // We had a focus path to restore, but now that path is unresolvable. Park focus
                    // on the container until we can try again.
                    this._setParkedFocus(true);
                }
            }
        };
        FocusZone.prototype.componentWillUnmount = function () {
            delete _allInstances[this._id];
            if (!this._isInnerZone) {
                _outerZones.delete(this);
                this._root.current && this._root.current.removeEventListener('keydown', FocusZone._onKeyDownCapture, true);
            }
            if (this._root.current) {
                this._root.current.removeEventListener('blur', this._onBlur, true);
            }
            this._activeElement = null;
            this._defaultFocusElement = null;
        };
        FocusZone.prototype.render = function () {
            var _this = this;
            // eslint-disable-next-line deprecation/deprecation
            var _a = this.props, tag = _a.as, elementType = _a.elementType, rootProps = _a.rootProps, ariaDescribedBy = _a.ariaDescribedBy, ariaLabelledBy = _a.ariaLabelledBy, className = _a.className;
            var divProps = getNativeProps(this.props, htmlElementProperties);
            var Tag = tag || elementType || 'div';
            // Note, right before rendering/reconciling proceeds, we need to record if focus
            // was in the zone before the update. This helper will track this and, if focus
            // was actually in the zone, what the index path to the element is at this time.
            // Then, later in componentDidUpdate, we can evaluate if we need to restore it in
            // the case the element was removed.
            this._evaluateFocusBeforeRender();
            // Only support RTL defined in global theme, not contextual theme/RTL.
            var theme = getTheme();
            return (react.exports.createElement(Tag, __assign$k({ "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy }, divProps, rootProps, { 
                // Once the getClassName correctly memoizes inputs this should
                // be replaced so that className is passed to getRootClass and is included there so
                // the class names will always be in the same order.
                className: css(getRootClass(), className), 
                // eslint-disable-next-line deprecation/deprecation
                ref: this._mergedRef(this.props.elementRef, this._root), "data-focuszone-id": this._id, 
                // eslint-disable-next-line react/jsx-no-bind
                onKeyDown: function (ev) { return _this._onKeyDown(ev, theme); }, onFocus: this._onFocus, onMouseDownCapture: this._onMouseDown }), this.props.children));
        };
        /**
         * Sets focus to the first tabbable item in the zone.
         * @param forceIntoFirstElement - If true, focus will be forced into the first element, even
         * if focus is already in the focus zone.
         * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.
         * @returns True if focus could be set to an active element, false if no operation was taken.
         */
        FocusZone.prototype.focus = function (forceIntoFirstElement, bypassHiddenElements) {
            if (forceIntoFirstElement === void 0) { forceIntoFirstElement = false; }
            if (bypassHiddenElements === void 0) { bypassHiddenElements = false; }
            if (this._root.current) {
                if (!forceIntoFirstElement &&
                    this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&
                    this._isInnerZone) {
                    var ownerZoneElement = this._getOwnerZone(this._root.current);
                    if (ownerZoneElement !== this._root.current) {
                        var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
                        return !!ownerZone && ownerZone.focusElement(this._root.current);
                    }
                    return false;
                }
                else if (!forceIntoFirstElement &&
                    this._activeElement &&
                    elementContains(this._root.current, this._activeElement) &&
                    isElementTabbable(this._activeElement) &&
                    (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))) {
                    this._activeElement.focus();
                    return true;
                }
                else {
                    var firstChild = this._root.current.firstChild;
                    return this.focusElement(getNextElement(this._root.current, firstChild, true, undefined, undefined, undefined, undefined, undefined, bypassHiddenElements));
                }
            }
            return false;
        };
        /**
         * Sets focus to the last tabbable item in the zone.
         * @returns True if focus could be set to an active element, false if no operation was taken.
         */
        FocusZone.prototype.focusLast = function () {
            if (this._root.current) {
                var lastChild = this._root.current && this._root.current.lastChild;
                return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));
            }
            return false;
        };
        /**
         * Sets focus to a specific child element within the zone. This can be used in conjunction with
         * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct
         * location and then focus.)
         * @param element - The child element within the zone to focus.
         * @param forceAlignment - If true, focus alignment will be set according to the element provided.
         * @returns True if focus could be set to an active element, false if no operation was taken.
         */
        FocusZone.prototype.focusElement = function (element, forceAlignment) {
            // eslint-disable-next-line deprecation/deprecation
            var _a = this.props, onBeforeFocus = _a.onBeforeFocus, shouldReceiveFocus = _a.shouldReceiveFocus;
            if ((shouldReceiveFocus && !shouldReceiveFocus(element)) || (onBeforeFocus && !onBeforeFocus(element))) {
                return false;
            }
            if (element) {
                // when we set focus to a specific child, we should recalculate the alignment depending on its position.
                this._setActiveElement(element, forceAlignment);
                if (this._activeElement) {
                    this._activeElement.focus();
                }
                return true;
            }
            return false;
        };
        /**
         * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference,
         * rather than a center based on the last horizontal motion.
         * @param point - the new reference point.
         */
        FocusZone.prototype.setFocusAlignment = function (point) {
            this._focusAlignment = point;
        };
        Object.defineProperty(FocusZone.prototype, "defaultFocusElement", {
            get: function () {
                return this._defaultFocusElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FocusZone.prototype, "activeElement", {
            get: function () {
                return this._activeElement;
            },
            enumerable: false,
            configurable: true
        });
        FocusZone.prototype._evaluateFocusBeforeRender = function () {
            var root = this._root.current;
            var doc = this._getDocument();
            if (doc) {
                var focusedElement = doc.activeElement;
                // Only update the index path if we are not parked on the root.
                if (focusedElement !== root) {
                    var shouldRestoreFocus = elementContains(root, focusedElement, false);
                    this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root, focusedElement) : undefined;
                }
            }
        };
        /**
         * When focus is in the zone at render time but then all focusable elements are removed,
         * we "park" focus temporarily on the root. Once we update with focusable children, we restore
         * focus to the closest path from previous. If the user tabs away from the parked container,
         * we restore focusability to the pre-parked state.
         */
        FocusZone.prototype._setParkedFocus = function (isParked) {
            var root = this._root.current;
            if (root && this._isParked !== isParked) {
                this._isParked = isParked;
                if (isParked) {
                    if (!this.props.allowFocusRoot) {
                        this._parkedTabIndex = root.getAttribute('tabindex');
                        root.setAttribute('tabindex', '-1');
                    }
                    root.focus();
                }
                else if (!this.props.allowFocusRoot) {
                    if (this._parkedTabIndex) {
                        root.setAttribute('tabindex', this._parkedTabIndex);
                        this._parkedTabIndex = undefined;
                    }
                    else {
                        root.removeAttribute('tabindex');
                    }
                }
            }
        };
        FocusZone.prototype._setActiveElement = function (element, forceAlignment) {
            var previousActiveElement = this._activeElement;
            this._activeElement = element;
            if (previousActiveElement) {
                if (isElementFocusZone(previousActiveElement)) {
                    this._updateTabIndexes(previousActiveElement);
                }
                previousActiveElement.tabIndex = -1;
            }
            if (this._activeElement) {
                if (!this._focusAlignment || forceAlignment) {
                    this._setFocusAlignment(element, true, true);
                }
                this._activeElement.tabIndex = 0;
            }
        };
        FocusZone.prototype._preventDefaultWhenHandled = function (ev) {
            this.props.preventDefaultWhenHandled && ev.preventDefault();
        };
        /**
         * Walk up the dom try to find a focusable element.
         */
        FocusZone.prototype._tryInvokeClickForFocusable = function (targetElement, ev) {
            var target = targetElement;
            if (target === this._root.current) {
                return false;
            }
            do {
                if (target.tagName === 'BUTTON' ||
                    target.tagName === 'A' ||
                    target.tagName === 'INPUT' ||
                    target.tagName === 'TEXTAREA' ||
                    target.tagName === 'SUMMARY') {
                    return false;
                }
                if (this._isImmediateDescendantOfZone(target) &&
                    target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&
                    target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {
                    raiseClickFromKeyboardEvent(target, ev);
                    return true;
                }
                target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
            } while (target !== this._root.current);
            return false;
        };
        /**
         * Traverse to find first child zone.
         */
        FocusZone.prototype._getFirstInnerZone = function (rootElement) {
            rootElement = rootElement || this._activeElement || this._root.current;
            if (!rootElement) {
                return null;
            }
            if (isElementFocusZone(rootElement)) {
                return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
            }
            var child = rootElement.firstElementChild;
            while (child) {
                if (isElementFocusZone(child)) {
                    return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
                }
                var match = this._getFirstInnerZone(child);
                if (match) {
                    return match;
                }
                child = child.nextElementSibling;
            }
            return null;
        };
        FocusZone.prototype._moveFocus = function (isForward, getDistanceFromCenter, ev, useDefaultWrap) {
            if (useDefaultWrap === void 0) { useDefaultWrap = true; }
            var element = this._activeElement;
            var candidateDistance = -1;
            var candidateElement = undefined;
            var changedFocus = false;
            var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;
            if (!element || !this._root.current) {
                return false;
            }
            if (this._isElementInput(element)) {
                if (!this._shouldInputLoseFocus(element, isForward)) {
                    return false;
                }
            }
            var activeRect = isBidirectional ? element.getBoundingClientRect() : null;
            do {
                element = (isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element));
                if (isBidirectional) {
                    if (element) {
                        var targetRect = element.getBoundingClientRect();
                        var elementDistance = getDistanceFromCenter(activeRect, targetRect);
                        if (elementDistance === -1 && candidateDistance === -1) {
                            candidateElement = element;
                            break;
                        }
                        if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
                            candidateDistance = elementDistance;
                            candidateElement = element;
                        }
                        if (candidateDistance >= 0 && elementDistance < 0) {
                            break;
                        }
                    }
                }
                else {
                    candidateElement = element;
                    break;
                }
            } while (element);
            // Focus the closest candidate
            if (candidateElement && candidateElement !== this._activeElement) {
                changedFocus = true;
                this.focusElement(candidateElement);
            }
            else if (this.props.isCircularNavigation && useDefaultWrap) {
                if (isForward) {
                    return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
                }
                else {
                    return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
                }
            }
            return changedFocus;
        };
        FocusZone.prototype._moveFocusDown = function () {
            var _this = this;
            var targetTop = -1;
            // eslint-disable-next-line deprecation/deprecation
            var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
            if (this._moveFocus(true, function (activeRect, targetRect) {
                var distance = -1;
                // ClientRect values can be floats that differ by very small fractions of a decimal.
                // If the difference between top and bottom are within a pixel then we should treat
                // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
                // but without Math.Floor they will be handled incorrectly.
                var targetRectTop = Math.floor(targetRect.top);
                var activeRectBottom = Math.floor(activeRect.bottom);
                if (targetRectTop < activeRectBottom) {
                    if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
                        return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                    }
                    return LARGE_DISTANCE_FROM_CENTER;
                }
                if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {
                    targetTop = targetRectTop;
                    if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                        distance = 0;
                    }
                    else {
                        distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
                    }
                }
                return distance;
            })) {
                this._setFocusAlignment(this._activeElement, false, true);
                return true;
            }
            return false;
        };
        FocusZone.prototype._moveFocusUp = function () {
            var _this = this;
            var targetTop = -1;
            // eslint-disable-next-line deprecation/deprecation
            var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
            if (this._moveFocus(false, function (activeRect, targetRect) {
                var distance = -1;
                // ClientRect values can be floats that differ by very small fractions of a decimal.
                // If the difference between top and bottom are within a pixel then we should treat
                // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
                // but without Math.Floor they will be handled incorrectly.
                var targetRectBottom = Math.floor(targetRect.bottom);
                var targetRectTop = Math.floor(targetRect.top);
                var activeRectTop = Math.floor(activeRect.top);
                if (targetRectBottom > activeRectTop) {
                    if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
                        return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                    }
                    return LARGE_DISTANCE_FROM_CENTER;
                }
                if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {
                    targetTop = targetRectTop;
                    if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                        distance = 0;
                    }
                    else {
                        distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
                    }
                }
                return distance;
            })) {
                this._setFocusAlignment(this._activeElement, false, true);
                return true;
            }
            return false;
        };
        FocusZone.prototype._moveFocusLeft = function (theme) {
            var _this = this;
            var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
            if (this._moveFocus(getRTL(theme), function (activeRect, targetRect) {
                var distance = -1;
                var topBottomComparison;
                if (getRTL(theme)) {
                    // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.
                    // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.
                    // This is important, because we want to be comparing the top of the target rect
                    // with the bottom of the active rect.
                    topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
                }
                else {
                    topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
                }
                if (topBottomComparison &&
                    targetRect.right <= activeRect.right &&
                    _this.props.direction !== FocusZoneDirection.vertical) {
                    distance = activeRect.right - targetRect.right;
                }
                else if (!shouldWrap) {
                    distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                }
                return distance;
            }, undefined /*ev*/, shouldWrap)) {
                this._setFocusAlignment(this._activeElement, true, false);
                return true;
            }
            return false;
        };
        FocusZone.prototype._moveFocusRight = function (theme) {
            var _this = this;
            var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
            if (this._moveFocus(!getRTL(theme), function (activeRect, targetRect) {
                var distance = -1;
                var topBottomComparison;
                if (getRTL(theme)) {
                    // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.
                    // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.
                    // This is important, because we want to be comparing the bottom of the target rect
                    // with the top of the active rect.
                    topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
                }
                else {
                    topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
                }
                if (topBottomComparison &&
                    targetRect.left >= activeRect.left &&
                    _this.props.direction !== FocusZoneDirection.vertical) {
                    distance = targetRect.left - activeRect.left;
                }
                else if (!shouldWrap) {
                    distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                }
                return distance;
            }, undefined /*ev*/, shouldWrap)) {
                this._setFocusAlignment(this._activeElement, true, false);
                return true;
            }
            return false;
        };
        FocusZone.prototype._moveFocusPaging = function (isForward, useDefaultWrap) {
            if (useDefaultWrap === void 0) { useDefaultWrap = true; }
            var element = this._activeElement;
            if (!element || !this._root.current) {
                return false;
            }
            if (this._isElementInput(element)) {
                if (!this._shouldInputLoseFocus(element, isForward)) {
                    return false;
                }
            }
            var scrollableParent = findScrollableParent(element);
            if (!scrollableParent) {
                return false;
            }
            var candidateDistance = -1;
            var candidateElement = undefined;
            var targetTop = -1;
            var targetBottom = -1;
            var pagesize = scrollableParent.clientHeight;
            var activeRect = element.getBoundingClientRect();
            do {
                element = isForward
                    ? getNextElement(this._root.current, element)
                    : getPreviousElement(this._root.current, element);
                if (element) {
                    var targetRect = element.getBoundingClientRect();
                    var targetRectTop = Math.floor(targetRect.top);
                    var activeRectBottom = Math.floor(activeRect.bottom);
                    var targetRectBottom = Math.floor(targetRect.bottom);
                    var activeRectTop = Math.floor(activeRect.top);
                    var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);
                    var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
                    var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;
                    if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
                        break;
                    }
                    if (elementDistance > -1) {
                        // for paging down
                        if (isForward && targetRectTop > targetTop) {
                            targetTop = targetRectTop;
                            candidateDistance = elementDistance;
                            candidateElement = element;
                        }
                        else if (!isForward && targetRectBottom < targetBottom) {
                            // for paging up
                            targetBottom = targetRectBottom;
                            candidateDistance = elementDistance;
                            candidateElement = element;
                        }
                        else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
                            candidateDistance = elementDistance;
                            candidateElement = element;
                        }
                    }
                }
            } while (element);
            var changedFocus = false;
            // Focus the closest candidate
            if (candidateElement && candidateElement !== this._activeElement) {
                changedFocus = true;
                this.focusElement(candidateElement);
                this._setFocusAlignment(candidateElement, false, true);
            }
            else if (this.props.isCircularNavigation && useDefaultWrap) {
                if (isForward) {
                    return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
                }
                return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
            }
            return changedFocus;
        };
        FocusZone.prototype._setFocusAlignment = function (element, isHorizontal, isVertical) {
            if (this.props.direction === FocusZoneDirection.bidirectional &&
                (!this._focusAlignment || isHorizontal || isVertical)) {
                var rect = element.getBoundingClientRect();
                var left = rect.left + rect.width / 2;
                var top_1 = rect.top + rect.height / 2;
                if (!this._focusAlignment) {
                    this._focusAlignment = { left: left, top: top_1 };
                }
                if (isHorizontal) {
                    this._focusAlignment.left = left;
                }
                if (isVertical) {
                    this._focusAlignment.top = top_1;
                }
            }
        };
        FocusZone.prototype._isImmediateDescendantOfZone = function (element) {
            return this._getOwnerZone(element) === this._root.current;
        };
        FocusZone.prototype._getOwnerZone = function (element) {
            var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);
            while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {
                if (isElementFocusZone(parentElement)) {
                    return parentElement;
                }
                parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
            }
            return parentElement;
        };
        FocusZone.prototype._updateTabIndexes = function (element) {
            if (!this._activeElement &&
                this.props.defaultTabbableElement &&
                typeof this.props.defaultTabbableElement === 'function') {
                this._activeElement = this.props.defaultTabbableElement(this._root.current);
            }
            if (!element && this._root.current) {
                this._defaultFocusElement = null;
                element = this._root.current;
                if (this._activeElement && !elementContains(element, this._activeElement)) {
                    this._activeElement = null;
                }
            }
            // If active element changes state to disabled, set it to null.
            // Otherwise, we lose keyboard accessibility to other elements in focus zone.
            if (this._activeElement && !isElementTabbable(this._activeElement)) {
                this._activeElement = null;
            }
            var childNodes = element && element.children;
            for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
                var child = childNodes[childIndex];
                if (!isElementFocusZone(child)) {
                    // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.
                    if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {
                        child.setAttribute(TABINDEX, '-1');
                    }
                    if (isElementTabbable(child)) {
                        if (this.props.disabled) {
                            child.setAttribute(TABINDEX, '-1');
                        }
                        else if (!this._isInnerZone &&
                            ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {
                            this._defaultFocusElement = child;
                            if (child.getAttribute(TABINDEX) !== '0') {
                                child.setAttribute(TABINDEX, '0');
                            }
                        }
                        else if (child.getAttribute(TABINDEX) !== '-1') {
                            child.setAttribute(TABINDEX, '-1');
                        }
                    }
                    else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {
                        // Disgusting IE hack. Sad face.
                        child.setAttribute('focusable', 'false');
                    }
                }
                else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {
                    if (!this._isInnerZone &&
                        ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {
                        this._defaultFocusElement = child;
                        if (child.getAttribute(TABINDEX) !== '0') {
                            child.setAttribute(TABINDEX, '0');
                        }
                    }
                    else if (child.getAttribute(TABINDEX) !== '-1') {
                        child.setAttribute(TABINDEX, '-1');
                    }
                }
                this._updateTabIndexes(child);
            }
        };
        FocusZone.prototype._isContentEditableElement = function (element) {
            return element && element.getAttribute('contenteditable') === 'true';
        };
        FocusZone.prototype._isElementInput = function (element) {
            if (element &&
                element.tagName &&
                (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {
                return true;
            }
            return false;
        };
        FocusZone.prototype._shouldInputLoseFocus = function (element, isForward) {
            // If a tab was used, we want to focus on the next element.
            if (!this._processingTabKey &&
                element &&
                element.type &&
                ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
                var selectionStart = element.selectionStart;
                var selectionEnd = element.selectionEnd;
                var isRangeSelected = selectionStart !== selectionEnd;
                var inputValue = element.value;
                var isReadonly = element.readOnly;
                // We shouldn't lose focus in the following cases:
                // 1. There is range selected.
                // 2. When selection start is larger than 0 and it is backward and not readOnly.
                // 3. when selection start is not the end of length, it is forward and not readOnly.
                // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit
                // tab) and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is
                // determined by calling the callback shouldInputLoseFocusOnArrowKey
                if (isRangeSelected ||
                    (selectionStart > 0 && !isForward && !isReadonly) ||
                    (selectionStart !== inputValue.length && isForward && !isReadonly) ||
                    (!!this.props.handleTabKey &&
                        !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))) {
                    return false;
                }
            }
            return true;
        };
        FocusZone.prototype._shouldWrapFocus = function (element, noWrapDataAttribute) {
            return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;
        };
        /**
         * Returns true if the element is a descendant of the FocusZone through a React portal.
         */
        FocusZone.prototype._portalContainsElement = function (element) {
            return element && !!this._root.current && portalContainsElement(element, this._root.current);
        };
        FocusZone.prototype._getDocument = function () {
            return getDocument(this._root.current);
        };
        FocusZone.defaultProps = {
            isCircularNavigation: false,
            direction: FocusZoneDirection.bidirectional,
            shouldRaiseClicks: true,
        };
        return FocusZone;
    }(react.exports.Component));

    var FocusZone = /*#__PURE__*/Object.freeze({
        __proto__: null,
        FocusZone: FocusZone$1,
        get FocusZoneDirection () { return FocusZoneDirection; },
        FocusZoneTabbableElements: FocusZoneTabbableElements
    });

    /**
     * {@docCategory ContextualMenu}
     */
    var ContextualMenuItemType;
    (function (ContextualMenuItemType) {
        ContextualMenuItemType[ContextualMenuItemType["Normal"] = 0] = "Normal";
        ContextualMenuItemType[ContextualMenuItemType["Divider"] = 1] = "Divider";
        ContextualMenuItemType[ContextualMenuItemType["Header"] = 2] = "Header";
        ContextualMenuItemType[ContextualMenuItemType["Section"] = 3] = "Section";
    })(ContextualMenuItemType || (ContextualMenuItemType = {}));

    /**
     * Determines the effective checked state of a menu item.
     *
     * @param item {IContextualMenuItem} to get the check state of.
     * @returns {true} if the item is checked.
     * @returns {false} if the item is unchecked.
     * @returns {null} if the item is not checkable.
     */
    function getIsChecked(item) {
        if (item.canCheck) {
            return !!(item.isChecked || item.checked);
        }
        if (typeof item.isChecked === 'boolean') {
            return item.isChecked;
        }
        if (typeof item.checked === 'boolean') {
            return item.checked;
        }
        // Item is not checkable.
        return null;
    }
    function hasSubmenu(item) {
        // eslint-disable-next-line deprecation/deprecation
        return !!(item.subMenuProps || item.items);
    }
    function isItemDisabled(item) {
        return !!(item.isDisabled || item.disabled);
    }
    function getMenuItemAriaRole(item) {
        var isChecked = getIsChecked(item);
        var canCheck = isChecked !== null;
        return canCheck ? 'menuitemcheckbox' : 'menuitem';
    }

    var defaultIconRenderer = function (props) {
        var item = props.item, classNames = props.classNames;
        var iconProps = item.iconProps;
        return react.exports.createElement(Icon$1, __assign$k({}, iconProps, { className: classNames.icon }));
    };
    var renderItemIcon = function (props) {
        var item = props.item, hasIcons = props.hasIcons;
        if (!hasIcons) {
            return null;
        }
        if (item.onRenderIcon) {
            return item.onRenderIcon(props, defaultIconRenderer);
        }
        return defaultIconRenderer(props);
    };
    var renderCheckMarkIcon = function (_a) {
        var onCheckmarkClick = _a.onCheckmarkClick, item = _a.item, classNames = _a.classNames;
        var isItemChecked = getIsChecked(item);
        if (onCheckmarkClick) {
            // Ensures that the item is passed as the first argument to the checkmark click callback.
            var onClick = function (e) { return onCheckmarkClick(item, e); };
            return (react.exports.createElement(Icon$1, { iconName: item.canCheck !== false && isItemChecked ? 'CheckMark' : '', className: classNames.checkmarkIcon, 
                // eslint-disable-next-line react/jsx-no-bind
                onClick: onClick }));
        }
        return null;
    };
    var renderItemName = function (_a) {
        var item = _a.item, classNames = _a.classNames;
        /* eslint-disable deprecation/deprecation */
        if (item.text || item.name) {
            return react.exports.createElement("span", { className: classNames.label }, item.text || item.name);
        }
        /* eslint-enable deprecation/deprecation */
        return null;
    };
    var renderSecondaryText = function (_a) {
        var item = _a.item, classNames = _a.classNames;
        if (item.secondaryText) {
            return react.exports.createElement("span", { className: classNames.secondaryText }, item.secondaryText);
        }
        return null;
    };
    var renderSubMenuIcon = function (_a) {
        var item = _a.item, classNames = _a.classNames, theme = _a.theme;
        if (hasSubmenu(item)) {
            return (react.exports.createElement(Icon$1, __assign$k({ iconName: getRTL(theme) ? 'ChevronLeft' : 'ChevronRight' }, item.submenuIconProps, { className: classNames.subMenuIcon })));
        }
        return null;
    };
    var ContextualMenuItemBase = /** @class */ (function (_super) {
        __extends$4(ContextualMenuItemBase, _super);
        function ContextualMenuItemBase(props) {
            var _this = _super.call(this, props) || this;
            _this.openSubMenu = function () {
                var _a = _this.props, item = _a.item, openSubMenu = _a.openSubMenu, getSubmenuTarget = _a.getSubmenuTarget;
                if (getSubmenuTarget) {
                    var submenuTarget = getSubmenuTarget();
                    if (hasSubmenu(item) && openSubMenu && submenuTarget) {
                        openSubMenu(item, submenuTarget);
                    }
                }
            };
            _this.dismissSubMenu = function () {
                var _a = _this.props, item = _a.item, dismissSubMenu = _a.dismissSubMenu;
                if (hasSubmenu(item) && dismissSubMenu) {
                    dismissSubMenu();
                }
            };
            _this.dismissMenu = function (dismissAll) {
                var dismissMenu = _this.props.dismissMenu;
                if (dismissMenu) {
                    dismissMenu(undefined /* ev */, dismissAll);
                }
            };
            initializeComponentRef(_this);
            return _this;
        }
        ContextualMenuItemBase.prototype.render = function () {
            var _a = this.props, item = _a.item, classNames = _a.classNames;
            var renderContent = item.onRenderContent || this._renderLayout;
            return (react.exports.createElement("div", { className: item.split ? classNames.linkContentMenu : classNames.linkContent }, renderContent(this.props, {
                renderCheckMarkIcon: renderCheckMarkIcon,
                renderItemIcon: renderItemIcon,
                renderItemName: renderItemName,
                renderSecondaryText: renderSecondaryText,
                renderSubMenuIcon: renderSubMenuIcon,
            })));
        };
        ContextualMenuItemBase.prototype._renderLayout = function (props, defaultRenders) {
            return (react.exports.createElement(react.exports.Fragment, null,
                defaultRenders.renderCheckMarkIcon(props),
                defaultRenders.renderItemIcon(props),
                defaultRenders.renderItemName(props),
                defaultRenders.renderSecondaryText(props),
                defaultRenders.renderSubMenuIcon(props)));
        };
        return ContextualMenuItemBase;
    }(react.exports.Component));

    /**
     * @deprecated use getStyles exported from VerticalDivider.styles.ts
     */
    var getDividerClassNames = memoizeFunction(
    // eslint-disable-next-line deprecation/deprecation
    function (theme) {
        return mergeStyleSets({
            wrapper: {
                display: 'inline-flex',
                height: '100%',
                alignItems: 'center',
            },
            divider: {
                width: 1,
                height: '100%',
                backgroundColor: theme.palette.neutralTertiaryAlt,
            },
        });
    });

    var CONTEXTUAL_MENU_ITEM_HEIGHT = 36;
    var MediumScreenSelector$1 = getScreenSelector(0, ScreenWidthMaxMedium);
    var getItemHighContrastStyles = memoizeFunction(function () {
        var _a;
        return {
            selectors: (_a = {},
                _a[HighContrastSelector] = __assign$k({ backgroundColor: 'Highlight', borderColor: 'Highlight', color: 'HighlightText' }, getHighContrastNoAdjustStyle()),
                _a),
        };
    });
    var getMenuItemStyles = memoizeFunction(function (theme) {
        var _a, _b, _c, _d, _e, _f, _g;
        var semanticColors = theme.semanticColors, fonts = theme.fonts, palette = theme.palette;
        var ContextualMenuItemBackgroundHoverColor = semanticColors.menuItemBackgroundHovered;
        var ContextualMenuItemTextHoverColor = semanticColors.menuItemTextHovered;
        var ContextualMenuItemBackgroundSelectedColor = semanticColors.menuItemBackgroundPressed;
        var ContextualMenuItemDividerColor = semanticColors.bodyDivider;
        var menuItemStyles = {
            item: [
                fonts.medium,
                {
                    color: semanticColors.bodyText,
                    position: 'relative',
                    boxSizing: 'border-box',
                },
            ],
            divider: {
                display: 'block',
                height: '1px',
                backgroundColor: ContextualMenuItemDividerColor,
                position: 'relative',
            },
            root: [
                getFocusStyle(theme),
                fonts.medium,
                {
                    color: semanticColors.bodyText,
                    backgroundColor: 'transparent',
                    border: 'none',
                    width: '100%',
                    height: CONTEXTUAL_MENU_ITEM_HEIGHT,
                    lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
                    display: 'block',
                    cursor: 'pointer',
                    padding: '0px 8px 0 4px',
                    textAlign: 'left',
                },
            ],
            rootDisabled: {
                color: semanticColors.disabledBodyText,
                cursor: 'default',
                pointerEvents: 'none',
                selectors: (_a = {},
                    _a[HighContrastSelector] = __assign$k({ color: 'GrayText', opacity: 1 }, getHighContrastNoAdjustStyle()),
                    _a),
            },
            rootHovered: __assign$k({ backgroundColor: ContextualMenuItemBackgroundHoverColor, color: ContextualMenuItemTextHoverColor, selectors: {
                    '.ms-ContextualMenu-icon': {
                        color: palette.themeDarkAlt,
                    },
                    '.ms-ContextualMenu-submenuIcon': {
                        color: palette.neutralPrimary,
                    },
                } }, getItemHighContrastStyles()),
            rootFocused: __assign$k({ backgroundColor: palette.white }, getItemHighContrastStyles()),
            rootChecked: __assign$k({ selectors: {
                    '.ms-ContextualMenu-checkmarkIcon': {
                        color: palette.neutralPrimary,
                    },
                } }, getItemHighContrastStyles()),
            rootPressed: __assign$k({ backgroundColor: ContextualMenuItemBackgroundSelectedColor, selectors: {
                    '.ms-ContextualMenu-icon': {
                        color: palette.themeDark,
                    },
                    '.ms-ContextualMenu-submenuIcon': {
                        color: palette.neutralPrimary,
                    },
                } }, getItemHighContrastStyles()),
            rootExpanded: __assign$k({ backgroundColor: ContextualMenuItemBackgroundSelectedColor, color: semanticColors.bodyTextChecked }, getItemHighContrastStyles()),
            linkContent: {
                whiteSpace: 'nowrap',
                height: 'inherit',
                display: 'flex',
                alignItems: 'center',
                maxWidth: '100%',
            },
            anchorLink: {
                padding: '0px 8px 0 4px',
                textRendering: 'auto',
                color: 'inherit',
                letterSpacing: 'normal',
                wordSpacing: 'normal',
                textTransform: 'none',
                textIndent: '0px',
                textShadow: 'none',
                textDecoration: 'none',
                boxSizing: 'border-box',
            },
            label: {
                margin: '0 4px',
                verticalAlign: 'middle',
                display: 'inline-block',
                flexGrow: '1',
                textOverflow: 'ellipsis',
                overflow: 'hidden',
                whiteSpace: 'nowrap',
            },
            secondaryText: {
                color: theme.palette.neutralSecondary,
                paddingLeft: '20px',
                textAlign: 'right',
            },
            icon: {
                display: 'inline-block',
                minHeight: '1px',
                maxHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
                fontSize: IconFontSizes.medium,
                width: IconFontSizes.medium,
                margin: '0 4px',
                verticalAlign: 'middle',
                flexShrink: '0',
                selectors: (_b = {},
                    _b[MediumScreenSelector$1] = {
                        fontSize: IconFontSizes.large,
                        width: IconFontSizes.large,
                    },
                    _b),
            },
            iconColor: {
                color: semanticColors.menuIcon,
                selectors: (_c = {},
                    _c[HighContrastSelector] = {
                        color: 'inherit',
                    },
                    _c['$root:hover &'] = {
                        selectors: (_d = {},
                            _d[HighContrastSelector] = {
                                color: 'HighlightText',
                            },
                            _d),
                    },
                    _c['$root:focus &'] = {
                        selectors: (_e = {},
                            _e[HighContrastSelector] = {
                                color: 'HighlightText',
                            },
                            _e),
                    },
                    _c),
            },
            iconDisabled: {
                color: semanticColors.disabledBodyText,
            },
            checkmarkIcon: {
                color: semanticColors.bodySubtext,
                selectors: (_f = {},
                    _f[HighContrastSelector] = {
                        color: 'HighlightText',
                    },
                    _f),
            },
            subMenuIcon: {
                height: CONTEXTUAL_MENU_ITEM_HEIGHT,
                lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
                color: palette.neutralSecondary,
                textAlign: 'center',
                display: 'inline-block',
                verticalAlign: 'middle',
                flexShrink: '0',
                fontSize: IconFontSizes.small,
                selectors: (_g = {
                        ':hover': {
                            color: palette.neutralPrimary,
                        },
                        ':active': {
                            color: palette.neutralPrimary,
                        }
                    },
                    _g[MediumScreenSelector$1] = {
                        fontSize: IconFontSizes.medium, // 16px
                    },
                    _g[HighContrastSelector] = {
                        color: 'HighlightText',
                    },
                    _g),
            },
            splitButtonFlexContainer: [
                getFocusStyle(theme),
                {
                    display: 'flex',
                    height: CONTEXTUAL_MENU_ITEM_HEIGHT,
                    flexWrap: 'nowrap',
                    justifyContent: 'center',
                    alignItems: 'flex-start',
                },
            ],
        };
        return concatStyleSets(menuItemStyles);
    });

    var CONTEXTUAL_SPLIT_MENU_MINWIDTH = '28px';
    var MediumScreenSelector = getScreenSelector(0, ScreenWidthMaxMedium);
    var getSplitButtonVerticalDividerClassNames = memoizeFunction(
    /* eslint-disable deprecation/deprecation */
    function (theme) {
        var _a;
        return mergeStyleSets(getDividerClassNames(theme), {
            /* eslint-enable deprecation/deprecation */
            wrapper: {
                position: 'absolute',
                right: 28,
                selectors: (_a = {},
                    _a[MediumScreenSelector] = {
                        right: 32, // fontSize of the icon increased from 12px to 16px
                    },
                    _a),
            },
            divider: {
                height: 16,
                width: 1,
            },
        });
    });
    var GlobalClassNames$5 = {
        item: 'ms-ContextualMenu-item',
        divider: 'ms-ContextualMenu-divider',
        root: 'ms-ContextualMenu-link',
        isChecked: 'is-checked',
        isExpanded: 'is-expanded',
        isDisabled: 'is-disabled',
        linkContent: 'ms-ContextualMenu-linkContent',
        linkContentMenu: 'ms-ContextualMenu-linkContent',
        icon: 'ms-ContextualMenu-icon',
        iconColor: 'ms-ContextualMenu-iconColor',
        checkmarkIcon: 'ms-ContextualMenu-checkmarkIcon',
        subMenuIcon: 'ms-ContextualMenu-submenuIcon',
        label: 'ms-ContextualMenu-itemText',
        secondaryText: 'ms-ContextualMenu-secondaryText',
        splitMenu: 'ms-ContextualMenu-splitMenu',
        screenReaderText: 'ms-ContextualMenu-screenReaderText',
    };
    /**
     * @deprecated Will be removed in \>= 7.0.
     * This is a package-internal method that has been depended on.
     * It is being kept in this form for backwards compatibility.
     * @internal
     */
    // TODO: Audit perf. impact of and potentially remove memoizeFunction.
    // https://github.com/microsoft/fluentui/issues/5534
    var getItemClassNames = memoizeFunction(function (theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className) {
        var _a, _b, _c, _d;
        var styles = getMenuItemStyles(theme);
        var classNames = getGlobalClassNames(GlobalClassNames$5, theme);
        return mergeStyleSets({
            item: [classNames.item, styles.item, itemClassName],
            divider: [classNames.divider, styles.divider, dividerClassName],
            root: [
                classNames.root,
                styles.root,
                checked && [classNames.isChecked, styles.rootChecked],
                isAnchorLink && styles.anchorLink,
                expanded && [classNames.isExpanded, styles.rootExpanded],
                disabled && [classNames.isDisabled, styles.rootDisabled],
                !disabled &&
                    !expanded && [
                    {
                        selectors: (_a = {
                                ':hover': styles.rootHovered,
                                ':active': styles.rootPressed
                            },
                            _a["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles.rootFocused,
                            _a["." + IsFocusVisibleClassName + " &:hover"] = { background: 'inherit;' },
                            _a),
                    },
                ],
                className,
            ],
            splitPrimary: [
                styles.root,
                {
                    width: "calc(100% - " + CONTEXTUAL_SPLIT_MENU_MINWIDTH + ")",
                },
                checked && ['is-checked', styles.rootChecked],
                (disabled || primaryDisabled) && ['is-disabled', styles.rootDisabled],
                !(disabled || primaryDisabled) &&
                    !checked && [
                    {
                        selectors: (_b = {
                                ':hover': styles.rootHovered
                            },
                            // when hovering over the splitPrimary also affect the splitMenu
                            _b[":hover ~ ." + classNames.splitMenu] = styles.rootHovered,
                            _b[':active'] = styles.rootPressed,
                            _b["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles.rootFocused,
                            _b["." + IsFocusVisibleClassName + " &:hover"] = { background: 'inherit;' },
                            _b),
                    },
                ],
            ],
            splitMenu: [
                classNames.splitMenu,
                styles.root,
                {
                    flexBasis: '0',
                    padding: '0 8px',
                    minWidth: CONTEXTUAL_SPLIT_MENU_MINWIDTH,
                },
                expanded && ['is-expanded', styles.rootExpanded],
                disabled && ['is-disabled', styles.rootDisabled],
                !disabled &&
                    !expanded && [
                    {
                        selectors: (_c = {
                                ':hover': styles.rootHovered,
                                ':active': styles.rootPressed
                            },
                            _c["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles.rootFocused,
                            _c["." + IsFocusVisibleClassName + " &:hover"] = { background: 'inherit;' },
                            _c),
                    },
                ],
            ],
            anchorLink: styles.anchorLink,
            linkContent: [classNames.linkContent, styles.linkContent],
            linkContentMenu: [
                classNames.linkContentMenu,
                styles.linkContent,
                {
                    justifyContent: 'center',
                },
            ],
            icon: [
                classNames.icon,
                knownIcon && styles.iconColor,
                styles.icon,
                iconClassName,
                disabled && [classNames.isDisabled, styles.iconDisabled],
            ],
            iconColor: styles.iconColor,
            checkmarkIcon: [classNames.checkmarkIcon, knownIcon && styles.checkmarkIcon, styles.icon, iconClassName],
            subMenuIcon: [
                classNames.subMenuIcon,
                styles.subMenuIcon,
                subMenuClassName,
                expanded && { color: theme.palette.neutralPrimary },
                disabled && [styles.iconDisabled],
            ],
            label: [classNames.label, styles.label],
            secondaryText: [classNames.secondaryText, styles.secondaryText],
            splitContainer: [
                styles.splitButtonFlexContainer,
                !disabled &&
                    !checked && [
                    {
                        selectors: (_d = {},
                            _d["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles.rootFocused,
                            _d),
                    },
                ],
            ],
            screenReaderText: [
                classNames.screenReaderText,
                styles.screenReaderText,
                hiddenContentStyle,
                { visibility: 'hidden' },
            ],
        });
    });
    /**
     * Wrapper function for generating ContextualMenuItem classNames which adheres to
     * the getStyles API, but invokes memoized className generator function with
     * primitive values.
     *
     * @param props the ContextualMenuItem style props used to generate its styles.
     */
    var getItemStyles = function (props) {
        var theme = props.theme, disabled = props.disabled, expanded = props.expanded, checked = props.checked, isAnchorLink = props.isAnchorLink, knownIcon = props.knownIcon, itemClassName = props.itemClassName, dividerClassName = props.dividerClassName, iconClassName = props.iconClassName, subMenuClassName = props.subMenuClassName, primaryDisabled = props.primaryDisabled, className = props.className;
        // eslint-disable-next-line deprecation/deprecation
        return getItemClassNames(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className);
    };

    /**
     * ContextualMenuItem description
     */
    var ContextualMenuItem = styled(ContextualMenuItemBase, getItemStyles, undefined, { scope: 'ContextualMenuItem' });

    var ContextualMenuItemWrapper = /** @class */ (function (_super) {
        __extends$4(ContextualMenuItemWrapper, _super);
        function ContextualMenuItemWrapper(props) {
            var _this = _super.call(this, props) || this;
            _this._onItemMouseEnter = function (ev) {
                var _a = _this.props, item = _a.item, onItemMouseEnter = _a.onItemMouseEnter;
                if (onItemMouseEnter) {
                    onItemMouseEnter(item, ev, ev.currentTarget);
                }
            };
            _this._onItemClick = function (ev) {
                var _a = _this.props, item = _a.item, onItemClickBase = _a.onItemClickBase;
                if (onItemClickBase) {
                    onItemClickBase(item, ev, ev.currentTarget);
                }
            };
            _this._onItemMouseLeave = function (ev) {
                var _a = _this.props, item = _a.item, onItemMouseLeave = _a.onItemMouseLeave;
                if (onItemMouseLeave) {
                    onItemMouseLeave(item, ev);
                }
            };
            _this._onItemKeyDown = function (ev) {
                var _a = _this.props, item = _a.item, onItemKeyDown = _a.onItemKeyDown;
                if (onItemKeyDown) {
                    onItemKeyDown(item, ev);
                }
            };
            _this._onItemMouseMove = function (ev) {
                var _a = _this.props, item = _a.item, onItemMouseMove = _a.onItemMouseMove;
                if (onItemMouseMove) {
                    onItemMouseMove(item, ev, ev.currentTarget);
                }
            };
            _this._getSubmenuTarget = function () {
                return undefined;
            };
            initializeComponentRef(_this);
            return _this;
        }
        ContextualMenuItemWrapper.prototype.shouldComponentUpdate = function (newProps) {
            return !shallowCompare(newProps, this.props);
        };
        return ContextualMenuItemWrapper;
    }(react.exports.Component));

    var KTP_PREFIX = 'ktp';
    var KTP_SEPARATOR = '-';
    var DATAKTP_TARGET = 'data-ktp-target';
    var DATAKTP_EXECUTE_TARGET = 'data-ktp-execute-target';
    var KTP_LAYER_ID = 'ktp-layer-id';
    // Events
    var KeytipEvents;
    (function (KeytipEvents) {
        KeytipEvents.KEYTIP_ADDED = 'keytipAdded';
        KeytipEvents.KEYTIP_REMOVED = 'keytipRemoved';
        KeytipEvents.KEYTIP_UPDATED = 'keytipUpdated';
        KeytipEvents.PERSISTED_KEYTIP_ADDED = 'persistedKeytipAdded';
        KeytipEvents.PERSISTED_KEYTIP_REMOVED = 'persistedKeytipRemoved';
        KeytipEvents.PERSISTED_KEYTIP_EXECUTE = 'persistedKeytipExecute';
        KeytipEvents.ENTER_KEYTIP_MODE = 'enterKeytipMode';
        KeytipEvents.EXIT_KEYTIP_MODE = 'exitKeytipMode';
    })(KeytipEvents || (KeytipEvents = {}));

    /**
     * This class is responsible for handling registering, updating, and unregistering of keytips
     */
    var KeytipManager = /** @class */ (function () {
        function KeytipManager() {
            this.keytips = {};
            this.persistedKeytips = {};
            this.sequenceMapping = {};
            // This is (and should be) updated and kept in sync
            // with the inKeytipMode in KeytipLayer.
            this.inKeytipMode = false;
            // Boolean that gets checked before entering keytip mode by the KeytipLayer
            // Used for an override in special cases (e.g. Disable entering keytip mode when a modal is shown)
            this.shouldEnterKeytipMode = true;
            // Boolean to indicate whether to delay firing an event to update subscribers of
            // keytip data changed.
            this.delayUpdatingKeytipChange = false;
        }
        /**
         * Static function to get singleton KeytipManager instance
         *
         * @returns Singleton KeytipManager instance
         */
        KeytipManager.getInstance = function () {
            return this._instance;
        };
        /**
         * Initialization code to set set parameters to define
         * how the KeytipManager handles keytip data.
         *
         * @param delayUpdatingKeytipChange - T/F if we should delay notifiying keytip subscribers
         * of keytip changes
         */
        KeytipManager.prototype.init = function (delayUpdatingKeytipChange) {
            this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;
        };
        /**
         * Registers a keytip
         *
         * @param keytipProps - Keytip to register
         * @param persisted - T/F if this keytip should be persisted, default is false
         * @returns Unique ID for this keytip
         */
        KeytipManager.prototype.register = function (keytipProps, persisted) {
            if (persisted === void 0) { persisted = false; }
            var props = keytipProps;
            if (!persisted) {
                // Add the overflowSetSequence if necessary
                props = this.addParentOverflow(keytipProps);
                this.sequenceMapping[props.keySequences.toString()] = props;
            }
            // Create a unique keytip
            var uniqueKeytip = this._getUniqueKtp(props);
            // Add to dictionary
            persisted
                ? (this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip)
                : (this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip);
            // We only want to add something new if we are currently showing keytip mode
            if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
                var event_1 = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;
                EventGroup.raise(this, event_1, {
                    keytip: props,
                    uniqueID: uniqueKeytip.uniqueID,
                });
            }
            return uniqueKeytip.uniqueID;
        };
        /**
         * Update a keytip
         *
         * @param keytipProps - Keytip to update
         * @param uniqueID - Unique ID of this keytip
         */
        KeytipManager.prototype.update = function (keytipProps, uniqueID) {
            var newKeytipProps = this.addParentOverflow(keytipProps);
            var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);
            var oldKeyTip = this.keytips[uniqueID];
            if (oldKeyTip) {
                // Update everything except 'visible'
                uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;
                // Update keytip in this.keytips
                this.keytips[uniqueID] = uniqueKeytip;
                // Update the sequence to be up to date
                delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];
                this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;
                // Raise event only if we are currently in keytip mode
                if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
                    EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {
                        keytip: uniqueKeytip.keytip,
                        uniqueID: uniqueKeytip.uniqueID,
                    });
                }
            }
        };
        /**
         * Unregisters a keytip
         *
         * @param keytipToRemove - IKeytipProps of the keytip to remove
         * @param uniqueID - Unique ID of this keytip
         * @param persisted - T/F if this keytip should be persisted, default is false
         */
        KeytipManager.prototype.unregister = function (keytipToRemove, uniqueID, persisted) {
            if (persisted === void 0) { persisted = false; }
            persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];
            !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];
            var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;
            // Update keytips only if we're in keytip mode
            if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
                EventGroup.raise(this, event, {
                    keytip: keytipToRemove,
                    uniqueID: uniqueID,
                });
            }
        };
        /**
         * Manual call to enter keytip mode
         */
        KeytipManager.prototype.enterKeytipMode = function () {
            EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);
        };
        /**
         * Manual call to exit keytip mode
         */
        KeytipManager.prototype.exitKeytipMode = function () {
            EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);
        };
        /**
         * Gets all IKeytipProps from this.keytips
         *
         * @returns All keytips stored in the manager
         */
        KeytipManager.prototype.getKeytips = function () {
            var _this = this;
            return Object.keys(this.keytips).map(function (key) { return _this.keytips[key].keytip; });
        };
        /**
         * Adds the overflowSetSequence to the keytipProps if its parent keytip also has it
         *
         * @param keytipProps - Keytip props to add overflowSetSequence to if necessary
         * @returns - Modified keytip props, if needed to be modified
         */
        KeytipManager.prototype.addParentOverflow = function (keytipProps) {
            var fullSequence = __spreadArray$2([], keytipProps.keySequences);
            fullSequence.pop();
            if (fullSequence.length !== 0) {
                var parentKeytip = this.sequenceMapping[fullSequence.toString()];
                if (parentKeytip && parentKeytip.overflowSetSequence) {
                    return __assign$k(__assign$k({}, keytipProps), { overflowSetSequence: parentKeytip.overflowSetSequence });
                }
            }
            return keytipProps;
        };
        /**
         * Public function to bind for overflow items that have a submenu
         */
        KeytipManager.prototype.menuExecute = function (overflowButtonSequences, keytipSequences) {
            EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {
                overflowButtonSequences: overflowButtonSequences,
                keytipSequences: keytipSequences,
            });
        };
        /**
         * Creates an IUniqueKeytip object
         *
         * @param keytipProps - IKeytipProps
         * @param uniqueID - Unique ID, will default to the next unique ID if not passed
         * @returns IUniqueKeytip object
         */
        KeytipManager.prototype._getUniqueKtp = function (keytipProps, uniqueID) {
            if (uniqueID === void 0) { uniqueID = getId(); }
            return { keytip: __assign$k({}, keytipProps), uniqueID: uniqueID };
        };
        KeytipManager._instance = new KeytipManager();
        return KeytipManager;
    }());

    /**
     * Converts a whole set of KeySequences into one keytip ID, which will be the ID for the last keytip sequence specified
     * keySequences should not include the initial keytip 'start' sequence.
     *
     * @param keySequences - Full path of IKeySequences for one keytip.
     * @returns String to use for the keytip ID.
     */
    function sequencesToID(keySequences) {
        return keySequences.reduce(function (prevValue, keySequence) {
            return prevValue + KTP_SEPARATOR + keySequence.split('').join(KTP_SEPARATOR);
        }, KTP_PREFIX);
    }
    /**
     * Merges an overflow sequence with a key sequence.
     *
     * @param keySequences - Full sequence for one keytip.
     * @param overflowKeySequences - Full overflow keytip sequence.
     * @returns Sequence that will be used by the keytip when in the overflow.
     */
    function mergeOverflows(keySequences, overflowKeySequences) {
        var overflowSequenceLen = overflowKeySequences.length;
        var overflowSequence = __spreadArray$2([], overflowKeySequences).pop();
        var newKeySequences = __spreadArray$2([], keySequences);
        return addElementAtIndex(newKeySequences, overflowSequenceLen - 1, overflowSequence);
    }
    /**
     * Gets the aria-describedby value to put on the component with this keytip.
     *
     * @param keySequences - KeySequences of the keytip.
     * @returns The aria-describedby value to set on the component with this keytip.
     */
    function getAriaDescribedBy(keySequences) {
        var describedby = ' ' + KTP_LAYER_ID;
        if (!keySequences.length) {
            // Return just the layer ID
            return describedby;
        }
        return describedby + ' ' + sequencesToID(keySequences);
    }

    /**
     * Hook that creates attributes for components which are enabled with Keytip.
     */
    function useKeytipData(options) {
        var uniqueId = react.exports.useRef();
        var keytipProps = options.keytipProps
            ? __assign$k({ disabled: options.disabled }, options.keytipProps) : undefined;
        var keytipManager = useConst(KeytipManager.getInstance());
        var prevOptions = usePrevious(options);
        // useLayoutEffect used to strictly emulate didUpdate/didMount behavior
        useIsomorphicLayoutEffect(function () {
            if (uniqueId.current &&
                keytipProps &&
                ((prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.keytipProps) !== options.keytipProps || (prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.disabled) !== options.disabled)) {
                keytipManager.update(keytipProps, uniqueId.current);
            }
        });
        useIsomorphicLayoutEffect(function () {
            // Register Keytip in KeytipManager
            if (keytipProps) {
                uniqueId.current = keytipManager.register(keytipProps);
            }
            return function () {
                // Unregister Keytip in KeytipManager
                keytipProps && keytipManager.unregister(keytipProps, uniqueId.current);
            };
            // this is meant to run only at mount, and updates are handled separately
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);
        var nativeKeytipProps = {
            ariaDescribedBy: undefined,
            keytipId: undefined,
        };
        if (keytipProps) {
            nativeKeytipProps = getKeytipData(keytipManager, keytipProps, options.ariaDescribedBy);
        }
        return nativeKeytipProps;
    }
    /**
     * Gets the aria- and data- attributes to attach to the component
     * @param keytipProps - options for Keytip
     * @param describedByPrepend - ariaDescribedBy value to prepend
     */
    function getKeytipData(keytipManager, keytipProps, describedByPrepend) {
        // Add the parent overflow sequence if necessary
        var newKeytipProps = keytipManager.addParentOverflow(keytipProps);
        // Construct aria-describedby and data-ktp-id attributes
        var ariaDescribedBy = mergeAriaAttributeValues(describedByPrepend, getAriaDescribedBy(newKeytipProps.keySequences));
        var keySequences = __spreadArray$2([], newKeytipProps.keySequences);
        if (newKeytipProps.overflowSetSequence) {
            keySequences = mergeOverflows(keySequences, newKeytipProps.overflowSetSequence);
        }
        var keytipId = sequencesToID(keySequences);
        return {
            ariaDescribedBy: ariaDescribedBy,
            keytipId: keytipId,
        };
    }

    /**
     * A small element to help the target component correctly read out its aria-describedby for its Keytip
     * {@docCategory Keytips}
     */
    var KeytipData = function (props) {
        var _a;
        var children = props.children, keytipDataProps = __rest(props, ["children"]);
        var _b = useKeytipData(keytipDataProps), keytipId = _b.keytipId, ariaDescribedBy = _b.ariaDescribedBy;
        return children((_a = {},
            _a[DATAKTP_TARGET] = keytipId,
            _a[DATAKTP_EXECUTE_TARGET] = keytipId,
            _a['aria-describedby'] = ariaDescribedBy,
            _a));
    };

    var ContextualMenuAnchor = /** @class */ (function (_super) {
        __extends$4(ContextualMenuAnchor, _super);
        function ContextualMenuAnchor() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._anchor = react.exports.createRef();
            _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {
                return __assign$k(__assign$k({}, keytipProps), { hasMenu: true });
            });
            _this._getSubmenuTarget = function () {
                return _this._anchor.current ? _this._anchor.current : undefined;
            };
            _this._onItemClick = function (ev) {
                var _a = _this.props, item = _a.item, onItemClick = _a.onItemClick;
                if (onItemClick) {
                    onItemClick(item, ev);
                }
            };
            _this._renderAriaDescription = function (ariaDescription, className) {
                // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan
                return ariaDescription ? (react.exports.createElement("span", { id: _this._ariaDescriptionId, className: className }, ariaDescription)) : null;
            };
            return _this;
        }
        ContextualMenuAnchor.prototype.render = function () {
            var _this = this;
            var _a = this.props, item = _a.item, classNames = _a.classNames, index = _a.index, focusableElementIndex = _a.focusableElementIndex, totalItemCount = _a.totalItemCount, hasCheckmarks = _a.hasCheckmarks, hasIcons = _a.hasIcons, _b = _a.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, expandedMenuItemKey = _a.expandedMenuItemKey, onItemClick = _a.onItemClick, openSubMenu = _a.openSubMenu, dismissSubMenu = _a.dismissSubMenu, dismissMenu = _a.dismissMenu;
            var anchorRel = item.rel;
            if (item.target && item.target.toLowerCase() === '_blank') {
                anchorRel = anchorRel ? anchorRel : 'nofollow noopener noreferrer'; // Safe default to prevent tabjacking
            }
            var itemHasSubmenu = hasSubmenu(item);
            var nativeProps = getNativeProps(item, anchorProperties);
            var disabled = isItemDisabled(item);
            var itemProps = item.itemProps, ariaDescription = item.ariaDescription;
            var keytipProps = item.keytipProps;
            if (keytipProps && itemHasSubmenu) {
                keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
            }
            // Check for ariaDescription to set the _ariaDescriptionId and render a hidden span with
            // the description in it to be added to ariaDescribedBy
            if (ariaDescription) {
                this._ariaDescriptionId = getId();
            }
            var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : undefined, nativeProps['aria-describedby']);
            var additionalItemProperties = {
                'aria-describedby': ariaDescribedByIds,
            };
            return (react.exports.createElement("div", null,
                react.exports.createElement(KeytipData, { keytipProps: item.keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled: disabled }, function (keytipAttributes) { return (react.exports.createElement("a", __assign$k({}, additionalItemProperties, nativeProps, keytipAttributes, { ref: _this._anchor, href: item.href, target: item.target, rel: anchorRel, className: classNames.root, role: "menuitem", "aria-haspopup": itemHasSubmenu || undefined, "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : undefined, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, "aria-disabled": isItemDisabled(item), 
                    // eslint-disable-next-line deprecation/deprecation
                    style: item.style, onClick: _this._onItemClick, onMouseEnter: _this._onItemMouseEnter, onMouseLeave: _this._onItemMouseLeave, onMouseMove: _this._onItemMouseMove, onKeyDown: itemHasSubmenu ? _this._onItemKeyDown : undefined }),
                    react.exports.createElement(ChildrenRenderer, __assign$k({ componentRef: item.componentRef, item: item, classNames: classNames, index: index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : undefined, hasIcons: hasIcons, openSubMenu: openSubMenu, dismissSubMenu: dismissSubMenu, dismissMenu: dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
                    _this._renderAriaDescription(ariaDescription, classNames.screenReaderText))); })));
        };
        return ContextualMenuAnchor;
    }(ContextualMenuItemWrapper));

    var ContextualMenuButton = /** @class */ (function (_super) {
        __extends$4(ContextualMenuButton, _super);
        function ContextualMenuButton() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._btn = react.exports.createRef();
            _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {
                return __assign$k(__assign$k({}, keytipProps), { hasMenu: true });
            });
            _this._renderAriaDescription = function (ariaDescription, className) {
                // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan
                return ariaDescription ? (react.exports.createElement("span", { id: _this._ariaDescriptionId, className: className }, ariaDescription)) : null;
            };
            _this._getSubmenuTarget = function () {
                return _this._btn.current ? _this._btn.current : undefined;
            };
            return _this;
        }
        ContextualMenuButton.prototype.render = function () {
            var _this = this;
            var _a = this.props, item = _a.item, classNames = _a.classNames, index = _a.index, focusableElementIndex = _a.focusableElementIndex, totalItemCount = _a.totalItemCount, hasCheckmarks = _a.hasCheckmarks, hasIcons = _a.hasIcons, _b = _a.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, expandedMenuItemKey = _a.expandedMenuItemKey, onItemMouseDown = _a.onItemMouseDown, onItemClick = _a.onItemClick, openSubMenu = _a.openSubMenu, dismissSubMenu = _a.dismissSubMenu, dismissMenu = _a.dismissMenu;
            var isChecked = getIsChecked(item);
            var canCheck = isChecked !== null;
            var defaultRole = getMenuItemAriaRole(item);
            var itemHasSubmenu = hasSubmenu(item);
            var itemProps = item.itemProps, ariaLabel = item.ariaLabel, ariaDescription = item.ariaDescription;
            var buttonNativeProperties = getNativeProps(item, buttonProperties);
            // Do not add the disabled attribute to the button so that it is focusable
            delete buttonNativeProperties.disabled;
            var itemRole = item.role || defaultRole;
            // Check for ariaDescription to set the _ariaDescriptionId and render a hidden span with
            // the description in it to be added to ariaDescribedBy
            if (ariaDescription) {
                this._ariaDescriptionId = getId();
            }
            var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : undefined, buttonNativeProperties['aria-describedby']);
            var itemButtonProperties = {
                className: classNames.root,
                onClick: this._onItemClick,
                onKeyDown: itemHasSubmenu ? this._onItemKeyDown : undefined,
                onMouseEnter: this._onItemMouseEnter,
                onMouseLeave: this._onItemMouseLeave,
                onMouseDown: function (ev) {
                    return onItemMouseDown ? onItemMouseDown(item, ev) : undefined;
                },
                onMouseMove: this._onItemMouseMove,
                href: item.href,
                title: item.title,
                'aria-label': ariaLabel,
                'aria-describedby': ariaDescribedByIds,
                'aria-haspopup': itemHasSubmenu || undefined,
                'aria-expanded': itemHasSubmenu ? item.key === expandedMenuItemKey : undefined,
                'aria-posinset': focusableElementIndex + 1,
                'aria-setsize': totalItemCount,
                'aria-disabled': isItemDisabled(item),
                'aria-checked': (itemRole === 'menuitemcheckbox' || itemRole === 'menuitemradio') && canCheck ? !!isChecked : undefined,
                'aria-selected': itemRole === 'menuitem' && canCheck ? !!isChecked : undefined,
                role: itemRole,
                // eslint-disable-next-line deprecation/deprecation
                style: item.style,
            };
            var keytipProps = item.keytipProps;
            if (keytipProps && itemHasSubmenu) {
                keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
            }
            return (react.exports.createElement(KeytipData, { keytipProps: keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled: isItemDisabled(item) }, function (keytipAttributes) { return (react.exports.createElement("button", __assign$k({ ref: _this._btn }, buttonNativeProperties, itemButtonProperties, keytipAttributes),
                react.exports.createElement(ChildrenRenderer, __assign$k({ componentRef: item.componentRef, item: item, classNames: classNames, index: index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : undefined, hasIcons: hasIcons, openSubMenu: openSubMenu, dismissSubMenu: dismissSubMenu, dismissMenu: dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
                _this._renderAriaDescription(ariaDescription, classNames.screenReaderText))); }));
        };
        return ContextualMenuButton;
    }(ContextualMenuItemWrapper));

    var getStyles$k = function (props) {
        // eslint-disable-next-line deprecation/deprecation
        var theme = props.theme, getClassNames = props.getClassNames, className = props.className;
        if (!theme) {
            throw new Error('Theme is undefined or null.');
        }
        if (getClassNames) {
            var names = getClassNames(theme);
            return {
                wrapper: [names.wrapper],
                divider: [names.divider],
            };
        }
        return {
            wrapper: [
                {
                    display: 'inline-flex',
                    height: '100%',
                    alignItems: 'center',
                },
                className,
            ],
            divider: [
                {
                    width: 1,
                    height: '100%',
                    backgroundColor: theme.palette.neutralTertiaryAlt,
                },
            ],
        };
    };

    var getClassNames$b = classNamesFunction();
    var VerticalDividerBase = react.exports.forwardRef(function (props, ref) {
        // eslint-disable-next-line deprecation/deprecation
        var styles = props.styles, theme = props.theme, deprecatedGetClassNames = props.getClassNames, className = props.className;
        var classNames = getClassNames$b(styles, { theme: theme, getClassNames: deprecatedGetClassNames, className: className });
        return (react.exports.createElement("span", { className: classNames.wrapper, ref: ref },
            react.exports.createElement("span", { className: classNames.divider })));
    });
    VerticalDividerBase.displayName = 'VerticalDividerBase';

    var VerticalDivider = styled(VerticalDividerBase, getStyles$k, undefined, {
        scope: 'VerticalDivider',
    });

    var TouchIdleDelay$1 = 500; /* ms */
    var ContextualMenuSplitButton = /** @class */ (function (_super) {
        __extends$4(ContextualMenuSplitButton, _super);
        function ContextualMenuSplitButton(props) {
            var _this = _super.call(this, props) || this;
            _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {
                return __assign$k(__assign$k({}, keytipProps), { hasMenu: true });
            });
            _this._onItemKeyDown = function (ev) {
                var _a = _this.props, item = _a.item, onItemKeyDown = _a.onItemKeyDown;
                // eslint-disable-next-line deprecation/deprecation
                if (ev.which === KeyCodes.enter) {
                    _this._executeItemClick(ev);
                    ev.preventDefault();
                    ev.stopPropagation();
                }
                else if (onItemKeyDown) {
                    onItemKeyDown(item, ev);
                }
            };
            _this._getSubmenuTarget = function () {
                return _this._splitButton;
            };
            _this._renderAriaDescription = function (ariaDescription, className) {
                // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan
                return ariaDescription ? (react.exports.createElement("span", { id: _this._ariaDescriptionId, className: className }, ariaDescription)) : null;
            };
            _this._onItemMouseEnterPrimary = function (ev) {
                var _a = _this.props, item = _a.item, onItemMouseEnter = _a.onItemMouseEnter;
                if (onItemMouseEnter) {
                    onItemMouseEnter(__assign$k(__assign$k({}, item), { subMenuProps: undefined, items: undefined }), ev, _this._splitButton);
                }
            };
            _this._onItemMouseEnterIcon = function (ev) {
                var _a = _this.props, item = _a.item, onItemMouseEnter = _a.onItemMouseEnter;
                if (onItemMouseEnter) {
                    onItemMouseEnter(item, ev, _this._splitButton);
                }
            };
            _this._onItemMouseMovePrimary = function (ev) {
                var _a = _this.props, item = _a.item, onItemMouseMove = _a.onItemMouseMove;
                if (onItemMouseMove) {
                    onItemMouseMove(__assign$k(__assign$k({}, item), { subMenuProps: undefined, items: undefined }), ev, _this._splitButton);
                }
            };
            _this._onItemMouseMoveIcon = function (ev) {
                var _a = _this.props, item = _a.item, onItemMouseMove = _a.onItemMouseMove;
                if (onItemMouseMove) {
                    onItemMouseMove(item, ev, _this._splitButton);
                }
            };
            _this._onIconItemClick = function (ev) {
                var _a = _this.props, item = _a.item, onItemClickBase = _a.onItemClickBase;
                if (onItemClickBase) {
                    onItemClickBase(item, ev, (_this._splitButton ? _this._splitButton : ev.currentTarget));
                }
            };
            _this._executeItemClick = function (ev) {
                var _a = _this.props, item = _a.item, executeItemClick = _a.executeItemClick, onItemClick = _a.onItemClick;
                if (item.disabled || item.isDisabled) {
                    return;
                }
                if (_this._processingTouch && onItemClick) {
                    return onItemClick(item, ev);
                }
                if (executeItemClick) {
                    executeItemClick(item, ev);
                }
            };
            _this._onTouchStart = function (ev) {
                if (_this._splitButton && !('onpointerdown' in _this._splitButton)) {
                    _this._handleTouchAndPointerEvent(ev);
                }
            };
            _this._onPointerDown = function (ev) {
                if (ev.pointerType === 'touch') {
                    _this._handleTouchAndPointerEvent(ev);
                    ev.preventDefault();
                    ev.stopImmediatePropagation();
                }
            };
            _this._async = new Async(_this);
            _this._events = new EventGroup(_this);
            return _this;
        }
        ContextualMenuSplitButton.prototype.componentDidMount = function () {
            if (this._splitButton && 'onpointerdown' in this._splitButton) {
                this._events.on(this._splitButton, 'pointerdown', this._onPointerDown, true);
            }
        };
        ContextualMenuSplitButton.prototype.componentWillUnmount = function () {
            this._async.dispose();
            this._events.dispose();
        };
        ContextualMenuSplitButton.prototype.render = function () {
            var _this = this;
            var _a = this.props, item = _a.item, classNames = _a.classNames, index = _a.index, focusableElementIndex = _a.focusableElementIndex, totalItemCount = _a.totalItemCount, hasCheckmarks = _a.hasCheckmarks, hasIcons = _a.hasIcons, onItemMouseLeave = _a.onItemMouseLeave, expandedMenuItemKey = _a.expandedMenuItemKey;
            var itemHasSubmenu = hasSubmenu(item);
            var keytipProps = item.keytipProps;
            if (keytipProps) {
                keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
            }
            // Check for ariaDescription to set the _ariaDescriptionId and render a hidden span with
            // the description in it to be added to ariaDescribedBy
            var ariaDescription = item.ariaDescription;
            if (ariaDescription) {
                this._ariaDescriptionId = getId();
            }
            return (react.exports.createElement(KeytipData, { keytipProps: keytipProps, disabled: isItemDisabled(item) }, function (keytipAttributes) { return (react.exports.createElement("div", { "data-ktp-target": keytipAttributes['data-ktp-target'], ref: function (splitButton) { return (_this._splitButton = splitButton); }, role: getMenuItemAriaRole(item), "aria-label": item.ariaLabel, className: classNames.splitContainer, "aria-disabled": isItemDisabled(item), "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : undefined, "aria-haspopup": true, "aria-describedby": mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? _this._ariaDescriptionId : undefined, keytipAttributes['aria-describedby']), "aria-checked": item.isChecked || item.checked, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, onMouseEnter: _this._onItemMouseEnterPrimary, onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(_this, __assign$k(__assign$k({}, item), { subMenuProps: null, items: null })) : undefined, onMouseMove: _this._onItemMouseMovePrimary, onKeyDown: _this._onItemKeyDown, onClick: _this._executeItemClick, onTouchStart: _this._onTouchStart, tabIndex: 0, "data-is-focusable": true, "aria-roledescription": item['aria-roledescription'] },
                _this._renderSplitPrimaryButton(item, classNames, index, hasCheckmarks, hasIcons),
                _this._renderSplitDivider(item),
                _this._renderSplitIconButton(item, classNames, index, keytipAttributes),
                _this._renderAriaDescription(ariaDescription, classNames.screenReaderText))); }));
        };
        ContextualMenuSplitButton.prototype._renderSplitPrimaryButton = function (item, 
        // eslint-disable-next-line deprecation/deprecation
        classNames, index, hasCheckmarks, hasIcons) {
            var _a = this.props, _b = _a.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, onItemClick = _a.onItemClick;
            var itemProps = {
                key: item.key,
                disabled: isItemDisabled(item) || item.primaryDisabled,
                /* eslint-disable deprecation/deprecation */
                name: item.name,
                text: item.text || item.name,
                secondaryText: item.secondaryText,
                /* eslint-enable deprecation/deprecation */
                className: classNames.splitPrimary,
                canCheck: item.canCheck,
                isChecked: item.isChecked,
                checked: item.checked,
                iconProps: item.iconProps,
                onRenderIcon: item.onRenderIcon,
                data: item.data,
                'data-is-focusable': false,
            };
            var itemComponentProps = item.itemProps;
            return (react.exports.createElement("button", __assign$k({}, getNativeProps(itemProps, buttonProperties)),
                react.exports.createElement(ChildrenRenderer, __assign$k({ "data-is-focusable": false, item: itemProps, classNames: classNames, index: index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : undefined, hasIcons: hasIcons }, itemComponentProps))));
        };
        ContextualMenuSplitButton.prototype._renderSplitDivider = function (item) {
            var getDividerClassNames = item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;
            return react.exports.createElement(VerticalDivider, { getClassNames: getDividerClassNames });
        };
        ContextualMenuSplitButton.prototype._renderSplitIconButton = function (item, classNames, // eslint-disable-line deprecation/deprecation
        index, keytipAttributes) {
            var _a = this.props, _b = _a.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, onItemMouseLeave = _a.onItemMouseLeave, onItemMouseDown = _a.onItemMouseDown, openSubMenu = _a.openSubMenu, dismissSubMenu = _a.dismissSubMenu, dismissMenu = _a.dismissMenu;
            var itemProps = {
                onClick: this._onIconItemClick,
                disabled: isItemDisabled(item),
                className: classNames.splitMenu,
                subMenuProps: item.subMenuProps,
                submenuIconProps: item.submenuIconProps,
                split: true,
                key: item.key,
            };
            var buttonProps = __assign$k(__assign$k({}, getNativeProps(itemProps, buttonProperties)), {
                onMouseEnter: this._onItemMouseEnterIcon,
                onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : undefined,
                onMouseDown: function (ev) {
                    return onItemMouseDown ? onItemMouseDown(item, ev) : undefined;
                },
                onMouseMove: this._onItemMouseMoveIcon,
                'data-is-focusable': false,
                'data-ktp-execute-target': keytipAttributes['data-ktp-execute-target'],
                'aria-hidden': true,
            });
            var itemComponentProps = item.itemProps;
            return (react.exports.createElement("button", __assign$k({}, buttonProps),
                react.exports.createElement(ChildrenRenderer, __assign$k({ componentRef: item.componentRef, item: itemProps, classNames: classNames, index: index, hasIcons: false, openSubMenu: openSubMenu, dismissSubMenu: dismissSubMenu, dismissMenu: dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemComponentProps))));
        };
        ContextualMenuSplitButton.prototype._handleTouchAndPointerEvent = function (ev) {
            var _this = this;
            var onTap = this.props.onTap;
            if (onTap) {
                onTap(ev);
            }
            // If we already have an existing timeout from a previous touch/pointer event
            // cancel that timeout so we can set a new one.
            if (this._lastTouchTimeoutId) {
                this._async.clearTimeout(this._lastTouchTimeoutId);
                this._lastTouchTimeoutId = undefined;
            }
            this._processingTouch = true;
            this._lastTouchTimeoutId = this._async.setTimeout(function () {
                _this._processingTouch = false;
                _this._lastTouchTimeoutId = undefined;
            }, TouchIdleDelay$1);
        };
        return ContextualMenuSplitButton;
    }(ContextualMenuItemWrapper));

    var BaseDecorator = /** @class */ (function (_super) {
        __extends$4(BaseDecorator, _super);
        function BaseDecorator(props) {
            var _this = _super.call(this, props) || this;
            _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
            return _this;
        }
        /**
         * Updates the ref to the component composed by the decorator, which will also take care of hoisting
         * (and unhoisting as appropriate) methods from said component.
         *
         * Pass this method as the argument to the 'ref' property of the composed component.
         */
        BaseDecorator.prototype._updateComposedComponentRef = function (composedComponentInstance) {
            this._composedComponentInstance = composedComponentInstance;
            if (composedComponentInstance) {
                this._hoisted = hoistMethods(this, composedComponentInstance);
            }
            else if (this._hoisted) {
                unhoistMethods(this, this._hoisted);
            }
        };
        return BaseDecorator;
    }(react.exports.Component));

    var ResponsiveMode;
    (function (ResponsiveMode) {
        /** Width \<= 479px */
        ResponsiveMode[ResponsiveMode["small"] = 0] = "small";
        /** Width \> 479px and \<= 639px */
        ResponsiveMode[ResponsiveMode["medium"] = 1] = "medium";
        /** Width \> 639px and \<= 1023px */
        ResponsiveMode[ResponsiveMode["large"] = 2] = "large";
        /** Width \> 1023px and \<= 1365px */
        ResponsiveMode[ResponsiveMode["xLarge"] = 3] = "xLarge";
        /** Width \> 1365px and \<= 1919px */
        ResponsiveMode[ResponsiveMode["xxLarge"] = 4] = "xxLarge";
        /** Width \> 1919px */
        ResponsiveMode[ResponsiveMode["xxxLarge"] = 5] = "xxxLarge";
        ResponsiveMode[ResponsiveMode["unknown"] = 999] = "unknown";
    })(ResponsiveMode || (ResponsiveMode = {}));
    var RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];
    /**
     * Tracking the last mode we successfully rendered, which allows us to
     * paint initial renders with the correct size.
     */
    var _lastMode;
    function getInitialResponsiveMode() {
        var _a;
        return (_a = _lastMode) !== null && _a !== void 0 ? _a : ResponsiveMode.large;
    }
    /**
     * @deprecated Decorator usage is deprecated. Either call `getResponsiveMode` manually, or
     * use the `useResponsiveMode` hook within a function component.
     */
    function withResponsiveMode(ComposedComponent) {
        var _a;
        // eslint-disable-next-line deprecation/deprecation
        var resultClass = (_a = /** @class */ (function (_super) {
                __extends$4(WithResponsiveMode, _super);
                function WithResponsiveMode(props) {
                    var _this = _super.call(this, props) || this;
                    _this._onResize = function () {
                        var responsiveMode = getResponsiveMode(_this.context.window);
                        if (responsiveMode !== _this.state.responsiveMode) {
                            _this.setState({
                                responsiveMode: responsiveMode,
                            });
                        }
                    };
                    _this._events = new EventGroup(_this);
                    _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
                    _this.state = {
                        responsiveMode: getInitialResponsiveMode(),
                    };
                    return _this;
                }
                WithResponsiveMode.prototype.componentDidMount = function () {
                    this._events.on(this.context.window, 'resize', this._onResize);
                    this._onResize();
                };
                WithResponsiveMode.prototype.componentWillUnmount = function () {
                    this._events.dispose();
                };
                WithResponsiveMode.prototype.render = function () {
                    var responsiveMode = this.state.responsiveMode;
                    return responsiveMode === ResponsiveMode.unknown ? null : (react.exports.createElement(ComposedComponent, __assign$k({ ref: this._updateComposedComponentRef, responsiveMode: responsiveMode }, this.props)));
                };
                return WithResponsiveMode;
            }(BaseDecorator)),
            _a.contextType = WindowContext,
            _a);
        return hoistStatics(ComposedComponent, resultClass);
    }
    /**
     * Hook to get the current responsive mode (window size category).
     * @param currentWindow - Use this window when determining the responsive mode.
     */
    function getResponsiveMode(currentWindow) {
        var responsiveMode = ResponsiveMode.small;
        if (currentWindow) {
            try {
                while (currentWindow.innerWidth > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {
                    responsiveMode++;
                }
            }
            catch (e) {
                // Return a best effort result in cases where we're in the browser but it throws on getting innerWidth.
                responsiveMode = getInitialResponsiveMode();
            }
            // Tracking last mode just gives us a better default in future renders,
            // which avoids starting with the wrong value if we've measured once.
            _lastMode = responsiveMode;
        }
        else {
            {
                throw new Error('Content was rendered in a server environment without providing a default responsive mode. ' +
                    'Call setResponsiveMode to define what the responsive mode is.');
            }
        }
        return responsiveMode;
    }

    /**
     * Hook to get the current responsive mode (window size category).
     * @param elementRef - Use this element's parent window when determining the responsive mode.
     * @param overrideResponsiveMode - Override the responsive mode. If this param is present, it's always returned.
     */
    var useResponsiveMode = function (elementRef, overrideResponsiveMode) {
        var _a = react.exports.useState(getInitialResponsiveMode()), lastResponsiveMode = _a[0], setLastResponsiveMode = _a[1];
        var onResize = react.exports.useCallback(function () {
            var newResponsiveMode = getResponsiveMode(getWindow(elementRef.current));
            // Setting the same value should not cause a re-render.
            if (lastResponsiveMode !== newResponsiveMode) {
                setLastResponsiveMode(newResponsiveMode);
            }
        }, [elementRef, lastResponsiveMode]);
        var win = useWindow();
        useOnEvent(win, 'resize', onResize);
        // Call resize function initially on mount, or if the override changes from defined to undefined
        // (the effect will run on all override changes, but onResize will only be called if it changed to undefined)
        react.exports.useEffect(function () {
            if (overrideResponsiveMode === undefined) {
                onResize();
            }
            // eslint-disable-next-line react-hooks/exhaustive-deps -- only meant to run on mount or when override changes
        }, [overrideResponsiveMode]);
        return overrideResponsiveMode !== null && overrideResponsiveMode !== void 0 ? overrideResponsiveMode : lastResponsiveMode;
    };

    var MenuContext = react.exports.createContext({});

    var getClassNames$a = classNamesFunction();
    var getContextualMenuItemClassNames = classNamesFunction();
    // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.
    var DEFAULT_PROPS$1 = {
        items: [],
        shouldFocusOnMount: true,
        gapSpace: 0,
        directionalHint: DirectionalHint.bottomAutoEdge,
        beakWidth: 16,
    };
    function getSubmenuItems(item, options) {
        var target = options === null || options === void 0 ? void 0 : options.target;
        // eslint-disable-next-line deprecation/deprecation
        var items = item.subMenuProps ? item.subMenuProps.items : item.items;
        if (items) {
            var overrideItems = [];
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var subItem = items_1[_i];
                if (subItem.preferMenuTargetAsEventTarget) {
                    // For sub-items which need an overridden target, intercept `onClick`
                    var onClick = subItem.onClick, contextItem = __rest(subItem, ["onClick"]);
                    overrideItems.push(__assign$k(__assign$k({}, contextItem), { onClick: getOnClickWithOverrideTarget(onClick, target) }));
                }
                else {
                    overrideItems.push(subItem);
                }
            }
            return overrideItems;
        }
    }
    /**
     * Returns true if a list of menu items can contain a checkbox
     */
    function canAnyMenuItemsCheck(items) {
        return items.some(function (item) {
            if (item.canCheck) {
                return true;
            }
            // If the item is a section, check if any of the items in the section can check.
            if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) { return submenuItem.canCheck === true; })) {
                return true;
            }
            return false;
        });
    }
    var NavigationIdleDelay = 250; /* ms */
    var COMPONENT_NAME$4 = 'ContextualMenu';
    var _getMenuItemStylesFunction = memoizeFunction(function () {
        var styles = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            styles[_i] = arguments[_i];
        }
        return function (styleProps) {
            return concatStyleSetsWithProps.apply(void 0, __spreadArray$2([styleProps, getItemStyles], styles));
        };
    });
    //#region Custom hooks
    function useVisibility(props, targetWindow) {
        var _a = props.hidden, hidden = _a === void 0 ? false : _a, onMenuDismissed = props.onMenuDismissed, onMenuOpened = props.onMenuOpened;
        var previousHidden = usePrevious(hidden);
        var onMenuOpenedRef = react.exports.useRef(onMenuOpened);
        var onMenuClosedRef = react.exports.useRef(onMenuDismissed);
        var propsRef = react.exports.useRef(props);
        onMenuOpenedRef.current = onMenuOpened;
        onMenuClosedRef.current = onMenuDismissed;
        propsRef.current = props;
        react.exports.useEffect(function () {
            var _a, _b;
            // Don't issue dismissed callbacks on initial mount
            if (hidden && previousHidden === false) {
                (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current);
            }
            else if (!hidden && previousHidden !== false) {
                (_b = onMenuOpenedRef.current) === null || _b === void 0 ? void 0 : _b.call(onMenuOpenedRef, propsRef.current);
            }
        }, [hidden, previousHidden]);
        // Issue onDismissedCallback on unmount
        react.exports.useEffect(function () { return function () { var _a; return (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current); }; }, []);
    }
    function useSubMenuState(_a, dismiss) {
        var hidden = _a.hidden, items = _a.items, theme = _a.theme, className = _a.className, id = _a.id, menuTarget = _a.target;
        var _b = react.exports.useState(), expandedMenuItemKey = _b[0], setExpandedMenuItemKey = _b[1];
        var _c = react.exports.useState(), submenuTarget = _c[0], setSubmenuTarget = _c[1];
        var subMenuId = useId(COMPONENT_NAME$4, id);
        var closeSubMenu = react.exports.useCallback(function () {
            setExpandedMenuItemKey(undefined);
            setSubmenuTarget(undefined);
        }, []);
        var openSubMenu = react.exports.useCallback(function (_a, target) {
            var submenuItemKey = _a.key;
            if (expandedMenuItemKey === submenuItemKey) {
                return;
            }
            target.focus();
            setExpandedMenuItemKey(submenuItemKey);
            setSubmenuTarget(target);
        }, [expandedMenuItemKey]);
        react.exports.useEffect(function () {
            if (hidden) {
                closeSubMenu();
            }
        }, [hidden, closeSubMenu]);
        var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);
        var getSubmenuProps = function () {
            var item = findItemByKeyFromItems(expandedMenuItemKey, items);
            var submenuProps = null;
            if (item) {
                submenuProps = {
                    items: getSubmenuItems(item, { target: menuTarget }),
                    target: submenuTarget,
                    onDismiss: onSubMenuDismiss,
                    isSubMenu: true,
                    id: subMenuId,
                    shouldFocusOnMount: true,
                    directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,
                    className: className,
                    gapSpace: 0,
                    isBeakVisible: false,
                };
                if (item.subMenuProps) {
                    assign(submenuProps, item.subMenuProps);
                }
                if (item.preferMenuTargetAsEventTarget) {
                    var onItemClick = item.onItemClick;
                    submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);
                }
            }
            return submenuProps;
        };
        return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];
    }
    function useShouldUpdateFocusOnMouseMove(_a) {
        var delayUpdateFocusOnHover = _a.delayUpdateFocusOnHover, hidden = _a.hidden;
        var shouldUpdateFocusOnMouseEvent = react.exports.useRef(!delayUpdateFocusOnHover);
        var gotMouseMove = react.exports.useRef(false);
        react.exports.useEffect(function () {
            shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;
            gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;
        }, [delayUpdateFocusOnHover, hidden]);
        var onMenuFocusCapture = react.exports.useCallback(function () {
            if (delayUpdateFocusOnHover) {
                shouldUpdateFocusOnMouseEvent.current = false;
            }
        }, [delayUpdateFocusOnHover]);
        return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];
    }
    function usePreviousActiveElement(_a, targetWindow) {
        var hidden = _a.hidden, onRestoreFocus = _a.onRestoreFocus;
        var previousActiveElement = react.exports.useRef();
        var tryFocusPreviousActiveElement = react.exports.useCallback(function (options) {
            var _a, _b;
            if (onRestoreFocus) {
                onRestoreFocus(options);
            }
            else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {
                // Make sure that the focus method actually exists
                // In some cases the object might exist but not be a real element.
                // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.
                (_b = (_a = previousActiveElement.current) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
        }, [onRestoreFocus]);
        useIsomorphicLayoutEffect(function () {
            var _a;
            if (!hidden) {
                previousActiveElement.current = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;
            }
            else if (previousActiveElement.current) {
                tryFocusPreviousActiveElement({
                    originalElement: previousActiveElement.current,
                    containsFocus: true,
                    documentContainsFocus: ((_a = getDocument()) === null || _a === void 0 ? void 0 : _a.hasFocus()) || false,
                });
                previousActiveElement.current = undefined;
            }
        }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement]);
        return [tryFocusPreviousActiveElement];
    }
    function useKeyHandlers(_a, dismiss, hostElement, openSubMenu) {
        var theme = _a.theme, isSubMenu = _a.isSubMenu, _b = _a.focusZoneProps, _c = _b === void 0 ? {} : _b, checkForNoWrap = _c.checkForNoWrap, _d = _c.direction, focusZoneDirection = _d === void 0 ? FocusZoneDirection.vertical : _d;
        /** True if the most recent keydown event was for alt (option) or meta (command). */
        var lastKeyDownWasAltOrMeta = react.exports.useRef();
        /**
         * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;
         * if so, stops event propagation and dismisses menu(s).
         * @param ev - The keyboard event.
         * @param shouldHandleKey - Returns whether we should handle this keyboard event.
         * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.
         * Only does anything if `shouldHandleKey` returns true.
         * @returns Whether the event was handled.
         */
        var keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {
            var handled = false;
            if (shouldHandleKey(ev)) {
                dismiss(ev, dismissAllMenus);
                ev.preventDefault();
                ev.stopPropagation();
                handled = true;
            }
            return handled;
        };
        /**
         * Checks if the submenu should be closed
         */
        var shouldCloseSubMenu = function (ev) {
            var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;
            // eslint-disable-next-line deprecation/deprecation
            if (ev.which !== submenuCloseKey || !isSubMenu) {
                return false;
            }
            return !!(focusZoneDirection === FocusZoneDirection.vertical ||
                (checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap')));
        };
        var shouldHandleKeyDown = function (ev) {
            return (
            // eslint-disable-next-line deprecation/deprecation
            ev.which === KeyCodes.escape ||
                shouldCloseSubMenu(ev) ||
                // eslint-disable-next-line deprecation/deprecation
                (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)));
        };
        var onKeyDown = function (ev) {
            // Take note if we are processing an alt (option) or meta (command) keydown.
            // See comment in shouldHandleKeyUp for reasoning.
            lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);
            // On Mac, pressing escape dismisses all levels of native context menus
            // eslint-disable-next-line deprecation/deprecation
            var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());
            return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);
        };
        /**
         * We close the menu on key up only if ALL of the following are true:
         * - Most recent key down was alt or meta (command)
         * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to
         *   expand/collapse the menu)
         * - We're not on a Mac (or iOS)
         *
         * This is because on Windows, pressing alt moves focus to the application menu bar or similar,
         * closing any open context menus. There is not a similar behavior on Macs.
         */
        var shouldHandleKeyUp = function (ev) {
            var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);
            lastKeyDownWasAltOrMeta.current = false;
            return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());
        };
        var onKeyUp = function (ev) {
            return keyHandler(ev, shouldHandleKeyUp, true /* dismissAllMenus */);
        };
        var onMenuKeyDown = function (ev) {
            // Mark as handled if onKeyDown returns true (for handling collapse cases)
            // or if we are attempting to expand a submenu
            var handled = onKeyDown(ev);
            if (handled || !hostElement.current) {
                return;
            }
            // If we have a modifier key being pressed, we do not want to move focus.
            // Otherwise, handle up and down keys.
            var hasModifier = !!(ev.altKey || ev.metaKey);
            // eslint-disable-next-line deprecation/deprecation
            var isUp = ev.which === KeyCodes.up;
            // eslint-disable-next-line deprecation/deprecation
            var isDown = ev.which === KeyCodes.down;
            if (!hasModifier && (isUp || isDown)) {
                var elementToFocus = isUp
                    ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true)
                    : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);
                if (elementToFocus) {
                    elementToFocus.focus();
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        var onItemKeyDown = function (item, ev) {
            var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;
            if (!item.disabled &&
                // eslint-disable-next-line deprecation/deprecation
                (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))) {
                openSubMenu(item, ev.currentTarget, false);
                ev.preventDefault();
            }
        };
        return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];
    }
    function useScrollHandler(asyncTracker) {
        var isScrollIdle = react.exports.useRef(true);
        var scrollIdleTimeoutId = react.exports.useRef();
        /**
         * Scroll handler for the callout to make sure the mouse events
         * for updating focus are not interacting during scroll
         */
        var onScroll = function () {
            if (!isScrollIdle.current && scrollIdleTimeoutId.current !== undefined) {
                asyncTracker.clearTimeout(scrollIdleTimeoutId.current);
                scrollIdleTimeoutId.current = undefined;
            }
            else {
                isScrollIdle.current = false;
            }
            scrollIdleTimeoutId.current = asyncTracker.setTimeout(function () {
                isScrollIdle.current = true;
            }, NavigationIdleDelay);
        };
        return [onScroll, isScrollIdle];
    }
    function useOnSubmenuDismiss(dismiss, closeSubMenu) {
        var isMountedRef = react.exports.useRef(false);
        react.exports.useEffect(function () {
            isMountedRef.current = true;
            return function () {
                isMountedRef.current = false;
            };
        }, []);
        /**
         * This function is called ASYNCHRONOUSLY, and so there is a chance it is called
         * after the component is unmounted. The isMountedRef is added to prevent
         * from calling setState() after unmount. Do NOT copy this pattern in synchronous
         * code.
         */
        var onSubMenuDismiss = function (ev, dismissAll) {
            if (dismissAll) {
                dismiss(ev, dismissAll);
            }
            else if (isMountedRef.current) {
                closeSubMenu();
            }
        };
        return onSubMenuDismiss;
    }
    function useSubmenuEnterTimer(_a, asyncTracker) {
        var _b = _a.subMenuHoverDelay, subMenuHoverDelay = _b === void 0 ? NavigationIdleDelay : _b;
        var enterTimerRef = react.exports.useRef(undefined);
        var cancelSubMenuTimer = function () {
            if (enterTimerRef.current !== undefined) {
                asyncTracker.clearTimeout(enterTimerRef.current);
                enterTimerRef.current = undefined;
            }
        };
        var startSubmenuTimer = function (onTimerExpired) {
            enterTimerRef.current = asyncTracker.setTimeout(function () {
                onTimerExpired();
                cancelSubMenuTimer();
            }, subMenuHoverDelay);
        };
        return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];
    }
    function useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {
        var menuTarget = props.target;
        var onItemMouseEnterBase = function (item, ev, target) {
            if (shouldUpdateFocusOnMouseEvent.current) {
                gotMouseMove.current = true;
            }
            if (shouldIgnoreMouseEvent()) {
                return;
            }
            updateFocusOnMouseEvent(item, ev, target);
        };
        var onItemMouseMoveBase = function (item, ev, target) {
            var targetElement = ev.currentTarget;
            // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)
            if (shouldUpdateFocusOnMouseEvent.current) {
                gotMouseMove.current = true;
            }
            else {
                return;
            }
            if (!isScrollIdle.current ||
                subMenuEntryTimer.current !== undefined ||
                targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {
                return;
            }
            updateFocusOnMouseEvent(item, ev, target);
        };
        var shouldIgnoreMouseEvent = function () {
            return !isScrollIdle.current || !gotMouseMove.current;
        };
        var onMouseItemLeave = function (item, ev) {
            var _a;
            if (shouldIgnoreMouseEvent()) {
                return;
            }
            cancelSubMenuTimer();
            if (expandedMenuItemKey !== undefined) {
                return;
            }
            /**
             * IE11 focus() method forces parents to scroll to top of element.
             * Edge and IE expose a setActive() function for focusable divs that
             * sets the page focus but does not scroll the parent element.
             */
            if (hostElement.current.setActive) {
                try {
                    hostElement.current.setActive();
                }
                catch (e) {
                    /* no-op */
                }
            }
            else {
                (_a = hostElement.current) === null || _a === void 0 ? void 0 : _a.focus();
            }
        };
        /**
         * Handles updating focus when mouseEnter or mouseMove fire.
         * As part of updating focus, This function will also update
         * the expand/collapse state accordingly.
         */
        var updateFocusOnMouseEvent = function (item, ev, target) {
            var targetElement = target ? target : ev.currentTarget;
            if (item.key === expandedMenuItemKey) {
                return;
            }
            cancelSubMenuTimer();
            // If the menu is not expanded we can update focus without any delay
            if (expandedMenuItemKey === undefined) {
                targetElement.focus();
            }
            // Delay updating expanding/dismissing the submenu
            // and only set focus if we have not already done so
            if (hasSubmenu(item)) {
                ev.stopPropagation();
                startSubmenuTimer(function () {
                    targetElement.focus();
                    openSubMenu(item, targetElement, true);
                });
            }
            else {
                startSubmenuTimer(function () {
                    onSubMenuDismiss(ev);
                    targetElement.focus();
                });
            }
        };
        var onItemClick = function (item, ev) {
            onItemClickBase(item, ev, ev.currentTarget);
        };
        var onItemClickBase = function (item, ev, target) {
            var items = getSubmenuItems(item, { target: menuTarget });
            // Cancel an async menu item hover timeout action from being taken and instead
            // just trigger the click event instead.
            cancelSubMenuTimer();
            if (!hasSubmenu(item) && (!items || !items.length)) {
                // This is an item without a menu. Click it.
                executeItemClick(item, ev);
            }
            else {
                if (item.key !== expandedMenuItemKey) {
                    // This has a collapsed sub menu. Expand it.
                    openSubMenu(item, target, 
                    // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing
                    // "Enter" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates
                    // between a real click event and a keypress event (detail should be the number of mouse clicks).
                    // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).
                    // So we also check the pointerType property, which both Edge and IE set to "mouse" for real clicks
                    // and "" for pressing "Enter" with Narrator on.
                    ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse');
                }
            }
            ev.stopPropagation();
            ev.preventDefault();
        };
        var onAnchorClick = function (item, ev) {
            executeItemClick(item, ev);
            ev.stopPropagation();
        };
        var executeItemClick = function (item, ev) {
            if (item.disabled || item.isDisabled) {
                return;
            }
            if (item.preferMenuTargetAsEventTarget) {
                overrideTarget(ev, menuTarget);
            }
            var shouldDismiss = false;
            if (item.onClick) {
                shouldDismiss = !!item.onClick(ev, item);
            }
            else if (props.onItemClick) {
                shouldDismiss = !!props.onItemClick(ev, item);
            }
            if (shouldDismiss || !ev.defaultPrevented) {
                dismiss(ev, true);
            }
        };
        return [
            onItemMouseEnterBase,
            onItemMouseMoveBase,
            onMouseItemLeave,
            onItemClick,
            onAnchorClick,
            executeItemClick,
            onItemClickBase,
        ];
    }
    //#endregion
    var ContextualMenuBase = react.exports.memo(react.exports.forwardRef(function (propsWithoutDefaults, forwardedRef) {
        var _a;
        var _b = getPropsWithDefaults(DEFAULT_PROPS$1, propsWithoutDefaults); _b.ref; var props = __rest(_b, ["ref"]);
        var hostElement = react.exports.useRef(null);
        var asyncTracker = useAsync();
        var menuId = useId(COMPONENT_NAME$4, props.id);
        var dismiss = function (ev, dismissAll) { var _a; return (_a = props.onDismiss) === null || _a === void 0 ? void 0 : _a.call(props, ev, dismissAll); };
        var _c = useTarget(props.target, hostElement), targetRef = _c[0], targetWindow = _c[1];
        var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow)[0];
        var _d = useSubMenuState(props, dismiss), expandedMenuItemKey = _d[0], openSubMenu = _d[1], getSubmenuProps = _d[2], onSubMenuDismiss = _d[3];
        var _e = useShouldUpdateFocusOnMouseMove(props), shouldUpdateFocusOnMouseEvent = _e[0], gotMouseMove = _e[1], onMenuFocusCapture = _e[2];
        var _f = useScrollHandler(asyncTracker), onScroll = _f[0], isScrollIdle = _f[1];
        var _g = useSubmenuEnterTimer(props, asyncTracker), cancelSubMenuTimer = _g[0], startSubmenuTimer = _g[1], subMenuEntryTimer = _g[2];
        var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);
        useVisibility(props);
        var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu), onKeyDown = _h[0], onKeyUp = _h[1], onMenuKeyDown = _h[2], onItemKeyDown = _h[3];
        var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss), onItemMouseEnterBase = _j[0], onItemMouseMoveBase = _j[1], onMouseItemLeave = _j[2], onItemClick = _j[3], onAnchorClick = _j[4], executeItemClick = _j[5], onItemClickBase = _j[6];
        //#region Render helpers
        var onDefaultRenderMenuList = function (menuListProps, 
        // eslint-disable-next-line deprecation/deprecation
        menuClassNames, defaultRender) {
            var indexCorrection = 0;
            var items = menuListProps.items, totalItemCount = menuListProps.totalItemCount, hasCheckmarks = menuListProps.hasCheckmarks, hasIcons = menuListProps.hasIcons;
            return (react.exports.createElement("ul", { className: menuClassNames.list, onKeyDown: onKeyDown, onKeyUp: onKeyUp, role: 'presentation' }, items.map(function (item, index) {
                var menuItem = renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);
                if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
                    var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
                    indexCorrection += indexIncrease;
                }
                return menuItem;
            })));
        };
        var renderFocusZone = function (children, adjustedFocusZoneProps) {
            var _a = props.focusZoneAs, ChildrenRenderer = _a === void 0 ? FocusZone$1 : _a;
            return react.exports.createElement(ChildrenRenderer, __assign$k({}, adjustedFocusZoneProps), children);
        };
        /**
         * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will
         * cause the menu items to always re-render because the component update is based on shallow comparison.
         */
        var renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, 
        // eslint-disable-next-line deprecation/deprecation
        menuClassNames) {
            var _a;
            var renderedItems = [];
            var iconProps = item.iconProps || { iconName: 'None' };
            var getItemClassNames = item.getItemClassNames, // eslint-disable-line deprecation/deprecation
            itemProps = item.itemProps;
            var styles = itemProps ? itemProps.styles : undefined;
            // We only send a dividerClassName when the item to be rendered is a divider.
            // For all other cases, the default divider style is used.
            var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;
            var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';
            // eslint-disable-next-line deprecation/deprecation
            var itemClassNames;
            // IContextualMenuItem#getItemClassNames for backwards compatibility
            // otherwise uses mergeStyles for class names.
            if (getItemClassNames) {
                itemClassNames = getItemClassNames(props.theme, isItemDisabled(item), expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);
            }
            else {
                var itemStyleProps = {
                    theme: props.theme,
                    disabled: isItemDisabled(item),
                    expanded: expandedMenuItemKey === item.key,
                    checked: !!getIsChecked(item),
                    isAnchorLink: !!item.href,
                    knownIcon: iconProps.iconName !== 'None',
                    itemClassName: item.className,
                    dividerClassName: dividerClassName,
                    iconClassName: iconProps.className,
                    subMenuClassName: subMenuIconClassName,
                    primaryDisabled: item.primaryDisabled,
                };
                // We need to generate default styles then override if styles are provided
                // since the ContextualMenu currently handles item classNames.
                itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a = menuClassNames.subComponentStyles) === null || _a === void 0 ? void 0 : _a.menuItem, styles), itemStyleProps);
            }
            // eslint-disable-next-line deprecation/deprecation
            if (item.text === '-' || item.name === '-') {
                item.itemType = ContextualMenuItemType.Divider;
            }
            switch (item.itemType) {
                case ContextualMenuItemType.Divider:
                    renderedItems.push(renderSeparator(index, itemClassNames));
                    break;
                case ContextualMenuItemType.Header:
                    renderedItems.push(renderSeparator(index, itemClassNames));
                    var headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);
                    renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));
                    break;
                case ContextualMenuItemType.Section:
                    renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons));
                    break;
                default:
                    var defaultRenderNormalItem = function () {
                        return renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);
                    };
                    var menuItem = props.onRenderContextualMenuItem
                        ? props.onRenderContextualMenuItem(item, defaultRenderNormalItem)
                        : defaultRenderNormalItem();
                    renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));
                    break;
            }
            // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.
            // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.
            return react.exports.createElement(react.exports.Fragment, { key: item.key }, renderedItems);
        };
        var defaultMenuItemRenderer = function (item, 
        // eslint-disable-next-line deprecation/deprecation
        menuClassNames) {
            var index = item.index, focusableElementIndex = item.focusableElementIndex, totalItemCount = item.totalItemCount, hasCheckmarks = item.hasCheckmarks, hasIcons = item.hasIcons;
            return renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);
        };
        var renderSectionItem = function (sectionItem, 
        // eslint-disable-next-line deprecation/deprecation
        itemClassNames, 
        // eslint-disable-next-line deprecation/deprecation
        menuClassNames, index, hasCheckmarks, hasIcons) {
            var sectionProps = sectionItem.sectionProps;
            if (!sectionProps) {
                return;
            }
            var headerItem;
            var groupProps;
            if (sectionProps.title) {
                var headerContextualMenuItem = undefined;
                var ariaLabelledby = '';
                if (typeof sectionProps.title === 'string') {
                    // Since title is a user-facing string, it needs to be stripped
                    // of whitespace in order to build a valid element ID
                    var id_1 = menuId + sectionProps.title.replace(/\s/g, '');
                    headerContextualMenuItem = {
                        key: "section-" + sectionProps.title + "-title",
                        itemType: ContextualMenuItemType.Header,
                        text: sectionProps.title,
                        id: id_1,
                    };
                    ariaLabelledby = id_1;
                }
                else {
                    var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\s/g, '');
                    headerContextualMenuItem = __assign$k(__assign$k({}, sectionProps.title), { id: id_2 });
                    ariaLabelledby = id_2;
                }
                if (headerContextualMenuItem) {
                    groupProps = {
                        role: 'group',
                        'aria-labelledby': ariaLabelledby,
                    };
                    headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);
                }
            }
            if (sectionProps.items && sectionProps.items.length > 0) {
                return (react.exports.createElement("li", { role: "presentation", key: sectionProps.key || sectionItem.key || "section-" + index },
                    react.exports.createElement("div", __assign$k({}, groupProps),
                        react.exports.createElement("ul", { className: menuClassNames.list, role: "presentation" },
                            sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true),
                            headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title),
                            sectionProps.items.map(function (contextualMenuItem, itemsIndex) {
                                return renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons, menuClassNames);
                            }),
                            sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true)))));
            }
        };
        var renderListItem = function (content, key, classNames, // eslint-disable-line deprecation/deprecation
        title) {
            return (react.exports.createElement("li", { role: "presentation", title: title, key: key, className: classNames.item }, content));
        };
        var renderSeparator = function (index, classNames, // eslint-disable-line deprecation/deprecation
        top, fromSection) {
            if (fromSection || index > 0) {
                return (react.exports.createElement("li", { role: "separator", key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'), className: classNames.divider, "aria-hidden": "true" }));
            }
            return null;
        };
        var renderNormalItem = function (item, classNames, // eslint-disable-line deprecation/deprecation
        index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
            if (item.onRender) {
                return item.onRender(__assign$k({ 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount }, item), dismiss);
            }
            var contextualMenuItemAs = props.contextualMenuItemAs;
            var commonProps = {
                item: item,
                classNames: classNames,
                index: index,
                focusableElementIndex: focusableElementIndex,
                totalItemCount: totalItemCount,
                hasCheckmarks: hasCheckmarks,
                hasIcons: hasIcons,
                contextualMenuItemAs: contextualMenuItemAs,
                onItemMouseEnter: onItemMouseEnterBase,
                onItemMouseLeave: onMouseItemLeave,
                onItemMouseMove: onItemMouseMoveBase,
                onItemMouseDown: onItemMouseDown,
                executeItemClick: executeItemClick,
                onItemKeyDown: onItemKeyDown,
                expandedMenuItemKey: expandedMenuItemKey,
                openSubMenu: openSubMenu,
                dismissSubMenu: onSubMenuDismiss,
                dismissMenu: dismiss,
            };
            if (item.href) {
                return react.exports.createElement(ContextualMenuAnchor, __assign$k({}, commonProps, { onItemClick: onAnchorClick }));
            }
            if (item.split && hasSubmenu(item)) {
                return (react.exports.createElement(ContextualMenuSplitButton, __assign$k({}, commonProps, { onItemClick: onItemClick, onItemClickBase: onItemClickBase, onTap: cancelSubMenuTimer })));
            }
            return react.exports.createElement(ContextualMenuButton, __assign$k({}, commonProps, { onItemClick: onItemClick, onItemClickBase: onItemClickBase }));
        };
        var renderHeaderMenuItem = function (item, 
        // eslint-disable-next-line deprecation/deprecation
        itemClassNames, 
        // eslint-disable-next-line deprecation/deprecation
        menuClassNames, index, hasCheckmarks, hasIcons) {
            var _a = props.contextualMenuItemAs, ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;
            var itemProps = item.itemProps, id = item.id;
            var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);
            return (
            // eslint-disable-next-line deprecation/deprecation
            react.exports.createElement("div", __assign$k({ id: id, className: menuClassNames.header }, divHtmlProperties, { style: item.style }),
                react.exports.createElement(ChildrenRenderer, __assign$k({ item: item, classNames: itemClassNames, index: index, onCheckmarkClick: hasCheckmarks ? onItemClick : undefined, hasIcons: hasIcons }, itemProps))));
        };
        //#endregion
        //#region Main render
        var isBeakVisible = props.isBeakVisible;
        var items = props.items, labelElementId = props.labelElementId, id = props.id, className = props.className, beakWidth = props.beakWidth, directionalHint = props.directionalHint, directionalHintForRTL = props.directionalHintForRTL, alignTargetEdge = props.alignTargetEdge, gapSpace = props.gapSpace, coverTarget = props.coverTarget, ariaLabel = props.ariaLabel, doNotLayer = props.doNotLayer, target = props.target, bounds = props.bounds, useTargetWidth = props.useTargetWidth, useTargetAsMinWidth = props.useTargetAsMinWidth, directionalHintFixed = props.directionalHintFixed, shouldFocusOnMount = props.shouldFocusOnMount, shouldFocusOnContainer = props.shouldFocusOnContainer, title = props.title, styles = props.styles, theme = props.theme, calloutProps = props.calloutProps, _k = props.onRenderSubMenu, onRenderSubMenu = _k === void 0 ? onDefaultRenderSubMenu : _k, _l = props.onRenderMenuList, onRenderMenuList = _l === void 0 ? function (menuListProps, defaultRender) { return onDefaultRenderMenuList(menuListProps, classNames); } : _l, focusZoneProps = props.focusZoneProps, 
        // eslint-disable-next-line deprecation/deprecation
        getMenuClassNames = props.getMenuClassNames;
        var classNames = getMenuClassNames
            ? getMenuClassNames(theme, className)
            : getClassNames$a(styles, {
                theme: theme,
                className: className,
            });
        var hasIcons = itemsHaveIcons(items);
        function itemsHaveIcons(contextualMenuItems) {
            for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {
                var item = contextualMenuItems_1[_i];
                if (item.iconProps) {
                    return true;
                }
                if (item.itemType === ContextualMenuItemType.Section &&
                    item.sectionProps &&
                    itemsHaveIcons(item.sectionProps.items)) {
                    return true;
                }
            }
            return false;
        }
        var adjustedFocusZoneProps = __assign$k(__assign$k({ direction: FocusZoneDirection.vertical, handleTabKey: FocusZoneTabbableElements.all, isCircularNavigation: true }, focusZoneProps), { className: css(classNames.root, (_a = props.focusZoneProps) === null || _a === void 0 ? void 0 : _a.className) });
        var hasCheckmarks = canAnyMenuItemsCheck(items);
        var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;
        isBeakVisible = isBeakVisible === undefined ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;
        /**
         * When useTargetWidth is true, get the width of the target element and apply it for the context menu container
         */
        var contextMenuStyle;
        var targetAsHtmlElement = targetRef.current;
        if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {
            var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();
            var targetWidth = targetBoundingRect.width - 2; /* Accounts for 1px border */
            if (useTargetWidth) {
                contextMenuStyle = {
                    width: targetWidth,
                };
            }
            else if (useTargetAsMinWidth) {
                contextMenuStyle = {
                    minWidth: targetWidth,
                };
            }
        }
        // The menu should only return if items were provided, if no items were provided then it should not appear.
        if (items && items.length > 0) {
            var totalItemCount_1 = 0;
            for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
                var item = items_2[_i];
                if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
                    var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
                    totalItemCount_1 += itemCount;
                }
            }
            var calloutStyles_1 = classNames.subComponentStyles
                ? classNames.subComponentStyles.callout
                : undefined;
            return (react.exports.createElement(MenuContext.Consumer, null, function (menuContext) { return (react.exports.createElement(Callout$1, __assign$k({ styles: calloutStyles_1, onRestoreFocus: tryFocusPreviousActiveElement }, calloutProps, { target: target || menuContext.target, isBeakVisible: isBeakVisible, beakWidth: beakWidth, directionalHint: directionalHint, directionalHintForRTL: directionalHintForRTL, gapSpace: gapSpace, coverTarget: coverTarget, doNotLayer: doNotLayer, className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className), setInitialFocus: shouldFocusOnMount, onDismiss: props.onDismiss || menuContext.onDismiss, onScroll: onScroll, bounds: bounds, directionalHintFixed: directionalHintFixed, alignTargetEdge: alignTargetEdge, hidden: props.hidden || menuContext.hidden, ref: forwardedRef }),
                react.exports.createElement("div", { style: contextMenuStyle, ref: hostElement, id: id, className: classNames.container, tabIndex: shouldFocusOnContainer ? 0 : -1, onKeyDown: onMenuKeyDown, onKeyUp: onKeyUp, onFocusCapture: onMenuFocusCapture, "aria-label": ariaLabel, "aria-labelledby": labelElementId, role: 'menu' },
                    title && react.exports.createElement("div", { className: classNames.title },
                        " ",
                        title,
                        " "),
                    items && items.length
                        ? renderFocusZone(onRenderMenuList({
                            ariaLabel: ariaLabel,
                            items: items,
                            totalItemCount: totalItemCount_1,
                            hasCheckmarks: hasCheckmarks,
                            hasIcons: hasIcons,
                            defaultMenuItemRenderer: function (item) {
                                return defaultMenuItemRenderer(item, classNames);
                            },
                            labelElementId: labelElementId,
                        }, function (menuListProps, defaultRender) { return onDefaultRenderMenuList(menuListProps, classNames); }), adjustedFocusZoneProps)
                        : null,
                    submenuProps && onRenderSubMenu(submenuProps, onDefaultRenderSubMenu)))); }));
        }
        else {
            return null;
        }
        //#endregion
    }), function (prevProps, newProps) {
        if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {
            // Do not update when hidden.
            return true;
        }
        return shallowCompare(prevProps, newProps);
    });
    ContextualMenuBase.displayName = 'ContextualMenuBase';
    /**
     * Returns true if the key for the event is alt (Mac option) or meta (Mac command).
     */
    function isAltOrMeta(ev) {
        // eslint-disable-next-line deprecation/deprecation
        return ev.which === KeyCodes.alt || ev.key === 'Meta';
    }
    function onItemMouseDown(item, ev) {
        var _a;
        (_a = item.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(item, item, ev);
    }
    function onDefaultRenderSubMenu(subMenuProps, defaultRender) {
        throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' +
            'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');
    }
    /**
     * Returns the item that matches a given key if any.
     * @param key - The key of the item to match
     * @param items - The items to look for the key
     */
    function findItemByKeyFromItems(key, items) {
        for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
            var item = items_3[_i];
            if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {
                var match = findItemByKeyFromItems(key, item.sectionProps.items);
                if (match) {
                    return match;
                }
            }
            else if (item.key && item.key === key) {
                return item;
            }
        }
    }
    function getOnClickWithOverrideTarget(onClick, target) {
        return onClick
            ? function (ev, item) {
                overrideTarget(ev, target);
                return onClick(ev, item);
            }
            : onClick;
    }
    function overrideTarget(ev, target) {
        if (ev && target) {
            ev.persist();
            if (target instanceof Event) {
                ev.target = target.target;
            }
            else if (target instanceof Element) {
                ev.target = target;
            }
        }
    }

    var GlobalClassNames$4 = {
        root: 'ms-ContextualMenu',
        container: 'ms-ContextualMenu-container',
        list: 'ms-ContextualMenu-list',
        header: 'ms-ContextualMenu-header',
        title: 'ms-ContextualMenu-title',
        isopen: 'is-open',
    };
    var getStyles$j = function (props) {
        var className = props.className, theme = props.theme;
        var classNames = getGlobalClassNames(GlobalClassNames$4, theme);
        var fonts = theme.fonts, semanticColors = theme.semanticColors, effects = theme.effects;
        return {
            root: [
                theme.fonts.medium,
                classNames.root,
                classNames.isopen,
                {
                    backgroundColor: semanticColors.menuBackground,
                    minWidth: '180px',
                },
                className,
            ],
            container: [
                classNames.container,
                {
                    selectors: {
                        ':focus': { outline: 0 },
                    },
                },
            ],
            list: [
                classNames.list,
                classNames.isopen,
                {
                    listStyleType: 'none',
                    margin: '0',
                    padding: '0',
                },
            ],
            header: [
                classNames.header,
                fonts.small,
                {
                    fontWeight: FontWeights.semibold,
                    color: semanticColors.menuHeader,
                    background: 'none',
                    backgroundColor: 'transparent',
                    border: 'none',
                    height: CONTEXTUAL_MENU_ITEM_HEIGHT,
                    lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
                    cursor: 'default',
                    padding: '0px 6px',
                    userSelect: 'none',
                    textAlign: 'left',
                },
            ],
            title: [
                classNames.title,
                {
                    fontSize: fonts.mediumPlus.fontSize,
                    paddingRight: '14px',
                    paddingLeft: '14px',
                    paddingBottom: '5px',
                    paddingTop: '5px',
                    backgroundColor: semanticColors.menuItemBackgroundPressed,
                },
            ],
            subComponentStyles: {
                callout: {
                    root: {
                        boxShadow: effects.elevation8,
                    },
                },
                menuItem: {},
            },
        };
    };

    function onRenderSubMenu(subMenuProps) {
        return react.exports.createElement(LocalContextualMenu, __assign$k({}, subMenuProps));
    }
    // This is to prevent cyclic import with ContextualMenu.base.tsx.
    var LocalContextualMenu = styled(ContextualMenuBase, getStyles$j, function (props) { return ({
        onRenderSubMenu: props.onRenderSubMenu
            ? composeRenderFunction(props.onRenderSubMenu, onRenderSubMenu)
            : onRenderSubMenu,
    }); }, { scope: 'ContextualMenu' });
    /**
     * ContextualMenu description
     */
    var ContextualMenu$1 = LocalContextualMenu;
    ContextualMenu$1.displayName = 'ContextualMenu';

    var ContextualMenu = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getMenuItemStyles: getMenuItemStyles,
        ContextualMenu: ContextualMenu$1,
        getSubmenuItems: getSubmenuItems,
        canAnyMenuItemsCheck: canAnyMenuItemsCheck,
        ContextualMenuBase: ContextualMenuBase,
        DirectionalHint: DirectionalHint,
        get ContextualMenuItemType () { return ContextualMenuItemType; },
        ContextualMenuItem: ContextualMenuItem,
        ContextualMenuItemBase: ContextualMenuItemBase
    });

    var ButtonGlobalClassNames = {
        msButton: 'ms-Button',
        msButtonHasMenu: 'ms-Button--hasMenu',
        msButtonIcon: 'ms-Button-icon',
        msButtonMenuIcon: 'ms-Button-menuIcon',
        msButtonLabel: 'ms-Button-label',
        msButtonDescription: 'ms-Button-description',
        msButtonScreenReaderText: 'ms-Button-screenReaderText',
        msButtonFlexContainer: 'ms-Button-flexContainer',
        msButtonTextContainer: 'ms-Button-textContainer',
    };
    var getBaseButtonClassNames = memoizeFunction(function (theme, styles, className, variantClassName, iconClassName, menuIconClassName, disabled, hasMenu, checked, expanded, isSplit) {
        var _a, _b;
        var classNames = getGlobalClassNames(ButtonGlobalClassNames, theme || {});
        var isExpanded = expanded && !isSplit;
        return mergeStyleSets({
            root: [
                classNames.msButton,
                styles.root,
                variantClassName,
                checked && ['is-checked', styles.rootChecked],
                isExpanded && [
                    'is-expanded',
                    styles.rootExpanded,
                    {
                        selectors: (_a = {},
                            _a[":hover ." + classNames.msButtonIcon] = styles.iconExpandedHovered,
                            // menuIcon falls back to rootExpandedHovered to support original behavior
                            _a[":hover ." + classNames.msButtonMenuIcon] = styles.menuIconExpandedHovered || styles.rootExpandedHovered,
                            _a[':hover'] = styles.rootExpandedHovered,
                            _a),
                    },
                ],
                hasMenu && [ButtonGlobalClassNames.msButtonHasMenu, styles.rootHasMenu],
                disabled && ['is-disabled', styles.rootDisabled],
                !disabled &&
                    !isExpanded &&
                    !checked && {
                    selectors: (_b = {
                            ':hover': styles.rootHovered
                        },
                        _b[":hover ." + classNames.msButtonLabel] = styles.labelHovered,
                        _b[":hover ." + classNames.msButtonIcon] = styles.iconHovered,
                        _b[":hover ." + classNames.msButtonDescription] = styles.descriptionHovered,
                        _b[":hover ." + classNames.msButtonMenuIcon] = styles.menuIconHovered,
                        _b[':focus'] = styles.rootFocused,
                        _b[':active'] = styles.rootPressed,
                        _b[":active ." + classNames.msButtonIcon] = styles.iconPressed,
                        _b[":active ." + classNames.msButtonDescription] = styles.descriptionPressed,
                        _b[":active ." + classNames.msButtonMenuIcon] = styles.menuIconPressed,
                        _b),
                },
                disabled && checked && [styles.rootCheckedDisabled],
                !disabled &&
                    checked && {
                    selectors: {
                        ':hover': styles.rootCheckedHovered,
                        ':active': styles.rootCheckedPressed,
                    },
                },
                className,
            ],
            flexContainer: [classNames.msButtonFlexContainer, styles.flexContainer],
            textContainer: [classNames.msButtonTextContainer, styles.textContainer],
            icon: [
                classNames.msButtonIcon,
                iconClassName,
                styles.icon,
                isExpanded && styles.iconExpanded,
                checked && styles.iconChecked,
                disabled && styles.iconDisabled,
            ],
            label: [classNames.msButtonLabel, styles.label, checked && styles.labelChecked, disabled && styles.labelDisabled],
            menuIcon: [
                classNames.msButtonMenuIcon,
                menuIconClassName,
                styles.menuIcon,
                checked && styles.menuIconChecked,
                disabled && !isSplit && styles.menuIconDisabled,
                !disabled &&
                    !isExpanded &&
                    !checked && {
                    selectors: {
                        ':hover': styles.menuIconHovered,
                        ':active': styles.menuIconPressed,
                    },
                },
                isExpanded && ['is-expanded', styles.menuIconExpanded],
            ],
            description: [
                classNames.msButtonDescription,
                styles.description,
                checked && styles.descriptionChecked,
                disabled && styles.descriptionDisabled,
            ],
            screenReaderText: [classNames.msButtonScreenReaderText, styles.screenReaderText],
        });
    });

    var getSplitButtonClassNames = memoizeFunction(function (styles, disabled, expanded, checked, primaryDisabled) {
        return {
            root: mergeStyles(styles.splitButtonMenuButton, expanded && [styles.splitButtonMenuButtonExpanded], disabled && [styles.splitButtonMenuButtonDisabled], checked && !disabled && [styles.splitButtonMenuButtonChecked], primaryDisabled &&
                !disabled && [
                {
                    selectors: {
                        ':focus': styles.splitButtonMenuFocused,
                    },
                },
            ]),
            splitButtonContainer: mergeStyles(styles.splitButtonContainer, !disabled &&
                checked && [
                styles.splitButtonContainerChecked,
                {
                    selectors: {
                        ':hover': styles.splitButtonContainerCheckedHovered,
                    },
                },
            ], !disabled &&
                !checked && [
                {
                    selectors: {
                        ':hover': styles.splitButtonContainerHovered,
                        ':focus': styles.splitButtonContainerFocused,
                    },
                },
            ], disabled && styles.splitButtonContainerDisabled),
            icon: mergeStyles(styles.splitButtonMenuIcon, disabled && styles.splitButtonMenuIconDisabled, !disabled && primaryDisabled && styles.splitButtonMenuIcon),
            flexContainer: mergeStyles(styles.splitButtonFlexContainer),
            divider: mergeStyles(styles.splitButtonDivider, (primaryDisabled || disabled) && styles.splitButtonDividerDisabled),
        };
    });

    var TouchIdleDelay = 500; /* ms */
    var COMPONENT_NAME$3 = 'BaseButton';
    /**
     * {@docCategory Button}
     */
    var BaseButton = /** @class */ (function (_super) {
        __extends$4(BaseButton, _super);
        function BaseButton(props) {
            var _this = _super.call(this, props) || this;
            _this._buttonElement = react.exports.createRef();
            _this._splitButtonContainer = react.exports.createRef();
            _this._mergedRef = createMergedRef();
            _this._renderedVisibleMenu = false;
            _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {
                return __assign$k(__assign$k({}, keytipProps), { hasMenu: true });
            });
            _this._onRenderIcon = function (buttonProps, defaultRender) {
                var iconProps = _this.props.iconProps;
                if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {
                    var className = iconProps.className, imageProps = iconProps.imageProps, rest = __rest(iconProps, ["className", "imageProps"]);
                    // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon
                    // do not have this prop.
                    if (iconProps.styles) {
                        return react.exports.createElement(Icon$1, __assign$k({ className: css(_this._classNames.icon, className), imageProps: imageProps }, rest));
                    }
                    if (iconProps.iconName) {
                        return react.exports.createElement(FontIcon, __assign$k({ className: css(_this._classNames.icon, className) }, rest));
                    }
                    if (imageProps) {
                        return react.exports.createElement(ImageIcon, __assign$k({ className: css(_this._classNames.icon, className), imageProps: imageProps }, rest));
                    }
                }
                return null;
            };
            _this._onRenderTextContents = function () {
                var _a = _this.props, text = _a.text, children = _a.children, 
                // eslint-disable-next-line deprecation/deprecation
                _b = _a.secondaryText, 
                // eslint-disable-next-line deprecation/deprecation
                secondaryText = _b === void 0 ? _this.props.description : _b, _c = _a.onRenderText, onRenderText = _c === void 0 ? _this._onRenderText : _c, _d = _a.onRenderDescription, onRenderDescription = _d === void 0 ? _this._onRenderDescription : _d;
                if (text || typeof children === 'string' || secondaryText) {
                    return (react.exports.createElement("span", { className: _this._classNames.textContainer },
                        onRenderText(_this.props, _this._onRenderText),
                        onRenderDescription(_this.props, _this._onRenderDescription)));
                }
                return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];
            };
            _this._onRenderText = function () {
                var text = _this.props.text;
                var children = _this.props.children;
                // For backwards compat, we should continue to take in the text content from children.
                if (text === undefined && typeof children === 'string') {
                    text = children;
                }
                if (_this._hasText()) {
                    return (react.exports.createElement("span", { key: _this._labelId, className: _this._classNames.label, id: _this._labelId }, text));
                }
                return null;
            };
            _this._onRenderChildren = function () {
                var children = _this.props.children;
                // If children is just a string, either it or the text will be rendered via onRenderLabel
                // If children is another component, it will be rendered after text
                if (typeof children === 'string') {
                    return null;
                }
                return children;
            };
            _this._onRenderDescription = function (props) {
                // eslint-disable-next-line deprecation/deprecation
                var _a = props.secondaryText, secondaryText = _a === void 0 ? _this.props.description : _a;
                // ms-Button-description is only shown when the button type is compound.
                // In other cases it will not be displayed.
                return secondaryText ? (react.exports.createElement("span", { key: _this._descriptionId, className: _this._classNames.description, id: _this._descriptionId }, secondaryText)) : null;
            };
            _this._onRenderAriaDescription = function () {
                var ariaDescription = _this.props.ariaDescription;
                // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,
                // otherwise it will be assigned to descriptionSpan.
                return ariaDescription ? (react.exports.createElement("span", { className: _this._classNames.screenReaderText, id: _this._ariaDescriptionId }, ariaDescription)) : null;
            };
            _this._onRenderMenuIcon = function (props) {
                var menuIconProps = _this.props.menuIconProps;
                return react.exports.createElement(FontIcon, __assign$k({ iconName: "ChevronDown" }, menuIconProps, { className: _this._classNames.menuIcon }));
            };
            _this._onRenderMenu = function (menuProps) {
                var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu$1) : ContextualMenu$1;
                return react.exports.createElement(MenuType, __assign$k({}, menuProps));
            };
            _this._onDismissMenu = function (ev) {
                var menuProps = _this.props.menuProps;
                if (menuProps && menuProps.onDismiss) {
                    menuProps.onDismiss(ev);
                }
                if (!ev || !ev.defaultPrevented) {
                    _this._dismissMenu();
                }
            };
            _this._dismissMenu = function () {
                _this._menuShouldFocusOnMount = undefined;
                _this._menuShouldFocusOnContainer = undefined;
                _this.setState({ menuHidden: true });
            };
            _this._openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {
                if (shouldFocusOnMount === void 0) { shouldFocusOnMount = true; }
                if (_this.props.menuProps) {
                    _this._menuShouldFocusOnContainer = shouldFocusOnContainer;
                    _this._menuShouldFocusOnMount = shouldFocusOnMount;
                    _this._renderedVisibleMenu = true;
                    _this.setState({ menuHidden: false });
                }
            };
            _this._onToggleMenu = function (shouldFocusOnContainer) {
                var shouldFocusOnMount = true;
                if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {
                    shouldFocusOnMount = false;
                }
                _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();
            };
            _this._onSplitContainerFocusCapture = function (ev) {
                var container = _this._splitButtonContainer.current;
                // If the target is coming from the portal we do not need to set focus on the container.
                if (!container || (ev.target && portalContainsElement(ev.target, container))) {
                    return;
                }
                // We should never be able to focus the individual buttons in a split button. Focus
                // should always remain on the container.
                container.focus();
            };
            _this._onSplitButtonPrimaryClick = function (ev) {
                if (!_this.state.menuHidden) {
                    _this._dismissMenu();
                }
                if (!_this._processingTouch && _this.props.onClick) {
                    _this.props.onClick(ev);
                }
                else if (_this._processingTouch) {
                    _this._onMenuClick(ev);
                }
            };
            _this._onKeyDown = function (ev) {
                // explicity cancelling event so click won't fire after this
                // eslint-disable-next-line deprecation/deprecation
                if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
                    ev.preventDefault();
                    ev.stopPropagation();
                }
                else if (!_this.props.disabled) {
                    if (_this.props.menuProps) {
                        _this._onMenuKeyDown(ev);
                    }
                    else if (_this.props.onKeyDown !== undefined) {
                        _this.props.onKeyDown(ev); // not cancelling event because it's not disabled
                    }
                }
            };
            _this._onKeyUp = function (ev) {
                if (!_this.props.disabled && _this.props.onKeyUp !== undefined) {
                    _this.props.onKeyUp(ev); // not cancelling event because it's not disabled
                }
            };
            _this._onKeyPress = function (ev) {
                if (!_this.props.disabled && _this.props.onKeyPress !== undefined) {
                    _this.props.onKeyPress(ev); // not cancelling event because it's not disabled
                }
            };
            _this._onMouseUp = function (ev) {
                if (!_this.props.disabled && _this.props.onMouseUp !== undefined) {
                    _this.props.onMouseUp(ev); // not cancelling event because it's not disabled
                }
            };
            _this._onMouseDown = function (ev) {
                if (!_this.props.disabled && _this.props.onMouseDown !== undefined) {
                    _this.props.onMouseDown(ev); // not cancelling event because it's not disabled
                }
            };
            _this._onClick = function (ev) {
                if (!_this.props.disabled) {
                    if (_this.props.menuProps) {
                        _this._onMenuClick(ev);
                    }
                    else if (_this.props.onClick !== undefined) {
                        _this.props.onClick(ev); // not cancelling event because it's not disabled
                    }
                }
            };
            _this._onSplitButtonContainerKeyDown = function (ev) {
                // eslint-disable-next-line deprecation/deprecation
                if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
                    if (_this._buttonElement.current) {
                        _this._buttonElement.current.click();
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                }
                else {
                    _this._onMenuKeyDown(ev);
                }
            };
            _this._onMenuKeyDown = function (ev) {
                if (_this.props.disabled) {
                    return;
                }
                if (_this.props.onKeyDown) {
                    _this.props.onKeyDown(ev);
                }
                // eslint-disable-next-line deprecation/deprecation
                var isUp = ev.which === KeyCodes.up;
                // eslint-disable-next-line deprecation/deprecation
                var isDown = ev.which === KeyCodes.down;
                if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {
                    var onMenuClick = _this.props.onMenuClick;
                    if (onMenuClick) {
                        onMenuClick(ev, _this.props);
                    }
                    _this._onToggleMenu(false);
                    ev.preventDefault();
                    ev.stopPropagation();
                }
                // eslint-disable-next-line deprecation/deprecation
                if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
                    // We manually set the focus visibility to true if opening via Enter or Space to account for the scenario where
                    // a user clicks on the button, closes the menu and then opens it via keyboard. In this scenario our default logic
                    // for setting focus visibility is not triggered since there is no keyboard navigation present beforehand.
                    setFocusVisibility(true, ev.target);
                }
                if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {
                    // Suppose a menu, with shouldFocusOnMount: false, is open, and user wants to keyboard to the menu items
                    // We need to re-render the menu with shouldFocusOnMount as true.
                    if (!_this.state.menuHidden && _this.props.menuProps) {
                        var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== undefined
                            ? _this._menuShouldFocusOnMount
                            : _this.props.menuProps.shouldFocusOnMount;
                        if (!currentShouldFocusOnMount) {
                            ev.preventDefault();
                            ev.stopPropagation();
                            _this._menuShouldFocusOnMount = true;
                            _this.forceUpdate();
                        }
                    }
                }
            };
            _this._onTouchStart = function () {
                if (_this._isSplitButton &&
                    _this._splitButtonContainer.current &&
                    !('onpointerdown' in _this._splitButtonContainer.current)) {
                    _this._handleTouchAndPointerEvent();
                }
            };
            _this._onMenuClick = function (ev) {
                var onMenuClick = _this.props.onMenuClick;
                if (onMenuClick) {
                    onMenuClick(ev, _this.props);
                }
                if (!ev.defaultPrevented) {
                    _this._onToggleMenu(false);
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            };
            initializeComponentRef(_this);
            _this._async = new Async(_this);
            _this._events = new EventGroup(_this);
            warnConditionallyRequiredProps(COMPONENT_NAME$3, props, ['menuProps', 'onClick'], 'split', _this.props.split);
            _this._labelId = getId();
            _this._descriptionId = getId();
            _this._ariaDescriptionId = getId();
            _this.state = {
                menuHidden: true,
            };
            return _this;
        }
        Object.defineProperty(BaseButton.prototype, "_isSplitButton", {
            get: function () {
                return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;
            },
            enumerable: false,
            configurable: true
        });
        BaseButton.prototype.render = function () {
            var _a;
            var _b = this.props, ariaDescription = _b.ariaDescription, ariaLabel = _b.ariaLabel, ariaHidden = _b.ariaHidden, className = _b.className, disabled = _b.disabled, allowDisabledFocus = _b.allowDisabledFocus, primaryDisabled = _b.primaryDisabled, 
            // eslint-disable-next-line deprecation/deprecation
            _c = _b.secondaryText, 
            // eslint-disable-next-line deprecation/deprecation
            secondaryText = _c === void 0 ? this.props.description : _c, href = _b.href, iconProps = _b.iconProps, menuIconProps = _b.menuIconProps, styles = _b.styles, checked = _b.checked, variantClassName = _b.variantClassName, theme = _b.theme, toggle = _b.toggle, getClassNames = _b.getClassNames, role = _b.role;
            var menuHidden = this.state.menuHidden;
            // Button is disabled if the whole button (in case of splitButton is disabled) or if the primary action is disabled
            var isPrimaryButtonDisabled = disabled || primaryDisabled;
            this._classNames = getClassNames
                ? getClassNames(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus)
                : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);
            var _d = this, _ariaDescriptionId = _d._ariaDescriptionId, _labelId = _d._labelId, _descriptionId = _d._descriptionId;
            // Anchor tag cannot be disabled hence in disabled state rendering
            // anchor button as normal button
            var renderAsAnchor = !isPrimaryButtonDisabled && !!href;
            var tag = renderAsAnchor ? 'a' : 'button';
            var nativeProps = getNativeProps(
            // eslint-disable-next-line deprecation/deprecation
            assign(renderAsAnchor ? {} : { type: 'button' }, this.props.rootProps, this.props), renderAsAnchor ? anchorProperties : buttonProperties, [
                'disabled', // let disabled buttons be focused and styled as disabled.
            ]);
            // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props
            var resolvedAriaLabel = ariaLabel || nativeProps['aria-label'];
            // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of
            // aria-describedby. Otherwise default to undefined so property does not appear in output.
            var ariaDescribedBy = undefined;
            if (ariaDescription) {
                ariaDescribedBy = _ariaDescriptionId;
            }
            else if (secondaryText && this.props.onRenderDescription !== nullRender) {
                // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy
                // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy
                ariaDescribedBy = _descriptionId;
            }
            else if (nativeProps['aria-describedby']) {
                ariaDescribedBy = nativeProps['aria-describedby'];
            }
            // If an explicit aria-labelledby is given, use that and we're done.
            // If any kind of description is given (which will end up as an aria-describedby attribute)
            // and no ariaLabel is specified, set the labelledby element.
            // Otherwise, the button is labeled implicitly by the descendent text on the button (if it exists).
            var ariaLabelledBy = undefined;
            if (nativeProps['aria-labelledby']) {
                ariaLabelledBy = nativeProps['aria-labelledby'];
            }
            else if (ariaDescribedBy && !resolvedAriaLabel) {
                ariaLabelledBy = this._hasText() ? _labelId : undefined;
            }
            var dataIsFocusable = this.props['data-is-focusable'] === false || (disabled && !allowDisabledFocus) || this._isSplitButton
                ? false
                : true;
            var isCheckboxTypeRole = role === 'menuitemcheckbox' || role === 'checkbox';
            // if isCheckboxTypeRole, always return a checked value.
            // Otherwise only return checked value if toggle is set to true.
            // This is because role="checkbox" always needs to have an aria-checked value
            // but our checked prop only sets aria-pressed if we mark the button as a toggle="true"
            var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : undefined;
            var buttonProps = assign(nativeProps, (_a = {
                    className: this._classNames.root,
                    // eslint-disable-next-line deprecation/deprecation
                    ref: this._mergedRef(this.props.elementRef, this._buttonElement),
                    disabled: isPrimaryButtonDisabled && !allowDisabledFocus,
                    onKeyDown: this._onKeyDown,
                    onKeyPress: this._onKeyPress,
                    onKeyUp: this._onKeyUp,
                    onMouseDown: this._onMouseDown,
                    onMouseUp: this._onMouseUp,
                    onClick: this._onClick,
                    'aria-label': resolvedAriaLabel,
                    'aria-labelledby': ariaLabelledBy,
                    'aria-describedby': ariaDescribedBy,
                    'aria-disabled': isPrimaryButtonDisabled,
                    'data-is-focusable': dataIsFocusable
                },
                // aria-pressed attribute should only be present for toggle buttons
                // aria-checked attribute should only be present for toggle buttons with checkbox type role
                _a[isCheckboxTypeRole ? 'aria-checked' : 'aria-pressed'] = checkedOrPressedValue,
                _a));
            if (ariaHidden) {
                buttonProps['aria-hidden'] = true;
            }
            if (this._isSplitButton) {
                return this._onRenderSplitButtonContent(tag, buttonProps);
            }
            else if (this.props.menuProps) {
                var _e = this.props.menuProps.id, id = _e === void 0 ? this._labelId + "-menu" : _e;
                assign(buttonProps, {
                    'aria-expanded': !menuHidden,
                    'aria-controls': !menuHidden ? id : null,
                    'aria-haspopup': true,
                });
            }
            return this._onRenderContent(tag, buttonProps);
        };
        BaseButton.prototype.componentDidMount = function () {
            // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the
            // primary action. This gives more hit target space for touch environments. We're setting the onpointerdown here,
            // because React does not support Pointer events yet.
            if (this._isSplitButton && this._splitButtonContainer.current) {
                if ('onpointerdown' in this._splitButtonContainer.current) {
                    this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);
                }
                if ('onpointerup' in this._splitButtonContainer.current && this.props.onPointerUp) {
                    this._events.on(this._splitButtonContainer.current, 'pointerup', this.props.onPointerUp, true);
                }
            }
        };
        BaseButton.prototype.componentDidUpdate = function (prevProps, prevState) {
            // If Button's menu was closed, run onAfterMenuDismiss.
            if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {
                this.props.onAfterMenuDismiss();
            }
        };
        BaseButton.prototype.componentWillUnmount = function () {
            this._async.dispose();
            this._events.dispose();
        };
        BaseButton.prototype.focus = function () {
            if (this._isSplitButton && this._splitButtonContainer.current) {
                setFocusVisibility(true);
                this._splitButtonContainer.current.focus();
            }
            else if (this._buttonElement.current) {
                setFocusVisibility(true);
                this._buttonElement.current.focus();
            }
        };
        BaseButton.prototype.dismissMenu = function () {
            this._dismissMenu();
        };
        BaseButton.prototype.openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {
            this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);
        };
        BaseButton.prototype._onRenderContent = function (tag, buttonProps) {
            var _this = this;
            var props = this.props;
            var Tag = tag;
            var menuIconProps = props.menuIconProps, menuProps = props.menuProps, _a = props.onRenderIcon, onRenderIcon = _a === void 0 ? this._onRenderIcon : _a, _b = props.onRenderAriaDescription, onRenderAriaDescription = _b === void 0 ? this._onRenderAriaDescription : _b, _c = props.onRenderChildren, onRenderChildren = _c === void 0 ? this._onRenderChildren : _c, 
            // eslint-disable-next-line deprecation/deprecation
            _d = props.onRenderMenu, 
            // eslint-disable-next-line deprecation/deprecation
            onRenderMenu = _d === void 0 ? this._onRenderMenu : _d, _e = props.onRenderMenuIcon, onRenderMenuIcon = _e === void 0 ? this._onRenderMenuIcon : _e, disabled = props.disabled;
            var keytipProps = props.keytipProps;
            if (keytipProps && menuProps) {
                keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
            }
            var Button = function (keytipAttributes) { return (react.exports.createElement(Tag, __assign$k({}, buttonProps, keytipAttributes),
                react.exports.createElement("span", { className: _this._classNames.flexContainer, "data-automationid": "splitbuttonprimary" },
                    onRenderIcon(props, _this._onRenderIcon),
                    _this._onRenderTextContents(),
                    onRenderAriaDescription(props, _this._onRenderAriaDescription),
                    onRenderChildren(props, _this._onRenderChildren),
                    !_this._isSplitButton &&
                        (menuProps || menuIconProps || _this.props.onRenderMenuIcon) &&
                        onRenderMenuIcon(_this.props, _this._onRenderMenuIcon),
                    menuProps &&
                        !menuProps.doNotLayer &&
                        _this._shouldRenderMenu() &&
                        onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)))); };
            var Content = keytipProps ? (
            // If we're making a split button, we won't put the keytip here
            react.exports.createElement(KeytipData, { keytipProps: !this._isSplitButton ? keytipProps : undefined, ariaDescribedBy: buttonProps['aria-describedby'], disabled: disabled }, function (keytipAttributes) { return Button(keytipAttributes); })) : (Button());
            if (menuProps && menuProps.doNotLayer) {
                return (react.exports.createElement(react.exports.Fragment, null,
                    Content,
                    this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)));
            }
            return (react.exports.createElement(react.exports.Fragment, null,
                Content,
                react.exports.createElement(FocusRects, null)));
        };
        /**
         * Method to help determine if the menu's component tree should
         * be rendered. It takes into account whether the menu is expanded,
         * whether it is a persisted menu and whether it has been shown to the user.
         */
        BaseButton.prototype._shouldRenderMenu = function () {
            var menuHidden = this.state.menuHidden;
            // eslint-disable-next-line deprecation/deprecation
            var _a = this.props, persistMenu = _a.persistMenu, renderPersistedMenuHiddenOnMount = _a.renderPersistedMenuHiddenOnMount;
            if (!menuHidden) {
                // Always should render a menu when it is expanded
                return true;
            }
            else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {
                // _renderedVisibleMenu ensures that the first rendering of
                // the menu happens on-screen, as edge's scrollbar calculations are off if done while hidden.
                return true;
            }
            return false;
        };
        BaseButton.prototype._hasText = function () {
            // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText
            // used to have before the refactor that introduced this function. _onRenderTextContents does not require props.
            // text to be undefined in order for props.children to be used as a fallback.
            // Purely a code maintainability/reuse issue, but logged as Issue #4979.
            return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');
        };
        BaseButton.prototype._getMenuProps = function (menuProps) {
            var persistMenu = this.props.persistMenu;
            var menuHidden = this.state.menuHidden;
            // the accessible menu label (accessible name) has a relationship to the button.
            // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,
            // AND the button has text, we'll set the menu aria-labelledBy to the text element id.
            if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {
                menuProps = __assign$k(__assign$k({}, menuProps), { labelElementId: this._labelId });
            }
            return __assign$k(__assign$k({ id: this._labelId + '-menu', directionalHint: DirectionalHint.bottomLeftEdge }, menuProps), { shouldFocusOnContainer: this._menuShouldFocusOnContainer, shouldFocusOnMount: this._menuShouldFocusOnMount, hidden: persistMenu ? menuHidden : undefined, className: css('ms-BaseButton-menuhost', menuProps.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: this._onDismissMenu });
        };
        BaseButton.prototype._onRenderSplitButtonContent = function (tag, buttonProps) {
            var _this = this;
            var _a = this.props, _b = _a.styles, styles = _b === void 0 ? {} : _b, disabled = _a.disabled, allowDisabledFocus = _a.allowDisabledFocus, checked = _a.checked, getSplitButtonClassNames$1 = _a.getSplitButtonClassNames, primaryDisabled = _a.primaryDisabled, menuProps = _a.menuProps, toggle = _a.toggle, role = _a.role, primaryActionButtonProps = _a.primaryActionButtonProps;
            var keytipProps = this.props.keytipProps;
            var menuHidden = this.state.menuHidden;
            var classNames = getSplitButtonClassNames$1
                ? getSplitButtonClassNames$1(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus)
                : styles && getSplitButtonClassNames(styles, !!disabled, !menuHidden, !!checked, !!primaryDisabled);
            assign(buttonProps, {
                onClick: undefined,
                onPointerDown: undefined,
                onPointerUp: undefined,
                tabIndex: -1,
                'data-is-focusable': false,
            });
            if (keytipProps && menuProps) {
                keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
            }
            var containerProps = getNativeProps(buttonProps, [], ['disabled']);
            // Add additional props to apply on primary action button
            if (primaryActionButtonProps) {
                assign(buttonProps, primaryActionButtonProps);
            }
            var SplitButton = function (keytipAttributes) { return (react.exports.createElement("div", __assign$k({}, containerProps, { "data-ktp-target": keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined, role: role ? role : 'button', "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": !menuHidden, "aria-pressed": toggle ? !!checked : undefined, "aria-describedby": mergeAriaAttributeValues(buttonProps['aria-describedby'], keytipAttributes ? keytipAttributes['aria-describedby'] : undefined), className: classNames && classNames.splitButtonContainer, onKeyDown: _this._onSplitButtonContainerKeyDown, onTouchStart: _this._onTouchStart, ref: _this._splitButtonContainer, "data-is-focusable": true, onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : undefined, tabIndex: (!disabled && !primaryDisabled) || allowDisabledFocus ? 0 : undefined, "aria-roledescription": buttonProps['aria-roledescription'], onFocusCapture: _this._onSplitContainerFocusCapture }),
                react.exports.createElement("span", { style: { display: 'flex' } },
                    _this._onRenderContent(tag, buttonProps),
                    _this._onRenderSplitButtonMenuButton(classNames, keytipAttributes),
                    _this._onRenderSplitButtonDivider(classNames)))); };
            return keytipProps ? (react.exports.createElement(KeytipData, { keytipProps: keytipProps, disabled: disabled }, function (keytipAttributes) { return SplitButton(keytipAttributes); })) : (SplitButton());
        };
        BaseButton.prototype._onRenderSplitButtonDivider = function (classNames) {
            if (classNames && classNames.divider) {
                var onClick = function (ev) {
                    ev.stopPropagation();
                };
                return react.exports.createElement("span", { className: classNames.divider, "aria-hidden": true, onClick: onClick });
            }
            return null;
        };
        BaseButton.prototype._onRenderSplitButtonMenuButton = function (classNames, keytipAttributes) {
            var _a = this.props, allowDisabledFocus = _a.allowDisabledFocus, checked = _a.checked, disabled = _a.disabled, splitButtonMenuProps = _a.splitButtonMenuProps, splitButtonAriaLabel = _a.splitButtonAriaLabel, primaryDisabled = _a.primaryDisabled;
            var menuHidden = this.state.menuHidden;
            var menuIconProps = this.props.menuIconProps;
            if (menuIconProps === undefined) {
                menuIconProps = {
                    iconName: 'ChevronDown',
                };
            }
            var splitButtonProps = __assign$k(__assign$k({}, splitButtonMenuProps), { styles: classNames, checked: checked, disabled: disabled, allowDisabledFocus: allowDisabledFocus, onClick: this._onMenuClick, menuProps: undefined, iconProps: __assign$k(__assign$k({}, menuIconProps), { className: this._classNames.menuIcon }), ariaLabel: splitButtonAriaLabel, 'aria-haspopup': true, 'aria-expanded': !menuHidden, 'data-is-focusable': false });
            // Add data-ktp-execute-target to the split button if the keytip is defined
            return (react.exports.createElement(BaseButton, __assign$k({}, splitButtonProps, { "data-ktp-execute-target": keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes, onMouseDown: this._onMouseDown, tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1 })));
        };
        BaseButton.prototype._onPointerDown = function (ev) {
            var onPointerDown = this.props.onPointerDown;
            if (onPointerDown) {
                onPointerDown(ev);
            }
            if (ev.pointerType === 'touch') {
                this._handleTouchAndPointerEvent();
                ev.preventDefault();
                ev.stopImmediatePropagation();
            }
        };
        BaseButton.prototype._handleTouchAndPointerEvent = function () {
            var _this = this;
            // If we already have an existing timeout from a previous touch and pointer event
            // cancel that timeout so we can set a new one.
            if (this._lastTouchTimeoutId !== undefined) {
                this._async.clearTimeout(this._lastTouchTimeoutId);
                this._lastTouchTimeoutId = undefined;
            }
            this._processingTouch = true;
            this._lastTouchTimeoutId = this._async.setTimeout(function () {
                _this._processingTouch = false;
                _this._lastTouchTimeoutId = undefined;
                // Touch and pointer events don't focus the button naturally,
                // so adding an imperative focus call to guarantee this behavior.
                _this.focus();
            }, TouchIdleDelay);
        };
        /**
         * Returns if the user hits a valid keyboard key to open the menu
         * @param ev - the keyboard event
         * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.
         */
        BaseButton.prototype._isValidMenuOpenKey = function (ev) {
            if (this.props.menuTriggerKeyCode) {
                // eslint-disable-next-line deprecation/deprecation
                return ev.which === this.props.menuTriggerKeyCode;
            }
            else if (this.props.menuProps) {
                // eslint-disable-next-line deprecation/deprecation
                return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);
            }
            // Note: When enter is pressed, we will let the event continue to propagate
            // to trigger the onClick event on the button
            return false;
        };
        BaseButton.defaultProps = {
            baseClassName: 'ms-Button',
            styles: {},
            split: false,
        };
        return BaseButton;
    }(react.exports.Component));

    /**
     * {@docCategory Button}
     */
    var ElementType;
    (function (ElementType) {
        /** `button` element. */
        ElementType[ElementType["button"] = 0] = "button";
        /** `a` element. */
        ElementType[ElementType["anchor"] = 1] = "anchor";
    })(ElementType || (ElementType = {}));
    /**
     * {@docCategory Button}
     */
    var ButtonType;
    (function (ButtonType) {
        ButtonType[ButtonType["normal"] = 0] = "normal";
        ButtonType[ButtonType["primary"] = 1] = "primary";
        ButtonType[ButtonType["hero"] = 2] = "hero";
        ButtonType[ButtonType["compound"] = 3] = "compound";
        ButtonType[ButtonType["command"] = 4] = "command";
        ButtonType[ButtonType["icon"] = 5] = "icon";
        ButtonType[ButtonType["default"] = 6] = "default";
    })(ButtonType || (ButtonType = {}));

    var noOutline = {
        outline: 0,
    };
    var iconStyle = function (fontSize) {
        return {
            fontSize: fontSize,
            margin: '0 4px',
            height: '16px',
            lineHeight: '16px',
            textAlign: 'center',
            flexShrink: 0,
        };
    };
    /**
     * Gets the base button styles. Note: because it is a base class to be used with the `mergeRules`
     * helper, it should have values for all class names in the interface. This let `mergeRules` optimize
     * mixing class names together.
     */
    var getStyles$i = memoizeFunction(function (theme) {
        var _a, _b;
        var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
        var border = semanticColors.buttonBorder;
        var disabledBackground = semanticColors.disabledBackground;
        var disabledText = semanticColors.disabledText;
        var buttonHighContrastFocus = {
            left: -2,
            top: -2,
            bottom: -2,
            right: -2,
            outlineColor: 'ButtonText',
        };
        return {
            root: [
                getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: 'transparent' }),
                theme.fonts.medium,
                {
                    boxSizing: 'border-box',
                    border: '1px solid ' + border,
                    userSelect: 'none',
                    display: 'inline-block',
                    textDecoration: 'none',
                    textAlign: 'center',
                    cursor: 'pointer',
                    padding: '0 16px',
                    borderRadius: effects.roundedCorner2,
                    selectors: {
                        // IE11 workaround for preventing shift of child elements of a button when active.
                        ':active > *': {
                            position: 'relative',
                            left: 0,
                            top: 0,
                        },
                    },
                },
            ],
            rootDisabled: [
                getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: 'transparent' }),
                {
                    backgroundColor: disabledBackground,
                    borderColor: disabledBackground,
                    color: disabledText,
                    cursor: 'default',
                    selectors: {
                        ':hover': noOutline,
                        ':focus': noOutline,
                    },
                },
            ],
            iconDisabled: {
                color: disabledText,
                selectors: (_a = {},
                    _a[HighContrastSelector] = {
                        color: 'GrayText',
                    },
                    _a),
            },
            menuIconDisabled: {
                color: disabledText,
                selectors: (_b = {},
                    _b[HighContrastSelector] = {
                        color: 'GrayText',
                    },
                    _b),
            },
            flexContainer: {
                display: 'flex',
                height: '100%',
                flexWrap: 'nowrap',
                justifyContent: 'center',
                alignItems: 'center',
            },
            description: {
                display: 'block',
            },
            textContainer: {
                flexGrow: 1,
                display: 'block',
            },
            icon: iconStyle(fonts.mediumPlus.fontSize),
            menuIcon: iconStyle(fonts.small.fontSize),
            label: {
                margin: '0 4px',
                lineHeight: '100%',
                display: 'block',
            },
            screenReaderText: hiddenContentStyle,
        };
    });

    var getStyles$h = memoizeFunction(function (theme, customStyles) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        var effects = theme.effects, palette = theme.palette, semanticColors = theme.semanticColors;
        var buttonHighContrastFocus = {
            left: -2,
            top: -2,
            bottom: -2,
            right: -2,
            border: 'none',
        };
        var splitButtonDividerBaseStyles = {
            position: 'absolute',
            width: 1,
            right: 31,
            top: 8,
            bottom: 8,
        };
        var splitButtonStyles = {
            splitButtonContainer: [
                getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2 }),
                {
                    display: 'inline-flex',
                    selectors: {
                        '.ms-Button--default': {
                            borderTopRightRadius: '0',
                            borderBottomRightRadius: '0',
                            borderRight: 'none',
                        },
                        '.ms-Button--primary': {
                            borderTopRightRadius: '0',
                            borderBottomRightRadius: '0',
                            border: 'none',
                            selectors: (_a = {},
                                _a[HighContrastSelector] = __assign$k({ color: 'WindowText', backgroundColor: 'Window', border: '1px solid WindowText', borderRightWidth: '0' }, getHighContrastNoAdjustStyle()),
                                _a),
                        },
                        '.ms-Button--primary + .ms-Button': {
                            border: 'none',
                            selectors: (_b = {},
                                _b[HighContrastSelector] = {
                                    border: '1px solid WindowText',
                                    borderLeftWidth: '0',
                                },
                                _b),
                        },
                    },
                },
            ],
            splitButtonContainerHovered: {
                selectors: {
                    '.ms-Button--primary': {
                        selectors: (_c = {},
                            _c[HighContrastSelector] = {
                                color: 'Window',
                                backgroundColor: 'Highlight',
                            },
                            _c),
                    },
                    '.ms-Button.is-disabled': {
                        color: semanticColors.buttonTextDisabled,
                        selectors: (_d = {},
                            _d[HighContrastSelector] = {
                                color: 'GrayText',
                                borderColor: 'GrayText',
                                backgroundColor: 'Window',
                            },
                            _d),
                    },
                },
            },
            splitButtonContainerChecked: {
                selectors: {
                    '.ms-Button--primary': {
                        selectors: (_e = {},
                            _e[HighContrastSelector] = __assign$k({ color: 'Window', backgroundColor: 'WindowText' }, getHighContrastNoAdjustStyle()),
                            _e),
                    },
                },
            },
            splitButtonContainerCheckedHovered: {
                selectors: {
                    '.ms-Button--primary': {
                        selectors: (_f = {},
                            _f[HighContrastSelector] = __assign$k({ color: 'Window', backgroundColor: 'WindowText' }, getHighContrastNoAdjustStyle()),
                            _f),
                    },
                },
            },
            splitButtonContainerFocused: {
                outline: 'none!important',
            },
            splitButtonMenuButton: (_g = {
                    padding: 6,
                    height: 'auto',
                    boxSizing: 'border-box',
                    borderRadius: 0,
                    borderTopRightRadius: effects.roundedCorner2,
                    borderBottomRightRadius: effects.roundedCorner2,
                    border: "1px solid " + palette.neutralSecondaryAlt,
                    borderLeft: 'none',
                    outline: 'transparent',
                    userSelect: 'none',
                    display: 'inline-block',
                    textDecoration: 'none',
                    textAlign: 'center',
                    cursor: 'pointer',
                    verticalAlign: 'top',
                    width: 32,
                    marginLeft: -1,
                    marginTop: 0,
                    marginRight: 0,
                    marginBottom: 0
                },
                _g[HighContrastSelector] = {
                    '.ms-Button-menuIcon': {
                        color: 'WindowText',
                    },
                },
                _g),
            splitButtonDivider: __assign$k(__assign$k({}, splitButtonDividerBaseStyles), { selectors: (_h = {},
                    _h[HighContrastSelector] = {
                        backgroundColor: 'WindowText',
                    },
                    _h) }),
            splitButtonDividerDisabled: __assign$k(__assign$k({}, splitButtonDividerBaseStyles), { selectors: (_j = {},
                    _j[HighContrastSelector] = {
                        backgroundColor: 'GrayText',
                    },
                    _j) }),
            splitButtonMenuButtonDisabled: {
                pointerEvents: 'none',
                border: 'none',
                selectors: (_k = {
                        ':hover': {
                            cursor: 'default',
                        },
                        '.ms-Button--primary': {
                            selectors: (_l = {},
                                _l[HighContrastSelector] = {
                                    color: 'GrayText',
                                    borderColor: 'GrayText',
                                    backgroundColor: 'Window',
                                },
                                _l),
                        },
                        '.ms-Button-menuIcon': {
                            selectors: (_m = {},
                                _m[HighContrastSelector] = {
                                    color: 'GrayText',
                                },
                                _m),
                        }
                    },
                    _k[HighContrastSelector] = {
                        color: 'GrayText',
                        border: '1px solid GrayText',
                        backgroundColor: 'Window',
                    },
                    _k),
            },
            splitButtonFlexContainer: {
                display: 'flex',
                height: '100%',
                flexWrap: 'nowrap',
                justifyContent: 'center',
                alignItems: 'center',
            },
            splitButtonContainerDisabled: {
                outline: 'none',
                border: 'none',
                selectors: (_o = {},
                    _o[HighContrastSelector] = __assign$k({ color: 'GrayText', borderColor: 'GrayText', backgroundColor: 'Window' }, getHighContrastNoAdjustStyle()),
                    _o),
            },
            splitButtonMenuFocused: __assign$k({}, getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2 })),
        };
        return concatStyleSets(splitButtonStyles, customStyles);
    });

    var splitButtonDividerBaseStyles = function () {
        return {
            position: 'absolute',
            width: 1,
            right: 31,
            top: 8,
            bottom: 8,
        };
    };
    function standardStyles(theme) {
        var _a, _b, _c, _d, _e;
        var s = theme.semanticColors, p = theme.palette;
        var buttonBackground = s.buttonBackground;
        var buttonBackgroundPressed = s.buttonBackgroundPressed;
        var buttonBackgroundHovered = s.buttonBackgroundHovered;
        var buttonBackgroundDisabled = s.buttonBackgroundDisabled;
        var buttonText = s.buttonText;
        var buttonTextHovered = s.buttonTextHovered;
        var buttonTextDisabled = s.buttonTextDisabled;
        var buttonTextChecked = s.buttonTextChecked;
        var buttonTextCheckedHovered = s.buttonTextCheckedHovered;
        return {
            root: {
                backgroundColor: buttonBackground,
                color: buttonText,
            },
            rootHovered: {
                backgroundColor: buttonBackgroundHovered,
                color: buttonTextHovered,
                selectors: (_a = {},
                    _a[HighContrastSelector] = {
                        borderColor: 'Highlight',
                        color: 'Highlight',
                    },
                    _a),
            },
            rootPressed: {
                backgroundColor: buttonBackgroundPressed,
                color: buttonTextChecked,
            },
            rootExpanded: {
                backgroundColor: buttonBackgroundPressed,
                color: buttonTextChecked,
            },
            rootChecked: {
                backgroundColor: buttonBackgroundPressed,
                color: buttonTextChecked,
            },
            rootCheckedHovered: {
                backgroundColor: buttonBackgroundPressed,
                color: buttonTextCheckedHovered,
            },
            rootDisabled: {
                color: buttonTextDisabled,
                backgroundColor: buttonBackgroundDisabled,
                selectors: (_b = {},
                    _b[HighContrastSelector] = {
                        color: 'GrayText',
                        borderColor: 'GrayText',
                        backgroundColor: 'Window',
                    },
                    _b),
            },
            // Split button styles
            splitButtonContainer: {
                selectors: (_c = {},
                    _c[HighContrastSelector] = {
                        border: 'none',
                    },
                    _c),
            },
            splitButtonMenuButton: {
                color: p.white,
                backgroundColor: 'transparent',
                selectors: {
                    ':hover': {
                        backgroundColor: p.neutralLight,
                        selectors: (_d = {},
                            _d[HighContrastSelector] = {
                                color: 'Highlight',
                            },
                            _d),
                    },
                },
            },
            splitButtonMenuButtonDisabled: {
                backgroundColor: s.buttonBackgroundDisabled,
                selectors: {
                    ':hover': {
                        backgroundColor: s.buttonBackgroundDisabled,
                    },
                },
            },
            splitButtonDivider: __assign$k(__assign$k({}, splitButtonDividerBaseStyles()), { backgroundColor: p.neutralTertiaryAlt, selectors: (_e = {},
                    _e[HighContrastSelector] = {
                        backgroundColor: 'WindowText',
                    },
                    _e) }),
            splitButtonDividerDisabled: {
                backgroundColor: theme.palette.neutralTertiaryAlt,
            },
            splitButtonMenuButtonChecked: {
                backgroundColor: p.neutralQuaternaryAlt,
                selectors: {
                    ':hover': {
                        backgroundColor: p.neutralQuaternaryAlt,
                    },
                },
            },
            splitButtonMenuButtonExpanded: {
                backgroundColor: p.neutralQuaternaryAlt,
                selectors: {
                    ':hover': {
                        backgroundColor: p.neutralQuaternaryAlt,
                    },
                },
            },
            splitButtonMenuIcon: {
                color: s.buttonText,
            },
            splitButtonMenuIconDisabled: {
                color: s.buttonTextDisabled,
            },
        };
    }
    function primaryStyles(theme) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var p = theme.palette, s = theme.semanticColors;
        return {
            root: {
                backgroundColor: s.primaryButtonBackground,
                border: "1px solid " + s.primaryButtonBackground,
                color: s.primaryButtonText,
                selectors: (_a = {},
                    _a[HighContrastSelector] = __assign$k({ color: 'Window', backgroundColor: 'WindowText', borderColor: 'WindowText' }, getHighContrastNoAdjustStyle()),
                    _a["." + IsFocusVisibleClassName + " &:focus"] = {
                        selectors: {
                            ':after': {
                                border: "none",
                                outlineColor: p.white,
                            },
                        },
                    },
                    _a),
            },
            rootHovered: {
                backgroundColor: s.primaryButtonBackgroundHovered,
                border: "1px solid " + s.primaryButtonBackgroundHovered,
                color: s.primaryButtonTextHovered,
                selectors: (_b = {},
                    _b[HighContrastSelector] = {
                        color: 'Window',
                        backgroundColor: 'Highlight',
                        borderColor: 'Highlight',
                    },
                    _b),
            },
            rootPressed: {
                backgroundColor: s.primaryButtonBackgroundPressed,
                border: "1px solid " + s.primaryButtonBackgroundPressed,
                color: s.primaryButtonTextPressed,
                selectors: (_c = {},
                    _c[HighContrastSelector] = __assign$k({ color: 'Window', backgroundColor: 'WindowText', borderColor: 'WindowText' }, getHighContrastNoAdjustStyle()),
                    _c),
            },
            rootExpanded: {
                backgroundColor: s.primaryButtonBackgroundPressed,
                color: s.primaryButtonTextPressed,
            },
            rootChecked: {
                backgroundColor: s.primaryButtonBackgroundPressed,
                color: s.primaryButtonTextPressed,
            },
            rootCheckedHovered: {
                backgroundColor: s.primaryButtonBackgroundPressed,
                color: s.primaryButtonTextPressed,
            },
            rootDisabled: {
                color: s.primaryButtonTextDisabled,
                backgroundColor: s.primaryButtonBackgroundDisabled,
                selectors: (_d = {},
                    _d[HighContrastSelector] = {
                        color: 'GrayText',
                        borderColor: 'GrayText',
                        backgroundColor: 'Window',
                    },
                    _d),
            },
            // Split button styles
            splitButtonContainer: {
                selectors: (_e = {},
                    _e[HighContrastSelector] = {
                        border: 'none',
                    },
                    _e),
            },
            splitButtonDivider: __assign$k(__assign$k({}, splitButtonDividerBaseStyles()), { backgroundColor: p.white, selectors: (_f = {},
                    _f[HighContrastSelector] = {
                        backgroundColor: 'Window',
                    },
                    _f) }),
            splitButtonMenuButton: {
                backgroundColor: s.primaryButtonBackground,
                color: s.primaryButtonText,
                selectors: (_g = {},
                    _g[HighContrastSelector] = {
                        backgroundColor: 'WindowText',
                    },
                    _g[':hover'] = {
                        backgroundColor: s.primaryButtonBackgroundHovered,
                        selectors: (_h = {},
                            _h[HighContrastSelector] = {
                                color: 'Highlight',
                            },
                            _h),
                    },
                    _g),
            },
            splitButtonMenuButtonDisabled: {
                backgroundColor: s.primaryButtonBackgroundDisabled,
                selectors: {
                    ':hover': {
                        backgroundColor: s.primaryButtonBackgroundDisabled,
                    },
                },
            },
            splitButtonMenuButtonChecked: {
                backgroundColor: s.primaryButtonBackgroundPressed,
                selectors: {
                    ':hover': {
                        backgroundColor: s.primaryButtonBackgroundPressed,
                    },
                },
            },
            splitButtonMenuButtonExpanded: {
                backgroundColor: s.primaryButtonBackgroundPressed,
                selectors: {
                    ':hover': {
                        backgroundColor: s.primaryButtonBackgroundPressed,
                    },
                },
            },
            splitButtonMenuIcon: {
                color: s.primaryButtonText,
            },
            splitButtonMenuIconDisabled: {
                color: p.neutralTertiary,
                selectors: (_j = {},
                    _j[HighContrastSelector] = {
                        color: 'GrayText',
                    },
                    _j),
            },
        };
    }

    var DEFAULT_BUTTON_HEIGHT$1 = '32px';
    var DEFAULT_BUTTON_MIN_WIDTH = '80px';
    var getStyles$g = memoizeFunction(function (theme, customStyles, primary) {
        var baseButtonStyles = getStyles$i(theme);
        var splitButtonStyles = getStyles$h(theme);
        var defaultButtonStyles = {
            root: {
                minWidth: DEFAULT_BUTTON_MIN_WIDTH,
                height: DEFAULT_BUTTON_HEIGHT$1,
            },
            label: {
                fontWeight: FontWeights.semibold,
            },
        };
        return concatStyleSets(baseButtonStyles, defaultButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), splitButtonStyles, customStyles);
    });

    /**
     * {@docCategory Button}
     */
    var DefaultButton = /** @class */ (function (_super) {
        __extends$4(DefaultButton, _super);
        function DefaultButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultButton.prototype.render = function () {
            var _a = this.props, _b = _a.primary, primary = _b === void 0 ? false : _b, styles = _a.styles, theme = _a.theme;
            return (react.exports.createElement(BaseButton, __assign$k({}, this.props, { variantClassName: primary ? 'ms-Button--primary' : 'ms-Button--default', styles: getStyles$g(theme, styles, primary), onRenderDescription: nullRender })));
        };
        DefaultButton = __decorate([
            customizable('DefaultButton', ['theme', 'styles'], true)
        ], DefaultButton);
        return DefaultButton;
    }(react.exports.Component));

    var DEFAULT_BUTTON_HEIGHT = '40px';
    var DEFAULT_PADDING = '0 4px';
    var getStyles$f = memoizeFunction(function (theme, customStyles) {
        var _a, _b, _c;
        var baseButtonStyles = getStyles$i(theme);
        var actionButtonStyles = {
            root: {
                padding: DEFAULT_PADDING,
                height: DEFAULT_BUTTON_HEIGHT,
                color: theme.palette.neutralPrimary,
                backgroundColor: 'transparent',
                border: '1px solid transparent',
                selectors: (_a = {},
                    _a[HighContrastSelector] = {
                        borderColor: 'Window',
                    },
                    _a),
            },
            rootHovered: {
                color: theme.palette.themePrimary,
                selectors: (_b = {},
                    _b[HighContrastSelector] = {
                        color: 'Highlight',
                    },
                    _b),
            },
            iconHovered: {
                color: theme.palette.themePrimary,
            },
            rootPressed: {
                color: theme.palette.black,
            },
            rootExpanded: {
                color: theme.palette.themePrimary,
            },
            iconPressed: {
                color: theme.palette.themeDarker,
            },
            rootDisabled: {
                color: theme.palette.neutralTertiary,
                backgroundColor: 'transparent',
                borderColor: 'transparent',
                selectors: (_c = {},
                    _c[HighContrastSelector] = {
                        color: 'GrayText',
                    },
                    _c),
            },
            rootChecked: {
                color: theme.palette.black,
            },
            iconChecked: {
                color: theme.palette.themeDarker,
            },
            flexContainer: {
                justifyContent: 'flex-start',
            },
            icon: {
                color: theme.palette.themeDarkAlt,
            },
            iconDisabled: {
                color: 'inherit',
            },
            menuIcon: {
                color: theme.palette.neutralSecondary,
            },
            textContainer: {
                flexGrow: 0,
            },
        };
        return concatStyleSets(baseButtonStyles, actionButtonStyles, customStyles);
    });

    /**
     * {@docCategory Button}
     */
    var ActionButton = /** @class */ (function (_super) {
        __extends$4(ActionButton, _super);
        function ActionButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ActionButton.prototype.render = function () {
            var _a = this.props, styles = _a.styles, theme = _a.theme;
            return (react.exports.createElement(BaseButton, __assign$k({}, this.props, { variantClassName: "ms-Button--action ms-Button--command", styles: getStyles$f(theme, styles), onRenderDescription: nullRender })));
        };
        ActionButton = __decorate([
            customizable('ActionButton', ['theme', 'styles'], true)
        ], ActionButton);
        return ActionButton;
    }(react.exports.Component));

    var getStyles$e = memoizeFunction(function (theme, customStyles, primary) {
        var _a, _b, _c, _d, _e;
        var fonts = theme.fonts, palette = theme.palette;
        var baseButtonStyles = getStyles$i(theme);
        var splitButtonStyles = getStyles$h(theme);
        var compoundButtonStyles = {
            root: {
                maxWidth: '280px',
                minHeight: '72px',
                height: 'auto',
                padding: '16px 12px',
            },
            flexContainer: {
                flexDirection: 'row',
                alignItems: 'flex-start',
                minWidth: '100%',
                margin: '',
            },
            textContainer: {
                textAlign: 'left',
            },
            icon: {
                fontSize: '2em',
                lineHeight: '1em',
                height: '1em',
                margin: '0px 8px 0px 0px',
                flexBasis: '1em',
                flexShrink: '0',
            },
            label: {
                margin: '0 0 5px',
                lineHeight: '100%',
                fontWeight: FontWeights.semibold,
            },
            description: [
                fonts.small,
                {
                    lineHeight: '100%',
                },
            ],
        };
        var standardCompoundTheme = {
            description: {
                color: palette.neutralSecondary,
            },
            descriptionHovered: {
                color: palette.neutralDark,
            },
            descriptionPressed: {
                color: 'inherit',
            },
            descriptionChecked: {
                color: 'inherit',
            },
            descriptionDisabled: {
                color: 'inherit',
            },
        };
        var primaryCompoundTheme = {
            description: {
                color: palette.white,
                selectors: (_a = {},
                    _a[HighContrastSelector] = __assign$k({ backgroundColor: 'WindowText', color: 'Window' }, getHighContrastNoAdjustStyle()),
                    _a),
            },
            descriptionHovered: {
                color: palette.white,
                selectors: (_b = {},
                    _b[HighContrastSelector] = {
                        backgroundColor: 'Highlight',
                        color: 'Window',
                    },
                    _b),
            },
            descriptionPressed: {
                color: 'inherit',
                selectors: (_c = {},
                    _c[HighContrastSelector] = __assign$k({ color: 'Window', backgroundColor: 'WindowText' }, getHighContrastNoAdjustStyle()),
                    _c),
            },
            descriptionChecked: {
                color: 'inherit',
                selectors: (_d = {},
                    _d[HighContrastSelector] = __assign$k({ color: 'Window', backgroundColor: 'WindowText' }, getHighContrastNoAdjustStyle()),
                    _d),
            },
            descriptionDisabled: {
                color: 'inherit',
                selectors: (_e = {},
                    _e[HighContrastSelector] = {
                        color: 'inherit',
                    },
                    _e),
            },
        };
        return concatStyleSets(baseButtonStyles, compoundButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), primary ? primaryCompoundTheme : standardCompoundTheme, splitButtonStyles, customStyles);
    });

    /**
     * {@docCategory Button}
     */
    var CompoundButton = /** @class */ (function (_super) {
        __extends$4(CompoundButton, _super);
        function CompoundButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CompoundButton.prototype.render = function () {
            var _a = this.props, _b = _a.primary, primary = _b === void 0 ? false : _b, styles = _a.styles, theme = _a.theme;
            return (react.exports.createElement(BaseButton, __assign$k({}, this.props, { variantClassName: primary ? 'ms-Button--compoundPrimary' : 'ms-Button--compound', styles: getStyles$e(theme, styles, primary) })));
        };
        CompoundButton = __decorate([
            customizable('CompoundButton', ['theme', 'styles'], true)
        ], CompoundButton);
        return CompoundButton;
    }(react.exports.Component));

    var getStyles$d = memoizeFunction(function (theme, customStyles) {
        var _a;
        var baseButtonStyles = getStyles$i(theme);
        var splitButtonStyles = getStyles$h(theme);
        var palette = theme.palette, semanticColors = theme.semanticColors;
        var iconButtonStyles = {
            root: {
                padding: '0 4px',
                width: '32px',
                height: '32px',
                backgroundColor: 'transparent',
                border: 'none',
                color: semanticColors.link,
            },
            rootHovered: {
                color: palette.themeDarkAlt,
                backgroundColor: palette.neutralLighter,
                selectors: (_a = {},
                    _a[HighContrastSelector] = {
                        borderColor: 'Highlight',
                        color: 'Highlight',
                    },
                    _a),
            },
            rootHasMenu: {
                width: 'auto',
            },
            rootPressed: {
                color: palette.themeDark,
                backgroundColor: palette.neutralLight,
            },
            rootExpanded: {
                color: palette.themeDark,
                backgroundColor: palette.neutralLight,
            },
            rootChecked: {
                color: palette.themeDark,
                backgroundColor: palette.neutralLight,
            },
            rootCheckedHovered: {
                color: palette.themeDark,
                backgroundColor: palette.neutralQuaternaryAlt,
            },
            rootDisabled: {
                color: palette.neutralTertiaryAlt,
            },
        };
        return concatStyleSets(baseButtonStyles, iconButtonStyles, splitButtonStyles, customStyles);
    });

    /**
     * {@docCategory Button}
     */
    var IconButton = /** @class */ (function (_super) {
        __extends$4(IconButton, _super);
        function IconButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IconButton.prototype.render = function () {
            var _a = this.props, styles = _a.styles, theme = _a.theme;
            return (react.exports.createElement(BaseButton, __assign$k({}, this.props, { variantClassName: "ms-Button--icon", styles: getStyles$d(theme, styles), onRenderText: nullRender, onRenderDescription: nullRender })));
        };
        IconButton = __decorate([
            customizable('IconButton', ['theme', 'styles'], true)
        ], IconButton);
        return IconButton;
    }(react.exports.Component));

    /**
     * {@docCategory Button}
     */
    var PrimaryButton = /** @class */ (function (_super) {
        __extends$4(PrimaryButton, _super);
        function PrimaryButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PrimaryButton.prototype.render = function () {
            return react.exports.createElement(DefaultButton, __assign$k({}, this.props, { primary: true, onRenderDescription: nullRender }));
        };
        PrimaryButton = __decorate([
            customizable('PrimaryButton', ['theme', 'styles'], true)
        ], PrimaryButton);
        return PrimaryButton;
    }(react.exports.Component));

    /**
     * This class is deprecated. Use the individual *Button components instead.
     * @deprecated Use the individual *Button components instead.
     * {@docCategory Button}
     */
    var Button$1 = /** @class */ (function (_super) {
        __extends$4(Button, _super);
        function Button(props) {
            var _this = _super.call(this, props) || this;
            warn("The Button component has been deprecated. Use specific variants instead. " +
                "(PrimaryButton, DefaultButton, IconButton, ActionButton, etc.)");
            return _this;
        }
        Button.prototype.render = function () {
            var props = this.props;
            // eslint-disable-next-line deprecation/deprecation
            switch (props.buttonType) {
                case ButtonType.command:
                    return react.exports.createElement(ActionButton, __assign$k({}, props));
                case ButtonType.compound:
                    return react.exports.createElement(CompoundButton, __assign$k({}, props));
                case ButtonType.icon:
                    return react.exports.createElement(IconButton, __assign$k({}, props));
                case ButtonType.primary:
                    return react.exports.createElement(PrimaryButton, __assign$k({}, props));
                default:
                    return react.exports.createElement(DefaultButton, __assign$k({}, props));
            }
        };
        return Button;
    }(react.exports.Component));

    var getStyles$c = memoizeFunction(function (theme, customStyles, focusInset, focusColor) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        var baseButtonStyles = getStyles$i(theme);
        var baseSplitButtonStyles = getStyles$h(theme);
        var p = theme.palette, semanticColors = theme.semanticColors;
        var commandButtonHighContrastFocus = {
            left: 4,
            top: 4,
            bottom: 4,
            right: 4,
            border: 'none',
        };
        var commandButtonStyles = {
            root: [
                getFocusStyle(theme, {
                    inset: 2,
                    highContrastStyle: commandButtonHighContrastFocus,
                    borderColor: 'transparent',
                }),
                theme.fonts.medium,
                {
                    minWidth: '40px',
                    backgroundColor: p.white,
                    color: p.neutralPrimary,
                    padding: '0 4px',
                    border: 'none',
                    borderRadius: 0,
                    selectors: (_a = {},
                        _a[HighContrastSelector] = {
                            border: 'none',
                        },
                        _a),
                },
            ],
            rootHovered: {
                backgroundColor: p.neutralLighter,
                color: p.neutralDark,
                selectors: (_b = {},
                    _b[HighContrastSelector] = {
                        color: 'Highlight',
                    },
                    _b["." + ButtonGlobalClassNames.msButtonIcon] = {
                        color: p.themeDarkAlt,
                    },
                    _b["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
                        color: p.neutralPrimary,
                    },
                    _b),
            },
            rootPressed: {
                backgroundColor: p.neutralLight,
                color: p.neutralDark,
                selectors: (_c = {},
                    _c["." + ButtonGlobalClassNames.msButtonIcon] = {
                        color: p.themeDark,
                    },
                    _c["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
                        color: p.neutralPrimary,
                    },
                    _c),
            },
            rootChecked: {
                backgroundColor: p.neutralLight,
                color: p.neutralDark,
                selectors: (_d = {},
                    _d["." + ButtonGlobalClassNames.msButtonIcon] = {
                        color: p.themeDark,
                    },
                    _d["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
                        color: p.neutralPrimary,
                    },
                    _d),
            },
            rootCheckedHovered: {
                backgroundColor: p.neutralQuaternaryAlt,
                selectors: (_e = {},
                    _e["." + ButtonGlobalClassNames.msButtonIcon] = {
                        color: p.themeDark,
                    },
                    _e["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
                        color: p.neutralPrimary,
                    },
                    _e),
            },
            rootExpanded: {
                backgroundColor: p.neutralLight,
                color: p.neutralDark,
                selectors: (_f = {},
                    _f["." + ButtonGlobalClassNames.msButtonIcon] = {
                        color: p.themeDark,
                    },
                    _f["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
                        color: p.neutralPrimary,
                    },
                    _f),
            },
            rootExpandedHovered: {
                backgroundColor: p.neutralQuaternaryAlt,
            },
            rootDisabled: {
                backgroundColor: p.white,
                selectors: (_g = {},
                    _g["." + ButtonGlobalClassNames.msButtonIcon] = {
                        color: semanticColors.disabledBodySubtext,
                        selectors: (_h = {},
                            _h[HighContrastSelector] = __assign$k({ color: 'GrayText' }, getHighContrastNoAdjustStyle()),
                            _h),
                    },
                    _g[HighContrastSelector] = __assign$k({ color: 'GrayText', backgroundColor: 'Window' }, getHighContrastNoAdjustStyle()),
                    _g),
            },
            // Split button styles
            splitButtonContainer: {
                height: '100%',
                selectors: (_j = {},
                    _j[HighContrastSelector] = {
                        border: 'none',
                    },
                    _j),
            },
            splitButtonDividerDisabled: {
                selectors: (_k = {},
                    _k[HighContrastSelector] = {
                        backgroundColor: 'Window',
                    },
                    _k),
            },
            splitButtonDivider: {
                backgroundColor: p.neutralTertiaryAlt,
            },
            splitButtonMenuButton: {
                backgroundColor: p.white,
                border: 'none',
                borderTopRightRadius: '0',
                borderBottomRightRadius: '0',
                color: p.neutralSecondary,
                selectors: {
                    ':hover': {
                        backgroundColor: p.neutralLighter,
                        color: p.neutralDark,
                        selectors: (_l = {},
                            _l[HighContrastSelector] = {
                                color: 'Highlight',
                            },
                            _l["." + ButtonGlobalClassNames.msButtonIcon] = {
                                color: p.neutralPrimary,
                            },
                            _l),
                    },
                    ':active': {
                        backgroundColor: p.neutralLight,
                        selectors: (_m = {},
                            _m["." + ButtonGlobalClassNames.msButtonIcon] = {
                                color: p.neutralPrimary,
                            },
                            _m),
                    },
                },
            },
            splitButtonMenuButtonDisabled: {
                backgroundColor: p.white,
                selectors: (_o = {},
                    _o[HighContrastSelector] = __assign$k({ color: 'GrayText', border: 'none', backgroundColor: 'Window' }, getHighContrastNoAdjustStyle()),
                    _o),
            },
            splitButtonMenuButtonChecked: {
                backgroundColor: p.neutralLight,
                color: p.neutralDark,
                selectors: {
                    ':hover': {
                        backgroundColor: p.neutralQuaternaryAlt,
                    },
                },
            },
            splitButtonMenuButtonExpanded: {
                backgroundColor: p.neutralLight,
                color: p.black,
                selectors: {
                    ':hover': {
                        backgroundColor: p.neutralQuaternaryAlt,
                    },
                },
            },
            splitButtonMenuIcon: {
                color: p.neutralPrimary,
            },
            splitButtonMenuIconDisabled: {
                color: p.neutralTertiary,
            },
            label: {
                fontWeight: 'normal', // theme.fontWeights.semibold,
            },
            icon: {
                color: p.themePrimary,
            },
            menuIcon: (_p = {
                    color: p.neutralSecondary
                },
                _p[HighContrastSelector] = {
                    color: 'GrayText',
                },
                _p),
        };
        return concatStyleSets(baseButtonStyles, baseSplitButtonStyles, commandButtonStyles, customStyles);
    });

    /**
     * {@docCategory Button}
     */
    var CommandBarButton = /** @class */ (function (_super) {
        __extends$4(CommandBarButton, _super);
        function CommandBarButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CommandBarButton.prototype.render = function () {
            var _a = this.props, styles = _a.styles, theme = _a.theme;
            return (react.exports.createElement(BaseButton, __assign$k({}, this.props, { variantClassName: "ms-Button--commandBar", styles: getStyles$c(theme, styles), onRenderDescription: nullRender })));
        };
        CommandBarButton = __decorate([
            customizable('CommandBarButton', ['theme', 'styles'], true)
        ], CommandBarButton);
        return CommandBarButton;
    }(react.exports.Component));

    /**
     * {@docCategory Button}
     */
    var CommandButton = ActionButton;

    var getStyles$b = memoizeFunction(function (theme, customStyles) {
        return concatStyleSets({
            root: [
                getFocusStyle(theme, {
                    inset: 1,
                    highContrastStyle: {
                        outlineOffset: '-4px',
                        outline: '1px solid Window',
                    },
                    borderColor: 'transparent',
                }),
                {
                    height: 24,
                },
            ],
        }, customStyles);
    });

    /**
     * {@docCategory MessageBar}
     */
    var MessageBarButton = /** @class */ (function (_super) {
        __extends$4(MessageBarButton, _super);
        function MessageBarButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MessageBarButton.prototype.render = function () {
            var _a = this.props, styles = _a.styles, theme = _a.theme;
            return react.exports.createElement(DefaultButton, __assign$k({}, this.props, { styles: getStyles$b(theme, styles), onRenderDescription: nullRender }));
        };
        MessageBarButton = __decorate([
            customizable('MessageBarButton', ['theme', 'styles'], true)
        ], MessageBarButton);
        return MessageBarButton;
    }(react.exports.Component));

    var Button = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BaseButton: BaseButton,
        get ElementType () { return ElementType; },
        get ButtonType () { return ButtonType; },
        Button: Button$1,
        ActionButton: ActionButton,
        CommandBarButton: CommandBarButton,
        CommandButton: CommandButton,
        CompoundButton: CompoundButton,
        DefaultButton: DefaultButton,
        MessageBarButton: MessageBarButton,
        PrimaryButton: PrimaryButton,
        IconButton: IconButton,
        getSplitButtonClassNames: getSplitButtonClassNames
    });

    /**
     * {@docCategory ResizeGroup}
     */
    var ResizeGroupDirection;
    (function (ResizeGroupDirection) {
        ResizeGroupDirection[ResizeGroupDirection["horizontal"] = 0] = "horizontal";
        ResizeGroupDirection[ResizeGroupDirection["vertical"] = 1] = "vertical";
    })(ResizeGroupDirection || (ResizeGroupDirection = {}));

    var RESIZE_DELAY = 16;
    /**
     * Returns a simple object is able to store measurements with a given key.
     */
    var getMeasurementCache = function () {
        var measurementsCache = {};
        return {
            /**
             * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a
             * corresponding entry in the measurementsCache, then it will return that value.
             * Returns undefined otherwise.
             */
            getCachedMeasurement: function (data) {
                if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {
                    return measurementsCache[data.cacheKey];
                }
                return undefined;
            },
            /**
             * Should be called whenever there is a new measurement associated with a given data object.
             * If the data has a cacheKey, store that measurement in the measurementsCache.
             */
            addMeasurementToCache: function (data, measurement) {
                if (data.cacheKey) {
                    measurementsCache[data.cacheKey] = measurement;
                }
            },
        };
    };
    /**
     * Returns a function that is able to compute the next state for the ResizeGroup given the current
     * state and any measurement updates.
     */
    var getNextResizeGroupStateProvider = function (measurementCache) {
        if (measurementCache === void 0) { measurementCache = getMeasurementCache(); }
        var _measurementCache = measurementCache;
        var _containerDimension;
        /**
         * Gets the width/height of the data rendered in a hidden div.
         * @param measuredData - The data corresponding to the measurement we wish to take.
         * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.
         * Only called when the measurement is not in the cache.
         */
        function _getMeasuredDimension(measuredData, getElementToMeasureDimension) {
            var cachedDimension = _measurementCache.getCachedMeasurement(measuredData);
            if (cachedDimension !== undefined) {
                return cachedDimension;
            }
            var measuredDimension = getElementToMeasureDimension();
            _measurementCache.addMeasurementToCache(measuredData, measuredDimension);
            return measuredDimension;
        }
        /**
         * Will get the next IResizeGroupState based on the current data while trying to shrink contents
         * to fit in the container.
         * @param data - The initial data point to start measuring.
         * @param onReduceData - Function that transforms the data into something that should render with less width/height.
         * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.
         * Only called when the measurement is not in the cache.
         */
        function _shrinkContentsUntilTheyFit(data, onReduceData, getElementToMeasureDimension) {
            var dataToMeasure = data;
            var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);
            while (measuredDimension > _containerDimension) {
                var nextMeasuredData = onReduceData(dataToMeasure);
                // We don't want to get stuck in an infinite render loop when there are no more
                // scaling steps, so implementations of onReduceData should return undefined when
                // there are no more scaling states to apply.
                if (nextMeasuredData === undefined) {
                    return {
                        renderedData: dataToMeasure,
                        resizeDirection: undefined,
                        dataToMeasure: undefined,
                    };
                }
                measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);
                // If the measurement isn't in the cache, we need to re-render with some data in a hidden div
                if (measuredDimension === undefined) {
                    return {
                        dataToMeasure: nextMeasuredData,
                        resizeDirection: 'shrink',
                    };
                }
                dataToMeasure = nextMeasuredData;
            }
            return {
                renderedData: dataToMeasure,
                resizeDirection: undefined,
                dataToMeasure: undefined,
            };
        }
        /**
         * This function should be called when the state changes in a manner that might allow for more content to fit
         * on the screen, such as the window width/height growing.
         * @param data - The initial data point to start measuring.
         * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.
         * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.
         * Only called when the measurement is not in the cache.
         */
        function _growDataUntilItDoesNotFit(data, onGrowData, getElementToMeasureDimension, onReduceData) {
            var dataToMeasure = data;
            var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);
            while (measuredDimension < _containerDimension) {
                var nextMeasuredData = onGrowData(dataToMeasure);
                // We don't want to get stuck in an infinite render loop when there are no more
                // scaling steps, so implementations of onGrowData should return undefined when
                // there are no more scaling states to apply.
                if (nextMeasuredData === undefined) {
                    return {
                        renderedData: dataToMeasure,
                        resizeDirection: undefined,
                        dataToMeasure: undefined,
                    };
                }
                measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);
                // If the measurement isn't in the cache, we need to re-render with some data in a hidden div
                if (measuredDimension === undefined) {
                    return {
                        dataToMeasure: nextMeasuredData,
                    };
                }
                dataToMeasure = nextMeasuredData;
            }
            // Once the loop is done, we should now shrink until the contents fit.
            return __assign$k({ resizeDirection: 'shrink' }, _shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension));
        }
        /**
         * Handles an update to the container width/height.
         * Should only be called when we knew the previous container width/height.
         * @param newDimension - The new width/height of the container.
         * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.
         * @param renderedData - The data that was rendered prior to the container size changing.
         * @param onGrowData - Set to true if the Resize group has an onGrowData function.
         */
        function _updateContainerDimension(newDimension, fullDimensionData, renderedData, onGrowData) {
            var nextState;
            if (newDimension > _containerDimension) {
                if (onGrowData) {
                    nextState = {
                        resizeDirection: 'grow',
                        dataToMeasure: onGrowData(renderedData),
                    };
                }
                else {
                    nextState = {
                        resizeDirection: 'shrink',
                        dataToMeasure: fullDimensionData,
                    };
                }
            }
            else {
                nextState = {
                    resizeDirection: 'shrink',
                    dataToMeasure: renderedData,
                };
            }
            _containerDimension = newDimension;
            return __assign$k(__assign$k({}, nextState), { measureContainer: false });
        }
        function getNextState(props, currentState, getElementToMeasureDimension, newContainerDimension) {
            // If there is no new container width/height or data to measure, there is no need for a new state update
            if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {
                return undefined;
            }
            if (newContainerDimension) {
                // If we know the last container size and we rendered data at that width/height, we can do an optimized render
                if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {
                    return __assign$k(__assign$k({}, currentState), _updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData));
                }
                // If we are just setting the container width/height for the first time, we can't do any optimizations
                _containerDimension = newContainerDimension;
            }
            var nextState = __assign$k(__assign$k({}, currentState), { measureContainer: false });
            if (currentState.dataToMeasure) {
                if (currentState.resizeDirection === 'grow' && props.onGrowData) {
                    nextState = __assign$k(__assign$k({}, nextState), _growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureDimension, props.onReduceData));
                }
                else {
                    nextState = __assign$k(__assign$k({}, nextState), _shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension));
                }
            }
            return nextState;
        }
        /** Function that determines if we need to render content for measurement based on the measurement cache contents. */
        function shouldRenderDataForMeasurement(dataToMeasure) {
            if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {
                return false;
            }
            return true;
        }
        function getInitialResizeGroupState(data) {
            return {
                dataToMeasure: __assign$k({}, data),
                resizeDirection: 'grow',
                measureContainer: true,
            };
        }
        return {
            getNextState: getNextState,
            shouldRenderDataForMeasurement: shouldRenderDataForMeasurement,
            getInitialResizeGroupState: getInitialResizeGroupState,
        };
    };
    // Provides a context property that (if true) tells any child components that
    // they are only being used for measurement purposes and will not be visible.
    var MeasuredContext = react.exports.createContext({ isMeasured: false });
    // Styles for the hidden div used for measurement
    var hiddenDivStyles = { position: 'fixed', visibility: 'hidden' };
    var hiddenParentStyles = { position: 'relative' };
    /**
     * Use useReducer instead of userState because React is not batching the state updates
     * when state is set in callbacks of setTimeout or requestAnimationFrame.
     * See issue: https://github.com/facebook/react/issues/14259
     */
    function resizeDataReducer(state, action) {
        var _a;
        switch (action.type) {
            case 'resizeData':
                return __assign$k({}, action.value);
            case 'dataToMeasure':
                return __assign$k(__assign$k({}, state), { dataToMeasure: action.value, resizeDirection: 'grow', measureContainer: true });
            default:
                return __assign$k(__assign$k({}, state), (_a = {}, _a[action.type] = action.value, _a));
        }
    }
    function useResizeState(props, nextResizeGroupStateProvider, rootRef) {
        var initialStateData = useConst(function () { return nextResizeGroupStateProvider.getInitialResizeGroupState(props.data); });
        var _a = react.exports.useReducer(resizeDataReducer, initialStateData), resizeData = _a[0], dispatchResizeDataAction = _a[1];
        // Reset state when new data is provided
        react.exports.useEffect(function () {
            dispatchResizeDataAction({
                type: 'dataToMeasure',
                value: props.data,
            });
        }, [props.data]);
        // Because it's possible that we may force more than one re-render per animation frame, we
        // want to make sure that the RAF request is using the most recent data.
        var stateRef = react.exports.useRef(initialStateData);
        stateRef.current = __assign$k({}, resizeData);
        var updateResizeState = react.exports.useCallback(function (nextState) {
            if (nextState) {
                dispatchResizeDataAction({
                    type: 'resizeData',
                    value: nextState,
                });
            }
        }, []);
        var remeasure = react.exports.useCallback(function () {
            if (rootRef.current) {
                dispatchResizeDataAction({
                    type: 'measureContainer',
                    value: true,
                });
            }
        }, [rootRef]);
        return [stateRef, updateResizeState, remeasure];
    }
    function useResizingBehavior(props, rootRef) {
        var nextResizeGroupStateProvider = useConst(getNextResizeGroupStateProvider);
        // A div that can be used for the initial measurement so that we can avoid mounting a second instance
        // of the component being measured for the initial render.
        var initialHiddenDiv = react.exports.useRef(null);
        // A hidden div that is used for mounting a new instance of the component for measurement in a hidden
        // div without unmounting the currently visible content.
        var updateHiddenDiv = react.exports.useRef(null);
        // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations
        // for the initial render.
        var hasRenderedContent = react.exports.useRef(false);
        var async = useAsync();
        var _a = useResizeState(props, nextResizeGroupStateProvider, rootRef), stateRef = _a[0], updateResizeState = _a[1], remeasure = _a[2];
        react.exports.useEffect(function () {
            var _a;
            if (stateRef.current.renderedData) {
                hasRenderedContent.current = true;
                (_a = props.dataDidRender) === null || _a === void 0 ? void 0 : _a.call(props, stateRef.current.renderedData);
            }
        });
        react.exports.useEffect(function () {
            async.requestAnimationFrame(function () {
                var containerDimension = undefined;
                if (stateRef.current.measureContainer && rootRef.current) {
                    var boundingRect = rootRef.current.getBoundingClientRect();
                    containerDimension =
                        props.direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;
                }
                var nextState = nextResizeGroupStateProvider.getNextState(props, stateRef.current, function () {
                    var refToMeasure = !hasRenderedContent.current ? initialHiddenDiv : updateHiddenDiv;
                    if (!refToMeasure.current) {
                        return 0;
                    }
                    return props.direction === ResizeGroupDirection.vertical
                        ? refToMeasure.current.scrollHeight
                        : refToMeasure.current.scrollWidth;
                }, containerDimension);
                updateResizeState(nextState);
            }, rootRef.current);
        });
        var win = useWindow();
        useOnEvent(win, 'resize', async.debounce(remeasure, RESIZE_DELAY, { leading: true }));
        var dataNeedsMeasuring = nextResizeGroupStateProvider.shouldRenderDataForMeasurement(stateRef.current.dataToMeasure);
        var isInitialMeasure = !hasRenderedContent.current && dataNeedsMeasuring;
        return [
            stateRef.current.dataToMeasure,
            stateRef.current.renderedData,
            remeasure,
            initialHiddenDiv,
            updateHiddenDiv,
            dataNeedsMeasuring,
            isInitialMeasure,
        ];
    }
    var measuredContextValue = { isMeasured: true };
    var ResizeGroupBase = react.exports.forwardRef(function (props, forwardedRef) {
        var rootRef = react.exports.useRef(null);
        // The root div which is the container inside of which we are trying to fit content.
        var mergedRootRef = useMergedRefs(rootRef, forwardedRef);
        var _a = useResizingBehavior(props, rootRef), dataToMeasure = _a[0], renderedData = _a[1], remeasure = _a[2], initialHiddenDiv = _a[3], updateHiddenDiv = _a[4], dataNeedsMeasuring = _a[5], isInitialMeasure = _a[6];
        react.exports.useImperativeHandle(props.componentRef, function () { return ({ remeasure: remeasure }); }, [remeasure]);
        var className = props.className, onRenderData = props.onRenderData;
        var divProps = getNativeProps(props, divProperties, ['data']);
        // We only ever render the final content to the user. All measurements are done in a hidden div.
        // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one
        // version of the component for measurement and the final render. For renders that update what is on screen, we
        // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for
        // measurement. In the update case, we mount a second version of the component just for measurement purposes and
        // leave the rendered content untouched until we know the next state to show to the user.
        return (react.exports.createElement("div", __assign$k({}, divProps, { className: className, ref: mergedRootRef }),
            react.exports.createElement("div", { style: hiddenParentStyles },
                dataNeedsMeasuring && !isInitialMeasure && (react.exports.createElement("div", { style: hiddenDivStyles, ref: updateHiddenDiv },
                    react.exports.createElement(MeasuredContext.Provider, { value: measuredContextValue }, onRenderData(dataToMeasure)))),
                react.exports.createElement("div", { ref: initialHiddenDiv, style: isInitialMeasure ? hiddenDivStyles : undefined, "data-automation-id": "visibleContent" }, isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData)))));
    });
    ResizeGroupBase.displayName = 'ResizeGroupBase';

    var ResizeGroup = ResizeGroupBase;

    var getClassNames$9 = classNamesFunction({
        // Label is used a lot by other components.
        // It's likely to see expected cases which pass different className to the Label.
        // Therefore setting a larger cache size.
        cacheSize: 100,
    });
    var LabelBase = /** @class */ (function (_super) {
        __extends$4(LabelBase, _super);
        function LabelBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LabelBase.prototype.render = function () {
            var _a = this.props, _b = _a.as, RootType = _b === void 0 ? 'label' : _b, children = _a.children, className = _a.className, disabled = _a.disabled, styles = _a.styles, required = _a.required, theme = _a.theme;
            var classNames = getClassNames$9(styles, {
                className: className,
                disabled: disabled,
                required: required,
                theme: theme,
            });
            return (react.exports.createElement(RootType, __assign$k({}, getNativeProps(this.props, divProperties), { className: classNames.root }), children));
        };
        return LabelBase;
    }(react.exports.Component));

    var getStyles$a = function (props) {
        var _a;
        var theme = props.theme, className = props.className, disabled = props.disabled, required = props.required;
        var semanticColors = theme.semanticColors;
        // Tokens
        var labelFontWeight = FontWeights.semibold;
        var labelColor = semanticColors.bodyText;
        var labelDisabledColor = semanticColors.disabledBodyText;
        var labelRequiredStarColor = semanticColors.errorText;
        return {
            root: [
                'ms-Label',
                theme.fonts.medium,
                {
                    fontWeight: labelFontWeight,
                    color: labelColor,
                    boxSizing: 'border-box',
                    boxShadow: 'none',
                    margin: 0,
                    display: 'block',
                    padding: '5px 0',
                    wordWrap: 'break-word',
                    overflowWrap: 'break-word',
                },
                disabled && {
                    color: labelDisabledColor,
                    selectors: (_a = {},
                        _a[HighContrastSelector] = __assign$k({ color: 'GrayText' }, getHighContrastNoAdjustStyle()),
                        _a),
                },
                required && {
                    selectors: {
                        '::after': {
                            content: "' *'",
                            color: labelRequiredStarColor,
                            paddingRight: 12,
                        },
                    },
                },
                className,
            ],
        };
    };

    var Label = styled(LabelBase, getStyles$a, undefined, {
        scope: 'Label',
    });

    var getClassNames$8 = classNamesFunction();
    var DEFAULT_STATE_VALUE = '';
    var COMPONENT_NAME$2 = 'TextField';
    var REVEAL_ICON_NAME = 'RedEye';
    var HIDE_ICON_NAME = 'Hide';
    var TextFieldBase = /** @class */ (function (_super) {
        __extends$4(TextFieldBase, _super);
        function TextFieldBase(props) {
            var _this = _super.call(this, props) || this;
            _this._textElement = react.exports.createRef();
            _this._onFocus = function (ev) {
                if (_this.props.onFocus) {
                    _this.props.onFocus(ev);
                }
                _this.setState({ isFocused: true }, function () {
                    if (_this.props.validateOnFocusIn) {
                        _this._validate(_this.value);
                    }
                });
            };
            _this._onBlur = function (ev) {
                if (_this.props.onBlur) {
                    _this.props.onBlur(ev);
                }
                _this.setState({ isFocused: false }, function () {
                    if (_this.props.validateOnFocusOut) {
                        _this._validate(_this.value);
                    }
                });
            };
            _this._onRenderLabel = function (props) {
                var label = props.label, required = props.required;
                // IProcessedStyleSet definition requires casting for what Label expects as its styles prop
                var labelStyles = _this._classNames.subComponentStyles
                    ? _this._classNames.subComponentStyles.label
                    : undefined;
                if (label) {
                    return (react.exports.createElement(Label, { required: required, htmlFor: _this._id, styles: labelStyles, disabled: props.disabled, id: _this._labelId }, props.label));
                }
                return null;
            };
            _this._onRenderDescription = function (props) {
                if (props.description) {
                    return react.exports.createElement("span", { className: _this._classNames.description }, props.description);
                }
                return null;
            };
            _this._onRevealButtonClick = function (event) {
                _this.setState(function (prevState) { return ({ isRevealingPassword: !prevState.isRevealingPassword }); });
            };
            _this._onInputChange = function (event) {
                // Previously, we needed to call both onInput and onChange due to some weird IE/React issues,
                // which have *probably* been fixed now:
                // - https://github.com/microsoft/fluentui/issues/744 (likely fixed)
                // - https://github.com/microsoft/fluentui/issues/824 (confirmed fixed)
                var _a, _b;
                // TODO (Fabric 8?) - Switch to calling only onChange. This switch is pretty disruptive for
                // tests (ours and maybe consumers' too), so it seemed best to do the switch in a major bump.
                var element = event.target;
                var value = element.value;
                // Ignore this event if any of the following are true:
                // - the value is undefined (in case one of the IE bugs comes back)
                // - it's a duplicate event (important since onInputChange is called twice per actual user event)
                // - it's the same as the previous value
                var previousValue = _getValue(_this.props, _this.state) || '';
                if (value === undefined || value === _this._lastChangeValue || value === previousValue) {
                    _this._lastChangeValue = undefined;
                    return;
                }
                _this._lastChangeValue = value;
                (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, event, value);
                if (!_this._isControlled) {
                    // ONLY if this is an uncontrolled component, update the displayed value.
                    // (Controlled components must update the `value` prop from `onChange`.)
                    _this.setState({ uncontrolledValue: value });
                }
            };
            initializeComponentRef(_this);
            _this._async = new Async(_this);
            _this._fallbackId = getId(COMPONENT_NAME$2);
            _this._descriptionId = getId(COMPONENT_NAME$2 + 'Description');
            _this._labelId = getId(COMPONENT_NAME$2 + 'Label');
            _this._prefixId = getId(COMPONENT_NAME$2 + 'Prefix');
            _this._suffixId = getId(COMPONENT_NAME$2 + 'Suffix');
            _this._warnControlledUsage();
            var _a = props.defaultValue, defaultValue = _a === void 0 ? DEFAULT_STATE_VALUE : _a;
            if (typeof defaultValue === 'number') {
                // This isn't allowed per the props, but happens anyway.
                defaultValue = String(defaultValue);
            }
            _this.state = {
                uncontrolledValue: _this._isControlled ? undefined : defaultValue,
                isFocused: false,
                errorMessage: '',
            };
            _this._delayedValidate = _this._async.debounce(_this._validate, _this.props.deferredValidationTime);
            _this._lastValidation = 0;
            return _this;
        }
        Object.defineProperty(TextFieldBase.prototype, "value", {
            /**
             * Gets the current value of the text field.
             */
            get: function () {
                return _getValue(this.props, this.state);
            },
            enumerable: false,
            configurable: true
        });
        TextFieldBase.prototype.componentDidMount = function () {
            this._adjustInputHeight();
            if (this.props.validateOnLoad) {
                this._validate(this.value);
            }
        };
        TextFieldBase.prototype.componentWillUnmount = function () {
            this._async.dispose();
        };
        TextFieldBase.prototype.getSnapshotBeforeUpdate = function (prevProps, prevState) {
            return {
                selection: [this.selectionStart, this.selectionEnd],
            };
        };
        TextFieldBase.prototype.componentDidUpdate = function (prevProps, prevState, snapshot) {
            var props = this.props;
            var _a = (snapshot || {}).selection, selection = _a === void 0 ? [null, null] : _a;
            var start = selection[0], end = selection[1];
            if (!!prevProps.multiline !== !!props.multiline && prevState.isFocused) {
                // The text field has just changed between single- and multi-line, so we need to reset focus
                // and selection/cursor.
                this.focus();
                if (start !== null && end !== null && start >= 0 && end >= 0) {
                    this.setSelectionRange(start, end);
                }
            }
            if (prevProps.value !== props.value) {
                // Only if the value in props changed, reset the record of the last value seen by a
                // change/input event (don't do this if the value in state changed, since at least in tests
                // the state update may happen before the second event in a series)
                this._lastChangeValue = undefined;
            }
            var prevValue = _getValue(prevProps, prevState);
            var value = this.value;
            if (prevValue !== value) {
                // Handle controlled/uncontrolled warnings and status
                this._warnControlledUsage(prevProps);
                // Clear error message if needed
                // TODO: is there any way to do this without an extra render?
                if (this.state.errorMessage && !props.errorMessage) {
                    this.setState({ errorMessage: '' });
                }
                // Adjust height if needed based on new value
                this._adjustInputHeight();
                // TODO: #5875 added logic to trigger validation in componentWillReceiveProps and other places.
                // This seems a bit odd and hard to integrate with the new approach.
                // (Starting to think we should just put the validation logic in a separate wrapper component...?)
                if (_shouldValidateAllChanges(props)) {
                    this._delayedValidate(value);
                }
            }
        };
        TextFieldBase.prototype.render = function () {
            var _a = this.props, borderless = _a.borderless, className = _a.className, disabled = _a.disabled, invalid = _a.invalid, iconProps = _a.iconProps, inputClassName = _a.inputClassName, label = _a.label, multiline = _a.multiline, required = _a.required, underlined = _a.underlined, prefix = _a.prefix, resizable = _a.resizable, suffix = _a.suffix, theme = _a.theme, styles = _a.styles, autoAdjustHeight = _a.autoAdjustHeight, canRevealPassword = _a.canRevealPassword, revealPasswordAriaLabel = _a.revealPasswordAriaLabel, type = _a.type, _b = _a.onRenderPrefix, onRenderPrefix = _b === void 0 ? this._onRenderPrefix : _b, _c = _a.onRenderSuffix, onRenderSuffix = _c === void 0 ? this._onRenderSuffix : _c, _d = _a.onRenderLabel, onRenderLabel = _d === void 0 ? this._onRenderLabel : _d, _e = _a.onRenderDescription, onRenderDescription = _e === void 0 ? this._onRenderDescription : _e;
            var _f = this.state, isFocused = _f.isFocused, isRevealingPassword = _f.isRevealingPassword;
            var errorMessage = this._errorMessage;
            var isInvalid = typeof invalid === 'boolean' ? invalid : !!errorMessage;
            var hasRevealButton = !!canRevealPassword && type === 'password' && _browserNeedsRevealButton();
            var classNames = (this._classNames = getClassNames$8(styles, {
                theme: theme,
                className: className,
                disabled: disabled,
                focused: isFocused,
                required: required,
                multiline: multiline,
                hasLabel: !!label,
                hasErrorMessage: isInvalid,
                borderless: borderless,
                resizable: resizable,
                hasIcon: !!iconProps,
                underlined: underlined,
                inputClassName: inputClassName,
                autoAdjustHeight: autoAdjustHeight,
                hasRevealButton: hasRevealButton,
            }));
            return (
            // eslint-disable-next-line deprecation/deprecation
            react.exports.createElement("div", { ref: this.props.elementRef, className: classNames.root },
                react.exports.createElement("div", { className: classNames.wrapper },
                    onRenderLabel(this.props, this._onRenderLabel),
                    react.exports.createElement("div", { className: classNames.fieldGroup },
                        (prefix !== undefined || this.props.onRenderPrefix) && (react.exports.createElement("div", { className: classNames.prefix, id: this._prefixId }, onRenderPrefix(this.props, this._onRenderPrefix))),
                        multiline ? this._renderTextArea() : this._renderInput(),
                        iconProps && react.exports.createElement(Icon$1, __assign$k({ className: classNames.icon }, iconProps)),
                        hasRevealButton && (
                        // Explicitly set type="button" since the default button type within a form is "submit"
                        react.exports.createElement("button", { "aria-label": revealPasswordAriaLabel, className: classNames.revealButton, onClick: this._onRevealButtonClick, "aria-pressed": !!isRevealingPassword, type: "button" },
                            react.exports.createElement("span", { className: classNames.revealSpan },
                                react.exports.createElement(Icon$1, { className: classNames.revealIcon, iconName: isRevealingPassword ? HIDE_ICON_NAME : REVEAL_ICON_NAME })))),
                        (suffix !== undefined || this.props.onRenderSuffix) && (react.exports.createElement("div", { className: classNames.suffix, id: this._suffixId }, onRenderSuffix(this.props, this._onRenderSuffix))))),
                this._isDescriptionAvailable && (react.exports.createElement("span", { id: this._descriptionId },
                    onRenderDescription(this.props, this._onRenderDescription),
                    errorMessage && (react.exports.createElement("div", { role: "alert" },
                        react.exports.createElement(DelayedRender, null, this._renderErrorMessage())))))));
        };
        /**
         * Sets focus on the text field
         */
        TextFieldBase.prototype.focus = function () {
            if (this._textElement.current) {
                this._textElement.current.focus();
            }
        };
        /**
         * Blurs the text field.
         */
        TextFieldBase.prototype.blur = function () {
            if (this._textElement.current) {
                this._textElement.current.blur();
            }
        };
        /**
         * Selects the text field
         */
        TextFieldBase.prototype.select = function () {
            if (this._textElement.current) {
                this._textElement.current.select();
            }
        };
        /**
         * Sets the selection start of the text field to a specified value
         */
        TextFieldBase.prototype.setSelectionStart = function (value) {
            if (this._textElement.current) {
                this._textElement.current.selectionStart = value;
            }
        };
        /**
         * Sets the selection end of the text field to a specified value
         */
        TextFieldBase.prototype.setSelectionEnd = function (value) {
            if (this._textElement.current) {
                this._textElement.current.selectionEnd = value;
            }
        };
        Object.defineProperty(TextFieldBase.prototype, "selectionStart", {
            /**
             * Gets the selection start of the text field
             */
            get: function () {
                return this._textElement.current ? this._textElement.current.selectionStart : -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextFieldBase.prototype, "selectionEnd", {
            /**
             * Gets the selection end of the text field
             */
            get: function () {
                return this._textElement.current ? this._textElement.current.selectionEnd : -1;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Sets the start and end positions of a selection in a text field.
         * @param start - Index of the start of the selection.
         * @param end - Index of the end of the selection.
         */
        TextFieldBase.prototype.setSelectionRange = function (start, end) {
            if (this._textElement.current) {
                this._textElement.current.setSelectionRange(start, end);
            }
        };
        TextFieldBase.prototype._warnControlledUsage = function (prevProps) {
            // Show warnings if props are being used in an invalid way
            warnControlledUsage({
                componentId: this._id,
                componentName: COMPONENT_NAME$2,
                props: this.props,
                oldProps: prevProps,
                valueProp: 'value',
                defaultValueProp: 'defaultValue',
                onChangeProp: 'onChange',
                readOnlyProp: 'readOnly',
            });
            if (this.props.value === null && !this._hasWarnedNullValue) {
                this._hasWarnedNullValue = true;
                warn("Warning: 'value' prop on '" + COMPONENT_NAME$2 + "' should not be null. Consider using an " +
                    'empty string to clear the component or undefined to indicate an uncontrolled component.');
            }
        };
        Object.defineProperty(TextFieldBase.prototype, "_id", {
            /** Returns `props.id` if available, or a fallback if not. */
            get: function () {
                return this.props.id || this._fallbackId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextFieldBase.prototype, "_isControlled", {
            get: function () {
                return isControlled(this.props, 'value');
            },
            enumerable: false,
            configurable: true
        });
        TextFieldBase.prototype._onRenderPrefix = function (props) {
            var prefix = props.prefix;
            return react.exports.createElement("span", { style: { paddingBottom: '1px' } }, prefix);
        };
        TextFieldBase.prototype._onRenderSuffix = function (props) {
            var suffix = props.suffix;
            return react.exports.createElement("span", { style: { paddingBottom: '1px' } }, suffix);
        };
        Object.defineProperty(TextFieldBase.prototype, "_errorMessage", {
            /**
             * Current error message from either `props.errorMessage` or the result of `props.onGetErrorMessage`.
             *
             * - If there is no validation error or we have not validated the input value, errorMessage is an empty string.
             * - If we have done the validation and there is validation error, errorMessage is the validation error message.
             */
            get: function () {
                var _a = this.props.errorMessage, errorMessage = _a === void 0 ? this.state.errorMessage : _a;
                return errorMessage || '';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Renders error message based on the type of the message.
         *
         * - If error message is string, it will render using the built in styles.
         * - If error message is an element, user has full control over how it's rendered.
         */
        TextFieldBase.prototype._renderErrorMessage = function () {
            var errorMessage = this._errorMessage;
            return errorMessage ? (typeof errorMessage === 'string' ? (react.exports.createElement("p", { className: this._classNames.errorMessage },
                react.exports.createElement("span", { "data-automation-id": "error-message" }, errorMessage))) : (react.exports.createElement("div", { className: this._classNames.errorMessage, "data-automation-id": "error-message" }, errorMessage))) : null;
        };
        Object.defineProperty(TextFieldBase.prototype, "_isDescriptionAvailable", {
            /**
             * If a custom description render function is supplied then treat description as always available.
             * Otherwise defer to the presence of description or error message text.
             */
            get: function () {
                var props = this.props;
                return !!(props.onRenderDescription || props.description || this._errorMessage);
            },
            enumerable: false,
            configurable: true
        });
        TextFieldBase.prototype._renderTextArea = function () {
            var _a = this.props.invalid, invalid = _a === void 0 ? !!this._errorMessage : _a;
            var textAreaProps = getNativeProps(this.props, textAreaProperties, ['defaultValue']);
            var ariaLabelledBy = this.props['aria-labelledby'] || (this.props.label ? this._labelId : undefined);
            return (react.exports.createElement("textarea", __assign$k({ id: this._id }, textAreaProps, { ref: this._textElement, value: this.value || '', onInput: this._onInputChange, onChange: this._onInputChange, className: this._classNames.field, "aria-labelledby": ariaLabelledBy, "aria-describedby": this._isDescriptionAvailable ? this._descriptionId : this.props['aria-describedby'], "aria-invalid": invalid, "aria-label": this.props.ariaLabel, readOnly: this.props.readOnly, onFocus: this._onFocus, onBlur: this._onBlur })));
        };
        TextFieldBase.prototype._renderInput = function () {
            var _a = this.props, ariaLabel = _a.ariaLabel, _b = _a.invalid, invalid = _b === void 0 ? !!this._errorMessage : _b, onRenderPrefix = _a.onRenderPrefix, onRenderSuffix = _a.onRenderSuffix, prefix = _a.prefix, suffix = _a.suffix, _c = _a.type, type = _c === void 0 ? 'text' : _c, label = _a.label;
            // build aria-labelledby list from label, prefix, and suffix
            var labelIds = [];
            label && labelIds.push(this._labelId);
            (prefix !== undefined || onRenderPrefix) && labelIds.push(this._prefixId);
            (suffix !== undefined || onRenderSuffix) && labelIds.push(this._suffixId);
            var inputProps = __assign$k(__assign$k({ type: this.state.isRevealingPassword ? 'text' : type, id: this._id }, getNativeProps(this.props, inputProperties, ['defaultValue', 'type'])), { 'aria-labelledby': this.props['aria-labelledby'] || (labelIds.length > 0 ? labelIds.join(' ') : undefined), ref: this._textElement, value: this.value || '', onInput: this._onInputChange, onChange: this._onInputChange, className: this._classNames.field, 'aria-label': ariaLabel, 'aria-describedby': this._isDescriptionAvailable ? this._descriptionId : this.props['aria-describedby'], 'aria-invalid': invalid, onFocus: this._onFocus, onBlur: this._onBlur });
            var defaultRender = function (updatedInputProps) {
                return react.exports.createElement("input", __assign$k({}, updatedInputProps));
            };
            var onRenderInput = this.props.onRenderInput || defaultRender;
            return onRenderInput(inputProps, defaultRender);
        };
        TextFieldBase.prototype._validate = function (value) {
            var _this = this;
            // In case _validate is called again while validation promise is executing
            if (this._latestValidateValue === value && _shouldValidateAllChanges(this.props)) {
                return;
            }
            this._latestValidateValue = value;
            var onGetErrorMessage = this.props.onGetErrorMessage;
            var result = onGetErrorMessage && onGetErrorMessage(value || '');
            if (result !== undefined) {
                if (typeof result === 'string' || !('then' in result)) {
                    this.setState({ errorMessage: result });
                    this._notifyAfterValidate(value, result);
                }
                else {
                    var currentValidation_1 = ++this._lastValidation;
                    result.then(function (errorMessage) {
                        if (currentValidation_1 === _this._lastValidation) {
                            _this.setState({ errorMessage: errorMessage });
                        }
                        _this._notifyAfterValidate(value, errorMessage);
                    });
                }
            }
            else {
                this._notifyAfterValidate(value, '');
            }
        };
        TextFieldBase.prototype._notifyAfterValidate = function (value, errorMessage) {
            if (value === this.value && this.props.onNotifyValidationResult) {
                this.props.onNotifyValidationResult(errorMessage, value);
            }
        };
        TextFieldBase.prototype._adjustInputHeight = function () {
            if (this._textElement.current && this.props.autoAdjustHeight && this.props.multiline) {
                var textField = this._textElement.current;
                textField.style.height = '';
                textField.style.height = textField.scrollHeight + 'px';
            }
        };
        TextFieldBase.defaultProps = {
            resizable: true,
            deferredValidationTime: 200,
            validateOnLoad: true,
        };
        return TextFieldBase;
    }(react.exports.Component));
    /** Get the value from the given state and props (converting from number to string if needed) */
    function _getValue(props, state) {
        var _a = props.value, value = _a === void 0 ? state.uncontrolledValue : _a;
        if (typeof value === 'number') {
            // not allowed per typings, but happens anyway
            return String(value);
        }
        return value;
    }
    /**
     * If `validateOnFocusIn` or `validateOnFocusOut` is true, validation should run **only** on that event.
     * Otherwise, validation should run on every change.
     */
    function _shouldValidateAllChanges(props) {
        return !(props.validateOnFocusIn || props.validateOnFocusOut);
    }
    // Only calculate this once across all TextFields, since will stay the same
    var __browserNeedsRevealButton;
    function _browserNeedsRevealButton() {
        if (typeof __browserNeedsRevealButton !== 'boolean') {
            var win = getWindow();
            if (win === null || win === void 0 ? void 0 : win.navigator) {
                // Edge, Chromium Edge
                var isEdge = /^Edg/.test(win.navigator.userAgent || '');
                __browserNeedsRevealButton = !(isIE11() || isEdge);
            }
            else {
                __browserNeedsRevealButton = true;
            }
        }
        return __browserNeedsRevealButton;
    }

    var globalClassNames$1 = {
        root: 'ms-TextField',
        description: 'ms-TextField-description',
        errorMessage: 'ms-TextField-errorMessage',
        field: 'ms-TextField-field',
        fieldGroup: 'ms-TextField-fieldGroup',
        prefix: 'ms-TextField-prefix',
        suffix: 'ms-TextField-suffix',
        wrapper: 'ms-TextField-wrapper',
        revealButton: 'ms-TextField-reveal',
        multiline: 'ms-TextField--multiline',
        borderless: 'ms-TextField--borderless',
        underlined: 'ms-TextField--underlined',
        unresizable: 'ms-TextField--unresizable',
        required: 'is-required',
        disabled: 'is-disabled',
        active: 'is-active',
    };
    function getLabelStyles(props) {
        var underlined = props.underlined, disabled = props.disabled, focused = props.focused, theme = props.theme;
        var palette = theme.palette, fonts = theme.fonts;
        return function () {
            var _a;
            return ({
                root: [
                    underlined &&
                        disabled && {
                        color: palette.neutralTertiary,
                    },
                    underlined && {
                        fontSize: fonts.medium.fontSize,
                        marginRight: 8,
                        paddingLeft: 12,
                        paddingRight: 0,
                        lineHeight: '22px',
                        height: 32,
                    },
                    underlined &&
                        focused && {
                        selectors: (_a = {},
                            _a[HighContrastSelector] = {
                                height: 31, // -1px to prevent jumpiness in HC with the increased border-width to 2px
                            },
                            _a),
                    },
                ],
            });
        };
    }
    function getStyles$9(props) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        var theme = props.theme, className = props.className, disabled = props.disabled, focused = props.focused, required = props.required, multiline = props.multiline, hasLabel = props.hasLabel, borderless = props.borderless, underlined = props.underlined, hasIcon = props.hasIcon, resizable = props.resizable, hasErrorMessage = props.hasErrorMessage, inputClassName = props.inputClassName, autoAdjustHeight = props.autoAdjustHeight, hasRevealButton = props.hasRevealButton;
        var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
        var classNames = getGlobalClassNames(globalClassNames$1, theme);
        var fieldPrefixSuffix = {
            // Suffix/Prefix are not editable so the disabled slot perfectly fits.
            background: semanticColors.disabledBackground,
            color: !disabled ? semanticColors.inputPlaceholderText : semanticColors.disabledText,
            display: 'flex',
            alignItems: 'center',
            padding: '0 10px',
            lineHeight: 1,
            whiteSpace: 'nowrap',
            flexShrink: 0,
            selectors: (_a = {},
                _a[HighContrastSelector] = {
                    background: 'Window',
                    color: disabled ? 'GrayText' : 'WindowText',
                },
                _a),
        };
        // placeholder style constants
        var placeholderStyles = [
            {
                color: semanticColors.inputPlaceholderText,
                opacity: 1,
                selectors: (_b = {},
                    _b[HighContrastSelector] = {
                        color: 'GrayText',
                    },
                    _b),
            },
        ];
        var disabledPlaceholderStyles = {
            color: semanticColors.disabledText,
            selectors: (_c = {},
                _c[HighContrastSelector] = {
                    color: 'GrayText',
                },
                _c),
        };
        return {
            root: [
                classNames.root,
                fonts.medium,
                required && classNames.required,
                disabled && classNames.disabled,
                focused && classNames.active,
                multiline && classNames.multiline,
                borderless && classNames.borderless,
                underlined && classNames.underlined,
                normalize,
                {
                    position: 'relative',
                },
                className,
            ],
            wrapper: [
                classNames.wrapper,
                underlined && [
                    {
                        display: 'flex',
                        borderBottom: "1px solid " + (!hasErrorMessage ? semanticColors.inputBorder : semanticColors.errorText),
                        width: '100%',
                    },
                    disabled && {
                        borderBottomColor: semanticColors.disabledBackground,
                        selectors: (_d = {},
                            _d[HighContrastSelector] = __assign$k({ borderColor: 'GrayText' }, getHighContrastNoAdjustStyle()),
                            _d),
                    },
                    !disabled && {
                        selectors: {
                            ':hover': {
                                borderBottomColor: !hasErrorMessage ? semanticColors.inputBorderHovered : semanticColors.errorText,
                                selectors: (_e = {},
                                    _e[HighContrastSelector] = __assign$k({ borderBottomColor: 'Highlight' }, getHighContrastNoAdjustStyle()),
                                    _e),
                            },
                        },
                    },
                    focused && [
                        {
                            position: 'relative',
                        },
                        getInputFocusStyle(!hasErrorMessage ? semanticColors.inputFocusBorderAlt : semanticColors.errorText, 0, 'borderBottom'),
                    ],
                ],
            ],
            fieldGroup: [
                classNames.fieldGroup,
                normalize,
                {
                    border: "1px solid " + semanticColors.inputBorder,
                    borderRadius: effects.roundedCorner2,
                    background: semanticColors.inputBackground,
                    cursor: 'text',
                    height: 32,
                    display: 'flex',
                    flexDirection: 'row',
                    alignItems: 'stretch',
                    position: 'relative',
                },
                multiline && {
                    minHeight: '60px',
                    height: 'auto',
                    display: 'flex',
                },
                !focused &&
                    !disabled && {
                    selectors: {
                        ':hover': {
                            borderColor: semanticColors.inputBorderHovered,
                            selectors: (_f = {},
                                _f[HighContrastSelector] = __assign$k({ borderColor: 'Highlight' }, getHighContrastNoAdjustStyle()),
                                _f),
                        },
                    },
                },
                focused &&
                    !underlined &&
                    getInputFocusStyle(!hasErrorMessage ? semanticColors.inputFocusBorderAlt : semanticColors.errorText, effects.roundedCorner2),
                disabled && {
                    borderColor: semanticColors.disabledBackground,
                    selectors: (_g = {},
                        _g[HighContrastSelector] = __assign$k({ borderColor: 'GrayText' }, getHighContrastNoAdjustStyle()),
                        _g),
                    cursor: 'default',
                },
                borderless && {
                    border: 'none',
                },
                borderless &&
                    focused && {
                    border: 'none',
                    selectors: {
                        ':after': {
                            border: 'none',
                        },
                    },
                },
                underlined && {
                    flex: '1 1 0px',
                    border: 'none',
                    textAlign: 'left',
                },
                underlined &&
                    disabled && {
                    backgroundColor: 'transparent',
                },
                hasErrorMessage &&
                    !underlined && {
                    borderColor: semanticColors.errorText,
                    selectors: {
                        '&:hover': {
                            borderColor: semanticColors.errorText,
                        },
                    },
                },
                !hasLabel &&
                    required && {
                    selectors: (_h = {
                            ':before': {
                                content: "'*'",
                                color: semanticColors.errorText,
                                position: 'absolute',
                                top: -5,
                                right: -10,
                            }
                        },
                        _h[HighContrastSelector] = {
                            selectors: {
                                ':before': {
                                    color: 'WindowText',
                                    right: -14, // moving the * 4 pixel to right to alleviate border clipping in HC mode.
                                },
                            },
                        },
                        _h),
                },
            ],
            field: [
                fonts.medium,
                classNames.field,
                normalize,
                {
                    borderRadius: 0,
                    border: 'none',
                    background: 'none',
                    backgroundColor: 'transparent',
                    color: semanticColors.inputText,
                    padding: '0 8px',
                    width: '100%',
                    minWidth: 0,
                    textOverflow: 'ellipsis',
                    outline: 0,
                    selectors: (_j = {
                            '&:active, &:focus, &:hover': { outline: 0 },
                            '::-ms-clear': {
                                display: 'none',
                            }
                        },
                        _j[HighContrastSelector] = {
                            background: 'Window',
                            color: disabled ? 'GrayText' : 'WindowText',
                        },
                        _j),
                },
                getPlaceholderStyles(placeholderStyles),
                multiline &&
                    !resizable && [
                    classNames.unresizable,
                    {
                        resize: 'none',
                    },
                ],
                multiline && {
                    minHeight: 'inherit',
                    lineHeight: 17,
                    flexGrow: 1,
                    paddingTop: 6,
                    paddingBottom: 6,
                    overflow: 'auto',
                    width: '100%',
                },
                multiline &&
                    autoAdjustHeight && {
                    overflow: 'hidden',
                },
                hasIcon &&
                    !hasRevealButton && {
                    paddingRight: 24,
                },
                multiline &&
                    hasIcon && {
                    paddingRight: 40,
                },
                disabled && [
                    {
                        backgroundColor: semanticColors.disabledBackground,
                        color: semanticColors.disabledText,
                        borderColor: semanticColors.disabledBackground,
                    },
                    getPlaceholderStyles(disabledPlaceholderStyles),
                ],
                underlined && {
                    textAlign: 'left',
                },
                focused &&
                    !borderless && {
                    selectors: (_k = {},
                        _k[HighContrastSelector] = {
                            paddingLeft: 11,
                            paddingRight: 11,
                        },
                        _k),
                },
                focused &&
                    multiline &&
                    !borderless && {
                    selectors: (_l = {},
                        _l[HighContrastSelector] = {
                            paddingTop: 4, // take into consideration the 2px increased border-width (not when borderless).
                        },
                        _l),
                },
                inputClassName,
            ],
            icon: [
                multiline && {
                    paddingRight: 24,
                    alignItems: 'flex-end',
                },
                {
                    pointerEvents: 'none',
                    position: 'absolute',
                    bottom: 6,
                    right: 8,
                    top: 'auto',
                    fontSize: IconFontSizes.medium,
                    lineHeight: 18,
                },
                disabled && {
                    color: semanticColors.disabledText,
                },
            ],
            description: [
                classNames.description,
                {
                    color: semanticColors.bodySubtext,
                    fontSize: fonts.xSmall.fontSize,
                },
            ],
            errorMessage: [
                classNames.errorMessage,
                AnimationClassNames.slideDownIn20,
                fonts.small,
                {
                    color: semanticColors.errorText,
                    margin: 0,
                    paddingTop: 5,
                    display: 'flex',
                    alignItems: 'center',
                },
            ],
            prefix: [classNames.prefix, fieldPrefixSuffix],
            suffix: [classNames.suffix, fieldPrefixSuffix],
            revealButton: [
                classNames.revealButton,
                'ms-Button',
                'ms-Button--icon',
                getFocusStyle(theme, { inset: 1 }),
                {
                    height: 30,
                    width: 32,
                    border: 'none',
                    padding: '0px 4px',
                    backgroundColor: 'transparent',
                    color: semanticColors.link,
                    selectors: {
                        ':hover': {
                            outline: 0,
                            color: semanticColors.primaryButtonBackgroundHovered,
                            backgroundColor: semanticColors.buttonBackgroundHovered,
                            selectors: (_m = {},
                                _m[HighContrastSelector] = {
                                    borderColor: 'Highlight',
                                    color: 'Highlight',
                                },
                                _m),
                        },
                        ':focus': { outline: 0 },
                    },
                },
                hasIcon && {
                    marginRight: 28,
                },
            ],
            revealSpan: {
                display: 'flex',
                height: '100%',
                alignItems: 'center',
            },
            revealIcon: {
                margin: '0px 4px',
                pointerEvents: 'none',
                bottom: 6,
                right: 8,
                top: 'auto',
                fontSize: IconFontSizes.medium,
                lineHeight: 18,
            },
            subComponentStyles: {
                label: getLabelStyles(props),
            },
        };
    }

    var TextField$1 = styled(TextFieldBase, getStyles$9, undefined, {
        scope: 'TextField',
    });

    var DEFAULT_MASK_FORMAT_CHARS = {
        '9': /[0-9]/,
        a: /[a-zA-Z]/,
        '*': /[a-zA-Z0-9]/,
    };
    /**
     * Takes in the mask string and the formatCharacters and returns an array of MaskValues
     * Example:
     * mask = 'Phone Number: (999) - 9999'
     * return = [
     *    { value: undefined, displayIndex: 16, format: /[0-9]/ },
     *    { value: undefined, displayIndex: 17, format: /[0-9]/ },
     *    { value: undefined, displayIndex: 18, format: /[0-9]/ },
     *    { value: undefined, displayIndex: 22, format: /[0-9]/ },
     * ]
     *
     * @param mask The string use to define the format of the displayed maskedValue.
     * @param formatChars An object defining how certain characters in the mask should accept input.
     */
    function parseMask(mask, formatChars) {
        if (formatChars === void 0) { formatChars = DEFAULT_MASK_FORMAT_CHARS; }
        if (!mask) {
            return [];
        }
        var maskCharData = [];
        // Count the escape characters in the mask string.
        var escapedChars = 0;
        for (var i = 0; i + escapedChars < mask.length; i++) {
            var maskChar = mask.charAt(i + escapedChars);
            if (maskChar === '\\') {
                escapedChars++;
            }
            else {
                // Check if the maskChar is a format character.
                var maskFormat = formatChars[maskChar];
                if (maskFormat) {
                    maskCharData.push({
                        /**
                         * Do not add escapedChars to the displayIndex.
                         * The index refers to a position in the mask's displayValue.
                         * Since the backslashes don't appear in the displayValue,
                         * we do not add them to the charData displayIndex.
                         */
                        displayIndex: i,
                        format: maskFormat,
                    });
                }
            }
        }
        return maskCharData;
    }
    /**
     * Takes in the mask string, an array of MaskValues, and the maskCharacter
     * returns the mask string formatted with the input values and maskCharacter.
     * If the maskChar is undefined, the maskDisplay is truncated to the last filled format character.
     * Example:
     * mask = 'Phone Number: (999) 999 - 9999'
     * maskCharData = '12345'
     * maskChar = '_'
     * return = 'Phone Number: (123) 45_ - ___'
     *
     * Example:
     * mask = 'Phone Number: (999) 999 - 9999'
     * value = '12345'
     * maskChar = undefined
     * return = 'Phone Number: (123) 45'
     *
     * @param mask The string use to define the format of the displayed maskedValue.
     * @param maskCharData The input values to insert into the mask string for displaying.
     * @param maskChar? A character to display in place of unfilled mask format characters.
     */
    function getMaskDisplay(mask, maskCharData, maskChar) {
        var maskDisplay = mask;
        if (!maskDisplay) {
            return '';
        }
        // Remove all backslashes
        maskDisplay = maskDisplay.replace(/\\/g, '');
        // lastDisplayIndex is is used to truncate the string if necessary.
        var lastDisplayIndex = 0;
        if (maskCharData.length > 0) {
            lastDisplayIndex = maskCharData[0].displayIndex - 1;
        }
        /**
         * For each input value, replace the character in the maskDisplay with the value.
         * If there is no value set for the format character, use the maskChar.
         */
        for (var _i = 0, maskCharData_1 = maskCharData; _i < maskCharData_1.length; _i++) {
            var charData = maskCharData_1[_i];
            var nextChar = ' ';
            if (charData.value) {
                nextChar = charData.value;
                if (charData.displayIndex > lastDisplayIndex) {
                    lastDisplayIndex = charData.displayIndex;
                }
            }
            else {
                if (maskChar) {
                    nextChar = maskChar;
                }
            }
            // Insert the character into the maskdisplay at its corresponding index
            maskDisplay = maskDisplay.slice(0, charData.displayIndex) + nextChar + maskDisplay.slice(charData.displayIndex + 1);
        }
        // Cut off all mask characters after the last filled format value
        if (!maskChar) {
            maskDisplay = maskDisplay.slice(0, lastDisplayIndex + 1);
        }
        return maskDisplay;
    }
    /**
     * Get the next format index right of or at a specified index.
     * If no index exists, returns the rightmost index.
     * @param maskCharData
     * @param index
     */
    function getRightFormatIndex(maskCharData, index) {
        for (var i = 0; i < maskCharData.length; i++) {
            if (maskCharData[i].displayIndex >= index) {
                return maskCharData[i].displayIndex;
            }
        }
        return maskCharData[maskCharData.length - 1].displayIndex;
    }
    /**
     * Get the next format index left of a specified index.
     * If no index exists, returns the leftmost index.
     * @param maskCharData
     * @param index
     */
    function getLeftFormatIndex(maskCharData, index) {
        for (var i = maskCharData.length - 1; i >= 0; i--) {
            if (maskCharData[i].displayIndex < index) {
                return maskCharData[i].displayIndex;
            }
        }
        return maskCharData[0].displayIndex;
    }
    /**
     * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.
     * maskCharData is modified inline and also returned.
     * @param maskCharData
     * @param selectionStart
     * @param selectionCount
     */
    function clearRange(maskCharData, selectionStart, selectionCount) {
        for (var i = 0; i < maskCharData.length; i++) {
            if (maskCharData[i].displayIndex >= selectionStart) {
                if (maskCharData[i].displayIndex >= selectionStart + selectionCount) {
                    break;
                }
                maskCharData[i].value = undefined;
            }
        }
        return maskCharData;
    }
    /**
     * Deletes the input character at or after a specified index and returns the new array of charData
     * maskCharData is modified inline and also returned.
     * @param maskCharData
     * @param selectionStart
     */
    function clearNext(maskCharData, selectionStart) {
        for (var i = 0; i < maskCharData.length; i++) {
            if (maskCharData[i].displayIndex >= selectionStart) {
                maskCharData[i].value = undefined;
                break;
            }
        }
        return maskCharData;
    }
    /**
     * Deletes the input character before a specified index and returns the new array of charData
     * maskCharData is modified inline and also returned.
     * @param maskCharData
     * @param selectionStart
     */
    function clearPrev(maskCharData, selectionStart) {
        for (var i = maskCharData.length - 1; i >= 0; i--) {
            if (maskCharData[i].displayIndex < selectionStart) {
                maskCharData[i].value = undefined;
                break;
            }
        }
        return maskCharData;
    }
    /**
     * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.
     * Modifies the maskCharData inplace with the passed string and returns the display index of the
     * next format character after the inserted string.
     * @param maskCharData
     * @param selectionStart
     * @param selectionCount
     * @return The displayIndex of the next format character
     */
    function insertString(maskCharData, selectionStart, newString) {
        var stringIndex = 0;
        var nextIndex = 0;
        var isStringInserted = false;
        // Iterate through _maskCharData finding values with a displayIndex after the specified range start
        for (var i = 0; i < maskCharData.length && stringIndex < newString.length; i++) {
            if (maskCharData[i].displayIndex >= selectionStart) {
                isStringInserted = true;
                nextIndex = maskCharData[i].displayIndex;
                // Find the next character in the newString that matches the format
                while (stringIndex < newString.length) {
                    // If the character matches the format regexp, set the maskCharData to the new character
                    if (maskCharData[i].format.test(newString.charAt(stringIndex))) {
                        maskCharData[i].value = newString.charAt(stringIndex++);
                        // Set the nextIndex to the display index of the next mask format character.
                        if (i + 1 < maskCharData.length) {
                            nextIndex = maskCharData[i + 1].displayIndex;
                        }
                        else {
                            nextIndex++;
                        }
                        break;
                    }
                    stringIndex++;
                }
            }
        }
        return isStringInserted ? nextIndex : selectionStart;
    }

    var COMPONENT_NAME$1 = 'MaskedTextField';
    var useComponentRef$2 = function (componentRef, internalState, textField) {
        react.exports.useImperativeHandle(componentRef, function () { return ({
            get value() {
                var value = '';
                for (var i = 0; i < internalState.maskCharData.length; i++) {
                    if (!internalState.maskCharData[i].value) {
                        return undefined;
                    }
                    value += internalState.maskCharData[i].value;
                }
                return value;
            },
            get selectionStart() {
                return textField.current && textField.current.selectionStart !== null ? textField.current.selectionStart : -1;
            },
            get selectionEnd() {
                return textField.current && textField.current.selectionEnd ? textField.current.selectionEnd : -1;
            },
            focus: function () {
                textField.current && textField.current.focus();
            },
            blur: function () {
                textField.current && textField.current.blur();
            },
            select: function () {
                textField.current && textField.current.select();
            },
            setSelectionStart: function (value) {
                textField.current && textField.current.setSelectionStart(value);
            },
            setSelectionEnd: function (value) {
                textField.current && textField.current.setSelectionEnd(value);
            },
            setSelectionRange: function (start, end) {
                textField.current && textField.current.setSelectionRange(start, end);
            },
        }); }, [internalState, textField]);
    };
    var DEFAULT_MASK_CHAR = '_';
    var MaskedTextField = react.exports.forwardRef(function (props, ref) {
        var textField = react.exports.useRef(null);
        var componentRef = props.componentRef, onFocus = props.onFocus, onBlur = props.onBlur, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, onChange = props.onChange, onPaste = props.onPaste, onKeyDown = props.onKeyDown, mask = props.mask, _a = props.maskChar, maskChar = _a === void 0 ? DEFAULT_MASK_CHAR : _a, _b = props.maskFormat, maskFormat = _b === void 0 ? DEFAULT_MASK_FORMAT_CHARS : _b, value = props.value;
        var internalState = useConst(function () { return ({
            maskCharData: parseMask(mask, maskFormat),
            isFocused: false,
            moveCursorOnMouseUp: false,
            changeSelectionData: null,
        }); });
        /** The index into the rendered value of the first unfilled format character */
        var _c = react.exports.useState(), maskCursorPosition = _c[0], setMaskCursorPosition = _c[1];
        /**
         * The mask string formatted with the input value.
         * This is what is displayed inside the TextField
         * @example
         *  `Phone Number: 12_ - 4___`
         */
        var _d = react.exports.useState(function () {
            return getMaskDisplay(mask, internalState.maskCharData, maskChar);
        }), displayValue = _d[0], setDisplayValue = _d[1];
        var setValue = react.exports.useCallback(function (newValue) {
            var valueIndex = 0;
            var charDataIndex = 0;
            while (valueIndex < newValue.length && charDataIndex < internalState.maskCharData.length) {
                // Test if the next character in the new value fits the next format character
                var testVal = newValue[valueIndex];
                if (internalState.maskCharData[charDataIndex].format.test(testVal)) {
                    internalState.maskCharData[charDataIndex].value = testVal;
                    charDataIndex++;
                }
                valueIndex++;
            }
        }, [internalState]);
        var handleFocus = react.exports.useCallback(function (ev) {
            onFocus === null || onFocus === void 0 ? void 0 : onFocus(ev);
            internalState.isFocused = true;
            // Move the cursor position to the leftmost unfilled position
            for (var i = 0; i < internalState.maskCharData.length; i++) {
                if (!internalState.maskCharData[i].value) {
                    setMaskCursorPosition(internalState.maskCharData[i].displayIndex);
                    break;
                }
            }
        }, [internalState, onFocus]);
        var handleBlur = react.exports.useCallback(function (ev) {
            onBlur === null || onBlur === void 0 ? void 0 : onBlur(ev);
            internalState.isFocused = false;
            internalState.moveCursorOnMouseUp = true;
        }, [internalState, onBlur]);
        var handleMouseDown = react.exports.useCallback(function (ev) {
            onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(ev);
            if (!internalState.isFocused) {
                internalState.moveCursorOnMouseUp = true;
            }
        }, [internalState, onMouseDown]);
        var handleMouseUp = react.exports.useCallback(function (ev) {
            onMouseUp === null || onMouseUp === void 0 ? void 0 : onMouseUp(ev);
            // Move the cursor on mouseUp after focusing the textField
            if (internalState.moveCursorOnMouseUp) {
                internalState.moveCursorOnMouseUp = false;
                // Move the cursor position to the rightmost unfilled position
                for (var i = 0; i < internalState.maskCharData.length; i++) {
                    if (!internalState.maskCharData[i].value) {
                        setMaskCursorPosition(internalState.maskCharData[i].displayIndex);
                        break;
                    }
                }
            }
        }, [internalState, onMouseUp]);
        var handleInputChange = react.exports.useCallback(function (ev, inputValue) {
            if (internalState.changeSelectionData === null && textField.current) {
                internalState.changeSelectionData = {
                    changeType: 'default',
                    selectionStart: textField.current.selectionStart !== null ? textField.current.selectionStart : -1,
                    selectionEnd: textField.current.selectionEnd !== null ? textField.current.selectionEnd : -1,
                };
            }
            if (!internalState.changeSelectionData) {
                return;
            }
            // The initial value of cursorPos does not matter
            var cursorPos = 0;
            var _a = internalState.changeSelectionData, changeType = _a.changeType, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;
            if (changeType === 'textPasted') {
                var charsSelected = selectionEnd - selectionStart;
                var charCount = inputValue.length + charsSelected - displayValue.length;
                var startPos = selectionStart;
                var pastedString = inputValue.substr(startPos, charCount);
                // Clear any selected characters
                if (charsSelected) {
                    internalState.maskCharData = clearRange(internalState.maskCharData, selectionStart, charsSelected);
                }
                cursorPos = insertString(internalState.maskCharData, startPos, pastedString);
            }
            else if (changeType === 'delete' || changeType === 'backspace') {
                // isDel is true If the characters are removed LTR, otherwise RTL
                var isDel = changeType === 'delete';
                var charCount = selectionEnd - selectionStart;
                if (charCount) {
                    // charCount is > 0 if range was deleted
                    internalState.maskCharData = clearRange(internalState.maskCharData, selectionStart, charCount);
                    cursorPos = getRightFormatIndex(internalState.maskCharData, selectionStart);
                }
                else {
                    // If charCount === 0, there was no selection and a single character was deleted
                    if (isDel) {
                        internalState.maskCharData = clearNext(internalState.maskCharData, selectionStart);
                        cursorPos = getRightFormatIndex(internalState.maskCharData, selectionStart);
                    }
                    else {
                        internalState.maskCharData = clearPrev(internalState.maskCharData, selectionStart);
                        cursorPos = getLeftFormatIndex(internalState.maskCharData, selectionStart);
                    }
                }
            }
            else if (inputValue.length > displayValue.length) {
                // This case is if the user added characters
                var charCount = inputValue.length - displayValue.length;
                var startPos = selectionEnd - charCount;
                var enteredString = inputValue.substr(startPos, charCount);
                cursorPos = insertString(internalState.maskCharData, startPos, enteredString);
            }
            else if (inputValue.length <= displayValue.length) {
                /**
                 * This case is reached only if the user has selected a block of 1 or more
                 * characters and input a character replacing the characters they've selected.
                 */
                var charCount = 1;
                var selectCount = displayValue.length + charCount - inputValue.length;
                var startPos = selectionEnd - charCount;
                var enteredString = inputValue.substr(startPos, charCount);
                // Clear the selected range
                internalState.maskCharData = clearRange(internalState.maskCharData, startPos, selectCount);
                // Insert the printed character
                cursorPos = insertString(internalState.maskCharData, startPos, enteredString);
            }
            internalState.changeSelectionData = null;
            var newValue = getMaskDisplay(mask, internalState.maskCharData, maskChar);
            setDisplayValue(newValue);
            setMaskCursorPosition(cursorPos);
            // Perform onChange after input has been processed. Return value is expected to be the displayed text
            onChange === null || onChange === void 0 ? void 0 : onChange(ev, newValue);
        }, [displayValue.length, internalState, mask, maskChar, onChange]);
        var handleKeyDown = react.exports.useCallback(function (ev) {
            onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
            internalState.changeSelectionData = null;
            if (textField.current && textField.current.value) {
                var keyCode = ev.keyCode, ctrlKey = ev.ctrlKey, metaKey = ev.metaKey;
                // Ignore ctrl and meta keydown
                if (ctrlKey || metaKey) {
                    return;
                }
                // On backspace or delete, store the selection and the keyCode
                if (keyCode === KeyCodes.backspace || keyCode === KeyCodes.del) {
                    var selectionStart = ev.target.selectionStart;
                    var selectionEnd = ev.target.selectionEnd;
                    // Check if backspace or delete press is valid.
                    if (!(keyCode === KeyCodes.backspace && selectionEnd && selectionEnd > 0) &&
                        !(keyCode === KeyCodes.del && selectionStart !== null && selectionStart < textField.current.value.length)) {
                        return;
                    }
                    internalState.changeSelectionData = {
                        changeType: keyCode === KeyCodes.backspace ? 'backspace' : 'delete',
                        selectionStart: selectionStart !== null ? selectionStart : -1,
                        selectionEnd: selectionEnd !== null ? selectionEnd : -1,
                    };
                }
            }
        }, [internalState, onKeyDown]);
        var handlePaste = react.exports.useCallback(function (ev) {
            onPaste === null || onPaste === void 0 ? void 0 : onPaste(ev);
            var selectionStart = ev.target.selectionStart;
            var selectionEnd = ev.target.selectionEnd;
            // Store the paste selection range
            internalState.changeSelectionData = {
                changeType: 'textPasted',
                selectionStart: selectionStart !== null ? selectionStart : -1,
                selectionEnd: selectionEnd !== null ? selectionEnd : -1,
            };
        }, [internalState, onPaste]);
        // Updates the display value if mask or value props change.
        react.exports.useEffect(function () {
            internalState.maskCharData = parseMask(mask, maskFormat);
            value !== undefined && setValue(value);
            setDisplayValue(getMaskDisplay(mask, internalState.maskCharData, maskChar));
            // eslint-disable-next-line react-hooks/exhaustive-deps -- Should only update when mask or value changes.
        }, [mask, value]);
        // Run before browser paint to avoid flickering from selection reset.
        useIsomorphicLayoutEffect(function () {
            // Move the cursor to position before paint.
            if (maskCursorPosition !== undefined && textField.current) {
                textField.current.setSelectionRange(maskCursorPosition, maskCursorPosition);
            }
        }, [maskCursorPosition]);
        // Run after browser paint.
        react.exports.useEffect(function () {
            // Move the cursor to the start of the mask format after values update.
            if (internalState.isFocused && maskCursorPosition !== undefined && textField.current) {
                textField.current.setSelectionRange(maskCursorPosition, maskCursorPosition);
            }
        });
        useComponentRef$2(componentRef, internalState, textField);
        return (react.exports.createElement(TextField$1, __assign$k({}, props, { elementRef: ref, onFocus: handleFocus, onBlur: handleBlur, onMouseDown: handleMouseDown, onMouseUp: handleMouseUp, onChange: handleInputChange, onKeyDown: handleKeyDown, onPaste: handlePaste, value: displayValue || '', componentRef: textField })));
    });
    MaskedTextField.displayName = COMPONENT_NAME$1;

    var TextField = /*#__PURE__*/Object.freeze({
        __proto__: null,
        TextField: TextField$1,
        TextFieldBase: TextFieldBase,
        DEFAULT_MASK_CHAR: DEFAULT_MASK_CHAR,
        MaskedTextField: MaskedTextField
    });

    var registerPersistedKeytips = function (keytipsToRegister, keytipManager, registeredPersistedKeytips) {
        for (var _i = 0, keytipsToRegister_1 = keytipsToRegister; _i < keytipsToRegister_1.length; _i++) {
            var keytip = keytipsToRegister_1[_i];
            var uniqueID = keytipManager.register(keytip, true);
            // Update map
            registeredPersistedKeytips[uniqueID] = keytip;
        }
    };
    var unregisterPersistedKeytips = function (keytipManager, registeredPersistedKeytips) {
        for (var _i = 0, _a = Object.keys(registeredPersistedKeytips); _i < _a.length; _i++) {
            var uniqueID = _a[_i];
            keytipManager.unregister(registeredPersistedKeytips[uniqueID], uniqueID, true);
            delete registeredPersistedKeytips[uniqueID];
        }
    };
    var useKeytipRegistrations = function (registeredPersistedKeytips, keytipsToRegister, keytipManager) {
        var prevPersistedKeytips = usePrevious(registeredPersistedKeytips);
        // Update
        react.exports.useEffect(function () {
            if (prevPersistedKeytips) {
                // Unregister old keytips
                unregisterPersistedKeytips(keytipManager, prevPersistedKeytips);
                // Register new keytips
                registerPersistedKeytips(keytipsToRegister, keytipManager, registeredPersistedKeytips);
            }
        });
        // Mount/Unmount
        react.exports.useEffect(function () {
            // Register on mount
            registerPersistedKeytips(keytipsToRegister, keytipManager, registeredPersistedKeytips);
            return function () {
                // Unregister on unmount
                unregisterPersistedKeytips(keytipManager, registeredPersistedKeytips);
            };
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);
    };
    var OverflowButton = function (props) {
        var keytipManager = KeytipManager.getInstance();
        var className = props.className, overflowItems = props.overflowItems, keytipSequences = props.keytipSequences, itemSubMenuProvider = props.itemSubMenuProvider, onRenderOverflowButton = props.onRenderOverflowButton;
        var persistedKeytips = useConst({});
        // Gets the subMenu for an overflow item
        var getSubMenuForItem = react.exports.useCallback(function (item) {
            // Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps
            if (itemSubMenuProvider) {
                return itemSubMenuProvider(item);
            }
            if (item.subMenuProps) {
                return item.subMenuProps.items;
            }
            return undefined;
        }, [itemSubMenuProvider]);
        var _a = react.exports.useMemo(function () {
            var newKeytipsToRegister = [];
            var newOverflowItems = [];
            if (keytipSequences) {
                overflowItems === null || overflowItems === void 0 ? void 0 : overflowItems.forEach(function (overflowItem) {
                    var _a;
                    var keytip = overflowItem.keytipProps;
                    if (keytip) {
                        // Create persisted keytip
                        var persistedKeytip = {
                            content: keytip.content,
                            keySequences: keytip.keySequences,
                            disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),
                            hasDynamicChildren: keytip.hasDynamicChildren,
                            hasMenu: keytip.hasMenu,
                        };
                        if (keytip.hasDynamicChildren || getSubMenuForItem(overflowItem)) {
                            // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute
                            persistedKeytip.onExecute = keytipManager.menuExecute.bind(keytipManager, keytipSequences, (_a = overflowItem === null || overflowItem === void 0 ? void 0 : overflowItem.keytipProps) === null || _a === void 0 ? void 0 : _a.keySequences);
                            persistedKeytip.hasOverflowSubMenu = true;
                        }
                        else {
                            // If the keytip doesn't have a submenu, just execute the original function
                            persistedKeytip.onExecute = keytip.onExecute;
                        }
                        newKeytipsToRegister.push(persistedKeytip);
                        // Add the overflow sequence to this item
                        var newOverflowItem = __assign$k(__assign$k({}, overflowItem), { keytipProps: __assign$k(__assign$k({}, keytip), { overflowSetSequence: keytipSequences }) });
                        newOverflowItems === null || newOverflowItems === void 0 ? void 0 : newOverflowItems.push(newOverflowItem);
                    }
                    else {
                        // Nothing to change, add overflowItem to list
                        newOverflowItems === null || newOverflowItems === void 0 ? void 0 : newOverflowItems.push(overflowItem);
                    }
                });
            }
            else {
                newOverflowItems = overflowItems;
            }
            return { modifiedOverflowItems: newOverflowItems, keytipsToRegister: newKeytipsToRegister };
        }, [overflowItems, getSubMenuForItem, keytipManager, keytipSequences]), modifiedOverflowItems = _a.modifiedOverflowItems, keytipsToRegister = _a.keytipsToRegister;
        useKeytipRegistrations(persistedKeytips, keytipsToRegister, keytipManager);
        return react.exports.createElement("div", { className: className }, onRenderOverflowButton(modifiedOverflowItems));
    };

    var getClassNames$7 = classNamesFunction();
    var COMPONENT_NAME = 'OverflowSet';
    var useComponentRef$1 = function (props, divContainer) {
        react.exports.useImperativeHandle(props.componentRef, function () { return ({
            focus: function () {
                var focusSucceeded = false;
                if (divContainer.current) {
                    focusSucceeded = focusFirstChild(divContainer.current);
                }
                return focusSucceeded;
            },
            focusElement: function (childElement) {
                var focusSucceeded = false;
                if (!childElement) {
                    return false;
                }
                if (divContainer.current && elementContains(divContainer.current, childElement)) {
                    childElement.focus();
                    focusSucceeded = document.activeElement === childElement;
                }
                return focusSucceeded;
            },
        }); }, [divContainer]);
    };
    var OverflowSetBase = react.exports.forwardRef(function (props, forwardedRef) {
        var divContainer = react.exports.useRef(null);
        var mergedRef = useMergedRefs(divContainer, forwardedRef);
        useComponentRef$1(props, divContainer);
        var items = props.items, overflowItems = props.overflowItems, className = props.className, styles = props.styles, vertical = props.vertical, role = props.role, _a = props.overflowSide, overflowSide = _a === void 0 ? 'end' : _a, onRenderItem = props.onRenderItem;
        var classNames = getClassNames$7(styles, { className: className, vertical: vertical });
        var showOverflow = !!overflowItems && overflowItems.length > 0;
        return (react.exports.createElement("div", __assign$k({}, getNativeProps(props, divProperties), { role: role || 'group', "aria-orientation": role === 'menubar' ? (vertical === true ? 'vertical' : 'horizontal') : undefined, className: classNames.root, ref: mergedRef }),
            overflowSide === 'start' && showOverflow && react.exports.createElement(OverflowButton, __assign$k({}, props, { className: classNames.overflowButton })),
            items &&
                items.map(function (item, i) { return (react.exports.createElement("div", { className: classNames.item, key: item.key, role: "none" }, onRenderItem(item))); }),
            overflowSide === 'end' && showOverflow && react.exports.createElement(OverflowButton, __assign$k({}, props, { className: classNames.overflowButton }))));
    });
    OverflowSetBase.displayName = COMPONENT_NAME;

    var overflowItemStyle = {
        flexShrink: 0,
        display: 'inherit',
    };
    var getStyles$8 = function (props) {
        var className = props.className, vertical = props.vertical;
        return {
            root: [
                'ms-OverflowSet',
                {
                    position: 'relative',
                    display: 'flex',
                    flexWrap: 'nowrap',
                },
                vertical && { flexDirection: 'column' },
                className,
            ],
            item: ['ms-OverflowSet-item', overflowItemStyle],
            overflowButton: ['ms-OverflowSet-overflowButton', overflowItemStyle],
        };
    };

    var OverflowSet = styled(OverflowSetBase, getStyles$8, undefined, {
        scope: 'OverflowSet',
    });

    var COMMAND_BAR_HEIGHT = 44;
    var getStyles$7 = function (props) {
        var className = props.className, theme = props.theme;
        var semanticColors = theme.semanticColors;
        return {
            root: [
                theme.fonts.medium,
                'ms-CommandBar',
                {
                    display: 'flex',
                    backgroundColor: semanticColors.bodyBackground,
                    padding: '0 14px 0 24px',
                    height: COMMAND_BAR_HEIGHT,
                },
                className,
            ],
            primarySet: [
                'ms-CommandBar-primaryCommand',
                {
                    flexGrow: '1',
                    display: 'flex',
                    alignItems: 'stretch',
                },
            ],
            secondarySet: [
                'ms-CommandBar-secondaryCommand',
                {
                    flexShrink: '0',
                    display: 'flex',
                    alignItems: 'stretch',
                },
            ],
        };
    };
    var getCommandButtonStyles = memoizeFunction(function (customStyles) {
        var rootStyles = {
            height: '100%',
        };
        var labelStyles = {
            whiteSpace: 'nowrap',
        };
        var _a = customStyles || {}, root = _a.root, label = _a.label, restCustomStyles = __rest(_a, ["root", "label"]);
        return __assign$k(__assign$k({}, restCustomStyles), { root: root ? [rootStyles, root] : rootStyles, label: label ? [labelStyles, label] : labelStyles });
    });

    var getClassNames$6 = classNamesFunction();
    var CommandBarBase = /** @class */ (function (_super) {
        __extends$4(CommandBarBase, _super);
        function CommandBarBase(props) {
            var _this = _super.call(this, props) || this;
            _this._overflowSet = react.exports.createRef();
            _this._resizeGroup = react.exports.createRef();
            _this._onRenderData = function (data) {
                var _a = _this.props, ariaLabel = _a.ariaLabel, primaryGroupAriaLabel = _a.primaryGroupAriaLabel, farItemsGroupAriaLabel = _a.farItemsGroupAriaLabel;
                var hasSecondSet = data.farItems && data.farItems.length > 0;
                return (react.exports.createElement(FocusZone$1, { className: css(_this._classNames.root), direction: FocusZoneDirection.horizontal, role: 'menubar', "aria-label": ariaLabel },
                    react.exports.createElement(OverflowSet, { role: hasSecondSet ? 'group' : 'none', "aria-label": hasSecondSet ? primaryGroupAriaLabel : undefined, componentRef: _this._overflowSet, className: css(_this._classNames.primarySet), items: data.primaryItems, overflowItems: data.overflowItems.length ? data.overflowItems : undefined, onRenderItem: _this._onRenderItem, onRenderOverflowButton: _this._onRenderOverflowButton }),
                    hasSecondSet && (react.exports.createElement(OverflowSet, { role: "group", "aria-label": farItemsGroupAriaLabel, className: css(_this._classNames.secondarySet), items: data.farItems, onRenderItem: _this._onRenderItem, onRenderOverflowButton: nullRender }))));
            };
            _this._onRenderItem = function (item) {
                if (item.onRender) {
                    // These are the top level items, there is no relevant menu dismissing function to
                    // provide for the IContextualMenuItem onRender function. Pass in a no op function instead.
                    return item.onRender(item, function () { return undefined; });
                }
                // eslint-disable-next-line deprecation/deprecation
                var itemText = item.text || item.name;
                var commandButtonProps = __assign$k(__assign$k({ allowDisabledFocus: true, role: 'menuitem' }, item), { styles: getCommandButtonStyles(item.buttonStyles), className: css('ms-CommandBarItem-link', item.className), text: !item.iconOnly ? itemText : undefined, menuProps: item.subMenuProps, onClick: _this._onButtonClick(item) });
                if (item.iconOnly && (itemText !== undefined || item.tooltipHostProps)) {
                    return (react.exports.createElement(TooltipHost, __assign$k({ role: "none", content: itemText, setAriaDescribedBy: false }, item.tooltipHostProps), _this._commandButton(item, commandButtonProps)));
                }
                return _this._commandButton(item, commandButtonProps);
            };
            _this._commandButton = function (item, props) {
                var ButtonAs = _this.props.buttonAs;
                var CommandBarButtonAs = item.commandBarButtonAs;
                var DefaultButtonAs = CommandBarButton;
                // The prop types between these three possible implementations overlap enough that a force-cast is safe.
                var Type = DefaultButtonAs;
                if (CommandBarButtonAs) {
                    Type = composeComponentAs(CommandBarButtonAs, Type);
                }
                if (ButtonAs) {
                    Type = composeComponentAs(ButtonAs, Type);
                }
                // Always pass the default implementation to the override so it may be composed.
                return react.exports.createElement(Type, __assign$k({}, props));
            };
            _this._onRenderOverflowButton = function (overflowItems) {
                var _a = _this.props.overflowButtonProps, overflowButtonProps = _a === void 0 ? {} : _a;
                var combinedOverflowItems = __spreadArray$2(__spreadArray$2([], (overflowButtonProps.menuProps ? overflowButtonProps.menuProps.items : [])), overflowItems);
                var overflowProps = __assign$k(__assign$k({ role: 'menuitem' }, overflowButtonProps), { styles: __assign$k({ menuIcon: { fontSize: '17px' } }, overflowButtonProps.styles), className: css('ms-CommandBar-overflowButton', overflowButtonProps.className), menuProps: __assign$k(__assign$k({}, overflowButtonProps.menuProps), { items: combinedOverflowItems }), menuIconProps: __assign$k({ iconName: 'More' }, overflowButtonProps.menuIconProps) });
                var OverflowButtonType = _this.props.overflowButtonAs
                    ? composeComponentAs(_this.props.overflowButtonAs, CommandBarButton)
                    : CommandBarButton;
                return react.exports.createElement(OverflowButtonType, __assign$k({}, overflowProps));
            };
            _this._onReduceData = function (data) {
                var _a = _this.props, shiftOnReduce = _a.shiftOnReduce, onDataReduced = _a.onDataReduced;
                var primaryItems = data.primaryItems, overflowItems = data.overflowItems, cacheKey = data.cacheKey;
                // Use first item if shiftOnReduce, otherwise use last item
                var movedItem = primaryItems[shiftOnReduce ? 0 : primaryItems.length - 1];
                if (movedItem !== undefined) {
                    movedItem.renderedInOverflow = true;
                    overflowItems = __spreadArray$2([movedItem], overflowItems);
                    primaryItems = shiftOnReduce ? primaryItems.slice(1) : primaryItems.slice(0, -1);
                    var newData = __assign$k(__assign$k({}, data), { primaryItems: primaryItems, overflowItems: overflowItems });
                    cacheKey = _this._computeCacheKey({ primaryItems: primaryItems, overflow: overflowItems.length > 0 });
                    if (onDataReduced) {
                        onDataReduced(movedItem);
                    }
                    newData.cacheKey = cacheKey;
                    return newData;
                }
                return undefined;
            };
            _this._onGrowData = function (data) {
                var _a = _this.props, shiftOnReduce = _a.shiftOnReduce, onDataGrown = _a.onDataGrown;
                var minimumOverflowItems = data.minimumOverflowItems;
                var primaryItems = data.primaryItems, overflowItems = data.overflowItems, cacheKey = data.cacheKey;
                var movedItem = overflowItems[0];
                // Make sure that moved item exists and is not one of the original overflow items
                if (movedItem !== undefined && overflowItems.length > minimumOverflowItems) {
                    movedItem.renderedInOverflow = false;
                    overflowItems = overflowItems.slice(1);
                    // if shiftOnReduce, movedItem goes first, otherwise, last.
                    primaryItems = shiftOnReduce ? __spreadArray$2([movedItem], primaryItems) : __spreadArray$2(__spreadArray$2([], primaryItems), [movedItem]);
                    var newData = __assign$k(__assign$k({}, data), { primaryItems: primaryItems, overflowItems: overflowItems });
                    cacheKey = _this._computeCacheKey({ primaryItems: primaryItems, overflow: overflowItems.length > 0 });
                    if (onDataGrown) {
                        onDataGrown(movedItem);
                    }
                    newData.cacheKey = cacheKey;
                    return newData;
                }
                return undefined;
            };
            initializeComponentRef(_this);
            return _this;
        }
        CommandBarBase.prototype.render = function () {
            var _a = this.props, items = _a.items, overflowItems = _a.overflowItems, farItems = _a.farItems, styles = _a.styles, theme = _a.theme, dataDidRender = _a.dataDidRender, _b = _a.onReduceData, onReduceData = _b === void 0 ? this._onReduceData : _b, _c = _a.onGrowData, onGrowData = _c === void 0 ? this._onGrowData : _c, _d = _a.resizeGroupAs, ResizeGroupAs = _d === void 0 ? ResizeGroup : _d;
            var commandBarData = {
                primaryItems: __spreadArray$2([], items),
                overflowItems: __spreadArray$2([], overflowItems),
                minimumOverflowItems: __spreadArray$2([], overflowItems).length,
                farItems: farItems,
                cacheKey: this._computeCacheKey({
                    primaryItems: __spreadArray$2([], items),
                    overflow: overflowItems && overflowItems.length > 0,
                }),
            };
            this._classNames = getClassNames$6(styles, { theme: theme });
            // ResizeGroup will render these attributes to the root <div>.
            // TODO We may need to elevate classNames from <FocusZone> into <ResizeGroup> ?
            var nativeProps = getNativeProps(this.props, divProperties);
            return (react.exports.createElement(ResizeGroupAs, __assign$k({}, nativeProps, { componentRef: this._resizeGroup, data: commandBarData, onReduceData: onReduceData, onGrowData: onGrowData, onRenderData: this._onRenderData, dataDidRender: dataDidRender })));
        };
        CommandBarBase.prototype.focus = function () {
            var overflowSet = this._overflowSet.current;
            overflowSet && overflowSet.focus();
        };
        CommandBarBase.prototype.remeasure = function () {
            this._resizeGroup.current && this._resizeGroup.current.remeasure();
        };
        CommandBarBase.prototype._onButtonClick = function (item) {
            return function (ev) {
                // inactive is deprecated. remove check in 7.0
                // eslint-disable-next-line deprecation/deprecation
                if (item.inactive) {
                    return;
                }
                if (item.onClick) {
                    item.onClick(ev, item);
                }
            };
        };
        CommandBarBase.prototype._computeCacheKey = function (data) {
            var primaryItems = data.primaryItems, overflow = data.overflow;
            var returnKey = function (acc, current) {
                var _a = current.cacheKey, cacheKey = _a === void 0 ? current.key : _a;
                return acc + cacheKey;
            };
            var primaryKey = primaryItems && primaryItems.reduce(returnKey, '');
            var overflowKey = overflow ? 'overflow' : '';
            return [primaryKey, overflowKey].join('');
        };
        CommandBarBase.defaultProps = {
            items: [],
            overflowItems: [],
        };
        return CommandBarBase;
    }(react.exports.Component));

    // Create a CommandBar variant which uses these default styles and this styled subcomponent.
    var CommandBar$1 = styled(CommandBarBase, getStyles$7, undefined, {
        scope: 'CommandBar',
    });

    var CommandBar = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CommandBar: CommandBar$1,
        CommandBarBase: CommandBarBase
    });

    /**
     * {@docCategory Dialog}
     */
    var DialogType;
    (function (DialogType) {
        /** Standard dialog */
        DialogType[DialogType["normal"] = 0] = "normal";
        /** Dialog with large header banner */
        DialogType[DialogType["largeHeader"] = 1] = "largeHeader";
        /** Dialog with an 'x' close button in the upper-right corner */
        DialogType[DialogType["close"] = 2] = "close";
    })(DialogType || (DialogType = {}));

    var animationDuration = AnimationVariables.durationValue2;
    var globalClassNames = {
        root: 'ms-Modal',
        main: 'ms-Dialog-main',
        scrollableContent: 'ms-Modal-scrollableContent',
        isOpen: 'is-open',
        layer: 'ms-Modal-Layer',
    };
    var getStyles$6 = function (props) {
        var _a;
        var className = props.className, containerClassName = props.containerClassName, scrollableContentClassName = props.scrollableContentClassName, isOpen = props.isOpen, isVisible = props.isVisible, hasBeenOpened = props.hasBeenOpened, modalRectangleTop = props.modalRectangleTop, theme = props.theme, topOffsetFixed = props.topOffsetFixed, isModeless = props.isModeless, layerClassName = props.layerClassName, isDefaultDragHandle = props.isDefaultDragHandle, windowInnerHeight = props.windowInnerHeight;
        var palette = theme.palette, effects = theme.effects, fonts = theme.fonts;
        var classNames = getGlobalClassNames(globalClassNames, theme);
        return {
            root: [
                classNames.root,
                fonts.medium,
                {
                    backgroundColor: 'transparent',
                    position: isModeless ? 'absolute' : 'fixed',
                    height: '100%',
                    width: '100%',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    opacity: 0,
                    pointerEvents: 'none',
                    transition: "opacity " + animationDuration,
                },
                topOffsetFixed &&
                    typeof modalRectangleTop === 'number' &&
                    hasBeenOpened && {
                    alignItems: 'flex-start',
                },
                isOpen && classNames.isOpen,
                isVisible && {
                    opacity: 1,
                    pointerEvents: 'auto',
                },
                className,
            ],
            main: [
                classNames.main,
                {
                    boxShadow: effects.elevation64,
                    borderRadius: effects.roundedCorner2,
                    backgroundColor: palette.white,
                    boxSizing: 'border-box',
                    position: 'relative',
                    textAlign: 'left',
                    outline: '3px solid transparent',
                    maxHeight: 'calc(100% - 32px)',
                    maxWidth: 'calc(100% - 32px)',
                    minHeight: '176px',
                    minWidth: '288px',
                    overflowY: 'auto',
                    zIndex: isModeless ? ZIndexes.Layer : undefined,
                },
                topOffsetFixed &&
                    typeof modalRectangleTop === 'number' &&
                    hasBeenOpened && {
                    top: modalRectangleTop,
                },
                isDefaultDragHandle && {
                    cursor: 'move',
                },
                containerClassName,
            ],
            scrollableContent: [
                classNames.scrollableContent,
                {
                    overflowY: 'auto',
                    flexGrow: 1,
                    maxHeight: '100vh',
                    selectors: (_a = {},
                        _a['@supports (-webkit-overflow-scrolling: touch)'] = {
                            maxHeight: windowInnerHeight,
                        },
                        _a),
                },
                scrollableContentClassName,
            ],
            layer: isModeless && [
                layerClassName,
                classNames.layer,
                {
                    position: 'static',
                    width: 'unset',
                    height: 'unset',
                },
            ],
            keyboardMoveIconContainer: {
                position: 'absolute',
                display: 'flex',
                justifyContent: 'center',
                width: '100%',
                padding: '3px 0px',
            },
            keyboardMoveIcon: {
                // eslint-disable-next-line deprecation/deprecation
                fontSize: fonts.xLargePlus.fontSize,
                width: '24px',
            },
        };
    };

    var getClassNames$5 = classNamesFunction();
    var OverlayBase = /** @class */ (function (_super) {
        __extends$4(OverlayBase, _super);
        function OverlayBase(props) {
            var _this = _super.call(this, props) || this;
            initializeComponentRef(_this);
            var _a = _this.props.allowTouchBodyScroll, allowTouchBodyScroll = _a === void 0 ? false : _a;
            _this._allowTouchBodyScroll = allowTouchBodyScroll;
            return _this;
        }
        OverlayBase.prototype.componentDidMount = function () {
            !this._allowTouchBodyScroll && disableBodyScroll();
        };
        OverlayBase.prototype.componentWillUnmount = function () {
            !this._allowTouchBodyScroll && enableBodyScroll();
        };
        OverlayBase.prototype.render = function () {
            var _a = this.props, isDark = _a.isDarkThemed, className = _a.className, theme = _a.theme, styles = _a.styles;
            var divProps = getNativeProps(this.props, divProperties);
            var classNames = getClassNames$5(styles, {
                theme: theme,
                className: className,
                isDark: isDark,
            });
            return react.exports.createElement("div", __assign$k({}, divProps, { className: classNames.root }));
        };
        return OverlayBase;
    }(react.exports.Component));

    var GlobalClassNames$3 = {
        root: 'ms-Overlay',
        rootDark: 'ms-Overlay--dark',
    };
    var getStyles$5 = function (props) {
        var _a;
        var className = props.className, theme = props.theme, isNone = props.isNone, isDark = props.isDark;
        var palette = theme.palette;
        var classNames = getGlobalClassNames(GlobalClassNames$3, theme);
        return {
            root: [
                classNames.root,
                theme.fonts.medium,
                {
                    backgroundColor: palette.whiteTranslucent40,
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0,
                    position: 'absolute',
                    selectors: (_a = {},
                        _a[HighContrastSelector] = {
                            border: '1px solid WindowText',
                            opacity: 0,
                        },
                        _a),
                },
                isNone && {
                    visibility: 'hidden',
                },
                isDark && [
                    classNames.rootDark,
                    {
                        backgroundColor: palette.blackTranslucent40,
                    },
                ],
                className,
            ],
        };
    };

    var Overlay = styled(OverlayBase, getStyles$5, undefined, {
        scope: 'Overlay',
    });

    var getClassNames$4 = memoizeFunction(function (className, isDragging) {
        return {
            root: mergeStyles(className, isDragging && {
                touchAction: 'none',
                selectors: {
                    '& *': {
                        userSelect: 'none',
                    },
                },
            }),
        };
    });

    var eventMapping = {
        touch: {
            start: 'touchstart',
            move: 'touchmove',
            stop: 'touchend',
        },
        mouse: {
            start: 'mousedown',
            move: 'mousemove',
            stop: 'mouseup',
        },
    };
    var DraggableZone = /** @class */ (function (_super) {
        __extends$4(DraggableZone, _super);
        function DraggableZone(props) {
            var _this = _super.call(this, props) || this;
            _this._currentEventType = eventMapping.mouse;
            _this._events = [];
            _this._onMouseDown = function (event) {
                var onMouseDown = react.exports.Children.only(_this.props.children).props.onMouseDown;
                if (onMouseDown) {
                    onMouseDown(event);
                }
                _this._currentEventType = eventMapping.mouse;
                return _this._onDragStart(event);
            };
            _this._onMouseUp = function (event) {
                var onMouseUp = react.exports.Children.only(_this.props.children).props.onMouseUp;
                if (onMouseUp) {
                    onMouseUp(event);
                }
                _this._currentEventType = eventMapping.mouse;
                return _this._onDragStop(event);
            };
            _this._onTouchStart = function (event) {
                var onTouchStart = react.exports.Children.only(_this.props.children).props.onTouchStart;
                if (onTouchStart) {
                    onTouchStart(event);
                }
                _this._currentEventType = eventMapping.touch;
                return _this._onDragStart(event);
            };
            _this._onTouchEnd = function (event) {
                var onTouchEnd = react.exports.Children.only(_this.props.children).props.onTouchEnd;
                if (onTouchEnd) {
                    onTouchEnd(event);
                }
                _this._currentEventType = eventMapping.touch;
                _this._onDragStop(event);
            };
            _this._onDragStart = function (event) {
                // Only handle left click for dragging
                if (typeof event.button === 'number' && event.button !== 0) {
                    return false;
                }
                // If the target doesn't match the handleSelector OR
                // if the target does match the preventDragSelector, bail out
                if ((_this.props.handleSelector && !_this._matchesSelector(event.target, _this.props.handleSelector)) ||
                    (_this.props.preventDragSelector &&
                        _this._matchesSelector(event.target, _this.props.preventDragSelector))) {
                    return;
                }
                // Remember the touch identifier if this is a touch event so we can
                // distinguish between individual touches in multitouch scenarios
                // by remembering which touch point we were given
                _this._touchId = _this._getTouchId(event);
                var position = _this._getControlPosition(event);
                if (position === undefined) {
                    return;
                }
                var dragData = _this._createDragDataFromPosition(position);
                _this.props.onStart && _this.props.onStart(event, dragData);
                _this.setState({
                    isDragging: true,
                    lastPosition: position,
                });
                // hook up the appropriate mouse/touch events to the body to ensure
                // smooth dragging
                _this._events = [
                    on(document.body, _this._currentEventType.move, _this._onDrag, true /* use capture phase */),
                    on(document.body, _this._currentEventType.stop, _this._onDragStop, true /* use capture phase */),
                ];
            };
            _this._onDrag = function (event) {
                // Prevent scrolling on mobile devices
                if (event.type === 'touchmove') {
                    event.preventDefault();
                }
                var position = _this._getControlPosition(event);
                if (!position) {
                    return;
                }
                // create the updated drag data from the position data
                var updatedData = _this._createUpdatedDragData(_this._createDragDataFromPosition(position));
                var updatedPosition = updatedData.position;
                _this.props.onDragChange && _this.props.onDragChange(event, updatedData);
                _this.setState({
                    position: updatedPosition,
                    lastPosition: position,
                });
            };
            _this._onDragStop = function (event) {
                if (!_this.state.isDragging) {
                    return;
                }
                var position = _this._getControlPosition(event);
                if (!position) {
                    return;
                }
                var baseDragData = _this._createDragDataFromPosition(position);
                // Set dragging to false and reset the lastPosition
                _this.setState({
                    isDragging: false,
                    lastPosition: undefined,
                });
                _this.props.onStop && _this.props.onStop(event, baseDragData);
                if (_this.props.position) {
                    _this.setState({
                        position: _this.props.position,
                    });
                }
                // Remove event handlers
                _this._events.forEach(function (dispose) { return dispose(); });
            };
            _this.state = {
                isDragging: false,
                position: _this.props.position || { x: 0, y: 0 },
                lastPosition: undefined,
            };
            return _this;
        }
        DraggableZone.prototype.componentDidUpdate = function (prevProps) {
            if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {
                this.setState({ position: this.props.position });
            }
        };
        DraggableZone.prototype.componentWillUnmount = function () {
            this._events.forEach(function (dispose) { return dispose(); });
        };
        DraggableZone.prototype.render = function () {
            var child = react.exports.Children.only(this.props.children);
            var props = child.props;
            var position = this.props.position;
            var _a = this.state, statePosition = _a.position, isDragging = _a.isDragging;
            var x = statePosition.x;
            var y = statePosition.y;
            if (position && !isDragging) {
                x = position.x;
                y = position.y;
            }
            return react.exports.cloneElement(child, {
                style: __assign$k(__assign$k({}, props.style), { transform: "translate(" + x + "px, " + y + "px)" }),
                className: getClassNames$4(props.className, this.state.isDragging).root,
                onMouseDown: this._onMouseDown,
                onMouseUp: this._onMouseUp,
                onTouchStart: this._onTouchStart,
                onTouchEnd: this._onTouchEnd,
            });
        };
        /**
         * Get the control position based off the event that fired
         * @param event - The event to get offsets from
         */
        DraggableZone.prototype._getControlPosition = function (event) {
            var touchObj = this._getActiveTouch(event);
            // did we get the right touch?
            if (this._touchId !== undefined && !touchObj) {
                return undefined;
            }
            var eventToGetOffset = touchObj || event;
            return {
                x: eventToGetOffset.clientX,
                y: eventToGetOffset.clientY,
            };
        };
        /**
         * Get the active touch point that we have saved from the event's TouchList
         * @param event - The event used to get the TouchList for the active touch point
         */
        DraggableZone.prototype._getActiveTouch = function (event) {
            return ((event.targetTouches && this._findTouchInTouchList(event.targetTouches)) ||
                (event.changedTouches && this._findTouchInTouchList(event.changedTouches)));
        };
        /**
         * Get the initial touch identifier associated with the given event
         * @param event - The event that contains the TouchList
         */
        DraggableZone.prototype._getTouchId = function (event) {
            var touch = (event.targetTouches && event.targetTouches[0]) || (event.changedTouches && event.changedTouches[0]);
            if (touch) {
                return touch.identifier;
            }
        };
        /**
         * Returns if an element (or any of the element's parents) match the given selector
         */
        DraggableZone.prototype._matchesSelector = function (element, selector) {
            if (!element || element === document.body) {
                return false;
            }
            var matchesSelectorFn = element.matches || element.webkitMatchesSelector || element.msMatchesSelector; /* for IE */
            if (!matchesSelectorFn) {
                return false;
            }
            return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);
        };
        /**
         * Attempts to find the Touch that matches the identifier  we stored in dragStart
         * @param touchList The TouchList to look for the stored identifier from dragStart
         */
        DraggableZone.prototype._findTouchInTouchList = function (touchList) {
            if (this._touchId === undefined) {
                return;
            }
            for (var i = 0; i < touchList.length; i++) {
                if (touchList[i].identifier === this._touchId) {
                    return touchList[i];
                }
            }
            return undefined;
        };
        /**
         * Create DragData based off of the last known position and the new position passed in
         * @param position The new position as part of the drag
         */
        DraggableZone.prototype._createDragDataFromPosition = function (position) {
            var lastPosition = this.state.lastPosition;
            // If we have no lastPosition, use the given position
            // for last position
            if (lastPosition === undefined) {
                return {
                    delta: { x: 0, y: 0 },
                    lastPosition: position,
                    position: position,
                };
            }
            return {
                delta: {
                    x: position.x - lastPosition.x,
                    y: position.y - lastPosition.y,
                },
                lastPosition: lastPosition,
                position: position,
            };
        };
        /**
         * Creates an updated DragData based off the current position and given baseDragData
         * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions
         */
        DraggableZone.prototype._createUpdatedDragData = function (baseDragData) {
            var position = this.state.position;
            return {
                position: {
                    x: position.x + baseDragData.delta.x,
                    y: position.y + baseDragData.delta.y,
                },
                delta: baseDragData.delta,
                lastPosition: position,
            };
        };
        return DraggableZone;
    }(react.exports.Component));

    var ZERO = { x: 0, y: 0 };
    var DEFAULT_PROPS = {
        isOpen: false,
        isDarkOverlay: true,
        className: '',
        containerClassName: '',
        enableAriaHiddenSiblings: true,
    };
    var getClassNames$3 = classNamesFunction();
    var getMoveDelta = function (ev) {
        var delta = 10;
        if (ev.shiftKey) {
            if (!ev.ctrlKey) {
                delta = 50;
            }
        }
        else if (ev.ctrlKey) {
            delta = 1;
        }
        return delta;
    };
    var useComponentRef = function (props, focusTrapZone) {
        react.exports.useImperativeHandle(props.componentRef, function () { return ({
            focus: function () {
                if (focusTrapZone.current) {
                    focusTrapZone.current.focus();
                }
            },
        }); }, [focusTrapZone]);
    };
    var ModalBase = react.exports.forwardRef(function (propsWithoutDefaults, ref) {
        var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
        var allowTouchBodyScroll = props.allowTouchBodyScroll, className = props.className, children = props.children, containerClassName = props.containerClassName, scrollableContentClassName = props.scrollableContentClassName, elementToFocusOnDismiss = props.elementToFocusOnDismiss, firstFocusableSelector = props.firstFocusableSelector, forceFocusInsideTrap = props.forceFocusInsideTrap, ignoreExternalFocusing = props.ignoreExternalFocusing, isBlocking = props.isBlocking, isAlert = props.isAlert, isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap, isDarkOverlay = props.isDarkOverlay, onDismiss = props.onDismiss, layerProps = props.layerProps, overlay = props.overlay, isOpen = props.isOpen, titleAriaId = props.titleAriaId, styles = props.styles, subtitleAriaId = props.subtitleAriaId, theme = props.theme, topOffsetFixed = props.topOffsetFixed, responsiveMode = props.responsiveMode, 
        // eslint-disable-next-line deprecation/deprecation
        onLayerDidMount = props.onLayerDidMount, isModeless = props.isModeless, dragOptions = props.dragOptions, onDismissed = props.onDismissed, 
        // eslint-disable-next-line deprecation/deprecation
        enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;
        var rootRef = react.exports.useRef(null);
        var focusTrapZone = react.exports.useRef(null);
        var focusTrapZoneElm = react.exports.useRef(null);
        var mergedRef = useMergedRefs(rootRef, ref);
        var modalResponsiveMode = useResponsiveMode(mergedRef);
        var focusTrapZoneId = useId('ModalFocusTrapZone');
        var win = useWindow();
        var _a = useSetTimeout(), setTimeout = _a.setTimeout, clearTimeout = _a.clearTimeout;
        var _b = react.exports.useState(isOpen), isModalOpen = _b[0], setIsModalOpen = _b[1];
        var _c = react.exports.useState(isOpen), isVisible = _c[0], setIsVisible = _c[1];
        var _d = react.exports.useState(ZERO), coordinates = _d[0], setCoordinates = _d[1];
        var _e = react.exports.useState(), modalRectangleTop = _e[0], setModalRectangleTop = _e[1];
        var _f = useBoolean(false), isModalMenuOpen = _f[0], _g = _f[1], toggleModalMenuOpen = _g.toggle, setModalMenuClose = _g.setFalse;
        var internalState = useConst(function () { return ({
            onModalCloseTimer: 0,
            allowTouchBodyScroll: allowTouchBodyScroll,
            scrollableContent: null,
            lastSetCoordinates: ZERO,
            events: new EventGroup({}),
        }); });
        var keepInBounds = (dragOptions || {}).keepInBounds;
        var isAlertRole = isAlert !== null && isAlert !== void 0 ? isAlert : (isBlocking && !isModeless);
        var layerClassName = layerProps === undefined ? '' : layerProps.className;
        var classNames = getClassNames$3(styles, {
            theme: theme,
            className: className,
            containerClassName: containerClassName,
            scrollableContentClassName: scrollableContentClassName,
            isOpen: isOpen,
            isVisible: isVisible,
            hasBeenOpened: internalState.hasBeenOpened,
            modalRectangleTop: modalRectangleTop,
            topOffsetFixed: topOffsetFixed,
            isModeless: isModeless,
            layerClassName: layerClassName,
            windowInnerHeight: win === null || win === void 0 ? void 0 : win.innerHeight,
            isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector,
        });
        var mergedLayerProps = __assign$k(__assign$k({ eventBubblingEnabled: false }, layerProps), { onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount, insertFirst: isModeless, className: classNames.layer });
        // Allow the user to scroll within the modal but not on the body
        var allowScrollOnModal = react.exports.useCallback(function (elt) {
            if (elt) {
                if (internalState.allowTouchBodyScroll) {
                    allowOverscrollOnElement(elt, internalState.events);
                }
                else {
                    allowScrollOnElement(elt, internalState.events);
                }
            }
            else {
                internalState.events.off(internalState.scrollableContent);
            }
            internalState.scrollableContent = elt;
        }, [internalState]);
        var registerInitialModalPosition = function () {
            var dialogMain = focusTrapZoneElm.current;
            var modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();
            if (modalRectangle) {
                if (topOffsetFixed) {
                    setModalRectangleTop(modalRectangle.top);
                }
                if (keepInBounds) {
                    // x/y are unavailable in IE, so use the equivalent left/top
                    internalState.minPosition = { x: -modalRectangle.left, y: -modalRectangle.top };
                    internalState.maxPosition = { x: modalRectangle.left, y: modalRectangle.top };
                }
            }
        };
        /**
         * Clamps an axis to a specified min and max position.
         *
         * @param axis A string that represents the axis (x/y).
         * @param position The position on the axis.
         */
        var getClampedAxis = react.exports.useCallback(function (axis, position) {
            var minPosition = internalState.minPosition, maxPosition = internalState.maxPosition;
            if (keepInBounds && minPosition && maxPosition) {
                position = Math.max(minPosition[axis], position);
                position = Math.min(maxPosition[axis], position);
            }
            return position;
        }, [keepInBounds, internalState]);
        var handleModalClose = function () {
            var _a;
            internalState.lastSetCoordinates = ZERO;
            setModalMenuClose();
            internalState.isInKeyboardMoveMode = false;
            setIsModalOpen(false);
            setCoordinates(ZERO);
            (_a = internalState.disposeOnKeyUp) === null || _a === void 0 ? void 0 : _a.call(internalState);
            onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();
        };
        var handleDragStart = react.exports.useCallback(function () {
            setModalMenuClose();
            internalState.isInKeyboardMoveMode = false;
        }, [internalState, setModalMenuClose]);
        var handleDrag = react.exports.useCallback(function (ev, dragData) {
            setCoordinates(function (prevValue) { return ({
                x: getClampedAxis('x', prevValue.x + dragData.delta.x),
                y: getClampedAxis('y', prevValue.y + dragData.delta.y),
            }); });
        }, [getClampedAxis]);
        var handleDragStop = react.exports.useCallback(function () {
            if (focusTrapZone.current) {
                focusTrapZone.current.focus();
            }
        }, []);
        var handleEnterKeyboardMoveMode = function () {
            // We need a global handleKeyDown event when we are in the move mode so that we can
            // handle the key presses and the components inside the modal do not get the events
            var handleKeyDown = function (ev) {
                if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {
                    // CTRL + ALT + SPACE is handled during keyUp
                    ev.preventDefault();
                    ev.stopPropagation();
                    return;
                }
                if (isModalMenuOpen && (ev.altKey || ev.keyCode === KeyCodes.escape)) {
                    setModalMenuClose();
                }
                if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {
                    internalState.isInKeyboardMoveMode = false;
                    ev.preventDefault();
                    ev.stopPropagation();
                }
                if (internalState.isInKeyboardMoveMode) {
                    var handledEvent = true;
                    var delta_1 = getMoveDelta(ev);
                    switch (ev.keyCode) {
                        /* eslint-disable no-fallthrough */
                        case KeyCodes.escape:
                            setCoordinates(internalState.lastSetCoordinates);
                        case KeyCodes.enter: {
                            // TODO: determine if fallthrough was intentional
                            /* eslint-enable no-fallthrough */
                            internalState.lastSetCoordinates = ZERO;
                            // setIsInKeyboardMoveMode(false);
                            break;
                        }
                        case KeyCodes.up: {
                            setCoordinates(function (prevValue) { return ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y - delta_1) }); });
                            break;
                        }
                        case KeyCodes.down: {
                            setCoordinates(function (prevValue) { return ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y + delta_1) }); });
                            break;
                        }
                        case KeyCodes.left: {
                            setCoordinates(function (prevValue) { return ({ x: getClampedAxis('x', prevValue.x - delta_1), y: prevValue.y }); });
                            break;
                        }
                        case KeyCodes.right: {
                            setCoordinates(function (prevValue) { return ({ x: getClampedAxis('x', prevValue.x + delta_1), y: prevValue.y }); });
                            break;
                        }
                        default: {
                            handledEvent = false;
                        }
                    }
                    if (handledEvent) {
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                }
            };
            internalState.lastSetCoordinates = coordinates;
            setModalMenuClose();
            internalState.isInKeyboardMoveMode = true;
            internalState.events.on(win, 'keydown', handleKeyDown, true /* useCapture */);
            internalState.disposeOnKeyDown = function () {
                internalState.events.off(win, 'keydown', handleKeyDown, true /* useCapture */);
                internalState.disposeOnKeyDown = undefined;
            };
        };
        var handleExitKeyboardMoveMode = function () {
            var _a;
            internalState.lastSetCoordinates = ZERO;
            internalState.isInKeyboardMoveMode = false;
            (_a = internalState.disposeOnKeyDown) === null || _a === void 0 ? void 0 : _a.call(internalState);
        };
        var registerForKeyUp = function () {
            var handleKeyUp = function (ev) {
                // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143
                if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {
                    if (elementContains(internalState.scrollableContent, ev.target)) {
                        toggleModalMenuOpen();
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                }
            };
            if (!internalState.disposeOnKeyUp) {
                internalState.events.on(win, 'keyup', handleKeyUp, true /* useCapture */);
                internalState.disposeOnKeyUp = function () {
                    internalState.events.off(win, 'keyup', handleKeyUp, true /* useCapture */);
                    internalState.disposeOnKeyUp = undefined;
                };
            }
        };
        react.exports.useEffect(function () {
            clearTimeout(internalState.onModalCloseTimer);
            // Opening the dialog
            if (isOpen) {
                // This must be done after the modal content has rendered
                requestAnimationFrame(function () { return setTimeout(registerInitialModalPosition, 0); });
                setIsModalOpen(true);
                // Add a keyUp handler for all key up events once the dialog is open.
                if (dragOptions) {
                    registerForKeyUp();
                }
                internalState.hasBeenOpened = true;
                setIsVisible(true);
            }
            // Closing the dialog
            if (!isOpen && isModalOpen) {
                internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);
                setIsVisible(false);
            }
            // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.
        }, [isModalOpen, isOpen]);
        useUnmount(function () {
            internalState.events.dispose();
        });
        useComponentRef(props, focusTrapZone);
        var modalContent = (react.exports.createElement(FocusTrapZone, { id: focusTrapZoneId, ref: focusTrapZoneElm, componentRef: focusTrapZone, className: classNames.main, elementToFocusOnDismiss: elementToFocusOnDismiss, isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking, ignoreExternalFocusing: ignoreExternalFocusing, forceFocusInsideTrap: forceFocusInsideTrap && !isModeless, firstFocusableSelector: firstFocusableSelector, focusPreviouslyFocusedInnerElement: true, onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined },
            dragOptions && internalState.isInKeyboardMoveMode && (react.exports.createElement("div", { className: classNames.keyboardMoveIconContainer }, dragOptions.keyboardMoveIconProps ? (react.exports.createElement(Icon$1, __assign$k({}, dragOptions.keyboardMoveIconProps))) : (react.exports.createElement(Icon$1, { iconName: "move", className: classNames.keyboardMoveIcon })))),
            react.exports.createElement("div", { ref: allowScrollOnModal, className: classNames.scrollableContent, "data-is-scrollable": true },
                dragOptions && isModalMenuOpen && (react.exports.createElement(dragOptions.menu, { items: [
                        { key: 'move', text: dragOptions.moveMenuItemText, onClick: handleEnterKeyboardMoveMode },
                        { key: 'close', text: dragOptions.closeMenuItemText, onClick: handleModalClose },
                    ], onDismiss: setModalMenuClose, alignTargetEdge: true, coverTarget: true, directionalHint: DirectionalHint.topLeftEdge, directionalHintFixed: true, shouldFocusOnMount: true, target: internalState.scrollableContent })),
                children)));
        return ((isModalOpen && modalResponsiveMode >= (responsiveMode || ResponsiveMode.small) && (react.exports.createElement(Layer, __assign$k({ ref: mergedRef }, mergedLayerProps),
            react.exports.createElement(Popup, { role: isAlertRole ? 'alertdialog' : 'dialog', ariaLabelledBy: titleAriaId, ariaDescribedBy: subtitleAriaId, onDismiss: onDismiss, shouldRestoreFocus: !ignoreExternalFocusing, 
                // Modeless modals shouldn't hide siblings.
                // Popup will automatically handle this based on the aria-modal setting.
                enableAriaHiddenSiblings: enableAriaHiddenSiblings, "aria-modal": !isModeless },
                react.exports.createElement("div", { className: classNames.root, role: !isModeless ? 'document' : undefined },
                    !isModeless && (react.exports.createElement(Overlay, __assign$k({ "aria-hidden": true, isDarkThemed: isDarkOverlay, onClick: isBlocking ? undefined : onDismiss, allowTouchBodyScroll: allowTouchBodyScroll }, overlay))),
                    dragOptions ? (react.exports.createElement(DraggableZone, { handleSelector: dragOptions.dragHandleSelector || "#" + focusTrapZoneId, preventDragSelector: "button", onStart: handleDragStart, onDragChange: handleDrag, onStop: handleDragStop, position: coordinates }, modalContent)) : (modalContent)))))) ||
            null);
    });
    ModalBase.displayName = 'Modal';

    var Modal = styled(ModalBase, getStyles$6, undefined, {
        scope: 'Modal',
        fields: ['theme', 'styles', 'enableAriaHiddenSiblings'],
    });
    Modal.displayName = 'Modal';

    var getClassNames$2 = classNamesFunction();
    var DialogFooterBase = /** @class */ (function (_super) {
        __extends$4(DialogFooterBase, _super);
        function DialogFooterBase(props) {
            var _this = _super.call(this, props) || this;
            initializeComponentRef(_this);
            return _this;
        }
        DialogFooterBase.prototype.render = function () {
            var _a = this.props, className = _a.className, styles = _a.styles, theme = _a.theme;
            this._classNames = getClassNames$2(styles, {
                theme: theme,
                className: className,
            });
            return (react.exports.createElement("div", { className: this._classNames.actions },
                react.exports.createElement("div", { className: this._classNames.actionsRight }, this._renderChildrenAsActions())));
        };
        DialogFooterBase.prototype._renderChildrenAsActions = function () {
            var _this = this;
            return react.exports.Children.map(this.props.children, function (child) {
                return child ? react.exports.createElement("span", { className: _this._classNames.action }, child) : null;
            });
        };
        return DialogFooterBase;
    }(react.exports.Component));

    var GlobalClassNames$2 = {
        actions: 'ms-Dialog-actions',
        action: 'ms-Dialog-action',
        actionsRight: 'ms-Dialog-actionsRight',
    };
    var getStyles$4 = function (props) {
        var className = props.className, theme = props.theme;
        var classNames = getGlobalClassNames(GlobalClassNames$2, theme);
        return {
            actions: [
                classNames.actions,
                {
                    position: 'relative',
                    width: '100%',
                    minHeight: '24px',
                    lineHeight: '24px',
                    margin: '16px 0 0',
                    fontSize: '0',
                    selectors: {
                        '.ms-Button': {
                            lineHeight: 'normal',
                        },
                    },
                },
                className,
            ],
            action: [
                classNames.action,
                {
                    margin: '0 4px',
                },
            ],
            actionsRight: [
                classNames.actionsRight,
                {
                    textAlign: 'right',
                    marginRight: '-4px',
                    fontSize: '0',
                },
            ],
        };
    };

    var DialogFooter = styled(DialogFooterBase, getStyles$4, undefined, { scope: 'DialogFooter' });

    var getClassNames$1 = classNamesFunction();
    var DialogFooterType = (react.exports.createElement(DialogFooter, null)).type;
    // eslint-disable-next-line deprecation/deprecation
    var DialogContentBase = /** @class */ (function (_super) {
        __extends$4(DialogContentBase, _super);
        function DialogContentBase(props) {
            var _this = _super.call(this, props) || this;
            initializeComponentRef(_this);
            return _this;
        }
        DialogContentBase.prototype.render = function () {
            var _a = this.props, showCloseButton = _a.showCloseButton, className = _a.className, closeButtonAriaLabel = _a.closeButtonAriaLabel, onDismiss = _a.onDismiss, subTextId = _a.subTextId, subText = _a.subText, _b = _a.titleProps, titleProps = _b === void 0 ? {} : _b, 
            // eslint-disable-next-line deprecation/deprecation
            titleId = _a.titleId, title = _a.title, type = _a.type, styles = _a.styles, theme = _a.theme, draggableHeaderClassName = _a.draggableHeaderClassName;
            var classNames = getClassNames$1(styles, {
                theme: theme,
                className: className,
                isLargeHeader: type === DialogType.largeHeader,
                isClose: type === DialogType.close,
                draggableHeaderClassName: draggableHeaderClassName,
            });
            var groupings = this._groupChildren();
            var subTextContent;
            if (subText) {
                subTextContent = (react.exports.createElement("p", { className: classNames.subText, id: subTextId }, subText));
            }
            return (react.exports.createElement("div", { className: classNames.content },
                react.exports.createElement("div", { className: classNames.header },
                    react.exports.createElement("div", __assign$k({ id: titleId, role: "heading", "aria-level": 1 }, titleProps, { className: css(classNames.title, titleProps.className) }), title),
                    react.exports.createElement("div", { className: classNames.topButton },
                        this.props.topButtonsProps.map(function (props, index) { return (react.exports.createElement(IconButton, __assign$k({ key: props.uniqueId || index }, props))); }),
                        (type === DialogType.close || (showCloseButton && type !== DialogType.largeHeader)) && (react.exports.createElement(IconButton, { className: classNames.button, iconProps: { iconName: 'Cancel' }, ariaLabel: closeButtonAriaLabel, onClick: onDismiss })))),
                react.exports.createElement("div", { className: classNames.inner },
                    react.exports.createElement("div", { className: classNames.innerContent },
                        subTextContent,
                        groupings.contents),
                    groupings.footers)));
        };
        // @TODO - typing the footers as an array of DialogFooter is difficult because
        // casing "child as DialogFooter" causes a problem because
        // "Neither type 'ReactElement<any>' nor type 'DialogFooter' is assignable to the other."
        DialogContentBase.prototype._groupChildren = function () {
            var groupings = {
                footers: [],
                contents: [],
            };
            react.exports.Children.map(this.props.children, function (child) {
                if (typeof child === 'object' && child !== null && child.type === DialogFooterType) {
                    groupings.footers.push(child);
                }
                else {
                    groupings.contents.push(child);
                }
            });
            return groupings;
        };
        DialogContentBase.defaultProps = {
            showCloseButton: false,
            className: '',
            topButtonsProps: [],
            closeButtonAriaLabel: 'Close',
        };
        DialogContentBase = __decorate([
            withResponsiveMode
        ], DialogContentBase);
        return DialogContentBase;
    }(react.exports.Component));

    var GlobalClassNames$1 = {
        contentLgHeader: 'ms-Dialog-lgHeader',
        close: 'ms-Dialog--close',
        subText: 'ms-Dialog-subText',
        header: 'ms-Dialog-header',
        headerLg: 'ms-Dialog--lgHeader',
        button: 'ms-Dialog-button ms-Dialog-button--close',
        inner: 'ms-Dialog-inner',
        content: 'ms-Dialog-content',
        title: 'ms-Dialog-title',
    };
    var getStyles$3 = function (props) {
        var _a, _b, _c;
        var className = props.className, theme = props.theme, isLargeHeader = props.isLargeHeader, isClose = props.isClose, hidden = props.hidden, isMultiline = props.isMultiline, draggableHeaderClassName = props.draggableHeaderClassName;
        var palette = theme.palette, fonts = theme.fonts, effects = theme.effects, semanticColors = theme.semanticColors;
        var classNames = getGlobalClassNames(GlobalClassNames$1, theme);
        return {
            content: [
                isLargeHeader && [
                    classNames.contentLgHeader,
                    {
                        borderTop: "4px solid " + palette.themePrimary,
                    },
                ],
                isClose && classNames.close,
                {
                    flexGrow: 1,
                    overflowY: 'hidden', // required for allowScrollOnElement
                },
                className,
            ],
            subText: [
                classNames.subText,
                fonts.medium,
                {
                    margin: '0 0 24px 0',
                    color: semanticColors.bodySubtext,
                    lineHeight: '1.5',
                    wordWrap: 'break-word',
                    fontWeight: FontWeights.regular,
                },
            ],
            header: [
                classNames.header,
                {
                    position: 'relative',
                    width: '100%',
                    boxSizing: 'border-box',
                },
                isClose && classNames.close,
                draggableHeaderClassName && [
                    draggableHeaderClassName,
                    {
                        cursor: 'move',
                    },
                ],
            ],
            button: [
                classNames.button,
                hidden && {
                    selectors: {
                        '.ms-Icon.ms-Icon--Cancel': {
                            color: semanticColors.buttonText,
                            fontSize: IconFontSizes.medium,
                        },
                    },
                },
            ],
            inner: [
                classNames.inner,
                {
                    padding: '0 24px 24px',
                    selectors: (_a = {},
                        _a["@media (min-width: " + ScreenWidthMinSmall + "px) and (max-width: " + ScreenWidthMaxSmall + "px)"] = {
                            padding: '0 16px 16px',
                        },
                        _a),
                },
            ],
            innerContent: [
                classNames.content,
                {
                    position: 'relative',
                    width: '100%',
                },
            ],
            title: [
                classNames.title,
                fonts.xLarge,
                {
                    color: semanticColors.bodyText,
                    margin: '0',
                    minHeight: fonts.xLarge.fontSize,
                    padding: '16px 46px 20px 24px',
                    lineHeight: 'normal',
                    selectors: (_b = {},
                        _b["@media (min-width: " + ScreenWidthMinSmall + "px) and (max-width: " + ScreenWidthMaxSmall + "px)"] = {
                            padding: '16px 46px 16px 16px',
                        },
                        _b),
                },
                isLargeHeader && {
                    color: semanticColors.menuHeader,
                },
                isMultiline && { fontSize: fonts.xxLarge.fontSize },
            ],
            topButton: [
                {
                    display: 'flex',
                    flexDirection: 'row',
                    flexWrap: 'nowrap',
                    position: 'absolute',
                    top: '0',
                    right: '0',
                    padding: '15px 15px 0 0',
                    selectors: (_c = {
                            '> *': {
                                flex: '0 0 auto',
                            },
                            '.ms-Dialog-button': {
                                color: semanticColors.buttonText,
                            },
                            '.ms-Dialog-button:hover': {
                                color: semanticColors.buttonTextHovered,
                                borderRadius: effects.roundedCorner2,
                            }
                        },
                        _c["@media (min-width: " + ScreenWidthMinSmall + "px) and (max-width: " + ScreenWidthMaxSmall + "px)"] = {
                            padding: '15px 8px 0 0',
                        },
                        _c),
                },
            ],
        };
    };

    var DialogContent = styled(DialogContentBase, getStyles$3, undefined, { scope: 'DialogContent' });

    var getClassNames = classNamesFunction();
    var DefaultModalProps = {
        isDarkOverlay: false,
        isBlocking: false,
        className: '',
        containerClassName: '',
        topOffsetFixed: false,
        enableAriaHiddenSiblings: true,
    };
    var DefaultDialogContentProps = {
        type: DialogType.normal,
        className: '',
        topButtonsProps: [],
    };
    // eslint-disable-next-line deprecation/deprecation
    var DialogBase = /** @class */ (function (_super) {
        __extends$4(DialogBase, _super);
        function DialogBase(props) {
            var _this = _super.call(this, props) || this;
            _this._getSubTextId = function () {
                // eslint-disable-next-line deprecation/deprecation
                var _a = _this.props, ariaDescribedById = _a.ariaDescribedById, modalProps = _a.modalProps, dialogContentProps = _a.dialogContentProps, subText = _a.subText;
                var id = (modalProps && modalProps.subtitleAriaId) || ariaDescribedById;
                if (!id) {
                    id = ((dialogContentProps && dialogContentProps.subText) || subText) && _this._defaultSubTextId;
                }
                return id;
            };
            _this._getTitleTextId = function () {
                // eslint-disable-next-line deprecation/deprecation
                var _a = _this.props, ariaLabelledById = _a.ariaLabelledById, modalProps = _a.modalProps, dialogContentProps = _a.dialogContentProps, title = _a.title;
                var id = (modalProps && modalProps.titleAriaId) || ariaLabelledById;
                if (!id) {
                    id = ((dialogContentProps && dialogContentProps.title) || title) && _this._defaultTitleTextId;
                }
                return id;
            };
            _this._id = getId('Dialog');
            _this._defaultTitleTextId = _this._id + '-title';
            _this._defaultSubTextId = _this._id + '-subText';
            return _this;
        }
        DialogBase.prototype.render = function () {
            var _a, _b;
            var props = this.props;
            var 
            /* eslint-disable deprecation/deprecation */
            className = props.className, containerClassName = props.containerClassName, contentClassName = props.contentClassName, elementToFocusOnDismiss = props.elementToFocusOnDismiss, firstFocusableSelector = props.firstFocusableSelector, forceFocusInsideTrap = props.forceFocusInsideTrap, styles = props.styles, hidden = props.hidden, ignoreExternalFocusing = props.ignoreExternalFocusing, isBlocking = props.isBlocking, isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap, isDarkOverlay = props.isDarkOverlay, _c = props.isOpen, isOpen = _c === void 0 ? !hidden : _c, onDismiss = props.onDismiss, onDismissed = props.onDismissed, onLayerDidMount = props.onLayerDidMount, responsiveMode = props.responsiveMode, subText = props.subText, theme = props.theme, title = props.title, topButtonsProps = props.topButtonsProps, type = props.type, 
            /* eslint-enable deprecation/deprecation */
            minWidth = props.minWidth, maxWidth = props.maxWidth, modalProps = props.modalProps;
            var mergedLayerProps = __assign$k({ onLayerDidMount: onLayerDidMount }, modalProps === null || modalProps === void 0 ? void 0 : modalProps.layerProps);
            var dialogDraggableClassName;
            var dragOptions = modalProps === null || modalProps === void 0 ? void 0 : modalProps.dragOptions;
            // if we are draggable, make sure we are using the correct
            // draggable classname and selectors
            if (dragOptions && !dragOptions.dragHandleSelector) {
                dialogDraggableClassName = 'ms-Dialog-draggable-header';
                dragOptions.dragHandleSelector = "." + dialogDraggableClassName;
            }
            var mergedModalProps = __assign$k(__assign$k(__assign$k(__assign$k({}, DefaultModalProps), { elementToFocusOnDismiss: elementToFocusOnDismiss, firstFocusableSelector: firstFocusableSelector, forceFocusInsideTrap: forceFocusInsideTrap, ignoreExternalFocusing: ignoreExternalFocusing, isClickableOutsideFocusTrap: isClickableOutsideFocusTrap, responsiveMode: responsiveMode, className: className, containerClassName: containerClassName, isBlocking: isBlocking, isDarkOverlay: isDarkOverlay, onDismissed: onDismissed }), modalProps), { layerProps: mergedLayerProps, dragOptions: dragOptions, isOpen: isOpen });
            var dialogContentProps = __assign$k(__assign$k(__assign$k({ className: contentClassName, subText: subText, title: title, topButtonsProps: topButtonsProps, type: type }, DefaultDialogContentProps), props.dialogContentProps), { draggableHeaderClassName: dialogDraggableClassName, titleProps: __assign$k({ 
                    // eslint-disable-next-line deprecation/deprecation
                    id: ((_a = props.dialogContentProps) === null || _a === void 0 ? void 0 : _a.titleId) || this._defaultTitleTextId }, (_b = props.dialogContentProps) === null || _b === void 0 ? void 0 : _b.titleProps) });
            var classNames = getClassNames(styles, {
                theme: theme,
                className: mergedModalProps.className,
                containerClassName: mergedModalProps.containerClassName,
                hidden: hidden,
                dialogDefaultMinWidth: minWidth,
                dialogDefaultMaxWidth: maxWidth,
            });
            return (react.exports.createElement(Modal, __assign$k({}, mergedModalProps, { className: classNames.root, containerClassName: classNames.main, onDismiss: onDismiss || mergedModalProps.onDismiss, subtitleAriaId: this._getSubTextId(), titleAriaId: this._getTitleTextId() }),
                react.exports.createElement(DialogContent, __assign$k({ subTextId: this._defaultSubTextId, showCloseButton: mergedModalProps.isBlocking, onDismiss: onDismiss }, dialogContentProps), props.children)));
        };
        DialogBase.defaultProps = {
            hidden: true,
        };
        DialogBase = __decorate([
            withResponsiveMode
        ], DialogBase);
        return DialogBase;
    }(react.exports.Component));

    var GlobalClassNames = {
        root: 'ms-Dialog',
    };
    var getStyles$2 = function (props) {
        var _a;
        var className = props.className, containerClassName = props.containerClassName, // eslint-disable-line deprecation/deprecation
        _b = props.dialogDefaultMinWidth, // eslint-disable-line deprecation/deprecation
        dialogDefaultMinWidth = _b === void 0 ? '288px' : _b, _c = props.dialogDefaultMaxWidth, dialogDefaultMaxWidth = _c === void 0 ? '340px' : _c, hidden = props.hidden, theme = props.theme;
        var classNames = getGlobalClassNames(GlobalClassNames, theme);
        return {
            root: [classNames.root, theme.fonts.medium, className],
            main: [
                {
                    width: dialogDefaultMinWidth,
                    outline: '3px solid transparent',
                    selectors: (_a = {},
                        _a["@media (min-width: " + ScreenWidthMinMedium + "px)"] = {
                            width: 'auto',
                            maxWidth: dialogDefaultMaxWidth,
                            minWidth: dialogDefaultMinWidth,
                        },
                        _a),
                },
                !hidden && { display: 'flex' },
                containerClassName,
            ],
        };
    };

    var Dialog$1 = styled(DialogBase, getStyles$2, undefined, { scope: 'Dialog' });
    Dialog$1.displayName = 'Dialog';

    var Dialog = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Dialog$1,
        Dialog: Dialog$1,
        DialogBase: DialogBase,
        DialogContent: DialogContent,
        DialogContentBase: DialogContentBase,
        DialogFooter: DialogFooter,
        DialogFooterBase: DialogFooterBase,
        get DialogType () { return DialogType; }
    });

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$j(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none',
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons\"",
                src: "url('" + baseUrl + "fabric-icons-a13498cf.woff') format('woff')",
            },
            icons: {
                GlobalNavButton: '\uE700',
                ChevronDown: '\uE70D',
                ChevronUp: '\uE70E',
                Edit: '\uE70F',
                Add: '\uE710',
                Cancel: '\uE711',
                More: '\uE712',
                Settings: '\uE713',
                Mail: '\uE715',
                Filter: '\uE71C',
                Search: '\uE721',
                Share: '\uE72D',
                BlockedSite: '\uE72F',
                FavoriteStar: '\uE734',
                FavoriteStarFill: '\uE735',
                CheckMark: '\uE73E',
                Delete: '\uE74D',
                ChevronLeft: '\uE76B',
                ChevronRight: '\uE76C',
                Calendar: '\uE787',
                Megaphone: '\uE789',
                Undo: '\uE7A7',
                Flag: '\uE7C1',
                Page: '\uE7C3',
                Pinned: '\uE840',
                View: '\uE890',
                Clear: '\uE894',
                Download: '\uE896',
                Upload: '\uE898',
                Folder: '\uE8B7',
                Sort: '\uE8CB',
                AlignRight: '\uE8E2',
                AlignLeft: '\uE8E4',
                Tag: '\uE8EC',
                AddFriend: '\uE8FA',
                Info: '\uE946',
                SortLines: '\uE9D0',
                List: '\uEA37',
                CircleRing: '\uEA3A',
                Heart: '\uEB51',
                HeartFill: '\uEB52',
                Tiles: '\uECA5',
                Embed: '\uECCE',
                Glimmer: '\uECF4',
                Ascending: '\uEDC0',
                Descending: '\uEDC1',
                SortUp: '\uEE68',
                SortDown: '\uEE69',
                SyncToPC: '\uEE6E',
                LargeGrid: '\uEECB',
                SkypeCheck: '\uEF80',
                SkypeClock: '\uEF81',
                SkypeMinus: '\uEF82',
                ClearFilter: '\uEF8F',
                Flow: '\uEF90',
                StatusCircleCheckmark: '\uF13E',
                MoreVertical: '\uF2BC',
            },
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$i(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-0\"",
                src: "url('" + baseUrl + "fabric-icons-0-467ee27f.woff') format('woff')"
            },
            icons: {
                'PageLink': '\uE302',
                'CommentSolid': '\uE30E',
                'ChangeEntitlements': '\uE310',
                'Installation': '\uE311',
                'WebAppBuilderModule': '\uE313',
                'WebAppBuilderFragment': '\uE314',
                'WebAppBuilderSlot': '\uE315',
                'BullseyeTargetEdit': '\uE319',
                'WebAppBuilderFragmentCreate': '\uE31B',
                'PageData': '\uE31C',
                'PageHeaderEdit': '\uE31D',
                'ProductList': '\uE31E',
                'UnpublishContent': '\uE31F',
                'DependencyAdd': '\uE344',
                'DependencyRemove': '\uE345',
                'EntitlementPolicy': '\uE346',
                'EntitlementRedemption': '\uE347',
                'SchoolDataSyncLogo': '\uE34C',
                'PinSolid12': '\uE352',
                'PinSolidOff12': '\uE353',
                'AddLink': '\uE35E',
                'SharepointAppIcon16': '\uE365',
                'DataflowsLink': '\uE366',
                'TimePicker': '\uE367',
                'UserWarning': '\uE368',
                'ComplianceAudit': '\uE369',
                'InternetSharing': '\uE704',
                'Brightness': '\uE706',
                'MapPin': '\uE707',
                'Airplane': '\uE709',
                'Tablet': '\uE70A',
                'QuickNote': '\uE70B',
                'Video': '\uE714',
                'People': '\uE716',
                'Phone': '\uE717',
                'Pin': '\uE718',
                'Shop': '\uE719',
                'Stop': '\uE71A',
                'Link': '\uE71B',
                'AllApps': '\uE71D',
                'Zoom': '\uE71E',
                'ZoomOut': '\uE71F',
                'Microphone': '\uE720',
                'Camera': '\uE722',
                'Attach': '\uE723',
                'Send': '\uE724',
                'FavoriteList': '\uE728',
                'PageSolid': '\uE729',
                'Forward': '\uE72A',
                'Back': '\uE72B',
                'Refresh': '\uE72C',
                'Lock': '\uE72E',
                'ReportHacked': '\uE730',
                'EMI': '\uE731',
                'MiniLink': '\uE732',
                'Blocked': '\uE733',
                'ReadingMode': '\uE736',
                'Favicon': '\uE737',
                'Remove': '\uE738',
                'Checkbox': '\uE739',
                'CheckboxComposite': '\uE73A',
                'CheckboxFill': '\uE73B',
                'CheckboxIndeterminate': '\uE73C',
                'CheckboxCompositeReversed': '\uE73D',
                'BackToWindow': '\uE73F',
                'FullScreen': '\uE740',
                'Print': '\uE749',
                'Up': '\uE74A',
                'Down': '\uE74B',
                'OEM': '\uE74C',
                'Save': '\uE74E',
                'ReturnKey': '\uE751',
                'Cloud': '\uE753',
                'Flashlight': '\uE754',
                'CommandPrompt': '\uE756',
                'Sad': '\uE757',
                'RealEstate': '\uE758',
                'SIPMove': '\uE759',
                'EraseTool': '\uE75C',
                'GripperTool': '\uE75E',
                'Dialpad': '\uE75F',
                'PageLeft': '\uE760',
                'PageRight': '\uE761',
                'MultiSelect': '\uE762',
                'KeyboardClassic': '\uE765',
                'Play': '\uE768',
                'Pause': '\uE769',
                'InkingTool': '\uE76D',
                'Emoji2': '\uE76E',
                'GripperBarHorizontal': '\uE76F',
                'System': '\uE770',
                'Personalize': '\uE771',
                'SearchAndApps': '\uE773',
                'Globe': '\uE774',
                'EaseOfAccess': '\uE776',
                'ContactInfo': '\uE779',
                'Unpin': '\uE77A',
                'Contact': '\uE77B',
                'Memo': '\uE77C',
                'IncomingCall': '\uE77E'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$h(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-1\"",
                src: "url('" + baseUrl + "fabric-icons-1-4d521695.woff') format('woff')"
            },
            icons: {
                'Paste': '\uE77F',
                'WindowsLogo': '\uE782',
                'Error': '\uE783',
                'GripperBarVertical': '\uE784',
                'Unlock': '\uE785',
                'Slideshow': '\uE786',
                'Trim': '\uE78A',
                'AutoEnhanceOn': '\uE78D',
                'AutoEnhanceOff': '\uE78E',
                'Color': '\uE790',
                'SaveAs': '\uE792',
                'Light': '\uE793',
                'Filters': '\uE795',
                'AspectRatio': '\uE799',
                'Contrast': '\uE7A1',
                'Redo': '\uE7A6',
                'Crop': '\uE7A8',
                'PhotoCollection': '\uE7AA',
                'Album': '\uE7AB',
                'Rotate': '\uE7AD',
                'PanoIndicator': '\uE7B0',
                'Translate': '\uE7B2',
                'RedEye': '\uE7B3',
                'ViewOriginal': '\uE7B4',
                'ThumbnailView': '\uE7B6',
                'Package': '\uE7B8',
                'Telemarketer': '\uE7B9',
                'Warning': '\uE7BA',
                'Financial': '\uE7BB',
                'Education': '\uE7BE',
                'ShoppingCart': '\uE7BF',
                'Train': '\uE7C0',
                'Move': '\uE7C2',
                'TouchPointer': '\uE7C9',
                'Merge': '\uE7D5',
                'TurnRight': '\uE7DB',
                'Ferry': '\uE7E3',
                'Highlight': '\uE7E6',
                'PowerButton': '\uE7E8',
                'Tab': '\uE7E9',
                'Admin': '\uE7EF',
                'TVMonitor': '\uE7F4',
                'Speakers': '\uE7F5',
                'Game': '\uE7FC',
                'HorizontalTabKey': '\uE7FD',
                'UnstackSelected': '\uE7FE',
                'StackIndicator': '\uE7FF',
                'Nav2DMapView': '\uE800',
                'StreetsideSplitMinimize': '\uE802',
                'Car': '\uE804',
                'Bus': '\uE806',
                'EatDrink': '\uE807',
                'SeeDo': '\uE808',
                'LocationCircle': '\uE80E',
                'Home': '\uE80F',
                'SwitcherStartEnd': '\uE810',
                'ParkingLocation': '\uE811',
                'IncidentTriangle': '\uE814',
                'Touch': '\uE815',
                'MapDirections': '\uE816',
                'CaretHollow': '\uE817',
                'CaretSolid': '\uE818',
                'History': '\uE81C',
                'Location': '\uE81D',
                'MapLayers': '\uE81E',
                'SearchNearby': '\uE820',
                'Work': '\uE821',
                'Recent': '\uE823',
                'Hotel': '\uE824',
                'Bank': '\uE825',
                'LocationDot': '\uE827',
                'Dictionary': '\uE82D',
                'ChromeBack': '\uE830',
                'FolderOpen': '\uE838',
                'PinnedFill': '\uE842',
                'RevToggleKey': '\uE845',
                'USB': '\uE88E',
                'Previous': '\uE892',
                'Next': '\uE893',
                'Sync': '\uE895',
                'Help': '\uE897',
                'Emoji': '\uE899',
                'MailForward': '\uE89C',
                'ClosePane': '\uE89F',
                'OpenPane': '\uE8A0',
                'PreviewLink': '\uE8A1',
                'ZoomIn': '\uE8A3',
                'Bookmarks': '\uE8A4',
                'Document': '\uE8A5',
                'ProtectedDocument': '\uE8A6',
                'OpenInNewWindow': '\uE8A7',
                'MailFill': '\uE8A8',
                'ViewAll': '\uE8A9',
                'Switch': '\uE8AB',
                'Rename': '\uE8AC',
                'Go': '\uE8AD',
                'Remote': '\uE8AF',
                'SelectAll': '\uE8B3',
                'Orientation': '\uE8B4',
                'Import': '\uE8B5'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$g(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-2\"",
                src: "url('" + baseUrl + "fabric-icons-2-63c99abf.woff') format('woff')"
            },
            icons: {
                'Picture': '\uE8B9',
                'ChromeClose': '\uE8BB',
                'ShowResults': '\uE8BC',
                'Message': '\uE8BD',
                'CalendarDay': '\uE8BF',
                'CalendarWeek': '\uE8C0',
                'MailReplyAll': '\uE8C2',
                'Read': '\uE8C3',
                'Cut': '\uE8C6',
                'PaymentCard': '\uE8C7',
                'Copy': '\uE8C8',
                'Important': '\uE8C9',
                'MailReply': '\uE8CA',
                'GotoToday': '\uE8D1',
                'Font': '\uE8D2',
                'FontColor': '\uE8D3',
                'FolderFill': '\uE8D5',
                'Permissions': '\uE8D7',
                'DisableUpdates': '\uE8D8',
                'Unfavorite': '\uE8D9',
                'Italic': '\uE8DB',
                'Underline': '\uE8DC',
                'Bold': '\uE8DD',
                'MoveToFolder': '\uE8DE',
                'Dislike': '\uE8E0',
                'Like': '\uE8E1',
                'AlignCenter': '\uE8E3',
                'OpenFile': '\uE8E5',
                'ClearSelection': '\uE8E6',
                'FontDecrease': '\uE8E7',
                'FontIncrease': '\uE8E8',
                'FontSize': '\uE8E9',
                'CellPhone': '\uE8EA',
                'RepeatOne': '\uE8ED',
                'RepeatAll': '\uE8EE',
                'Calculator': '\uE8EF',
                'Library': '\uE8F1',
                'PostUpdate': '\uE8F3',
                'NewFolder': '\uE8F4',
                'CalendarReply': '\uE8F5',
                'UnsyncFolder': '\uE8F6',
                'SyncFolder': '\uE8F7',
                'BlockContact': '\uE8F8',
                'Accept': '\uE8FB',
                'BulletedList': '\uE8FD',
                'Preview': '\uE8FF',
                'News': '\uE900',
                'Chat': '\uE901',
                'Group': '\uE902',
                'World': '\uE909',
                'Comment': '\uE90A',
                'DockLeft': '\uE90C',
                'DockRight': '\uE90D',
                'Repair': '\uE90F',
                'Accounts': '\uE910',
                'Street': '\uE913',
                'RadioBullet': '\uE915',
                'Stopwatch': '\uE916',
                'Clock': '\uE917',
                'WorldClock': '\uE918',
                'AlarmClock': '\uE919',
                'Photo': '\uE91B',
                'ActionCenter': '\uE91C',
                'Hospital': '\uE91D',
                'Timer': '\uE91E',
                'FullCircleMask': '\uE91F',
                'LocationFill': '\uE920',
                'ChromeMinimize': '\uE921',
                'ChromeRestore': '\uE923',
                'Annotation': '\uE924',
                'Fingerprint': '\uE928',
                'Handwriting': '\uE929',
                'ChromeFullScreen': '\uE92D',
                'Completed': '\uE930',
                'Label': '\uE932',
                'FlickDown': '\uE935',
                'FlickUp': '\uE936',
                'FlickLeft': '\uE937',
                'FlickRight': '\uE938',
                'MiniExpand': '\uE93A',
                'MiniContract': '\uE93B',
                'Streaming': '\uE93E',
                'MusicInCollection': '\uE940',
                'OneDriveLogo': '\uE941',
                'CompassNW': '\uE942',
                'Code': '\uE943',
                'LightningBolt': '\uE945',
                'CalculatorMultiply': '\uE947',
                'CalculatorAddition': '\uE948',
                'CalculatorSubtract': '\uE949',
                'CalculatorPercentage': '\uE94C',
                'CalculatorEqualTo': '\uE94E',
                'PrintfaxPrinterFile': '\uE956',
                'StorageOptical': '\uE958',
                'Communications': '\uE95A',
                'Headset': '\uE95B',
                'Health': '\uE95E',
                'Webcam2': '\uE960',
                'FrontCamera': '\uE96B',
                'ChevronUpSmall': '\uE96D'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$f(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-3\"",
                src: "url('" + baseUrl + "fabric-icons-3-089e217a.woff') format('woff')"
            },
            icons: {
                'ChevronDownSmall': '\uE96E',
                'ChevronLeftSmall': '\uE96F',
                'ChevronRightSmall': '\uE970',
                'ChevronUpMed': '\uE971',
                'ChevronDownMed': '\uE972',
                'ChevronLeftMed': '\uE973',
                'ChevronRightMed': '\uE974',
                'Devices2': '\uE975',
                'PC1': '\uE977',
                'PresenceChickletVideo': '\uE979',
                'Reply': '\uE97A',
                'HalfAlpha': '\uE97E',
                'ConstructionCone': '\uE98F',
                'DoubleChevronLeftMed': '\uE991',
                'Volume0': '\uE992',
                'Volume1': '\uE993',
                'Volume2': '\uE994',
                'Volume3': '\uE995',
                'Chart': '\uE999',
                'Robot': '\uE99A',
                'Manufacturing': '\uE99C',
                'LockSolid': '\uE9A2',
                'FitPage': '\uE9A6',
                'FitWidth': '\uE9A7',
                'BidiLtr': '\uE9AA',
                'BidiRtl': '\uE9AB',
                'RightDoubleQuote': '\uE9B1',
                'Sunny': '\uE9BD',
                'CloudWeather': '\uE9BE',
                'Cloudy': '\uE9BF',
                'PartlyCloudyDay': '\uE9C0',
                'PartlyCloudyNight': '\uE9C1',
                'ClearNight': '\uE9C2',
                'RainShowersDay': '\uE9C3',
                'Rain': '\uE9C4',
                'Thunderstorms': '\uE9C6',
                'RainSnow': '\uE9C7',
                'Snow': '\uE9C8',
                'BlowingSnow': '\uE9C9',
                'Frigid': '\uE9CA',
                'Fog': '\uE9CB',
                'Squalls': '\uE9CC',
                'Duststorm': '\uE9CD',
                'Unknown': '\uE9CE',
                'Precipitation': '\uE9CF',
                'Ribbon': '\uE9D1',
                'AreaChart': '\uE9D2',
                'Assign': '\uE9D3',
                'FlowChart': '\uE9D4',
                'CheckList': '\uE9D5',
                'Diagnostic': '\uE9D9',
                'Generate': '\uE9DA',
                'LineChart': '\uE9E6',
                'Equalizer': '\uE9E9',
                'BarChartHorizontal': '\uE9EB',
                'BarChartVertical': '\uE9EC',
                'Freezing': '\uE9EF',
                'FunnelChart': '\uE9F1',
                'Processing': '\uE9F5',
                'Quantity': '\uE9F8',
                'ReportDocument': '\uE9F9',
                'StackColumnChart': '\uE9FC',
                'SnowShowerDay': '\uE9FD',
                'HailDay': '\uEA00',
                'WorkFlow': '\uEA01',
                'HourGlass': '\uEA03',
                'StoreLogoMed20': '\uEA04',
                'TimeSheet': '\uEA05',
                'TriangleSolid': '\uEA08',
                'UpgradeAnalysis': '\uEA0B',
                'VideoSolid': '\uEA0C',
                'RainShowersNight': '\uEA0F',
                'SnowShowerNight': '\uEA11',
                'Teamwork': '\uEA12',
                'HailNight': '\uEA13',
                'PeopleAdd': '\uEA15',
                'Glasses': '\uEA16',
                'DateTime2': '\uEA17',
                'Shield': '\uEA18',
                'Header1': '\uEA19',
                'PageAdd': '\uEA1A',
                'NumberedList': '\uEA1C',
                'PowerBILogo': '\uEA1E',
                'Info2': '\uEA1F',
                'MusicInCollectionFill': '\uEA36',
                'Asterisk': '\uEA38',
                'ErrorBadge': '\uEA39',
                'CircleFill': '\uEA3B',
                'Record2': '\uEA3F',
                'AllAppsMirrored': '\uEA40',
                'BookmarksMirrored': '\uEA41',
                'BulletedListMirrored': '\uEA42',
                'CaretHollowMirrored': '\uEA45',
                'CaretSolidMirrored': '\uEA46',
                'ChromeBackMirrored': '\uEA47',
                'ClearSelectionMirrored': '\uEA48',
                'ClosePaneMirrored': '\uEA49',
                'DockLeftMirrored': '\uEA4C',
                'DoubleChevronLeftMedMirrored': '\uEA4D',
                'GoMirrored': '\uEA4F'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$e(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-4\"",
                src: "url('" + baseUrl + "fabric-icons-4-a656cc0a.woff') format('woff')"
            },
            icons: {
                'HelpMirrored': '\uEA51',
                'ImportMirrored': '\uEA52',
                'ImportAllMirrored': '\uEA53',
                'ListMirrored': '\uEA55',
                'MailForwardMirrored': '\uEA56',
                'MailReplyMirrored': '\uEA57',
                'MailReplyAllMirrored': '\uEA58',
                'MiniContractMirrored': '\uEA59',
                'MiniExpandMirrored': '\uEA5A',
                'OpenPaneMirrored': '\uEA5B',
                'ParkingLocationMirrored': '\uEA5E',
                'SendMirrored': '\uEA63',
                'ShowResultsMirrored': '\uEA65',
                'ThumbnailViewMirrored': '\uEA67',
                'Media': '\uEA69',
                'Devices3': '\uEA6C',
                'Focus': '\uEA6F',
                'VideoLightOff': '\uEA74',
                'Lightbulb': '\uEA80',
                'StatusTriangle': '\uEA82',
                'VolumeDisabled': '\uEA85',
                'Puzzle': '\uEA86',
                'EmojiNeutral': '\uEA87',
                'EmojiDisappointed': '\uEA88',
                'HomeSolid': '\uEA8A',
                'Ringer': '\uEA8F',
                'PDF': '\uEA90',
                'HeartBroken': '\uEA92',
                'StoreLogo16': '\uEA96',
                'MultiSelectMirrored': '\uEA98',
                'Broom': '\uEA99',
                'AddToShoppingList': '\uEA9A',
                'Cocktails': '\uEA9D',
                'Wines': '\uEABF',
                'Articles': '\uEAC1',
                'Cycling': '\uEAC7',
                'DietPlanNotebook': '\uEAC8',
                'Pill': '\uEACB',
                'ExerciseTracker': '\uEACC',
                'HandsFree': '\uEAD0',
                'Medical': '\uEAD4',
                'Running': '\uEADA',
                'Weights': '\uEADB',
                'Trackers': '\uEADF',
                'AddNotes': '\uEAE3',
                'AllCurrency': '\uEAE4',
                'BarChart4': '\uEAE7',
                'CirclePlus': '\uEAEE',
                'Coffee': '\uEAEF',
                'Cotton': '\uEAF3',
                'Market': '\uEAFC',
                'Money': '\uEAFD',
                'PieDouble': '\uEB04',
                'PieSingle': '\uEB05',
                'RemoveFilter': '\uEB08',
                'Savings': '\uEB0B',
                'Sell': '\uEB0C',
                'StockDown': '\uEB0F',
                'StockUp': '\uEB11',
                'Lamp': '\uEB19',
                'Source': '\uEB1B',
                'MSNVideos': '\uEB1C',
                'Cricket': '\uEB1E',
                'Golf': '\uEB1F',
                'Baseball': '\uEB20',
                'Soccer': '\uEB21',
                'MoreSports': '\uEB22',
                'AutoRacing': '\uEB24',
                'CollegeHoops': '\uEB25',
                'CollegeFootball': '\uEB26',
                'ProFootball': '\uEB27',
                'ProHockey': '\uEB28',
                'Rugby': '\uEB2D',
                'SubstitutionsIn': '\uEB31',
                'Tennis': '\uEB33',
                'Arrivals': '\uEB34',
                'Design': '\uEB3C',
                'Website': '\uEB41',
                'Drop': '\uEB42',
                'HistoricalWeather': '\uEB43',
                'SkiResorts': '\uEB45',
                'Snowflake': '\uEB46',
                'BusSolid': '\uEB47',
                'FerrySolid': '\uEB48',
                'AirplaneSolid': '\uEB4C',
                'TrainSolid': '\uEB4D',
                'Ticket': '\uEB54',
                'WifiWarning4': '\uEB63',
                'Devices4': '\uEB66',
                'AzureLogo': '\uEB6A',
                'BingLogo': '\uEB6B',
                'MSNLogo': '\uEB6C',
                'OutlookLogoInverse': '\uEB6D',
                'OfficeLogo': '\uEB6E',
                'SkypeLogo': '\uEB6F',
                'Door': '\uEB75',
                'EditMirrored': '\uEB7E',
                'GiftCard': '\uEB8E',
                'DoubleBookmark': '\uEB8F',
                'StatusErrorFull': '\uEB90'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$d(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-5\"",
                src: "url('" + baseUrl + "fabric-icons-5-f95ba260.woff') format('woff')"
            },
            icons: {
                'Certificate': '\uEB95',
                'FastForward': '\uEB9D',
                'Rewind': '\uEB9E',
                'Photo2': '\uEB9F',
                'OpenSource': '\uEBC2',
                'Movers': '\uEBCD',
                'CloudDownload': '\uEBD3',
                'Family': '\uEBDA',
                'WindDirection': '\uEBE6',
                'Bug': '\uEBE8',
                'SiteScan': '\uEBEC',
                'BrowserScreenShot': '\uEBED',
                'F12DevTools': '\uEBEE',
                'CSS': '\uEBEF',
                'JS': '\uEBF0',
                'DeliveryTruck': '\uEBF4',
                'ReminderPerson': '\uEBF7',
                'ReminderGroup': '\uEBF8',
                'ReminderTime': '\uEBF9',
                'TabletMode': '\uEBFC',
                'Umbrella': '\uEC04',
                'NetworkTower': '\uEC05',
                'CityNext': '\uEC06',
                'CityNext2': '\uEC07',
                'Section': '\uEC0C',
                'OneNoteLogoInverse': '\uEC0D',
                'ToggleFilled': '\uEC11',
                'ToggleBorder': '\uEC12',
                'SliderThumb': '\uEC13',
                'ToggleThumb': '\uEC14',
                'Documentation': '\uEC17',
                'Badge': '\uEC1B',
                'Giftbox': '\uEC1F',
                'VisualStudioLogo': '\uEC22',
                'HomeGroup': '\uEC26',
                'ExcelLogoInverse': '\uEC28',
                'WordLogoInverse': '\uEC29',
                'PowerPointLogoInverse': '\uEC2A',
                'Cafe': '\uEC32',
                'SpeedHigh': '\uEC4A',
                'Commitments': '\uEC4D',
                'ThisPC': '\uEC4E',
                'MusicNote': '\uEC4F',
                'MicOff': '\uEC54',
                'PlaybackRate1x': '\uEC57',
                'EdgeLogo': '\uEC60',
                'CompletedSolid': '\uEC61',
                'AlbumRemove': '\uEC62',
                'MessageFill': '\uEC70',
                'TabletSelected': '\uEC74',
                'MobileSelected': '\uEC75',
                'LaptopSelected': '\uEC76',
                'TVMonitorSelected': '\uEC77',
                'DeveloperTools': '\uEC7A',
                'Shapes': '\uEC7C',
                'InsertTextBox': '\uEC7D',
                'LowerBrightness': '\uEC8A',
                'WebComponents': '\uEC8B',
                'OfflineStorage': '\uEC8C',
                'DOM': '\uEC8D',
                'CloudUpload': '\uEC8E',
                'ScrollUpDown': '\uEC8F',
                'DateTime': '\uEC92',
                'Event': '\uECA3',
                'Cake': '\uECA4',
                'Org': '\uECA6',
                'PartyLeader': '\uECA7',
                'DRM': '\uECA8',
                'CloudAdd': '\uECA9',
                'AppIconDefault': '\uECAA',
                'Photo2Add': '\uECAB',
                'Photo2Remove': '\uECAC',
                'Calories': '\uECAD',
                'POI': '\uECAF',
                'AddTo': '\uECC8',
                'RadioBtnOff': '\uECCA',
                'RadioBtnOn': '\uECCB',
                'ExploreContent': '\uECCD',
                'Product': '\uECDC',
                'ProgressLoopInner': '\uECDE',
                'ProgressLoopOuter': '\uECDF',
                'Blocked2': '\uECE4',
                'FangBody': '\uECEB',
                'Toolbox': '\uECED',
                'PageHeader': '\uECEE',
                'ChatInviteFriend': '\uECFE',
                'Brush': '\uECFF',
                'Shirt': '\uED00',
                'Crown': '\uED01',
                'Diamond': '\uED02',
                'ScaleUp': '\uED09',
                'QRCode': '\uED14',
                'Feedback': '\uED15',
                'SharepointLogoInverse': '\uED18',
                'YammerLogo': '\uED19',
                'Hide': '\uED1A',
                'Uneditable': '\uED1D',
                'ReturnToSession': '\uED24',
                'OpenFolderHorizontal': '\uED25',
                'CalendarMirrored': '\uED28'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$c(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-6\"",
                src: "url('" + baseUrl + "fabric-icons-6-ef6fd590.woff') format('woff')"
            },
            icons: {
                'SwayLogoInverse': '\uED29',
                'OutOfOffice': '\uED34',
                'Trophy': '\uED3F',
                'ReopenPages': '\uED50',
                'EmojiTabSymbols': '\uED58',
                'AADLogo': '\uED68',
                'AccessLogo': '\uED69',
                'AdminALogoInverse32': '\uED6A',
                'AdminCLogoInverse32': '\uED6B',
                'AdminDLogoInverse32': '\uED6C',
                'AdminELogoInverse32': '\uED6D',
                'AdminLLogoInverse32': '\uED6E',
                'AdminMLogoInverse32': '\uED6F',
                'AdminOLogoInverse32': '\uED70',
                'AdminPLogoInverse32': '\uED71',
                'AdminSLogoInverse32': '\uED72',
                'AdminYLogoInverse32': '\uED73',
                'DelveLogoInverse': '\uED76',
                'ExchangeLogoInverse': '\uED78',
                'LyncLogo': '\uED79',
                'OfficeVideoLogoInverse': '\uED7A',
                'SocialListeningLogo': '\uED7C',
                'VisioLogoInverse': '\uED7D',
                'Balloons': '\uED7E',
                'Cat': '\uED7F',
                'MailAlert': '\uED80',
                'MailCheck': '\uED81',
                'MailLowImportance': '\uED82',
                'MailPause': '\uED83',
                'MailRepeat': '\uED84',
                'SecurityGroup': '\uED85',
                'Table': '\uED86',
                'VoicemailForward': '\uED87',
                'VoicemailReply': '\uED88',
                'Waffle': '\uED89',
                'RemoveEvent': '\uED8A',
                'EventInfo': '\uED8B',
                'ForwardEvent': '\uED8C',
                'WipePhone': '\uED8D',
                'AddOnlineMeeting': '\uED8E',
                'JoinOnlineMeeting': '\uED8F',
                'RemoveLink': '\uED90',
                'PeopleBlock': '\uED91',
                'PeopleRepeat': '\uED92',
                'PeopleAlert': '\uED93',
                'PeoplePause': '\uED94',
                'TransferCall': '\uED95',
                'AddPhone': '\uED96',
                'UnknownCall': '\uED97',
                'NoteReply': '\uED98',
                'NoteForward': '\uED99',
                'NotePinned': '\uED9A',
                'RemoveOccurrence': '\uED9B',
                'Timeline': '\uED9C',
                'EditNote': '\uED9D',
                'CircleHalfFull': '\uED9E',
                'Room': '\uED9F',
                'Unsubscribe': '\uEDA0',
                'Subscribe': '\uEDA1',
                'HardDrive': '\uEDA2',
                'RecurringTask': '\uEDB2',
                'TaskManager': '\uEDB7',
                'TaskManagerMirrored': '\uEDB8',
                'Combine': '\uEDBB',
                'Split': '\uEDBC',
                'DoubleChevronUp': '\uEDBD',
                'DoubleChevronLeft': '\uEDBE',
                'DoubleChevronRight': '\uEDBF',
                'TextBox': '\uEDC2',
                'TextField': '\uEDC3',
                'NumberField': '\uEDC4',
                'Dropdown': '\uEDC5',
                'PenWorkspace': '\uEDC6',
                'BookingsLogo': '\uEDC7',
                'ClassNotebookLogoInverse': '\uEDC8',
                'DelveAnalyticsLogo': '\uEDCA',
                'DocsLogoInverse': '\uEDCB',
                'Dynamics365Logo': '\uEDCC',
                'DynamicSMBLogo': '\uEDCD',
                'OfficeAssistantLogo': '\uEDCE',
                'OfficeStoreLogo': '\uEDCF',
                'OneNoteEduLogoInverse': '\uEDD0',
                'PlannerLogo': '\uEDD1',
                'PowerApps': '\uEDD2',
                'Suitcase': '\uEDD3',
                'ProjectLogoInverse': '\uEDD4',
                'CaretLeft8': '\uEDD5',
                'CaretRight8': '\uEDD6',
                'CaretUp8': '\uEDD7',
                'CaretDown8': '\uEDD8',
                'CaretLeftSolid8': '\uEDD9',
                'CaretRightSolid8': '\uEDDA',
                'CaretUpSolid8': '\uEDDB',
                'CaretDownSolid8': '\uEDDC',
                'ClearFormatting': '\uEDDD',
                'Superscript': '\uEDDE',
                'Subscript': '\uEDDF',
                'Strikethrough': '\uEDE0',
                'Export': '\uEDE1',
                'ExportMirrored': '\uEDE2'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$b(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-7\"",
                src: "url('" + baseUrl + "fabric-icons-7-2b97bb99.woff') format('woff')"
            },
            icons: {
                'SingleBookmark': '\uEDFF',
                'SingleBookmarkSolid': '\uEE00',
                'DoubleChevronDown': '\uEE04',
                'FollowUser': '\uEE05',
                'ReplyAll': '\uEE0A',
                'WorkforceManagement': '\uEE0F',
                'RecruitmentManagement': '\uEE12',
                'Questionnaire': '\uEE19',
                'ManagerSelfService': '\uEE23',
                'ProductionFloorManagement': '\uEE29',
                'ProductRelease': '\uEE2E',
                'ProductVariant': '\uEE30',
                'ReplyMirrored': '\uEE35',
                'ReplyAllMirrored': '\uEE36',
                'Medal': '\uEE38',
                'AddGroup': '\uEE3D',
                'QuestionnaireMirrored': '\uEE4B',
                'CloudImportExport': '\uEE55',
                'TemporaryUser': '\uEE58',
                'CaretSolid16': '\uEE62',
                'GroupedDescending': '\uEE66',
                'GroupedAscending': '\uEE67',
                'AwayStatus': '\uEE6A',
                'MyMoviesTV': '\uEE6C',
                'GenericScan': '\uEE6F',
                'AustralianRules': '\uEE70',
                'WifiEthernet': '\uEE77',
                'TrackersMirrored': '\uEE92',
                'DateTimeMirrored': '\uEE93',
                'StopSolid': '\uEE95',
                'DoubleChevronUp12': '\uEE96',
                'DoubleChevronDown12': '\uEE97',
                'DoubleChevronLeft12': '\uEE98',
                'DoubleChevronRight12': '\uEE99',
                'CalendarAgenda': '\uEE9A',
                'ConnectVirtualMachine': '\uEE9D',
                'AddEvent': '\uEEB5',
                'AssetLibrary': '\uEEB6',
                'DataConnectionLibrary': '\uEEB7',
                'DocLibrary': '\uEEB8',
                'FormLibrary': '\uEEB9',
                'FormLibraryMirrored': '\uEEBA',
                'ReportLibrary': '\uEEBB',
                'ReportLibraryMirrored': '\uEEBC',
                'ContactCard': '\uEEBD',
                'CustomList': '\uEEBE',
                'CustomListMirrored': '\uEEBF',
                'IssueTracking': '\uEEC0',
                'IssueTrackingMirrored': '\uEEC1',
                'PictureLibrary': '\uEEC2',
                'OfficeAddinsLogo': '\uEEC7',
                'OfflineOneDriveParachute': '\uEEC8',
                'OfflineOneDriveParachuteDisabled': '\uEEC9',
                'TriangleSolidUp12': '\uEECC',
                'TriangleSolidDown12': '\uEECD',
                'TriangleSolidLeft12': '\uEECE',
                'TriangleSolidRight12': '\uEECF',
                'TriangleUp12': '\uEED0',
                'TriangleDown12': '\uEED1',
                'TriangleLeft12': '\uEED2',
                'TriangleRight12': '\uEED3',
                'ArrowUpRight8': '\uEED4',
                'ArrowDownRight8': '\uEED5',
                'DocumentSet': '\uEED6',
                'GoToDashboard': '\uEEED',
                'DelveAnalytics': '\uEEEE',
                'ArrowUpRightMirrored8': '\uEEEF',
                'ArrowDownRightMirrored8': '\uEEF0',
                'CompanyDirectory': '\uEF0D',
                'OpenEnrollment': '\uEF1C',
                'CompanyDirectoryMirrored': '\uEF2B',
                'OneDriveAdd': '\uEF32',
                'ProfileSearch': '\uEF35',
                'Header2': '\uEF36',
                'Header3': '\uEF37',
                'Header4': '\uEF38',
                'RingerSolid': '\uEF3A',
                'Eyedropper': '\uEF3C',
                'MarketDown': '\uEF42',
                'CalendarWorkWeek': '\uEF51',
                'SidePanel': '\uEF52',
                'GlobeFavorite': '\uEF53',
                'CaretTopLeftSolid8': '\uEF54',
                'CaretTopRightSolid8': '\uEF55',
                'ViewAll2': '\uEF56',
                'DocumentReply': '\uEF57',
                'PlayerSettings': '\uEF58',
                'ReceiptForward': '\uEF59',
                'ReceiptReply': '\uEF5A',
                'ReceiptCheck': '\uEF5B',
                'Fax': '\uEF5C',
                'RecurringEvent': '\uEF5D',
                'ReplyAlt': '\uEF5E',
                'ReplyAllAlt': '\uEF5F',
                'EditStyle': '\uEF60',
                'EditMail': '\uEF61',
                'Lifesaver': '\uEF62',
                'LifesaverLock': '\uEF63',
                'InboxCheck': '\uEF64',
                'FolderSearch': '\uEF65'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$a(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-8\"",
                src: "url('" + baseUrl + "fabric-icons-8-6fdf1528.woff') format('woff')"
            },
            icons: {
                'CollapseMenu': '\uEF66',
                'ExpandMenu': '\uEF67',
                'Boards': '\uEF68',
                'SunAdd': '\uEF69',
                'SunQuestionMark': '\uEF6A',
                'LandscapeOrientation': '\uEF6B',
                'DocumentSearch': '\uEF6C',
                'PublicCalendar': '\uEF6D',
                'PublicContactCard': '\uEF6E',
                'PublicEmail': '\uEF6F',
                'PublicFolder': '\uEF70',
                'WordDocument': '\uEF71',
                'PowerPointDocument': '\uEF72',
                'ExcelDocument': '\uEF73',
                'GroupedList': '\uEF74',
                'ClassroomLogo': '\uEF75',
                'Sections': '\uEF76',
                'EditPhoto': '\uEF77',
                'Starburst': '\uEF78',
                'ShareiOS': '\uEF79',
                'AirTickets': '\uEF7A',
                'PencilReply': '\uEF7B',
                'Tiles2': '\uEF7C',
                'SkypeCircleCheck': '\uEF7D',
                'SkypeCircleClock': '\uEF7E',
                'SkypeCircleMinus': '\uEF7F',
                'SkypeMessage': '\uEF83',
                'ClosedCaption': '\uEF84',
                'ATPLogo': '\uEF85',
                'OfficeFormsLogoInverse': '\uEF86',
                'RecycleBin': '\uEF87',
                'EmptyRecycleBin': '\uEF88',
                'Hide2': '\uEF89',
                'Breadcrumb': '\uEF8C',
                'BirthdayCake': '\uEF8D',
                'TimeEntry': '\uEF95',
                'CRMProcesses': '\uEFB1',
                'PageEdit': '\uEFB6',
                'PageArrowRight': '\uEFB8',
                'PageRemove': '\uEFBA',
                'Database': '\uEFC7',
                'DataManagementSettings': '\uEFC8',
                'CRMServices': '\uEFD2',
                'EditContact': '\uEFD3',
                'ConnectContacts': '\uEFD4',
                'AppIconDefaultAdd': '\uEFDA',
                'AppIconDefaultList': '\uEFDE',
                'ActivateOrders': '\uEFE0',
                'DeactivateOrders': '\uEFE1',
                'ProductCatalog': '\uEFE8',
                'ScatterChart': '\uEFEB',
                'AccountActivity': '\uEFF4',
                'DocumentManagement': '\uEFFC',
                'CRMReport': '\uEFFE',
                'KnowledgeArticle': '\uF000',
                'Relationship': '\uF003',
                'HomeVerify': '\uF00E',
                'ZipFolder': '\uF012',
                'SurveyQuestions': '\uF01B',
                'TextDocument': '\uF029',
                'TextDocumentShared': '\uF02B',
                'PageCheckedOut': '\uF02C',
                'PageShared': '\uF02D',
                'SaveAndClose': '\uF038',
                'Script': '\uF03A',
                'Archive': '\uF03F',
                'ActivityFeed': '\uF056',
                'Compare': '\uF057',
                'EventDate': '\uF059',
                'ArrowUpRight': '\uF069',
                'CaretRight': '\uF06B',
                'SetAction': '\uF071',
                'ChatBot': '\uF08B',
                'CaretSolidLeft': '\uF08D',
                'CaretSolidDown': '\uF08E',
                'CaretSolidRight': '\uF08F',
                'CaretSolidUp': '\uF090',
                'PowerAppsLogo': '\uF091',
                'PowerApps2Logo': '\uF092',
                'SearchIssue': '\uF09A',
                'SearchIssueMirrored': '\uF09B',
                'FabricAssetLibrary': '\uF09C',
                'FabricDataConnectionLibrary': '\uF09D',
                'FabricDocLibrary': '\uF09E',
                'FabricFormLibrary': '\uF09F',
                'FabricFormLibraryMirrored': '\uF0A0',
                'FabricReportLibrary': '\uF0A1',
                'FabricReportLibraryMirrored': '\uF0A2',
                'FabricPublicFolder': '\uF0A3',
                'FabricFolderSearch': '\uF0A4',
                'FabricMovetoFolder': '\uF0A5',
                'FabricUnsyncFolder': '\uF0A6',
                'FabricSyncFolder': '\uF0A7',
                'FabricOpenFolderHorizontal': '\uF0A8',
                'FabricFolder': '\uF0A9',
                'FabricFolderFill': '\uF0AA',
                'FabricNewFolder': '\uF0AB',
                'FabricPictureLibrary': '\uF0AC',
                'PhotoVideoMedia': '\uF0B1',
                'AddFavorite': '\uF0C8'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$9(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-9\"",
                src: "url('" + baseUrl + "fabric-icons-9-c6162b42.woff') format('woff')"
            },
            icons: {
                'AddFavoriteFill': '\uF0C9',
                'BufferTimeBefore': '\uF0CF',
                'BufferTimeAfter': '\uF0D0',
                'BufferTimeBoth': '\uF0D1',
                'PublishContent': '\uF0D4',
                'ClipboardList': '\uF0E3',
                'ClipboardListMirrored': '\uF0E4',
                'CannedChat': '\uF0F2',
                'SkypeForBusinessLogo': '\uF0FC',
                'TabCenter': '\uF100',
                'PageCheckedin': '\uF104',
                'PageList': '\uF106',
                'ReadOutLoud': '\uF112',
                'CaretBottomLeftSolid8': '\uF121',
                'CaretBottomRightSolid8': '\uF122',
                'FolderHorizontal': '\uF12B',
                'MicrosoftStaffhubLogo': '\uF130',
                'GiftboxOpen': '\uF133',
                'StatusCircleOuter': '\uF136',
                'StatusCircleInner': '\uF137',
                'StatusCircleRing': '\uF138',
                'StatusTriangleOuter': '\uF139',
                'StatusTriangleInner': '\uF13A',
                'StatusTriangleExclamation': '\uF13B',
                'StatusCircleExclamation': '\uF13C',
                'StatusCircleErrorX': '\uF13D',
                'StatusCircleInfo': '\uF13F',
                'StatusCircleBlock': '\uF140',
                'StatusCircleBlock2': '\uF141',
                'StatusCircleQuestionMark': '\uF142',
                'StatusCircleSync': '\uF143',
                'Toll': '\uF160',
                'ExploreContentSingle': '\uF164',
                'CollapseContent': '\uF165',
                'CollapseContentSingle': '\uF166',
                'InfoSolid': '\uF167',
                'GroupList': '\uF168',
                'ProgressRingDots': '\uF16A',
                'CaloriesAdd': '\uF172',
                'BranchFork': '\uF173',
                'MuteChat': '\uF17A',
                'AddHome': '\uF17B',
                'AddWork': '\uF17C',
                'MobileReport': '\uF18A',
                'ScaleVolume': '\uF18C',
                'HardDriveGroup': '\uF18F',
                'FastMode': '\uF19A',
                'ToggleLeft': '\uF19E',
                'ToggleRight': '\uF19F',
                'TriangleShape': '\uF1A7',
                'RectangleShape': '\uF1A9',
                'CubeShape': '\uF1AA',
                'Trophy2': '\uF1AE',
                'BucketColor': '\uF1B6',
                'BucketColorFill': '\uF1B7',
                'Taskboard': '\uF1C2',
                'SingleColumn': '\uF1D3',
                'DoubleColumn': '\uF1D4',
                'TripleColumn': '\uF1D5',
                'ColumnLeftTwoThirds': '\uF1D6',
                'ColumnRightTwoThirds': '\uF1D7',
                'AccessLogoFill': '\uF1DB',
                'AnalyticsLogo': '\uF1DE',
                'AnalyticsQuery': '\uF1DF',
                'NewAnalyticsQuery': '\uF1E0',
                'AnalyticsReport': '\uF1E1',
                'WordLogo': '\uF1E3',
                'WordLogoFill': '\uF1E4',
                'ExcelLogo': '\uF1E5',
                'ExcelLogoFill': '\uF1E6',
                'OneNoteLogo': '\uF1E7',
                'OneNoteLogoFill': '\uF1E8',
                'OutlookLogo': '\uF1E9',
                'OutlookLogoFill': '\uF1EA',
                'PowerPointLogo': '\uF1EB',
                'PowerPointLogoFill': '\uF1EC',
                'PublisherLogo': '\uF1ED',
                'PublisherLogoFill': '\uF1EE',
                'ScheduleEventAction': '\uF1EF',
                'FlameSolid': '\uF1F3',
                'ServerProcesses': '\uF1FE',
                'Server': '\uF201',
                'SaveAll': '\uF203',
                'LinkedInLogo': '\uF20A',
                'Decimals': '\uF218',
                'SidePanelMirrored': '\uF221',
                'ProtectRestrict': '\uF22A',
                'Blog': '\uF22B',
                'UnknownMirrored': '\uF22E',
                'PublicContactCardMirrored': '\uF230',
                'GridViewSmall': '\uF232',
                'GridViewMedium': '\uF233',
                'GridViewLarge': '\uF234',
                'Step': '\uF241',
                'StepInsert': '\uF242',
                'StepShared': '\uF243',
                'StepSharedAdd': '\uF244',
                'StepSharedInsert': '\uF245',
                'ViewDashboard': '\uF246',
                'ViewList': '\uF247'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$8(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-10\"",
                src: "url('" + baseUrl + "fabric-icons-10-c4ded8e4.woff') format('woff')"
            },
            icons: {
                'ViewListGroup': '\uF248',
                'ViewListTree': '\uF249',
                'TriggerAuto': '\uF24A',
                'TriggerUser': '\uF24B',
                'PivotChart': '\uF24C',
                'StackedBarChart': '\uF24D',
                'StackedLineChart': '\uF24E',
                'BuildQueue': '\uF24F',
                'BuildQueueNew': '\uF250',
                'UserFollowed': '\uF25C',
                'ContactLink': '\uF25F',
                'Stack': '\uF26F',
                'Bullseye': '\uF272',
                'VennDiagram': '\uF273',
                'FiveTileGrid': '\uF274',
                'FocalPoint': '\uF277',
                'Insert': '\uF278',
                'RingerRemove': '\uF279',
                'TeamsLogoInverse': '\uF27A',
                'TeamsLogo': '\uF27B',
                'TeamsLogoFill': '\uF27C',
                'SkypeForBusinessLogoFill': '\uF27D',
                'SharepointLogo': '\uF27E',
                'SharepointLogoFill': '\uF27F',
                'DelveLogo': '\uF280',
                'DelveLogoFill': '\uF281',
                'OfficeVideoLogo': '\uF282',
                'OfficeVideoLogoFill': '\uF283',
                'ExchangeLogo': '\uF284',
                'ExchangeLogoFill': '\uF285',
                'Signin': '\uF286',
                'DocumentApproval': '\uF28B',
                'CloneToDesktop': '\uF28C',
                'InstallToDrive': '\uF28D',
                'Blur': '\uF28E',
                'Build': '\uF28F',
                'ProcessMetaTask': '\uF290',
                'BranchFork2': '\uF291',
                'BranchLocked': '\uF292',
                'BranchCommit': '\uF293',
                'BranchCompare': '\uF294',
                'BranchMerge': '\uF295',
                'BranchPullRequest': '\uF296',
                'BranchSearch': '\uF297',
                'BranchShelveset': '\uF298',
                'RawSource': '\uF299',
                'MergeDuplicate': '\uF29A',
                'RowsGroup': '\uF29B',
                'RowsChild': '\uF29C',
                'Deploy': '\uF29D',
                'Redeploy': '\uF29E',
                'ServerEnviroment': '\uF29F',
                'VisioDiagram': '\uF2A0',
                'HighlightMappedShapes': '\uF2A1',
                'TextCallout': '\uF2A2',
                'IconSetsFlag': '\uF2A4',
                'VisioLogo': '\uF2A7',
                'VisioLogoFill': '\uF2A8',
                'VisioDocument': '\uF2A9',
                'TimelineProgress': '\uF2AA',
                'TimelineDelivery': '\uF2AB',
                'Backlog': '\uF2AC',
                'TeamFavorite': '\uF2AD',
                'TaskGroup': '\uF2AE',
                'TaskGroupMirrored': '\uF2AF',
                'ScopeTemplate': '\uF2B0',
                'AssessmentGroupTemplate': '\uF2B1',
                'NewTeamProject': '\uF2B2',
                'CommentAdd': '\uF2B3',
                'CommentNext': '\uF2B4',
                'CommentPrevious': '\uF2B5',
                'ShopServer': '\uF2B6',
                'LocaleLanguage': '\uF2B7',
                'QueryList': '\uF2B8',
                'UserSync': '\uF2B9',
                'UserPause': '\uF2BA',
                'StreamingOff': '\uF2BB',
                'ArrowTallUpLeft': '\uF2BD',
                'ArrowTallUpRight': '\uF2BE',
                'ArrowTallDownLeft': '\uF2BF',
                'ArrowTallDownRight': '\uF2C0',
                'FieldEmpty': '\uF2C1',
                'FieldFilled': '\uF2C2',
                'FieldChanged': '\uF2C3',
                'FieldNotChanged': '\uF2C4',
                'RingerOff': '\uF2C5',
                'PlayResume': '\uF2C6',
                'BulletedList2': '\uF2C7',
                'BulletedList2Mirrored': '\uF2C8',
                'ImageCrosshair': '\uF2C9',
                'GitGraph': '\uF2CA',
                'Repo': '\uF2CB',
                'RepoSolid': '\uF2CC',
                'FolderQuery': '\uF2CD',
                'FolderList': '\uF2CE',
                'FolderListMirrored': '\uF2CF',
                'LocationOutline': '\uF2D0',
                'POISolid': '\uF2D1',
                'CalculatorNotEqualTo': '\uF2D2',
                'BoxSubtractSolid': '\uF2D3'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$7(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-11\"",
                src: "url('" + baseUrl + "fabric-icons-11-2a8393d6.woff') format('woff')"
            },
            icons: {
                'BoxAdditionSolid': '\uF2D4',
                'BoxMultiplySolid': '\uF2D5',
                'BoxPlaySolid': '\uF2D6',
                'BoxCheckmarkSolid': '\uF2D7',
                'CirclePauseSolid': '\uF2D8',
                'CirclePause': '\uF2D9',
                'MSNVideosSolid': '\uF2DA',
                'CircleStopSolid': '\uF2DB',
                'CircleStop': '\uF2DC',
                'NavigateBack': '\uF2DD',
                'NavigateBackMirrored': '\uF2DE',
                'NavigateForward': '\uF2DF',
                'NavigateForwardMirrored': '\uF2E0',
                'UnknownSolid': '\uF2E1',
                'UnknownMirroredSolid': '\uF2E2',
                'CircleAddition': '\uF2E3',
                'CircleAdditionSolid': '\uF2E4',
                'FilePDB': '\uF2E5',
                'FileTemplate': '\uF2E6',
                'FileSQL': '\uF2E7',
                'FileJAVA': '\uF2E8',
                'FileASPX': '\uF2E9',
                'FileCSS': '\uF2EA',
                'FileSass': '\uF2EB',
                'FileLess': '\uF2EC',
                'FileHTML': '\uF2ED',
                'JavaScriptLanguage': '\uF2EE',
                'CSharpLanguage': '\uF2EF',
                'CSharp': '\uF2F0',
                'VisualBasicLanguage': '\uF2F1',
                'VB': '\uF2F2',
                'CPlusPlusLanguage': '\uF2F3',
                'CPlusPlus': '\uF2F4',
                'FSharpLanguage': '\uF2F5',
                'FSharp': '\uF2F6',
                'TypeScriptLanguage': '\uF2F7',
                'PythonLanguage': '\uF2F8',
                'PY': '\uF2F9',
                'CoffeeScript': '\uF2FA',
                'MarkDownLanguage': '\uF2FB',
                'FullWidth': '\uF2FE',
                'FullWidthEdit': '\uF2FF',
                'Plug': '\uF300',
                'PlugSolid': '\uF301',
                'PlugConnected': '\uF302',
                'PlugDisconnected': '\uF303',
                'UnlockSolid': '\uF304',
                'Variable': '\uF305',
                'Parameter': '\uF306',
                'CommentUrgent': '\uF307',
                'Storyboard': '\uF308',
                'DiffInline': '\uF309',
                'DiffSideBySide': '\uF30A',
                'ImageDiff': '\uF30B',
                'ImagePixel': '\uF30C',
                'FileBug': '\uF30D',
                'FileCode': '\uF30E',
                'FileComment': '\uF30F',
                'BusinessHoursSign': '\uF310',
                'FileImage': '\uF311',
                'FileSymlink': '\uF312',
                'AutoFillTemplate': '\uF313',
                'WorkItem': '\uF314',
                'WorkItemBug': '\uF315',
                'LogRemove': '\uF316',
                'ColumnOptions': '\uF317',
                'Packages': '\uF318',
                'BuildIssue': '\uF319',
                'AssessmentGroup': '\uF31A',
                'VariableGroup': '\uF31B',
                'FullHistory': '\uF31C',
                'Wheelchair': '\uF31F',
                'SingleColumnEdit': '\uF321',
                'DoubleColumnEdit': '\uF322',
                'TripleColumnEdit': '\uF323',
                'ColumnLeftTwoThirdsEdit': '\uF324',
                'ColumnRightTwoThirdsEdit': '\uF325',
                'StreamLogo': '\uF329',
                'PassiveAuthentication': '\uF32A',
                'AlertSolid': '\uF331',
                'MegaphoneSolid': '\uF332',
                'TaskSolid': '\uF333',
                'ConfigurationSolid': '\uF334',
                'BugSolid': '\uF335',
                'CrownSolid': '\uF336',
                'Trophy2Solid': '\uF337',
                'QuickNoteSolid': '\uF338',
                'ConstructionConeSolid': '\uF339',
                'PageListSolid': '\uF33A',
                'PageListMirroredSolid': '\uF33B',
                'StarburstSolid': '\uF33C',
                'ReadingModeSolid': '\uF33D',
                'SadSolid': '\uF33E',
                'HealthSolid': '\uF33F',
                'ShieldSolid': '\uF340',
                'GiftBoxSolid': '\uF341',
                'ShoppingCartSolid': '\uF342',
                'MailSolid': '\uF343',
                'ChatSolid': '\uF344',
                'RibbonSolid': '\uF345'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$6(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-12\"",
                src: "url('" + baseUrl + "fabric-icons-12-7e945a1e.woff') format('woff')"
            },
            icons: {
                'FinancialSolid': '\uF346',
                'FinancialMirroredSolid': '\uF347',
                'HeadsetSolid': '\uF348',
                'PermissionsSolid': '\uF349',
                'ParkingSolid': '\uF34A',
                'ParkingMirroredSolid': '\uF34B',
                'DiamondSolid': '\uF34C',
                'AsteriskSolid': '\uF34D',
                'OfflineStorageSolid': '\uF34E',
                'BankSolid': '\uF34F',
                'DecisionSolid': '\uF350',
                'Parachute': '\uF351',
                'ParachuteSolid': '\uF352',
                'FiltersSolid': '\uF353',
                'ColorSolid': '\uF354',
                'ReviewSolid': '\uF355',
                'ReviewRequestSolid': '\uF356',
                'ReviewRequestMirroredSolid': '\uF357',
                'ReviewResponseSolid': '\uF358',
                'FeedbackRequestSolid': '\uF359',
                'FeedbackRequestMirroredSolid': '\uF35A',
                'FeedbackResponseSolid': '\uF35B',
                'WorkItemBar': '\uF35C',
                'WorkItemBarSolid': '\uF35D',
                'Separator': '\uF35E',
                'NavigateExternalInline': '\uF35F',
                'PlanView': '\uF360',
                'TimelineMatrixView': '\uF361',
                'EngineeringGroup': '\uF362',
                'ProjectCollection': '\uF363',
                'CaretBottomRightCenter8': '\uF364',
                'CaretBottomLeftCenter8': '\uF365',
                'CaretTopRightCenter8': '\uF366',
                'CaretTopLeftCenter8': '\uF367',
                'DonutChart': '\uF368',
                'ChevronUnfold10': '\uF369',
                'ChevronFold10': '\uF36A',
                'DoubleChevronDown8': '\uF36B',
                'DoubleChevronUp8': '\uF36C',
                'DoubleChevronLeft8': '\uF36D',
                'DoubleChevronRight8': '\uF36E',
                'ChevronDownEnd6': '\uF36F',
                'ChevronUpEnd6': '\uF370',
                'ChevronLeftEnd6': '\uF371',
                'ChevronRightEnd6': '\uF372',
                'ContextMenu': '\uF37C',
                'AzureAPIManagement': '\uF37F',
                'AzureServiceEndpoint': '\uF380',
                'VSTSLogo': '\uF381',
                'VSTSAltLogo1': '\uF382',
                'VSTSAltLogo2': '\uF383',
                'FileTypeSolution': '\uF387',
                'WordLogoInverse16': '\uF390',
                'WordLogo16': '\uF391',
                'WordLogoFill16': '\uF392',
                'PowerPointLogoInverse16': '\uF393',
                'PowerPointLogo16': '\uF394',
                'PowerPointLogoFill16': '\uF395',
                'ExcelLogoInverse16': '\uF396',
                'ExcelLogo16': '\uF397',
                'ExcelLogoFill16': '\uF398',
                'OneNoteLogoInverse16': '\uF399',
                'OneNoteLogo16': '\uF39A',
                'OneNoteLogoFill16': '\uF39B',
                'OutlookLogoInverse16': '\uF39C',
                'OutlookLogo16': '\uF39D',
                'OutlookLogoFill16': '\uF39E',
                'PublisherLogoInverse16': '\uF39F',
                'PublisherLogo16': '\uF3A0',
                'PublisherLogoFill16': '\uF3A1',
                'VisioLogoInverse16': '\uF3A2',
                'VisioLogo16': '\uF3A3',
                'VisioLogoFill16': '\uF3A4',
                'TestBeaker': '\uF3A5',
                'TestBeakerSolid': '\uF3A6',
                'TestExploreSolid': '\uF3A7',
                'TestAutoSolid': '\uF3A8',
                'TestUserSolid': '\uF3A9',
                'TestImpactSolid': '\uF3AA',
                'TestPlan': '\uF3AB',
                'TestStep': '\uF3AC',
                'TestParameter': '\uF3AD',
                'TestSuite': '\uF3AE',
                'TestCase': '\uF3AF',
                'Sprint': '\uF3B0',
                'SignOut': '\uF3B1',
                'TriggerApproval': '\uF3B2',
                'Rocket': '\uF3B3',
                'AzureKeyVault': '\uF3B4',
                'Onboarding': '\uF3BA',
                'Transition': '\uF3BC',
                'LikeSolid': '\uF3BF',
                'DislikeSolid': '\uF3C0',
                'CRMCustomerInsightsApp': '\uF3C8',
                'EditCreate': '\uF3C9',
                'PlayReverseResume': '\uF3E4',
                'PlayReverse': '\uF3E5',
                'SearchData': '\uF3F1',
                'UnSetColor': '\uF3F9',
                'DeclineCall': '\uF405'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$5(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-13\"",
                src: "url('" + baseUrl + "fabric-icons-13-c3989a02.woff') format('woff')"
            },
            icons: {
                'RectangularClipping': '\uF407',
                'TeamsLogo16': '\uF40A',
                'TeamsLogoFill16': '\uF40B',
                'Spacer': '\uF40D',
                'SkypeLogo16': '\uF40E',
                'SkypeForBusinessLogo16': '\uF40F',
                'SkypeForBusinessLogoFill16': '\uF410',
                'FilterSolid': '\uF412',
                'MailUndelivered': '\uF415',
                'MailTentative': '\uF416',
                'MailTentativeMirrored': '\uF417',
                'MailReminder': '\uF418',
                'ReceiptUndelivered': '\uF419',
                'ReceiptTentative': '\uF41A',
                'ReceiptTentativeMirrored': '\uF41B',
                'Inbox': '\uF41C',
                'IRMReply': '\uF41D',
                'IRMReplyMirrored': '\uF41E',
                'IRMForward': '\uF41F',
                'IRMForwardMirrored': '\uF420',
                'VoicemailIRM': '\uF421',
                'EventAccepted': '\uF422',
                'EventTentative': '\uF423',
                'EventTentativeMirrored': '\uF424',
                'EventDeclined': '\uF425',
                'IDBadge': '\uF427',
                'BackgroundColor': '\uF42B',
                'OfficeFormsLogoInverse16': '\uF433',
                'OfficeFormsLogo': '\uF434',
                'OfficeFormsLogoFill': '\uF435',
                'OfficeFormsLogo16': '\uF436',
                'OfficeFormsLogoFill16': '\uF437',
                'OfficeFormsLogoInverse24': '\uF43A',
                'OfficeFormsLogo24': '\uF43B',
                'OfficeFormsLogoFill24': '\uF43C',
                'PageLock': '\uF43F',
                'NotExecuted': '\uF440',
                'NotImpactedSolid': '\uF441',
                'FieldReadOnly': '\uF442',
                'FieldRequired': '\uF443',
                'BacklogBoard': '\uF444',
                'ExternalBuild': '\uF445',
                'ExternalTFVC': '\uF446',
                'ExternalXAML': '\uF447',
                'IssueSolid': '\uF448',
                'DefectSolid': '\uF449',
                'LadybugSolid': '\uF44A',
                'NugetLogo': '\uF44C',
                'TFVCLogo': '\uF44D',
                'ProjectLogo32': '\uF47E',
                'ProjectLogoFill32': '\uF47F',
                'ProjectLogo16': '\uF480',
                'ProjectLogoFill16': '\uF481',
                'SwayLogo32': '\uF482',
                'SwayLogoFill32': '\uF483',
                'SwayLogo16': '\uF484',
                'SwayLogoFill16': '\uF485',
                'ClassNotebookLogo32': '\uF486',
                'ClassNotebookLogoFill32': '\uF487',
                'ClassNotebookLogo16': '\uF488',
                'ClassNotebookLogoFill16': '\uF489',
                'ClassNotebookLogoInverse32': '\uF48A',
                'ClassNotebookLogoInverse16': '\uF48B',
                'StaffNotebookLogo32': '\uF48C',
                'StaffNotebookLogoFill32': '\uF48D',
                'StaffNotebookLogo16': '\uF48E',
                'StaffNotebookLogoFill16': '\uF48F',
                'StaffNotebookLogoInverted32': '\uF490',
                'StaffNotebookLogoInverted16': '\uF491',
                'KaizalaLogo': '\uF492',
                'TaskLogo': '\uF493',
                'ProtectionCenterLogo32': '\uF494',
                'GallatinLogo': '\uF496',
                'Globe2': '\uF49A',
                'Guitar': '\uF49B',
                'Breakfast': '\uF49C',
                'Brunch': '\uF49D',
                'BeerMug': '\uF49E',
                'Vacation': '\uF49F',
                'Teeth': '\uF4A0',
                'Taxi': '\uF4A1',
                'Chopsticks': '\uF4A2',
                'SyncOccurence': '\uF4A3',
                'UnsyncOccurence': '\uF4A4',
                'GIF': '\uF4A9',
                'PrimaryCalendar': '\uF4AE',
                'SearchCalendar': '\uF4AF',
                'VideoOff': '\uF4B0',
                'MicrosoftFlowLogo': '\uF4B1',
                'BusinessCenterLogo': '\uF4B2',
                'ToDoLogoBottom': '\uF4B3',
                'ToDoLogoTop': '\uF4B4',
                'EditSolid12': '\uF4B5',
                'EditSolidMirrored12': '\uF4B6',
                'UneditableSolid12': '\uF4B7',
                'UneditableSolidMirrored12': '\uF4B8',
                'UneditableMirrored': '\uF4B9',
                'AdminALogo32': '\uF4BA',
                'AdminALogoFill32': '\uF4BB',
                'ToDoLogoInverse': '\uF4BC'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$4(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-14\"",
                src: "url('" + baseUrl + "fabric-icons-14-5cf58db8.woff') format('woff')"
            },
            icons: {
                'Snooze': '\uF4BD',
                'WaffleOffice365': '\uF4E0',
                'ImageSearch': '\uF4E8',
                'NewsSearch': '\uF4E9',
                'VideoSearch': '\uF4EA',
                'R': '\uF4EB',
                'FontColorA': '\uF4EC',
                'FontColorSwatch': '\uF4ED',
                'LightWeight': '\uF4EE',
                'NormalWeight': '\uF4EF',
                'SemiboldWeight': '\uF4F0',
                'GroupObject': '\uF4F1',
                'UngroupObject': '\uF4F2',
                'AlignHorizontalLeft': '\uF4F3',
                'AlignHorizontalCenter': '\uF4F4',
                'AlignHorizontalRight': '\uF4F5',
                'AlignVerticalTop': '\uF4F6',
                'AlignVerticalCenter': '\uF4F7',
                'AlignVerticalBottom': '\uF4F8',
                'HorizontalDistributeCenter': '\uF4F9',
                'VerticalDistributeCenter': '\uF4FA',
                'Ellipse': '\uF4FB',
                'Line': '\uF4FC',
                'Octagon': '\uF4FD',
                'Hexagon': '\uF4FE',
                'Pentagon': '\uF4FF',
                'RightTriangle': '\uF500',
                'HalfCircle': '\uF501',
                'QuarterCircle': '\uF502',
                'ThreeQuarterCircle': '\uF503',
                '6PointStar': '\uF504',
                '12PointStar': '\uF505',
                'ArrangeBringToFront': '\uF506',
                'ArrangeSendToBack': '\uF507',
                'ArrangeSendBackward': '\uF508',
                'ArrangeBringForward': '\uF509',
                'BorderDash': '\uF50A',
                'BorderDot': '\uF50B',
                'LineStyle': '\uF50C',
                'LineThickness': '\uF50D',
                'WindowEdit': '\uF50E',
                'HintText': '\uF50F',
                'MediaAdd': '\uF510',
                'AnchorLock': '\uF511',
                'AutoHeight': '\uF512',
                'ChartSeries': '\uF513',
                'ChartXAngle': '\uF514',
                'ChartYAngle': '\uF515',
                'Combobox': '\uF516',
                'LineSpacing': '\uF517',
                'Padding': '\uF518',
                'PaddingTop': '\uF519',
                'PaddingBottom': '\uF51A',
                'PaddingLeft': '\uF51B',
                'PaddingRight': '\uF51C',
                'NavigationFlipper': '\uF51D',
                'AlignJustify': '\uF51E',
                'TextOverflow': '\uF51F',
                'VisualsFolder': '\uF520',
                'VisualsStore': '\uF521',
                'PictureCenter': '\uF522',
                'PictureFill': '\uF523',
                'PicturePosition': '\uF524',
                'PictureStretch': '\uF525',
                'PictureTile': '\uF526',
                'Slider': '\uF527',
                'SliderHandleSize': '\uF528',
                'DefaultRatio': '\uF529',
                'NumberSequence': '\uF52A',
                'GUID': '\uF52B',
                'ReportAdd': '\uF52C',
                'DashboardAdd': '\uF52D',
                'MapPinSolid': '\uF52E',
                'WebPublish': '\uF52F',
                'PieSingleSolid': '\uF530',
                'BlockedSolid': '\uF531',
                'DrillDown': '\uF532',
                'DrillDownSolid': '\uF533',
                'DrillExpand': '\uF534',
                'DrillShow': '\uF535',
                'SpecialEvent': '\uF536',
                'OneDriveFolder16': '\uF53B',
                'FunctionalManagerDashboard': '\uF542',
                'BIDashboard': '\uF543',
                'CodeEdit': '\uF544',
                'RenewalCurrent': '\uF545',
                'RenewalFuture': '\uF546',
                'SplitObject': '\uF547',
                'BulkUpload': '\uF548',
                'DownloadDocument': '\uF549',
                'GreetingCard': '\uF54B',
                'Flower': '\uF54E',
                'WaitlistConfirm': '\uF550',
                'WaitlistConfirmMirrored': '\uF551',
                'LaptopSecure': '\uF552',
                'DragObject': '\uF553',
                'EntryView': '\uF554',
                'EntryDecline': '\uF555',
                'ContactCardSettings': '\uF556',
                'ContactCardSettingsMirrored': '\uF557'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$3(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-15\"",
                src: "url('" + baseUrl + "fabric-icons-15-3807251b.woff') format('woff')"
            },
            icons: {
                'CalendarSettings': '\uF558',
                'CalendarSettingsMirrored': '\uF559',
                'HardDriveLock': '\uF55A',
                'HardDriveUnlock': '\uF55B',
                'AccountManagement': '\uF55C',
                'ReportWarning': '\uF569',
                'TransitionPop': '\uF5B2',
                'TransitionPush': '\uF5B3',
                'TransitionEffect': '\uF5B4',
                'LookupEntities': '\uF5B5',
                'ExploreData': '\uF5B6',
                'AddBookmark': '\uF5B7',
                'SearchBookmark': '\uF5B8',
                'DrillThrough': '\uF5B9',
                'MasterDatabase': '\uF5BA',
                'CertifiedDatabase': '\uF5BB',
                'MaximumValue': '\uF5BC',
                'MinimumValue': '\uF5BD',
                'VisualStudioIDELogo32': '\uF5D0',
                'PasteAsText': '\uF5D5',
                'PasteAsCode': '\uF5D6',
                'BrowserTab': '\uF5D7',
                'BrowserTabScreenshot': '\uF5D8',
                'DesktopScreenshot': '\uF5D9',
                'FileYML': '\uF5DA',
                'ClipboardSolid': '\uF5DC',
                'FabricUserFolder': '\uF5E5',
                'FabricNetworkFolder': '\uF5E6',
                'BullseyeTarget': '\uF5F0',
                'AnalyticsView': '\uF5F1',
                'Video360Generic': '\uF609',
                'Untag': '\uF60B',
                'Leave': '\uF627',
                'Trending12': '\uF62D',
                'Blocked12': '\uF62E',
                'Warning12': '\uF62F',
                'CheckedOutByOther12': '\uF630',
                'CheckedOutByYou12': '\uF631',
                'CircleShapeSolid': '\uF63C',
                'SquareShapeSolid': '\uF63D',
                'TriangleShapeSolid': '\uF63E',
                'DropShapeSolid': '\uF63F',
                'RectangleShapeSolid': '\uF640',
                'ZoomToFit': '\uF649',
                'InsertColumnsLeft': '\uF64A',
                'InsertColumnsRight': '\uF64B',
                'InsertRowsAbove': '\uF64C',
                'InsertRowsBelow': '\uF64D',
                'DeleteColumns': '\uF64E',
                'DeleteRows': '\uF64F',
                'DeleteRowsMirrored': '\uF650',
                'DeleteTable': '\uF651',
                'AccountBrowser': '\uF652',
                'VersionControlPush': '\uF664',
                'StackedColumnChart2': '\uF666',
                'TripleColumnWide': '\uF66E',
                'QuadColumn': '\uF66F',
                'WhiteBoardApp16': '\uF673',
                'WhiteBoardApp32': '\uF674',
                'PinnedSolid': '\uF676',
                'InsertSignatureLine': '\uF677',
                'ArrangeByFrom': '\uF678',
                'Phishing': '\uF679',
                'CreateMailRule': '\uF67A',
                'PublishCourse': '\uF699',
                'DictionaryRemove': '\uF69A',
                'UserRemove': '\uF69B',
                'UserEvent': '\uF69C',
                'Encryption': '\uF69D',
                'PasswordField': '\uF6AA',
                'OpenInNewTab': '\uF6AB',
                'Hide3': '\uF6AC',
                'VerifiedBrandSolid': '\uF6AD',
                'MarkAsProtected': '\uF6AE',
                'AuthenticatorApp': '\uF6B1',
                'WebTemplate': '\uF6B2',
                'DefenderTVM': '\uF6B3',
                'MedalSolid': '\uF6B9',
                'D365TalentLearn': '\uF6BB',
                'D365TalentInsight': '\uF6BC',
                'D365TalentHRCore': '\uF6BD',
                'BacklogList': '\uF6BF',
                'ButtonControl': '\uF6C0',
                'TableGroup': '\uF6D9',
                'MountainClimbing': '\uF6DB',
                'TagUnknown': '\uF6DF',
                'TagUnknownMirror': '\uF6E0',
                'TagUnknown12': '\uF6E1',
                'TagUnknown12Mirror': '\uF6E2',
                'Link12': '\uF6E3',
                'Presentation': '\uF6E4',
                'Presentation12': '\uF6E5',
                'Lock12': '\uF6E6',
                'BuildDefinition': '\uF6E9',
                'ReleaseDefinition': '\uF6EA',
                'SaveTemplate': '\uF6EC',
                'UserGauge': '\uF6ED',
                'BlockedSiteSolid12': '\uF70A',
                'TagSolid': '\uF70E',
                'OfficeChat': '\uF70F'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$2(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-16\"",
                src: "url('" + baseUrl + "fabric-icons-16-9cf93f3b.woff') format('woff')"
            },
            icons: {
                'OfficeChatSolid': '\uF710',
                'MailSchedule': '\uF72E',
                'WarningSolid': '\uF736',
                'Blocked2Solid': '\uF737',
                'SkypeCircleArrow': '\uF747',
                'SkypeArrow': '\uF748',
                'SyncStatus': '\uF751',
                'SyncStatusSolid': '\uF752',
                'ProjectDocument': '\uF759',
                'ToDoLogoOutline': '\uF75B',
                'VisioOnlineLogoFill32': '\uF75F',
                'VisioOnlineLogo32': '\uF760',
                'VisioOnlineLogoCloud32': '\uF761',
                'VisioDiagramSync': '\uF762',
                'Event12': '\uF763',
                'EventDateMissed12': '\uF764',
                'UserOptional': '\uF767',
                'ResponsesMenu': '\uF768',
                'DoubleDownArrow': '\uF769',
                'DistributeDown': '\uF76A',
                'BookmarkReport': '\uF76B',
                'FilterSettings': '\uF76C',
                'GripperDotsVertical': '\uF772',
                'MailAttached': '\uF774',
                'AddIn': '\uF775',
                'LinkedDatabase': '\uF779',
                'TableLink': '\uF77A',
                'PromotedDatabase': '\uF77D',
                'BarChartVerticalFilter': '\uF77E',
                'BarChartVerticalFilterSolid': '\uF77F',
                'MicOff2': '\uF781',
                'MicrosoftTranslatorLogo': '\uF782',
                'ShowTimeAs': '\uF787',
                'FileRequest': '\uF789',
                'WorkItemAlert': '\uF78F',
                'PowerBILogo16': '\uF790',
                'PowerBILogoBackplate16': '\uF791',
                'BulletedListText': '\uF792',
                'BulletedListBullet': '\uF793',
                'BulletedListTextMirrored': '\uF794',
                'BulletedListBulletMirrored': '\uF795',
                'NumberedListText': '\uF796',
                'NumberedListNumber': '\uF797',
                'NumberedListTextMirrored': '\uF798',
                'NumberedListNumberMirrored': '\uF799',
                'RemoveLinkChain': '\uF79A',
                'RemoveLinkX': '\uF79B',
                'FabricTextHighlight': '\uF79C',
                'ClearFormattingA': '\uF79D',
                'ClearFormattingEraser': '\uF79E',
                'Photo2Fill': '\uF79F',
                'IncreaseIndentText': '\uF7A0',
                'IncreaseIndentArrow': '\uF7A1',
                'DecreaseIndentText': '\uF7A2',
                'DecreaseIndentArrow': '\uF7A3',
                'IncreaseIndentTextMirrored': '\uF7A4',
                'IncreaseIndentArrowMirrored': '\uF7A5',
                'DecreaseIndentTextMirrored': '\uF7A6',
                'DecreaseIndentArrowMirrored': '\uF7A7',
                'CheckListText': '\uF7A8',
                'CheckListCheck': '\uF7A9',
                'CheckListTextMirrored': '\uF7AA',
                'CheckListCheckMirrored': '\uF7AB',
                'NumberSymbol': '\uF7AC',
                'Coupon': '\uF7BC',
                'VerifiedBrand': '\uF7BD',
                'ReleaseGate': '\uF7BE',
                'ReleaseGateCheck': '\uF7BF',
                'ReleaseGateError': '\uF7C0',
                'M365InvoicingLogo': '\uF7C1',
                'RemoveFromShoppingList': '\uF7D5',
                'ShieldAlert': '\uF7D7',
                'FabricTextHighlightComposite': '\uF7DA',
                'Dataflows': '\uF7DD',
                'GenericScanFilled': '\uF7DE',
                'DiagnosticDataBarTooltip': '\uF7DF',
                'SaveToMobile': '\uF7E0',
                'Orientation2': '\uF7E1',
                'ScreenCast': '\uF7E2',
                'ShowGrid': '\uF7E3',
                'SnapToGrid': '\uF7E4',
                'ContactList': '\uF7E5',
                'NewMail': '\uF7EA',
                'EyeShadow': '\uF7EB',
                'FabricFolderConfirm': '\uF7FF',
                'InformationBarriers': '\uF803',
                'CommentActive': '\uF804',
                'ColumnVerticalSectionEdit': '\uF806',
                'WavingHand': '\uF807',
                'ShakeDevice': '\uF80A',
                'SmartGlassRemote': '\uF80B',
                'Rotate90Clockwise': '\uF80D',
                'Rotate90CounterClockwise': '\uF80E',
                'CampaignTemplate': '\uF811',
                'ChartTemplate': '\uF812',
                'PageListFilter': '\uF813',
                'SecondaryNav': '\uF814',
                'ColumnVerticalSection': '\uF81E',
                'SkypeCircleSlash': '\uF825',
                'SkypeSlash': '\uF826'
            }
        };
        registerIcons(subset, options);
    }

    // Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fluentui-assets-license
    function initializeIcons$1(baseUrl, options) {
        if (baseUrl === void 0) { baseUrl = ''; }
        var subset = {
            style: {
                MozOsxFontSmoothing: 'grayscale',
                WebkitFontSmoothing: 'antialiased',
                fontStyle: 'normal',
                fontWeight: 'normal',
                speak: 'none'
            },
            fontFace: {
                fontFamily: "\"FabricMDL2Icons-17\"",
                src: "url('" + baseUrl + "fabric-icons-17-0c4ed701.woff') format('woff')"
            },
            icons: {
                'CustomizeToolbar': '\uF828',
                'DuplicateRow': '\uF82A',
                'RemoveFromTrash': '\uF82B',
                'MailOptions': '\uF82C',
                'Childof': '\uF82D',
                'Footer': '\uF82E',
                'Header': '\uF82F',
                'BarChartVerticalFill': '\uF830',
                'StackedColumnChart2Fill': '\uF831',
                'PlainText': '\uF834',
                'AccessibiltyChecker': '\uF835',
                'DatabaseSync': '\uF842',
                'ReservationOrders': '\uF845',
                'TabOneColumn': '\uF849',
                'TabTwoColumn': '\uF84A',
                'TabThreeColumn': '\uF84B',
                'BulletedTreeList': '\uF84C',
                'MicrosoftTranslatorLogoGreen': '\uF852',
                'MicrosoftTranslatorLogoBlue': '\uF853',
                'InternalInvestigation': '\uF854',
                'AddReaction': '\uF85D',
                'ContactHeart': '\uF862',
                'VisuallyImpaired': '\uF866',
                'EventToDoLogo': '\uF869',
                'Variable2': '\uF86D',
                'ModelingView': '\uF871',
                'DisconnectVirtualMachine': '\uF873',
                'ReportLock': '\uF875',
                'Uneditable2': '\uF876',
                'Uneditable2Mirrored': '\uF877',
                'BarChartVerticalEdit': '\uF89D',
                'GlobalNavButtonActive': '\uF89F',
                'PollResults': '\uF8A0',
                'Rerun': '\uF8A1',
                'QandA': '\uF8A2',
                'QandAMirror': '\uF8A3',
                'BookAnswers': '\uF8A4',
                'AlertSettings': '\uF8B6',
                'TrimStart': '\uF8BB',
                'TrimEnd': '\uF8BC',
                'TableComputed': '\uF8F5',
                'DecreaseIndentLegacy': '\uE290',
                'IncreaseIndentLegacy': '\uE291',
                'SizeLegacy': '\uE2B2'
            }
        };
        registerIcons(subset, options);
    }

    var registerIconAliases = function () {
        registerIconAlias('trash', 'delete');
        registerIconAlias('onedrive', 'onedrivelogo');
        registerIconAlias('alertsolid12', 'eventdatemissed12');
        registerIconAlias('sixpointstar', '6pointstar');
        registerIconAlias('twelvepointstar', '12pointstar');
        registerIconAlias('toggleon', 'toggleleft');
        registerIconAlias('toggleoff', 'toggleright');
    };

    // Do not modify this file; it is generated as part of publish.
    setVersion('@fluentui/font-icons-mdl2', '8.5.13');

    var DEFAULT_BASE_URL = FLUENT_CDN_BASE_URL + "/assets/icons/";
    var win = getWindow();
    function initializeIcons(baseUrl, options) {
        var _a, _b;
        if (baseUrl === void 0) { baseUrl = ((_a = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _a === void 0 ? void 0 : _a.iconBaseUrl) || ((_b = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _b === void 0 ? void 0 : _b.fontBaseUrl) || DEFAULT_BASE_URL; }
        [initializeIcons$j, initializeIcons$i, initializeIcons$h, initializeIcons$g, initializeIcons$f, initializeIcons$e, initializeIcons$d, initializeIcons$c, initializeIcons$b, initializeIcons$a, initializeIcons$9, initializeIcons$8, initializeIcons$7, initializeIcons$6, initializeIcons$5, initializeIcons$4, initializeIcons$3, initializeIcons$2, initializeIcons$1].forEach(function (initialize) { return initialize(baseUrl, options); });
        registerIconAliases();
    }

    var ThemeContext = react.exports.createContext(undefined);

    /**
     * Get theme from CustomizerContext or Customizations singleton.
     */
    function useCompatTheme() {
        return useCustomizationSettings(['theme']).theme;
    }
    /**
     * React hook for programmatically accessing the theme.
     */
    var useTheme = function () {
        var theme = react.exports.useContext(ThemeContext);
        var legacyTheme = useCompatTheme();
        return theme || legacyTheme || createTheme({});
    };

    var _seed = 0;
    var mergeStylesRenderer = {
        reset: function () {
            // If the stylesheet reset call is made, invalidate the cache keys.
            Stylesheet.getInstance().onReset(function () { return _seed++; });
        },
        getId: function () { return _seed; },
        renderStyles: function (styleSet, options) {
            return mergeCssSets((Array.isArray(styleSet) ? styleSet : [styleSet]), options);
        },
        renderFontFace: function (fontFace$1, options) {
            return fontFace(fontFace$1);
        },
        renderKeyframes: function (keyframes$1) {
            return keyframes(keyframes$1);
        },
    };

    var graphGet = function (graphNode, path) {
        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
            var key = path_1[_i];
            graphNode = graphNode.get(key);
            if (!graphNode) {
                return;
            }
        }
        return graphNode;
    };
    var graphSet = function (graphNode, path, value) {
        for (var i = 0; i < path.length - 1; i++) {
            var key = path[i];
            var current = graphNode.get(key);
            if (!current) {
                current = new Map();
                graphNode.set(key, current);
            }
            graphNode = current;
        }
        graphNode.set(path[path.length - 1], value);
    };
    /**
     * Registers a css object, optionally as a function of the theme.
     *
     * @param styleOrFunction - Either a css javascript object, or a function which takes in `ITheme`
     * and returns a css javascript object.
     *
     * @deprecated Use `mergeStyles` instead for v8 related code. We will be using a new implementation of `makeStyles` in
     * future versions of the library.
     */
    function makeStyles(styleOrFunction) {
        // Create graph of inputs to map to output.
        var graph = new Map();
        // eslint-disable-next-line deprecation/deprecation
        return function (options) {
            if (options === void 0) { options = {}; }
            var theme = options.theme;
            var win = useWindow();
            var contextualTheme = useTheme();
            theme = theme || contextualTheme;
            var renderer = mergeStylesRenderer;
            var id = renderer.getId();
            var isStyleFunction = typeof styleOrFunction === 'function';
            var path = isStyleFunction ? [id, win, theme] : [id, win];
            var value = graphGet(graph, path);
            if (!value) {
                var styles = isStyleFunction ? styleOrFunction(theme) : styleOrFunction;
                value = mergeStylesRenderer.renderStyles(styles, { targetWindow: win, rtl: !!theme.rtl });
                graphSet(graph, path, value);
            }
            return value;
        };
    }

    // eslint-disable-next-line deprecation/deprecation
    var useThemeProviderStyles = makeStyles(function (theme) {
        var semanticColors = theme.semanticColors, fonts = theme.fonts;
        return {
            body: [
                {
                    color: semanticColors.bodyText,
                    background: semanticColors.bodyBackground,
                    fontFamily: fonts.medium.fontFamily,
                    fontWeight: fonts.medium.fontWeight,
                    fontSize: fonts.medium.fontSize,
                    MozOsxFontSmoothing: fonts.medium.MozOsxFontSmoothing,
                    WebkitFontSmoothing: fonts.medium.WebkitFontSmoothing,
                },
            ],
        };
    });
    /**
     * Hook to add class to body element.
     */
    function useApplyClassToBody(state, classesToApply) {
        var _a;
        var applyTo = state.applyTo;
        var applyToBody = applyTo === 'body';
        var body = (_a = useDocument()) === null || _a === void 0 ? void 0 : _a.body;
        react.exports.useEffect(function () {
            if (!applyToBody || !body) {
                return;
            }
            for (var _i = 0, classesToApply_1 = classesToApply; _i < classesToApply_1.length; _i++) {
                var classToApply = classesToApply_1[_i];
                if (classToApply) {
                    body.classList.add(classToApply);
                }
            }
            return function () {
                if (!applyToBody || !body) {
                    return;
                }
                for (var _i = 0, classesToApply_2 = classesToApply; _i < classesToApply_2.length; _i++) {
                    var classToApply = classesToApply_2[_i];
                    if (classToApply) {
                        body.classList.remove(classToApply);
                    }
                }
            };
        }, [applyToBody, body, classesToApply]);
    }
    function useThemeProviderClasses(state) {
        var classes = useThemeProviderStyles(state);
        var className = state.className, applyTo = state.applyTo;
        useApplyClassToBody(state, [classes.root, classes.body]);
        state.className = css(className, classes.root, applyTo === 'element' && classes.body);
    }

    var renderThemeProvider = function (state) {
        var theme = state.theme, customizerContext = state.customizerContext;
        var Root = state.as || 'div';
        var rootProps = typeof state.as === 'string' ? getNativeElementProps(state.as, state) : omit(state, ['as']);
        return (react.exports.createElement(ThemeContext.Provider, { value: theme },
            react.exports.createElement(CustomizerContext.Provider, { value: customizerContext },
                react.exports.createElement(Root, __assign$k({}, rootProps)))));
    };

    var themeToIdMap = new Map();
    var getThemeId = function () {
        var themes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            themes[_i] = arguments[_i];
        }
        var ids = [];
        for (var _a = 0, themes_1 = themes; _a < themes_1.length; _a++) {
            var theme = themes_1[_a];
            if (theme) {
                var id = theme.id || themeToIdMap.get(theme);
                if (!id) {
                    id = getId('');
                    themeToIdMap.set(theme, id);
                }
                ids.push(id);
            }
        }
        return ids.join('-');
    };
    var useThemeProviderState = function (draftState) {
        var userTheme = draftState.theme;
        // Pull contextual theme.
        var parentTheme = useTheme();
        // Update the incoming theme with a memoized version of the merged theme.
        var theme = (draftState.theme = react.exports.useMemo(function () {
            var mergedTheme = mergeThemes(parentTheme, userTheme);
            mergedTheme.id = getThemeId(parentTheme, userTheme);
            return mergedTheme;
        }, [parentTheme, userTheme]));
        draftState.customizerContext = react.exports.useMemo(function () { return ({
            customizations: {
                inCustomizerContext: true,
                settings: { theme: theme },
                scopedSettings: theme.components || {},
            },
        }); }, [theme]);
        if (draftState.theme.rtl !== parentTheme.rtl) {
            draftState.dir = draftState.theme.rtl ? 'rtl' : 'ltr';
        }
    };

    /**
     * Returns the ThemeProvider render function and calculated state, given user input, ref, and
     * a set of default prop values.
     */
    var useThemeProvider = function (props, defaultProps) {
        var state = getPropsWithDefaults(defaultProps, props);
        // Apply changes to state.
        useThemeProviderState(state);
        return {
            state: state,
            render: renderThemeProvider,
        };
    };

    /**
     * ThemeProvider, used for providing css variables and registering stylesheets.
     */
    var ThemeProvider = react.exports.forwardRef(function (props, ref) {
        var rootRef = useMergedRefs(ref, react.exports.useRef(null));
        var _a = useThemeProvider(props, {
            ref: rootRef,
            as: 'div',
            applyTo: 'element',
        }), render = _a.render, state = _a.state;
        // Render styles.
        useThemeProviderClasses(state);
        // Apply focus rect class on key presses.
        useFocusRects(state.ref);
        // Return the rendered content.
        return render(state);
    });
    ThemeProvider.displayName = 'ThemeProvider';

    //When adding new exports to this file, also add them to index.ts.
    //When adding new exports to this file, also add them to index.ts.

    var Theme = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AnimationStyles: AnimationStyles,
        AnimationVariables: AnimationVariables,
        get CommunicationColors () { return CommunicationColors; },
        DefaultEffects: DefaultEffects,
        DefaultFontStyles: DefaultFontStyles,
        DefaultPalette: DefaultPalette,
        DefaultSpacing: DefaultSpacing,
        get Depths () { return Depths; },
        FluentTheme: FluentTheme,
        createFontStyles: createFontStyles,
        createTheme: createTheme,
        get LocalizedFontFamilies () { return LocalizedFontFamilies; },
        get LocalizedFontNames () { return LocalizedFontNames; },
        mergeThemes: mergeThemes,
        get MotionDurations () { return MotionDurations; },
        get MotionTimings () { return MotionTimings; },
        get MotionAnimations () { return MotionAnimations; },
        get NeutralColors () { return NeutralColors; },
        get SharedColors () { return SharedColors; },
        registerDefaultFontFaces: registerDefaultFontFaces,
        ThemeProvider: ThemeProvider,
        useTheme: useTheme,
        ThemeContext: ThemeContext,
        makeStyles: makeStyles
    });

    var lib$4 = {};

    var common = {};

    var createUIUtilities$1 = {};

    var lib$3 = {};

    var getBlockElementAtNode$1 = {};

    var collapseNodes$1 = {};

    var contains$1 = {};

    var safeInstanceOf$1 = {};

    Object.defineProperty(safeInstanceOf$1, "__esModule", { value: true });
    safeInstanceOf$1.getTargetWindow = void 0;
    // NOTE: Type TargetWindow is an auto-generated type.
    // Run node ./tools/generateTargetWindow.js to generate it.
    /**
     * @internal Export for test only
     * Try get window from the given node or range
     * @param node Source node to get window from
     */
    function getTargetWindow(node) {
        var document = node &&
            (node.ownerDocument ||
                (Object.prototype.toString.apply(node) == '[object HTMLDocument]'
                    ? node
                    : null));
        // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead
        var targetWindow = document && (document.defaultView || window);
        return targetWindow;
    }
    safeInstanceOf$1.getTargetWindow = getTargetWindow;
    /**
     * Check if the given object is instance of the target type
     * @param obj Object to check
     * @param typeName Target type name
     */
    function safeInstanceOf(obj, typeName) {
        var _a;
        if (typeName == 'Range') {
            return (Object.prototype.toString.apply(obj) == '[object Range]' &&
                !!((_a = obj) === null || _a === void 0 ? void 0 : _a.commonAncestorContainer));
        }
        var targetWindow = getTargetWindow(obj);
        var targetType = targetWindow && targetWindow[typeName];
        var mainWindow = window;
        var mainWindowType = mainWindow && mainWindow[typeName];
        return ((mainWindowType && obj instanceof mainWindowType) ||
            (targetType && obj instanceof targetType));
    }
    safeInstanceOf$1.default = safeInstanceOf;

    Object.defineProperty(contains$1, "__esModule", { value: true });
    var safeInstanceOf_1$i = safeInstanceOf$1;
    function contains(container, contained, treatSameNodeAsContain) {
        if (!container || !contained) {
            return false;
        }
        if (treatSameNodeAsContain && container == contained) {
            return true;
        }
        if ((0, safeInstanceOf_1$i.default)(contained, 'Range')) {
            contained = contained && contained.commonAncestorContainer;
            treatSameNodeAsContain = true;
        }
        if (contained && contained.nodeType == 3 /* Text */) {
            contained = contained.parentNode;
            treatSameNodeAsContain = true;
        }
        if (container.nodeType != 1 /* Element */ && container.nodeType != 11 /* DocumentFragment */) {
            return !!treatSameNodeAsContain && container == contained;
        }
        return (!!(treatSameNodeAsContain || container != contained) &&
            internalContains(container, contained));
    }
    contains$1.default = contains;
    function internalContains(container, contained) {
        if (container.contains) {
            return container.contains(contained);
        }
        else {
            while (contained) {
                if (contained == container) {
                    return true;
                }
                contained = contained.parentNode;
            }
            return false;
        }
    }

    var splitParentNode$1 = {};

    var isNodeAfter$1 = {};

    Object.defineProperty(isNodeAfter$1, "__esModule", { value: true });
    /**
     * Checks if node1 is after node2
     * @param node1 The node to check if it is after another node
     * @param node2 The node to check if another node is after this one
     * @returns True if node1 is after node2, otherwise false
     */
    function isNodeAfter(node1, node2) {
        return !!(node1 &&
            node2 &&
            (node2.compareDocumentPosition(node1) & 4 /* Following */) ==
                4 /* Following */);
    }
    isNodeAfter$1.default = isNodeAfter;

    Object.defineProperty(splitParentNode$1, "__esModule", { value: true });
    splitParentNode$1.splitBalancedNodeRange = void 0;
    var isNodeAfter_1$5 = isNodeAfter$1;
    /**
     * Split parent node of the given node before/after the given node.
     * When a parent node contains [A,B,C] and pass B as the given node,
     * If split before, the new nodes will be [A][B,C] and returns [A];
     * otherwise, it will be [A,B][C] and returns [C].
     * @param node The node to split before/after
     * @param splitBefore Whether split before or after
     * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),
     * we remove it. @default false
     * @returns The new parent node
     */
    function splitParentNode(node, splitBefore) {
        var _a;
        if (!node || !node.parentNode) {
            return null;
        }
        var parentNode = node.parentNode;
        var newParent = parentNode.cloneNode(false /*deep*/);
        newParent.removeAttribute('id');
        if (splitBefore) {
            while (parentNode.firstChild && parentNode.firstChild != node) {
                newParent.appendChild(parentNode.firstChild);
            }
        }
        else {
            while (node.nextSibling) {
                newParent.appendChild(node.nextSibling);
            }
        }
        // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true
        if (newParent.firstChild && newParent.innerHTML != '') {
            (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newParent, splitBefore ? parentNode : parentNode.nextSibling);
        }
        else {
            newParent = null;
        }
        return newParent;
    }
    splitParentNode$1.default = splitParentNode;
    /**
     * Split parent node by a balanced node range
     * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.
     * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored
     * @returns The parent node of the given node range if the given nodes are balanced, otherwise null
     */
    function splitBalancedNodeRange(nodes) {
        var start = Array.isArray(nodes) ? nodes[0] : nodes;
        var end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;
        var parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;
        if (parentNode) {
            if ((0, isNodeAfter_1$5.default)(start, end)) {
                var temp = end;
                end = start;
                start = temp;
            }
            splitParentNode(start, true /*splitBefore*/);
            splitParentNode(end, false /*splitBefore*/);
        }
        return parentNode;
    }
    splitParentNode$1.splitBalancedNodeRange = splitBalancedNodeRange;

    var toArray$1 = {};

    Object.defineProperty(toArray$1, "__esModule", { value: true });
    function toArray(collection) {
        return [].slice.call(collection);
    }
    toArray$1.default = toArray;

    Object.defineProperty(collapseNodes$1, "__esModule", { value: true });
    collapseNodes$1.collapse = void 0;
    var contains_1$c = contains$1;
    var splitParentNode_1$4 = splitParentNode$1;
    var toArray_1$9 = toArray$1;
    /**
     * Collapse nodes within the given start and end nodes to their common ancestor node,
     * split parent nodes if necessary
     * @param root The root node of the scope
     * @param start The start node
     * @param end The end node
     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent
     * and the returned nodes will be all nodes from start through end after splitting
     * False to disallow split parent
     * @returns When canSplitParent is true, returns all node from start through end after splitting,
     * otherwise just return start and end
     */
    function collapseNodes(root, start, end, canSplitParent) {
        var _a;
        if (!(0, contains_1$c.default)(root, start) || !(0, contains_1$c.default)(root, end)) {
            return [];
        }
        start = collapse(root, start, end, true /*isStart*/, canSplitParent);
        end = collapse(root, end, start, false /*isStart*/, canSplitParent);
        if ((0, contains_1$c.default)(start, end, true /*treatSameNodeAsContain*/)) {
            return [start];
        }
        else if ((0, contains_1$c.default)(end, start)) {
            return [end];
        }
        else if (start.parentNode == end.parentNode) {
            var nodes = start.parentNode ? (0, toArray_1$9.default)((_a = start.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes) : [];
            var startIndex = nodes.indexOf(start);
            var endIndex = nodes.indexOf(end);
            return nodes.slice(startIndex, endIndex + 1);
        }
        else {
            return [start, end];
        }
    }
    collapseNodes$1.default = collapseNodes;
    /**
     * @internal
     * Collapse a node by traversing its parent nodes until we get the common ancestor node of node and ref node
     * @param root Root node, traversing will be limited under this scope
     * @param node The node to collapse
     * @param ref Ref node. The result will be the nearest common ancestor node of the given node and this ref node
     * @param isStart Whether the given node is start of the sequence of nodes to collapse
     * @param canSplitParent Whether splitting parent node is allowed
     * @returns The common ancestor node of the given node ref node
     */
    function collapse(root, node, ref, isStart, canSplitParent) {
        while (node.parentNode != root && !(0, contains_1$c.default)(node.parentNode, ref)) {
            if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {
                if (!canSplitParent) {
                    break;
                }
                (0, splitParentNode_1$4.default)(node, isStart);
            }
            if (!node.parentNode) {
                break;
            }
            node = node.parentNode;
        }
        return node;
    }
    collapseNodes$1.collapse = collapse;

    var getTagOfNode$1 = {};

    Object.defineProperty(getTagOfNode$1, "__esModule", { value: true });
    /**
     * Get the html tag of a node, or empty if it is not an element
     * @param node The node to get tag of
     * @returns Tag name in upper case if the given node is an Element, or empty string otherwise
     */
    function getTagOfNode(node) {
        return node && node.nodeType == 1 /* Element */ ? node.tagName.toUpperCase() : '';
    }
    getTagOfNode$1.default = getTagOfNode;

    var isBlockElement$1 = {};

    Object.defineProperty(isBlockElement$1, "__esModule", { value: true });
    var getTagOfNode_1$h = getTagOfNode$1;
    var BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(',');
    var BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];
    /**
     * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.
     * @param node The node to check
     * @returns True if the node is a block element, otherwise false
     */
    function isBlockElement(node) {
        var tag = (0, getTagOfNode_1$h.default)(node);
        return !!(tag &&
            (BLOCK_DISPLAY_STYLES.indexOf(node.style.display) >= 0 ||
                BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0));
    }
    isBlockElement$1.default = isBlockElement;

    var NodeBlockElement$1 = {};

    Object.defineProperty(NodeBlockElement$1, "__esModule", { value: true });
    var contains_1$b = contains$1;
    var isNodeAfter_1$4 = isNodeAfter$1;
    /**
     * @internal
     * This presents a content block that can be represented by a single html block type element.
     * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.
     */
    var NodeBlockElement = /** @class */ (function () {
        function NodeBlockElement(element) {
            this.element = element;
        }
        /**
         * Collapse this element to a single DOM element.
         * If the content nodes are separated in different root nodes, wrap them to a single node
         * If the content nodes are included in root node with other nodes, split root node
         */
        NodeBlockElement.prototype.collapseToSingleElement = function () {
            return this.element;
        };
        /**
         * Get the start node of the block
         * For NodeBlockElement, start and end essentially refers to same node
         */
        NodeBlockElement.prototype.getStartNode = function () {
            return this.element;
        };
        /**
         * Get the end node of the block
         * For NodeBlockElement, start and end essentially refers to same node
         */
        NodeBlockElement.prototype.getEndNode = function () {
            return this.element;
        };
        /**
         * Checks if it refers to same block
         */
        NodeBlockElement.prototype.equals = function (blockElement) {
            // Ideally there is only one unique way to generate a block so we only need to compare the startNode
            return this.element == blockElement.getStartNode();
        };
        /**
         * Checks if a block is after the current block
         */
        NodeBlockElement.prototype.isAfter = function (blockElement) {
            // if the block's startNode is after current node endEnd, we say it is after
            return (0, isNodeAfter_1$4.default)(this.element, blockElement.getEndNode());
        };
        /**
         * Checks if a certain html node is within the block
         */
        NodeBlockElement.prototype.contains = function (node) {
            return (0, contains_1$b.default)(this.element, node, true /*treatSameNodeAsContain*/);
        };
        /**
         * Get the text content of this block element
         */
        NodeBlockElement.prototype.getTextContent = function () {
            var _a;
            return ((_a = this.element) === null || _a === void 0 ? void 0 : _a.textContent) || '';
        };
        return NodeBlockElement;
    }());
    NodeBlockElement$1.default = NodeBlockElement;

    var StartEndBlockElement$1 = {};

    var createRange$1 = {};

    var isVoidHtmlElement$1 = {};

    Object.defineProperty(isVoidHtmlElement$1, "__esModule", { value: true });
    var getTagOfNode_1$g = getTagOfNode$1;
    /**
     * HTML void elements
     * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes
     * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside
     * void elements so users don't accidentally create child nodes in them
     */
    var HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(',');
    /**
     * Check if the given node is html void element. Void element cannot have children
     * @param node The node to check
     */
    function isVoidHtmlElement(node) {
        return !!node && HTML_VOID_ELEMENTS.indexOf((0, getTagOfNode_1$g.default)(node)) >= 0;
    }
    isVoidHtmlElement$1.default = isVoidHtmlElement;

    var Position$1 = {};

    var findClosestElementAncestor$1 = {};

    var matchesSelector$1 = {};

    Object.defineProperty(matchesSelector$1, "__esModule", { value: true });
    var safeInstanceOf_1$h = safeInstanceOf$1;
    /**
     * A wrapper function of Element.matches
     * @param element The element to match
     * @param selector The selector to match
     */
    function matchesSelector(element, selector) {
        return ((0, safeInstanceOf_1$h.default)(element, 'HTMLElement') &&
            (element.matches || element.msMatchesSelector).call(element, selector));
    }
    matchesSelector$1.default = matchesSelector;

    Object.defineProperty(findClosestElementAncestor$1, "__esModule", { value: true });
    var contains_1$a = contains$1;
    var matchesSelector_1 = matchesSelector$1;
    /**
     * Find closest element ancestor start from the given node which matches the given selector
     * @param node Find ancestor start from this node
     * @param root Root node where the search should stop at. The return value can never be this node
     * @param selector The expected selector. If null, return the first HTML Element found from start node
     * @returns An HTML element which matches the given selector. If the given start node matches the selector,
     * returns the given node
     */
    function findClosestElementAncestor(node, root, selector) {
        node = !node ? null : node.nodeType == 1 /* Element */ ? node : node.parentNode;
        var element = node && node.nodeType == 1 /* Element */ ? node : null;
        if (element && selector) {
            if (element.closest) {
                element = element.closest(selector);
            }
            else {
                while (element && element != root && !(0, matchesSelector_1.default)(element, selector)) {
                    element = element.parentElement;
                }
            }
        }
        return !root || (0, contains_1$a.default)(root, element) ? element : null;
    }
    findClosestElementAncestor$1.default = findClosestElementAncestor;

    Object.defineProperty(Position$1, "__esModule", { value: true });
    var findClosestElementAncestor_1$5 = findClosestElementAncestor$1;
    var isNodeAfter_1$3 = isNodeAfter$1;
    /**
     * Represent a position in DOM tree by the node and its offset index
     */
    var Position = /** @class */ (function () {
        function Position(nodeOrPosition, offsetOrPosType, isFromEndOfRange) {
            if (offsetOrPosType === void 0) { offsetOrPosType = 0; }
            this.isFromEndOfRange = isFromEndOfRange;
            if (nodeOrPosition.node) {
                this.node = nodeOrPosition.node;
                offsetOrPosType = nodeOrPosition.offset;
            }
            else {
                this.node = nodeOrPosition;
            }
            switch (offsetOrPosType) {
                case -2 /* Before */:
                    this.offset = getIndexOfNode(this.node);
                    this.node = this.node.parentNode; // TODO: how to handle parentNode is null?
                    this.isAtEnd = false;
                    break;
                case -3 /* After */:
                    this.offset = getIndexOfNode(this.node) + 1;
                    this.isAtEnd = !this.node.nextSibling;
                    this.node = this.node.parentNode; // TODO: how to handle parentNode is null?
                    break;
                case -1 /* End */:
                    this.offset = getEndOffset(this.node);
                    this.isAtEnd = true;
                    break;
                default:
                    var endOffset = getEndOffset(this.node);
                    this.offset = Math.max(0, Math.min(offsetOrPosType, endOffset));
                    this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;
                    break;
            }
            this.element = (0, findClosestElementAncestor_1$5.default)(this.node); // TODO: how to handle parent element is null?
        }
        /**
         * Normalize this position to the leaf node, return the normalize result.
         * If current position is already using leaf node, return this position object itself
         */
        Position.prototype.normalize = function () {
            if (this.node.nodeType == 3 /* Text */ || !this.node.firstChild) {
                return this;
            }
            var node = this.node;
            var newOffset = this.isAtEnd
                ? -1 /* End */
                : this.offset;
            while (node.nodeType == 1 /* Element */ || node.nodeType == 11 /* DocumentFragment */) {
                var nextNode = this.isFromEndOfRange
                    ? newOffset == -1 /* End */
                        ? node.lastChild
                        : node.childNodes[newOffset - 1]
                    : newOffset == 0 /* Begin */
                        ? node.firstChild
                        : newOffset == -1 /* End */
                            ? node.lastChild
                            : node.childNodes[newOffset];
                if (nextNode) {
                    node = nextNode;
                    newOffset =
                        this.isAtEnd || this.isFromEndOfRange ? -1 /* End */ : 0 /* Begin */;
                }
                else {
                    break;
                }
            }
            return new Position(node, newOffset, this.isFromEndOfRange);
        };
        /**
         * Check if this position is equal to the given position
         * @param position The position to check
         */
        Position.prototype.equalTo = function (position) {
            return (position &&
                (this == position ||
                    (this.node == position.node &&
                        this.offset == position.offset &&
                        this.isAtEnd == position.isAtEnd)));
        };
        /**
         * Checks if this position is after the given position
         */
        Position.prototype.isAfter = function (position) {
            return this.node == position.node
                ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset
                : (0, isNodeAfter_1$3.default)(this.node, position.node);
        };
        /**
         * Move this position with offset, returns a new position with a valid offset in the same node
         * @param offset Offset to move with
         */
        Position.prototype.move = function (offset) {
            return new Position(this.node, Math.max(this.offset + offset, 0));
        };
        /**
         * Get start position of the given Range
         * @param range The range to get position from
         */
        Position.getStart = function (range) {
            return new Position(range.startContainer, range.startOffset);
        };
        /**
         * Get end position of the given Range
         * @param range The range to get position from
         */
        Position.getEnd = function (range) {
            // For collapsed range, always return the same value of start container to make sure
            // end position is not before start position
            return range.collapsed
                ? Position.getStart(range)
                : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);
        };
        return Position;
    }());
    Position$1.default = Position;
    function getIndexOfNode(node) {
        var i = 0;
        while ((node = (node === null || node === void 0 ? void 0 : node.previousSibling) || null)) {
            i++;
        }
        return i;
    }
    function getEndOffset(node) {
        var _a;
        if (node.nodeType == 3 /* Text */) {
            return ((_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) || 0;
        }
        else if (node.nodeType == 1 /* Element */ || node.nodeType == 11 /* DocumentFragment */) {
            return node.childNodes.length;
        }
        else {
            return 1;
        }
    }

    Object.defineProperty(createRange$1, "__esModule", { value: true });
    var isVoidHtmlElement_1$1 = isVoidHtmlElement$1;
    var Position_1$c = Position$1;
    var safeInstanceOf_1$g = safeInstanceOf$1;
    function createRange(arg1, arg2, arg3, arg4) {
        var _a;
        var start = null;
        var end = null;
        if (isNodePosition$1(arg1)) {
            // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;
            start = arg1;
            end = isNodePosition$1(arg2) ? arg2 : null;
        }
        else if ((0, safeInstanceOf_1$g.default)(arg1, 'Node')) {
            if (Array.isArray(arg2)) {
                // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;
                start = getPositionFromPath(arg1, arg2);
                end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;
            }
            else if (typeof arg2 == 'number') {
                // function createRange(node: Node, offset: number | PositionType): Range;
                // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;
                start = new Position_1$c.default(arg1, arg2);
                end = (0, safeInstanceOf_1$g.default)(arg3, 'Node') ? new Position_1$c.default(arg3, arg4) : null;
            }
            else if ((0, safeInstanceOf_1$g.default)(arg2, 'Node') || !arg2) {
                // function createRange(startNode: Node, endNode?: Node): Range;
                start = new Position_1$c.default(arg1, -2 /* Before */);
                end = new Position_1$c.default(arg2 || arg1, -3 /* After */);
            }
        }
        if ((_a = start === null || start === void 0 ? void 0 : start.node) === null || _a === void 0 ? void 0 : _a.ownerDocument) {
            var range = start.node.ownerDocument.createRange();
            start = getFocusablePosition(start);
            end = getFocusablePosition(end || start);
            range.setStart(start.node, start.offset);
            range.setEnd(end.node, end.offset);
            return range;
        }
        else {
            return null;
        }
    }
    createRange$1.default = createRange;
    /**
     * Convert to focusable position
     * If current node is a void element, we need to move up one level to put cursor outside void element
     */
    function getFocusablePosition(position) {
        return position.node.nodeType == 1 /* Element */ && (0, isVoidHtmlElement_1$1.default)(position.node)
            ? new Position_1$c.default(position.node, position.isAtEnd ? -3 /* After */ : -2 /* Before */)
            : position;
    }
    function isNodePosition$1(arg) {
        return arg && arg.node;
    }
    function getPositionFromPath(node, path) {
        if (!node || !path) {
            return null;
        }
        // Iterate with a for loop to avoid mutating the passed in element path stack
        // or needing to copy it.
        var offset = 0;
        for (var i = 0; i < path.length; i++) {
            offset = path[i];
            if (i < path.length - 1 &&
                node &&
                node.nodeType == 1 /* Element */ &&
                node.childNodes.length > offset) {
                node = node.childNodes[offset];
            }
            else {
                break;
            }
        }
        return new Position_1$c.default(node, offset);
    }

    var wrap$1 = {};

    var createElement = {};

    var getObjectKeys$1 = {};

    Object.defineProperty(getObjectKeys$1, "__esModule", { value: true });
    /**
     * Provide a strong-typed version of Object.keys()
     * @param obj The source object
     * @returns Array of keys
     */
    function getObjectKeys(obj) {
        return Object.keys(obj);
    }
    getObjectKeys$1.default = getObjectKeys;

    var Browser = {};

    Object.defineProperty(Browser, "__esModule", { value: true });
    Browser.Browser = Browser.getBrowserInfo = void 0;
    var isAndroidRegex = /android/i;
    /**
     * Get current browser information from user agent string
     * @param userAgent The userAgent string of a browser
     * @param appVersion The appVersion string of a browser
     * @param vendor The vendor string of a browser
     * @returns The BrowserInfo object calculated from the given userAgent and appVersion
     */
    function getBrowserInfo(userAgent, appVersion, vendor) {
        // checks whether the browser is running in IE
        // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for "Trident" to confirm this.
        // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)
        // therefore we should check that the Trident/rv combo is not just from an older IE browser
        var isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;
        var isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;
        // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well
        var isChrome = false;
        var isFirefox = false;
        var isSafari = false;
        var isEdge = false;
        var isWebKit = userAgent.indexOf('WebKit') != -1;
        var isMobileOrTablet = false;
        // Reference: http://detectmobilebrowsers.com/
        // The default regex on the website doesn't consider tablet.
        // To support tablet, add |android|ipad|playbook|silk to the first regex according to the info in /about page
        (function (userAgentOrVendor) {
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(userAgentOrVendor) ||
                /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(userAgentOrVendor.substr(0, 4))) {
                isMobileOrTablet = true;
            }
        })(userAgent || vendor || '');
        if (!isIE) {
            isChrome = userAgent.indexOf('Chrome') != -1;
            isFirefox = userAgent.indexOf('Firefox') != -1;
            if (userAgent.indexOf('Safari') != -1) {
                // Android and Chrome have Safari in the user string
                isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;
            }
            // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121
            isEdge = userAgent.indexOf('Edge') != -1;
            // When it is edge, it should not be chrome or firefox. and it is also not webkit
            if (isEdge) {
                isWebKit = isChrome = isFirefox = false;
            }
        }
        var isMac = appVersion.indexOf('Mac') != -1;
        var isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;
        var isAndroid = isAndroidRegex.test(userAgent);
        return {
            isMac: isMac,
            isWin: isWin,
            isWebKit: isWebKit,
            isIE: isIE,
            isIE11OrGreater: isIE11OrGreater,
            isSafari: isSafari,
            isChrome: isChrome,
            isFirefox: isFirefox,
            isEdge: isEdge,
            isIEOrEdge: isIE || isEdge,
            isAndroid: isAndroid,
            isMobileOrTablet: isMobileOrTablet,
        };
    }
    Browser.getBrowserInfo = getBrowserInfo;
    /**
     * Browser object contains browser and operating system information of current environment
     */
    Browser.Browser = typeof window !== 'undefined' && window
        ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion, window.navigator.vendor)
        : {};

    (function (exports) {
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KnownCreateElementData = void 0;
    var getObjectKeys_1 = getObjectKeys$1;
    var safeInstanceOf_1 = safeInstanceOf$1;
    var Browser_1 = Browser;
    /**
     * All known CreateElementData used by roosterjs to create elements
     */
    exports.KnownCreateElementData = (_a = {},
        _a[0 /* None */] = { tag: '' },
        // Edge can sometimes lose current format when Enter to new line.
        // So here we add an extra SPAN for Edge to workaround this bug
        _a[1 /* EmptyLine */] = Browser_1.Browser.isEdge
            ? { tag: 'div', children: [{ tag: 'span', children: [{ tag: 'br' }] }] }
            : { tag: 'div', children: [{ tag: 'br' }] },
        _a[2 /* BlockquoteWrapper */] = {
            tag: 'blockquote',
            style: 'margin-top:0;margin-bottom:0',
        },
        _a[3 /* CopyPasteTempDiv */] = {
            tag: 'div',
            style: 'width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text',
            attributes: {
                contenteditable: 'true',
            },
        },
        _a[4 /* BlockListItem */] = { tag: 'li', style: 'display:block' },
        _a[5 /* ContextMenuWrapper */] = {
            tag: 'div',
            style: 'position: fixed; width: 0; height: 0',
        },
        _a[6 /* ImageEditWrapper */] = {
            tag: 'span',
            style: 'max-width:100%;vertical-align:bottom',
            children: [
                {
                    tag: 'div',
                    style: 'width:100%;height:100%;position:relative;overflow:hidden',
                },
            ],
        },
        _a[7 /* TableHorizontalResizer */] = {
            tag: 'div',
            style: 'position: fixed; cursor: row-resize; user-select: none',
        },
        _a[8 /* TableVerticalResizer */] = {
            tag: 'div',
            style: 'position: fixed; cursor: col-resize; user-select: none',
        },
        _a[9 /* TableResizerLTR */] = {
            tag: 'div',
            style: 'position: fixed; cursor: nw-resize; user-select: none; border: 1px solid #808080',
        },
        _a[10 /* TableResizerRTL */] = {
            tag: 'div',
            style: 'position: fixed; cursor: ne-resize; user-select: none; border: 1px solid #808080',
        },
        _a[11 /* TableSelector */] = {
            tag: 'div',
            style: 'position: fixed; cursor: all-scroll; user-select: none; border: 1px solid #808080',
        },
        _a[12 /* EmptyLineFormatInSpan */] = {
            tag: 'div',
            children: [{ tag: 'span', children: [{ tag: 'br' }] }],
        },
        _a);
    /**
     * Create DOM element from the given CreateElementData
     * @param elementData The CreateElementData or an index of a known CreateElementData used for creating this element
     * @param document The document to create the element from
     * @returns The root DOM element just created
     */
    function createElement(elementData, document) {
        if (typeof elementData == 'number') {
            elementData = exports.KnownCreateElementData[elementData];
        }
        if (!elementData || !elementData.tag) {
            return null;
        }
        var tag = elementData.tag, namespace = elementData.namespace, className = elementData.className, style = elementData.style, dataset = elementData.dataset, attributes = elementData.attributes, children = elementData.children;
        var result = namespace
            ? document.createElementNS(namespace, tag)
            : document.createElement(tag);
        if (style) {
            result.setAttribute('style', style);
        }
        if (className) {
            result.className = className;
        }
        if (dataset && (0, safeInstanceOf_1.default)(result, 'HTMLElement')) {
            (0, getObjectKeys_1.default)(dataset).forEach(function (datasetName) {
                result.dataset[datasetName] = dataset[datasetName];
            });
        }
        if (attributes) {
            (0, getObjectKeys_1.default)(attributes).forEach(function (attrName) {
                result.setAttribute(attrName, attributes[attrName]);
            });
        }
        if (children) {
            children.forEach(function (child) {
                if (typeof child === 'string') {
                    result.appendChild(document.createTextNode(child));
                }
                else if (child) {
                    var childElement = createElement(child, document);
                    if (childElement) {
                        result.appendChild(childElement);
                    }
                }
            });
        }
        return result;
    }
    exports.default = createElement;

    }(createElement));

    var fromHtml$1 = {};

    Object.defineProperty(fromHtml$1, "__esModule", { value: true });
    var toArray_1$8 = toArray$1;
    /**
     * @deprecated
     * Creates an HTML node array from html
     * @param html the html string to create HTML elements from
     * @param ownerDocument Owner document of the result HTML elements
     * @returns An HTML node array to represent the given html string
     */
    function fromHtml(html, ownerDocument) {
        var element = ownerDocument.createElement('DIV');
        element.innerHTML = html;
        return (0, toArray_1$8.default)(element.childNodes);
    }
    fromHtml$1.default = fromHtml;

    Object.defineProperty(wrap$1, "__esModule", { value: true });
    var createElement_1$4 = createElement;
    var fromHtml_1 = fromHtml$1;
    var safeInstanceOf_1$f = safeInstanceOf$1;
    function wrap(nodes, wrapper) {
        nodes = !nodes ? [] : (0, safeInstanceOf_1$f.default)(nodes, 'Node') ? [nodes] : nodes;
        if (nodes.length == 0 || !nodes[0] || !nodes[0].ownerDocument) {
            return null;
        }
        if (!wrapper) {
            wrapper = 'div';
        }
        if (!(0, safeInstanceOf_1$f.default)(wrapper, 'HTMLElement')) {
            var document_1 = nodes[0].ownerDocument;
            if (typeof wrapper === 'string') {
                wrapper = /^\w+$/.test(wrapper)
                    ? document_1.createElement(wrapper)
                    : (0, fromHtml_1.default)(wrapper, document_1)[0]; // This will be removed in next major release
            }
            else {
                wrapper = (0, createElement_1$4.default)(wrapper, document_1);
            }
        }
        var parentNode = nodes[0].parentNode;
        if (parentNode) {
            parentNode.insertBefore(wrapper, nodes[0]);
        }
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var node = nodes_1[_i];
            wrapper.appendChild(node);
        }
        return wrapper;
    }
    wrap$1.default = wrap;

    Object.defineProperty(StartEndBlockElement$1, "__esModule", { value: true });
    var collapseNodes_1$3 = collapseNodes$1;
    var contains_1$9 = contains$1;
    var createRange_1$6 = createRange$1;
    var getTagOfNode_1$f = getTagOfNode$1;
    var isBlockElement_1$2 = isBlockElement$1;
    var isNodeAfter_1$2 = isNodeAfter$1;
    var wrap_1$4 = wrap$1;
    var splitParentNode_1$3 = splitParentNode$1;
    var STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];
    /**
     * @internal
     * This represents a block that is identified by a start and end node
     * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;
     * in that case, Hello&lt;BR&gt; is a block, World is another block
     * Such block cannot be represented by a NodeBlockElement since they don't chained up
     * to a single parent node, instead they have a start and end
     * This start and end must be in same sibling level and have same parent in DOM tree
     */
    var StartEndBlockElement = /** @class */ (function () {
        function StartEndBlockElement(rootNode, startNode, endNode) {
            this.rootNode = rootNode;
            this.startNode = startNode;
            this.endNode = endNode;
        }
        StartEndBlockElement.getBlockContext = function (node) {
            var currentNode = node;
            while (currentNode && !(0, isBlockElement_1$2.default)(currentNode)) {
                currentNode = currentNode.parentNode;
            }
            return currentNode;
        };
        /**
         * Collapse this element to a single DOM element.
         * If the content nodes are separated in different root nodes, wrap them to a single node
         * If the content nodes are included in root node with other nodes, split root node
         */
        StartEndBlockElement.prototype.collapseToSingleElement = function () {
            var nodeContext = StartEndBlockElement.getBlockContext(this.startNode);
            var nodes = nodeContext
                ? (0, collapseNodes_1$3.default)(nodeContext, this.startNode, this.endNode, true /*canSplitParent*/)
                : [];
            var blockContext = StartEndBlockElement.getBlockContext(this.startNode);
            while (nodes[0] &&
                nodes[0] != blockContext &&
                nodes[0].parentNode != this.rootNode &&
                STRUCTURE_NODE_TAGS.indexOf((0, getTagOfNode_1$f.default)(nodes[0].parentNode)) < 0) {
                var newNode = (0, splitParentNode_1$3.splitBalancedNodeRange)(nodes);
                if (newNode) {
                    nodes = [newNode];
                }
                else {
                    break;
                }
            }
            return nodes.length == 1 && (0, isBlockElement_1$2.default)(nodes[0])
                ? nodes[0]
                : (0, wrap_1$4.default)(nodes);
        };
        /**
         * Gets the start node
         */
        StartEndBlockElement.prototype.getStartNode = function () {
            return this.startNode;
        };
        /**
         * Gets the end node
         */
        StartEndBlockElement.prototype.getEndNode = function () {
            return this.endNode;
        };
        /**
         * Checks equals of two blocks
         */
        StartEndBlockElement.prototype.equals = function (blockElement) {
            return (this.startNode == blockElement.getStartNode() &&
                this.endNode == blockElement.getEndNode());
        };
        /**
         * Checks if another block is after this current
         */
        StartEndBlockElement.prototype.isAfter = function (blockElement) {
            return (0, isNodeAfter_1$2.default)(this.getStartNode(), blockElement.getEndNode());
        };
        /**
         * Checks if an Html node is contained within the block
         */
        StartEndBlockElement.prototype.contains = function (node) {
            return ((0, contains_1$9.default)(this.startNode, node, true /*treatSameNodeAsContain*/) ||
                (0, contains_1$9.default)(this.endNode, node, true /*treatSameNodeAsContain*/) ||
                ((0, isNodeAfter_1$2.default)(node, this.startNode) && (0, isNodeAfter_1$2.default)(this.endNode, node)));
        };
        /**
         * Get the text content of this block element
         */
        StartEndBlockElement.prototype.getTextContent = function () {
            var range = (0, createRange_1$6.default)(this.getStartNode(), this.getEndNode());
            return range ? range.toString() : '';
        };
        return StartEndBlockElement;
    }());
    StartEndBlockElement$1.default = StartEndBlockElement;

    Object.defineProperty(getBlockElementAtNode$1, "__esModule", { value: true });
    var collapseNodes_1$2 = collapseNodes$1;
    var contains_1$8 = contains$1;
    var getTagOfNode_1$e = getTagOfNode$1;
    var isBlockElement_1$1 = isBlockElement$1;
    var NodeBlockElement_1$1 = NodeBlockElement$1;
    var StartEndBlockElement_1 = StartEndBlockElement$1;
    /**
     * This produces a block element from a a node
     * It needs to account for various HTML structure. Examples:
     * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;
     *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;
     * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;
     *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;
     * 3) &lt;root&gt;abc&lt;/root&gt;
     *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc
     *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node
     * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;
     *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:
     *   block1: 1) abc&lt;br&gt; block2: 123
     * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;
     *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;
     * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;
     *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;
     *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456
     * In summary, given any arbitrary node (leaf), to identify the head and tail of the block, following rules need to be followed:
     * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered
     * 2) same for identifying tail
     * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node
     * @param rootNode Root node of the scope, the block element will be inside of this node
     * @param node The node to get BlockElement start from
     */
    function getBlockElementAtNode(rootNode, node) {
        if (!(0, contains_1$8.default)(rootNode, node)) {
            return null;
        }
        // Identify the containing block. This serves as ceiling for traversing down below
        // NOTE: this container block could be just the rootNode,
        // which cannot be used to create block element. We will special case handle it later on
        var containerBlockNode = StartEndBlockElement_1.default.getBlockContext(node);
        if (!containerBlockNode) {
            return null;
        }
        else if (containerBlockNode == node) {
            return new NodeBlockElement_1$1.default(containerBlockNode);
        }
        // Find the head and leaf node in the block
        var headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);
        var tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);
        // At this point, we have the head and tail of a block, here are some examples and where head and tail point to
        // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;
        // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style="font-family: Arial"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world
        // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block
        // So we shall try to collapse as much as we can to the nearest common ancestor
        var nodes = (0, collapseNodes_1$2.default)(rootNode, headNode, tailNode, false /*canSplitParent*/);
        headNode = nodes[0];
        tailNode = nodes[nodes.length - 1];
        if (headNode.parentNode != tailNode.parentNode) {
            // Un-Balanced start and end, create a start-end block
            return new StartEndBlockElement_1.default(rootNode, headNode, tailNode);
        }
        else {
            // Balanced start and end (point to same parent), need to see if further collapsing can be done
            while (!headNode.previousSibling && !tailNode.nextSibling) {
                var parentNode = headNode.parentNode;
                if (parentNode == containerBlockNode) {
                    // Has reached the container block
                    if (containerBlockNode != rootNode) {
                        // If the container block is not the root, use the container block
                        headNode = tailNode = parentNode;
                    }
                    break;
                }
                else if (parentNode && parentNode != rootNode) {
                    // Continue collapsing to parent
                    headNode = tailNode = parentNode;
                }
                else {
                    break;
                }
            }
            // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block
            return headNode == tailNode && (0, isBlockElement_1$1.default)(headNode)
                ? new NodeBlockElement_1$1.default(headNode)
                : new StartEndBlockElement_1.default(rootNode, headNode, tailNode);
        }
    }
    getBlockElementAtNode$1.default = getBlockElementAtNode;
    /**
     * Given a node and container block, identify the first/last leaf node
     * A leaf node is defined as deepest first/last node in a block
     * i.e. &lt;div&gt;&lt;span style="font-family: Arial"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block
     * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf
     * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;
     * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;
     */
    function findHeadTailLeafNode(node, containerBlockNode, isTail) {
        var result = node;
        if ((0, getTagOfNode_1$e.default)(result) == 'BR' && isTail) {
            return result;
        }
        while (result) {
            var sibling = node;
            while (node.parentNode && !(sibling = isTail ? node.nextSibling : node.previousSibling)) {
                node = node.parentNode;
                if (node == containerBlockNode) {
                    return result;
                }
            }
            while (sibling) {
                if ((0, isBlockElement_1$1.default)(sibling)) {
                    return result;
                }
                else if ((0, getTagOfNode_1$e.default)(sibling) == 'BR') {
                    return isTail ? sibling : result;
                }
                node = sibling;
                sibling = isTail ? node.firstChild : node.lastChild;
            }
            result = node;
        }
        return result;
    }

    var getFirstLastBlockElement$1 = {};

    Object.defineProperty(getFirstLastBlockElement$1, "__esModule", { value: true });
    var getBlockElementAtNode_1$8 = getBlockElementAtNode$1;
    /**
     * Get the first/last BlockElement of under the root node.
     * If no suitable BlockElement found, returns null
     * @param rootNode The root node to get BlockElement from
     * @param isFirst True to get first BlockElement, false to get last BlockElement
     */
    function getFirstLastBlockElement(rootNode, isFirst) {
        var node = rootNode;
        do {
            node = node && (isFirst ? node.firstChild : node.lastChild);
        } while (node && node.firstChild);
        return (node && (0, getBlockElementAtNode_1$8.default)(rootNode, node)) || null;
    }
    getFirstLastBlockElement$1.default = getFirstLastBlockElement;

    var ContentTraverser$1 = {};

    var BodyScoper$1 = {};

    var getInlineElementAtNode$1 = {};

    var ImageInlineElement$1 = {};

    var NodeInlineElement$1 = {};

    var applyTextStyle$1 = {};

    var splitTextNode$1 = {};

    Object.defineProperty(splitTextNode$1, "__esModule", { value: true });
    /**
     * Split a text node into two parts by an offset number, and return one of them
     * @param textNode The text node to split
     * @param offset The offset number to split at
     * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.
     * Otherwise return the second part, and the passed in textNode will become the first part
     */
    function splitTextNode(textNode, offset, returnFirstPart) {
        var _a, _b, _c;
        var firstPart = ((_a = textNode.nodeValue) === null || _a === void 0 ? void 0 : _a.substring(0, offset)) || '';
        var secondPart = ((_b = textNode.nodeValue) === null || _b === void 0 ? void 0 : _b.substring(offset)) || '';
        var newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);
        textNode.nodeValue = returnFirstPart ? secondPart : firstPart;
        (_c = textNode.parentNode) === null || _c === void 0 ? void 0 : _c.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);
        return newNode;
    }
    splitTextNode$1.default = splitTextNode;

    var getLeafSibling$1 = {};

    var shouldSkipNode$1 = {};

    var getComputedStyles$1 = {};

    Object.defineProperty(getComputedStyles$1, "__esModule", { value: true });
    getComputedStyles$1.getComputedStyle = void 0;
    var findClosestElementAncestor_1$4 = findClosestElementAncestor$1;
    /**
     * Get computed styles of a node
     * @param node The node to get computed styles from
     * @param styleNames Names of style to get, can be a single name or an array.
     * Default value is font-family, font-size, color, background-color
     * @returns An array of the computed styles
     */
    function getComputedStyles(node, styleNames) {
        if (styleNames === void 0) { styleNames = ['font-family', 'font-size', 'color', 'background-color']; }
        var element = (0, findClosestElementAncestor_1$4.default)(node);
        var result = [];
        styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];
        if (element) {
            var win = element.ownerDocument.defaultView || window;
            var styles = win.getComputedStyle(element);
            if (styles) {
                for (var _i = 0, styleNames_1 = styleNames; _i < styleNames_1.length; _i++) {
                    var style = styleNames_1[_i];
                    var value = styles.getPropertyValue(style) || '';
                    value = style != 'font-family' ? value.toLowerCase() : value;
                    value = style == 'font-size' ? px2Pt(value) : value;
                    result.push(value);
                }
            }
        }
        return result;
    }
    getComputedStyles$1.default = getComputedStyles;
    /**
     * A shortcut for getComputedStyles() when only one style is to be retrieved
     * @param node The node to get style from
     * @param styleName The style name
     * @returns The style value
     */
    function getComputedStyle$1(node, styleName) {
        return getComputedStyles(node, styleName)[0] || '';
    }
    getComputedStyles$1.getComputedStyle = getComputedStyle$1;
    function px2Pt(px) {
        if (px && px.indexOf('px') == px.length - 2) {
            // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value
            // So add 0.05 to fix it
            return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';
        }
        return px;
    }

    Object.defineProperty(shouldSkipNode$1, "__esModule", { value: true });
    var getTagOfNode_1$d = getTagOfNode$1;
    var getComputedStyles_1$1 = getComputedStyles$1;
    var CRLF = /^[\r\n]+$/g;
    var CRLF_SPACE = /[\t\r\n\u0020\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)
    /**
     * @internal
     * Skip a node when any of following conditions are true
     * - it is neither Element nor Text
     * - it is a text node but is empty
     * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)
     * - has a display:none
     * - it is just <div></div>
     * @param node The node to check
     * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.
     * If the value of a node value is only space, set this to true will treat this node can be skipped.
     * Default value is false
     */
    function shouldSkipNode(node, ignoreSpace) {
        if (node.nodeType == 3 /* Text */) {
            if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {
                return true;
            }
            else if (ignoreSpace && node.nodeValue.replace(CRLF_SPACE, '') == '') {
                return true;
            }
            else {
                return false;
            }
        }
        else if (node.nodeType == 1 /* Element */) {
            if ((0, getComputedStyles_1$1.getComputedStyle)(node, 'display') == 'none') {
                return true;
            }
            var tag = (0, getTagOfNode_1$d.default)(node);
            if (tag == 'DIV' || tag == 'SPAN') {
                // Empty SPAN/DIV or SPAN/DIV with only meaningless children is meaningless,
                // because it can render nothing. If we keep them here, there may be unexpected
                // LI elements added for those meaningless nodes.
                for (var child = node.firstChild; !!child; child = child.nextSibling) {
                    if (!shouldSkipNode(child, ignoreSpace)) {
                        return false;
                    }
                }
                return true;
            }
            else {
                // There may still be other cases that the node is not meaningful.
                // We can add those cases here once we hit them.
                return false;
            }
        }
        else {
            return true;
        }
    }
    shouldSkipNode$1.default = shouldSkipNode;

    Object.defineProperty(getLeafSibling$1, "__esModule", { value: true });
    getLeafSibling$1.getPreviousLeafSibling = getLeafSibling$1.getNextLeafSibling = getLeafSibling$1.getLeafSibling = void 0;
    var contains_1$7 = contains$1;
    var getTagOfNode_1$c = getTagOfNode$1;
    var shouldSkipNode_1$4 = shouldSkipNode$1;
    /**
     * @internal
     * This walks forwards/backwards DOM tree to get next meaningful node
     * @param rootNode Root node to scope the leaf sibling node
     * @param startNode current node to get sibling node from
     * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node
     * @param skipTags (Optional) tags that child elements will be skipped
     * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped
     */
    function getLeafSibling(rootNode, startNode, isNext, skipTags, ignoreSpace) {
        var result = null;
        var getSibling = isNext
            ? function (node) { return (node === null || node === void 0 ? void 0 : node.nextSibling) || null; }
            : function (node) { return (node === null || node === void 0 ? void 0 : node.previousSibling) || null; };
        var getChild = isNext ? function (node) { return node.firstChild; } : function (node) { return node.lastChild; };
        if ((0, contains_1$7.default)(rootNode, startNode)) {
            var curNode = startNode;
            var shouldContinue = true;
            while (shouldContinue) {
                // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent
                // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)
                var parentNode = (curNode === null || curNode === void 0 ? void 0 : curNode.parentNode) || null;
                curNode = getSibling(curNode);
                while (!curNode && parentNode != rootNode) {
                    curNode = getSibling(parentNode);
                    parentNode = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.parentNode) || null;
                }
                // Now traverse down to get first/last child
                while (curNode &&
                    (!skipTags || skipTags.indexOf((0, getTagOfNode_1$c.default)(curNode)) < 0) &&
                    getChild(curNode)) {
                    curNode = getChild(curNode);
                }
                // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so
                shouldContinue = !!curNode && (0, shouldSkipNode_1$4.default)(curNode, ignoreSpace);
                if (!shouldContinue) {
                    // Found a good leaf node, assign and exit
                    result = curNode;
                    break;
                }
            }
        }
        return result;
    }
    getLeafSibling$1.getLeafSibling = getLeafSibling;
    /**
     * This walks forwards DOM tree to get next meaningful node
     * @param rootNode Root node to scope the leaf sibling node
     * @param startNode current node to get sibling node from
     * @param skipTags (Optional) tags that child elements will be skipped
     */
    function getNextLeafSibling(rootNode, startNode, skipTags) {
        return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);
    }
    getLeafSibling$1.getNextLeafSibling = getNextLeafSibling;
    /**
     * This walks backwards DOM tree to get next meaningful node
     * @param rootNode Root node to scope the leaf sibling node
     * @param startNode current node to get sibling node from
     * @param skipTags (Optional) tags that child elements will be skipped
     */
    function getPreviousLeafSibling(rootNode, startNode, skipTags) {
        return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);
    }
    getLeafSibling$1.getPreviousLeafSibling = getPreviousLeafSibling;

    Object.defineProperty(applyTextStyle$1, "__esModule", { value: true });
    var getTagOfNode_1$b = getTagOfNode$1;
    var Position_1$b = Position$1;
    var splitTextNode_1$2 = splitTextNode$1;
    var wrap_1$3 = wrap$1;
    var getLeafSibling_1$7 = getLeafSibling$1;
    var splitParentNode_1$2 = splitParentNode$1;
    var safeInstanceOf_1$e = safeInstanceOf$1;
    var STYLET_AGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL,SUP,SUB'.split(',');
    /**
     * Apply style using a styler function to the given container node in the given range
     * @param container The container node to apply style to
     * @param styler The styler function
     * @param fromPosition From position
     * @param toPosition To position
     */
    function applyTextStyle(container, styler, from, to) {
        if (from === void 0) { from = new Position_1$b.default(container, 0 /* Begin */).normalize(); }
        if (to === void 0) { to = new Position_1$b.default(container, -1 /* End */).normalize(); }
        var formatNodes = [];
        var fromPosition = from;
        var toPosition = to;
        while (fromPosition && toPosition && toPosition.isAfter(fromPosition)) {
            var formatNode = fromPosition.node;
            var parentTag = (0, getTagOfNode_1$b.default)(formatNode.parentNode);
            // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node
            var nextNode = (0, getLeafSibling_1$7.getNextLeafSibling)(container, formatNode);
            if (formatNode.nodeType == 3 /* Text */ && ['TR', 'TABLE'].indexOf(parentTag) < 0) {
                if (formatNode == toPosition.node && !toPosition.isAtEnd) {
                    formatNode = (0, splitTextNode_1$2.default)(formatNode, toPosition.offset, true /*returnFirstPart*/);
                }
                if (fromPosition.offset > 0) {
                    formatNode = (0, splitTextNode_1$2.default)(formatNode, fromPosition.offset, false /*returnFirstPart*/);
                }
                formatNodes.push(formatNode);
            }
            fromPosition = nextNode && new Position_1$b.default(nextNode, 0 /* Begin */);
        }
        if (formatNodes.length > 0) {
            if (formatNodes.every(function (node) { return node.parentNode == formatNodes[0].parentNode; })) {
                var newNode_1 = formatNodes.shift();
                formatNodes.forEach(function (node) {
                    var _a;
                    var newNodeValue = (newNode_1.nodeValue || '') + (node.nodeValue || '');
                    newNode_1.nodeValue = newNodeValue;
                    (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
                });
                formatNodes = [newNode_1];
            }
            formatNodes.forEach(function (startingNode) {
                // When apply style within style tags like B/I/U/..., we split the tag and apply outside them
                // So that the inner style tag such as U, STRIKE can inherit the style we added
                var node = startingNode;
                while (node &&
                    (0, getTagOfNode_1$b.default)(node) != 'SPAN' &&
                    STYLET_AGS.indexOf((0, getTagOfNode_1$b.default)(node.parentNode)) >= 0) {
                    callStylerWithInnerNode(node, styler);
                    node = (0, splitParentNode_1$2.splitBalancedNodeRange)(node);
                }
                if (node && (0, getTagOfNode_1$b.default)(node) != 'SPAN') {
                    callStylerWithInnerNode(node, styler);
                    node = (0, wrap_1$3.default)(node, 'SPAN');
                }
                if ((0, safeInstanceOf_1$e.default)(node, 'HTMLElement')) {
                    styler(node);
                }
            });
        }
    }
    applyTextStyle$1.default = applyTextStyle;
    function callStylerWithInnerNode(node, styler) {
        if (node && node.nodeType == 1 /* Element */) {
            styler(node, true /*isInnerNode*/);
        }
    }

    Object.defineProperty(NodeInlineElement$1, "__esModule", { value: true });
    var applyTextStyle_1$1 = applyTextStyle$1;
    var isNodeAfter_1$1 = isNodeAfter$1;
    var Position_1$a = Position$1;
    /**
     * This presents an inline element that can be represented by a single html node.
     * This serves as base for most inline element as it contains most implementation
     * of all operations that can happen on an inline element. Other sub inline elements mostly
     * just identify themselves for a certain type
     */
    var NodeInlineElement = /** @class */ (function () {
        function NodeInlineElement(containerNode, parentBlock) {
            this.containerNode = containerNode;
            this.parentBlock = parentBlock;
        }
        /**
         * The text content for this inline element
         */
        NodeInlineElement.prototype.getTextContent = function () {
            // nodeValue is better way to retrieve content for a text. Others, just use textContent
            return ((this.containerNode.nodeType == 3 /* Text */
                ? this.containerNode.nodeValue
                : this.containerNode.textContent) || '');
        };
        /**
         * Get the container node
         */
        NodeInlineElement.prototype.getContainerNode = function () {
            return this.containerNode;
        };
        // Get the parent block
        NodeInlineElement.prototype.getParentBlock = function () {
            return this.parentBlock;
        };
        /**
         * Get the start position of the inline element
         */
        NodeInlineElement.prototype.getStartPosition = function () {
            // For a position, we always want it to point to a leaf node
            // We should try to go get the lowest first child node from the container
            return new Position_1$a.default(this.containerNode, 0).normalize();
        };
        /**
         * Get the end position of the inline element
         */
        NodeInlineElement.prototype.getEndPosition = function () {
            // For a position, we always want it to point to a leaf node
            // We should try to go get the lowest last child node from the container
            return new Position_1$a.default(this.containerNode, -1 /* End */).normalize();
        };
        /**
         * Checks if this inline element is a textual inline element
         */
        NodeInlineElement.prototype.isTextualInlineElement = function () {
            return this.containerNode && this.containerNode.nodeType == 3 /* Text */;
        };
        /**
         * Checks if an inline element is after the current inline element
         */
        NodeInlineElement.prototype.isAfter = function (inlineElement) {
            return inlineElement && (0, isNodeAfter_1$1.default)(this.containerNode, inlineElement.getContainerNode());
        };
        /**
         * Checks if the given position is contained in the inline element
         */
        NodeInlineElement.prototype.contains = function (pos) {
            var start = this.getStartPosition();
            var end = this.getEndPosition();
            return pos && pos.isAfter(start) && end.isAfter(pos);
        };
        /**
         * Apply inline style to an inline element
         */
        NodeInlineElement.prototype.applyStyle = function (styler) {
            (0, applyTextStyle_1$1.default)(this.containerNode, styler);
        };
        return NodeInlineElement;
    }());
    NodeInlineElement$1.default = NodeInlineElement;

    var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(ImageInlineElement$1, "__esModule", { value: true });
    var NodeInlineElement_1$2 = NodeInlineElement$1;
    /**
     * This is an inline element representing an Html image
     */
    var ImageInlineElement = /** @class */ (function (_super) {
        __extends$3(ImageInlineElement, _super);
        function ImageInlineElement(containerNode, parentBlock) {
            return _super.call(this, containerNode, parentBlock) || this;
        }
        return ImageInlineElement;
    }(NodeInlineElement_1$2.default));
    ImageInlineElement$1.default = ImageInlineElement;

    var LinkInlineElement$1 = {};

    var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(LinkInlineElement$1, "__esModule", { value: true });
    var NodeInlineElement_1$1 = NodeInlineElement$1;
    /**
     * This is inline element presenting an html hyperlink
     */
    var LinkInlineElement = /** @class */ (function (_super) {
        __extends$2(LinkInlineElement, _super);
        function LinkInlineElement(containerNode, parentBlock) {
            return _super.call(this, containerNode, parentBlock) || this;
        }
        return LinkInlineElement;
    }(NodeInlineElement_1$1.default));
    LinkInlineElement$1.default = LinkInlineElement;

    Object.defineProperty(getInlineElementAtNode$1, "__esModule", { value: true });
    var getBlockElementAtNode_1$7 = getBlockElementAtNode$1;
    var getTagOfNode_1$a = getTagOfNode$1;
    var ImageInlineElement_1 = ImageInlineElement$1;
    var LinkInlineElement_1$1 = LinkInlineElement$1;
    var NodeInlineElement_1 = NodeInlineElement$1;
    var safeInstanceOf_1$d = safeInstanceOf$1;
    function getInlineElementAtNode(parent, node) {
        // An inline element has to be in a block element, get the block first and then resolve through the factory
        var parentBlock = (0, safeInstanceOf_1$d.default)(parent, 'Node') ? (0, getBlockElementAtNode_1$7.default)(parent, node) : parent;
        return node && parentBlock && resolveInlineElement(node, parentBlock);
    }
    getInlineElementAtNode$1.default = getInlineElementAtNode;
    /**
     * Resolve an inline element by a leaf node
     * @param node The node to resolve from
     * @param parentBlock The parent block element
     */
    function resolveInlineElement(node, parentBlock) {
        var nodeChain = [node];
        for (var parent_1 = node.parentNode; parent_1 && parentBlock.contains(parent_1); parent_1 = parent_1.parentNode) {
            nodeChain.push(parent_1);
        }
        var inlineElement;
        for (var i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {
            var currentNode = nodeChain[i];
            var tag = (0, getTagOfNode_1$a.default)(currentNode);
            if (tag == 'A') {
                inlineElement = new LinkInlineElement_1$1.default(currentNode, parentBlock);
            }
            else if (tag == 'IMG') {
                inlineElement = new ImageInlineElement_1.default(currentNode, parentBlock);
            }
        }
        return inlineElement || new NodeInlineElement_1.default(node, parentBlock);
    }

    var getFirstLastInlineElement = {};

    var getLeafNode$1 = {};

    Object.defineProperty(getLeafNode$1, "__esModule", { value: true });
    getLeafNode$1.getLastLeafNode = getLeafNode$1.getFirstLeafNode = void 0;
    var shouldSkipNode_1$3 = shouldSkipNode$1;
    var getLeafSibling_1$6 = getLeafSibling$1;
    /**
     * Get first/last leaf node of the given root node.
     * @param rootNode Root node to get leaf node from
     * @param isFirst True to get first leaf node, false to get last leaf node
     */
    function getLeafNode(rootNode, isFirst) {
        var getChild = function (node) { return (isFirst ? node.firstChild : node.lastChild); };
        var result = getChild(rootNode);
        while (result && getChild(result)) {
            result = getChild(result);
        }
        if (result && (0, shouldSkipNode_1$3.default)(result)) {
            result = (0, getLeafSibling_1$6.getLeafSibling)(rootNode, result, isFirst);
        }
        return result;
    }
    /**
     * Get the first meaningful leaf node
     * @param rootNode Root node to get leaf node from
     */
    function getFirstLeafNode(rootNode) {
        return getLeafNode(rootNode, true /*isFirst*/);
    }
    getLeafNode$1.getFirstLeafNode = getFirstLeafNode;
    /**
     * Get the last meaningful leaf node
     * @param rootNode Root node to get leaf node from
     */
    function getLastLeafNode(rootNode) {
        return getLeafNode(rootNode, false /*isFirst*/);
    }
    getLeafNode$1.getLastLeafNode = getLastLeafNode;

    Object.defineProperty(getFirstLastInlineElement, "__esModule", { value: true });
    getFirstLastInlineElement.getLastInlineElement = getFirstLastInlineElement.getFirstInlineElement = void 0;
    var getInlineElementAtNode_1$4 = getInlineElementAtNode$1;
    var getLeafNode_1 = getLeafNode$1;
    /**
     * @internal
     * Get the first inline element inside the given node
     */
    function getFirstInlineElement(rootNode) {
        // getFirstLeafNode can return null for empty container
        // do check null before passing on to get inline from the node
        var node = (0, getLeafNode_1.getFirstLeafNode)(rootNode);
        return node ? (0, getInlineElementAtNode_1$4.default)(rootNode, node) : null;
    }
    getFirstLastInlineElement.getFirstInlineElement = getFirstInlineElement;
    /**
     * @internal
     * Get the last inline element inside the given node
     */
    function getLastInlineElement(rootNode) {
        // getLastLeafNode can return null for empty container
        // do check null before passing on to get inline from the node
        var node = (0, getLeafNode_1.getLastLeafNode)(rootNode);
        return node ? (0, getInlineElementAtNode_1$4.default)(rootNode, node) : null;
    }
    getFirstLastInlineElement.getLastInlineElement = getLastInlineElement;

    Object.defineProperty(BodyScoper$1, "__esModule", { value: true });
    var contains_1$6 = contains$1;
    var getBlockElementAtNode_1$6 = getBlockElementAtNode$1;
    var getFirstLastBlockElement_1 = getFirstLastBlockElement$1;
    var getInlineElementAtNode_1$3 = getInlineElementAtNode$1;
    var getFirstLastInlineElement_1$1 = getFirstLastInlineElement;
    /**
     * @internal
     * provides a scope object for traversing the entire editor body starting from the beginning
     */
    var BodyScoper = /** @class */ (function () {
        /**
         * Construct a new instance of BodyScoper class
         * @param rootNode Root node of the body
         * @param startNode The node to start from. If not passed, it will start from the beginning of the body
         */
        function BodyScoper(rootNode, startNode) {
            this.rootNode = rootNode;
            this.startNode = (0, contains_1$6.default)(rootNode, startNode) ? startNode : null;
        }
        /**
         * Get the start block element
         */
        BodyScoper.prototype.getStartBlockElement = function () {
            return this.startNode
                ? (0, getBlockElementAtNode_1$6.default)(this.rootNode, this.startNode)
                : (0, getFirstLastBlockElement_1.default)(this.rootNode, true /*isFirst*/);
        };
        /**
         * Get the start inline element
         */
        BodyScoper.prototype.getStartInlineElement = function () {
            return this.startNode
                ? (0, getInlineElementAtNode_1$3.default)(this.rootNode, this.startNode)
                : (0, getFirstLastInlineElement_1$1.getFirstInlineElement)(this.rootNode);
        };
        /**
         * Since the scope is global, all blocks under the root node are in scope
         */
        BodyScoper.prototype.isBlockInScope = function (blockElement) {
            return (0, contains_1$6.default)(this.rootNode, blockElement.getStartNode());
        };
        /**
         * Since we're at body scope, inline elements never need to be trimmed
         */
        BodyScoper.prototype.trimInlineElement = function (inlineElement) {
            return inlineElement;
        };
        return BodyScoper;
    }());
    BodyScoper$1.default = BodyScoper;

    var EmptyInlineElement$1 = {};

    Object.defineProperty(EmptyInlineElement$1, "__esModule", { value: true });
    /**
     * @internal
     * Represents an empty InlineElement.
     * This is used for ContentTraverser internally only.
     * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element
     */
    var EmptyInlineElement = /** @class */ (function () {
        function EmptyInlineElement(position, parentBlock) {
            this.position = position;
            this.parentBlock = parentBlock;
        }
        /**
         * Get the text content of this inline element
         */
        EmptyInlineElement.prototype.getTextContent = function () {
            return '';
        };
        /**
         * Get the container node of this inline element
         */
        EmptyInlineElement.prototype.getContainerNode = function () {
            return this.position.node;
        };
        /**
         * Get the parent block element of this inline element
         */
        EmptyInlineElement.prototype.getParentBlock = function () {
            return this.parentBlock;
        };
        /**
         * Get the start position of this inline element
         */
        EmptyInlineElement.prototype.getStartPosition = function () {
            return this.position;
        };
        /**
         * Get the end position of this inline element
         */
        EmptyInlineElement.prototype.getEndPosition = function () {
            return this.position;
        };
        /**
         * Checks if the given inline element is after this inline element
         */
        EmptyInlineElement.prototype.isAfter = function (inlineElement) {
            return inlineElement && this.position.isAfter(inlineElement.getEndPosition());
        };
        /**
         * Checks if this inline element is a textual inline element
         */
        EmptyInlineElement.prototype.isTextualInlineElement = function () {
            return false;
        };
        /**
         * Checks if the given editor position is contained in this inline element
         */
        EmptyInlineElement.prototype.contains = function (position) {
            return false;
        };
        /**
         * Apply inline style to a region of an inline element.
         */
        EmptyInlineElement.prototype.applyStyle = function (styler) { };
        return EmptyInlineElement;
    }());
    EmptyInlineElement$1.default = EmptyInlineElement;

    var PartialInlineElement$1 = {};

    Object.defineProperty(PartialInlineElement$1, "__esModule", { value: true });
    var applyTextStyle_1 = applyTextStyle$1;
    var createRange_1$5 = createRange$1;
    var Position_1$9 = Position$1;
    var getLeafSibling_1$5 = getLeafSibling$1;
    /**
     * This is a special version of inline element that identifies a section of an inline element
     * We often have the need to cut an inline element in half and perform some operation only on half of an inline element
     * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element
     * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter
     * It also offers some special methods that others don't have, i.e. nextInlineElement etc.
     */
    var PartialInlineElement = /** @class */ (function () {
        function PartialInlineElement(inlineElement, start, end) {
            if (start === void 0) { start = null; }
            if (end === void 0) { end = null; }
            this.inlineElement = inlineElement;
            this.start = start;
            this.end = end;
        }
        /**
         * Get the full inline element that this partial inline decorates
         */
        PartialInlineElement.prototype.getDecoratedInline = function () {
            return this.inlineElement;
        };
        /**
         * Gets the container node
         */
        PartialInlineElement.prototype.getContainerNode = function () {
            return this.inlineElement.getContainerNode();
        };
        /**
         * Gets the parent block
         */
        PartialInlineElement.prototype.getParentBlock = function () {
            return this.inlineElement.getParentBlock();
        };
        /**
         * Gets the text content
         */
        PartialInlineElement.prototype.getTextContent = function () {
            var range = (0, createRange_1$5.default)(this.getStartPosition(), this.getEndPosition());
            return range.toString();
        };
        /**
         * Get start position of this inline element.
         */
        PartialInlineElement.prototype.getStartPosition = function () {
            return this.start || this.inlineElement.getStartPosition();
        };
        /**
         * Get end position of this inline element.
         */
        PartialInlineElement.prototype.getEndPosition = function () {
            return this.end || this.inlineElement.getEndPosition();
        };
        Object.defineProperty(PartialInlineElement.prototype, "nextInlineElement", {
            /**
             * Get next partial inline element if it is not at the end boundary yet
             */
            get: function () {
                return this.end ? new PartialInlineElement(this.inlineElement, this.end) : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PartialInlineElement.prototype, "previousInlineElement", {
            /**
             * Get previous partial inline element if it is not at the begin boundary yet
             */
            get: function () {
                return this.start
                    ? new PartialInlineElement(this.inlineElement, undefined, this.start)
                    : null;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Checks if it contains a position
         */
        PartialInlineElement.prototype.contains = function (pos) {
            return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);
        };
        /**
         * Checks if this inline element is a textual inline element
         */
        PartialInlineElement.prototype.isTextualInlineElement = function () {
            return this.inlineElement && this.inlineElement.isTextualInlineElement();
        };
        /**
         * Check if this inline element is after the other inline element
         */
        PartialInlineElement.prototype.isAfter = function (inlineElement) {
            var thisStart = this.getStartPosition();
            var otherEnd = inlineElement && inlineElement.getEndPosition();
            return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));
        };
        /**
         * apply style
         */
        PartialInlineElement.prototype.applyStyle = function (styler) {
            var from = this.getStartPosition().normalize();
            var to = this.getEndPosition().normalize();
            var container = this.getContainerNode();
            if (from.isAtEnd) {
                var nextNode = (0, getLeafSibling_1$5.getNextLeafSibling)(container, from.node);
                from = nextNode ? new Position_1$9.default(nextNode, 0 /* Begin */) : null;
            }
            if (to.offset == 0) {
                var previousNode = (0, getLeafSibling_1$5.getPreviousLeafSibling)(container, to.node);
                to = previousNode ? new Position_1$9.default(previousNode, -1 /* End */) : null;
            }
            (0, applyTextStyle_1.default)(container, styler, from || undefined, to || undefined);
        };
        return PartialInlineElement;
    }());
    PartialInlineElement$1.default = PartialInlineElement;

    var SelectionBlockScoper$1 = {};

    var getInlineElementBeforeAfter$1 = {};

    Object.defineProperty(getInlineElementBeforeAfter$1, "__esModule", { value: true });
    getInlineElementBeforeAfter$1.getInlineElementBeforeAfter = getInlineElementBeforeAfter$1.getInlineElementAfter = getInlineElementBeforeAfter$1.getInlineElementBefore = void 0;
    var getInlineElementAtNode_1$2 = getInlineElementAtNode$1;
    var PartialInlineElement_1$2 = PartialInlineElement$1;
    var shouldSkipNode_1$2 = shouldSkipNode$1;
    var getLeafSibling_1$4 = getLeafSibling$1;
    /**
     * @internal
     * Get inline element before a position
     * This is mostly used when we want to get the inline element before selection/cursor
     * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)
     * in this case, we only want to return what is before cursor (a partial of an inline) to indicate
     * that we're in middle.
     * @param root Root node of current scope, use for create InlineElement
     * @param position The position to get InlineElement before
     */
    function getInlineElementBefore(root, position) {
        return getInlineElementBeforeAfter(root, position, false /*isAfter*/);
    }
    getInlineElementBeforeAfter$1.getInlineElementBefore = getInlineElementBefore;
    /**
     * @internal
     * Get inline element after a position
     * This is mostly used when we want to get the inline element after selection/cursor
     * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)
     * in this case, we only want to return what is before cursor (a partial of an inline) to indicate
     * that we're in middle.
     * @param root Root node of current scope, use for create InlineElement
     * @param position The position to get InlineElement after
     */
    function getInlineElementAfter(root, position) {
        return getInlineElementBeforeAfter(root, position, true /*isAfter*/);
    }
    getInlineElementBeforeAfter$1.getInlineElementAfter = getInlineElementAfter;
    /**
     * @internal
     */
    function getInlineElementBeforeAfter(root, position, isAfter) {
        if (!root || !position || !position.node) {
            return null;
        }
        position = position.normalize();
        var offset = position.offset, isAtEnd = position.isAtEnd;
        var node = position.node;
        var isPartial = false;
        if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {
            node = (0, getLeafSibling_1$4.getLeafSibling)(root, node, isAfter);
        }
        else if (node.nodeType == 3 /* Text */ &&
            ((!isAfter && !isAtEnd) || (isAfter && offset > 0))) {
            isPartial = true;
        }
        if (node && (0, shouldSkipNode_1$2.default)(node)) {
            node = (0, getLeafSibling_1$4.getLeafSibling)(root, node, isAfter);
        }
        var inlineElement = (0, getInlineElementAtNode_1$2.default)(root, node);
        if (inlineElement && (isPartial || inlineElement.contains(position))) {
            inlineElement = isAfter
                ? new PartialInlineElement_1$2.default(inlineElement, position, undefined)
                : new PartialInlineElement_1$2.default(inlineElement, undefined, position);
        }
        return inlineElement;
    }
    getInlineElementBeforeAfter$1.getInlineElementBeforeAfter = getInlineElementBeforeAfter;

    Object.defineProperty(SelectionBlockScoper$1, "__esModule", { value: true });
    var EmptyInlineElement_1$1 = EmptyInlineElement$1;
    var getBlockElementAtNode_1$5 = getBlockElementAtNode$1;
    var getInlineElementAtNode_1$1 = getInlineElementAtNode$1;
    var NodeBlockElement_1 = NodeBlockElement$1;
    var Position_1$8 = Position$1;
    var safeInstanceOf_1$c = safeInstanceOf$1;
    var getInlineElementBeforeAfter_1$2 = getInlineElementBeforeAfter$1;
    var getFirstLastInlineElement_1 = getFirstLastInlineElement;
    /**
     * @internal
     * This provides traversing content in a selection start block
     * This is commonly used for those cursor context sensitive plugin,
     * they want to know text being typed at cursor
     * This provides a scope for parsing from cursor position up to begin of the selection block
     */
    var SelectionBlockScoper = /** @class */ (function () {
        /**
         * Create a new instance of SelectionBlockScoper class
         * @param rootNode The root node of the whole scope
         * @param position Position of the selection start
         * @param startFrom Where to start, can be Begin, End, SelectionStart
         */
        function SelectionBlockScoper(rootNode, position, startFrom) {
            this.rootNode = rootNode;
            this.startFrom = startFrom;
            if ((0, safeInstanceOf_1$c.default)(position, 'Range')) {
                position = Position_1$8.default.getStart(position);
            }
            this.position = position.normalize();
            this.block = (0, getBlockElementAtNode_1$5.default)(this.rootNode, this.position.node);
        }
        /**
         * Get the start block element
         */
        SelectionBlockScoper.prototype.getStartBlockElement = function () {
            return this.block;
        };
        /**
         * Get the start inline element
         * The start inline refers to inline before the selection start
         *  The reason why we choose the one before rather after is, when cursor is at the end of a paragraph,
         * the one after likely will point to inline in next paragraph which may be null if the cursor is at bottom of editor
         */
        SelectionBlockScoper.prototype.getStartInlineElement = function () {
            if (this.block) {
                switch (this.startFrom) {
                    case 0 /* Begin */:
                    case 1 /* End */:
                    case 2 /* DomEnd */:
                        return getFirstLastInlineElementFromBlockElement(this.block, this.startFrom == 0 /* Begin */);
                    case 3 /* SelectionStart */:
                        // Get the inline before selection start point, and ensure it falls in the selection block
                        var startInline = (0, getInlineElementBeforeAfter_1$2.getInlineElementAfter)(this.rootNode, this.position);
                        return startInline && this.block.contains(startInline.getContainerNode())
                            ? startInline
                            : new EmptyInlineElement_1$1.default(this.position, this.block);
                }
            }
            return null;
        };
        /**
         * Check if the given block element is in current scope
         * @param blockElement The block element to check
         */
        SelectionBlockScoper.prototype.isBlockInScope = function (blockElement) {
            return this.block && blockElement ? this.block.equals(blockElement) : false;
        };
        /**
         * Trim the incoming inline element, and return an inline element
         * This just tests and return the inline element if it is in block
         * This is a block scoper, which is not like selection scoper where it may cut an inline element in half
         * A block scoper does not cut an inline in half
         */
        SelectionBlockScoper.prototype.trimInlineElement = function (inlineElement) {
            return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())
                ? inlineElement
                : null;
        };
        return SelectionBlockScoper;
    }());
    SelectionBlockScoper$1.default = SelectionBlockScoper;
    /**
     * Get first/last InlineElement of the given BlockElement
     * @param block The BlockElement to get InlineElement from
     * @param isFirst True to get first InlineElement, false to get last InlineElement
     */
    function getFirstLastInlineElementFromBlockElement(block, isFirst) {
        if (block instanceof NodeBlockElement_1.default) {
            var blockNode = block.getStartNode();
            return isFirst ? (0, getFirstLastInlineElement_1.getFirstInlineElement)(blockNode) : (0, getFirstLastInlineElement_1.getLastInlineElement)(blockNode);
        }
        else {
            return (0, getInlineElementAtNode_1$1.default)(block, isFirst ? block.getStartNode() : block.getEndNode());
        }
    }

    var SelectionScoper$1 = {};

    Object.defineProperty(SelectionScoper$1, "__esModule", { value: true });
    var getBlockElementAtNode_1$4 = getBlockElementAtNode$1;
    var PartialInlineElement_1$1 = PartialInlineElement$1;
    var Position_1$7 = Position$1;
    var getInlineElementBeforeAfter_1$1 = getInlineElementBeforeAfter$1;
    /**
     * @internal
     * This is selection scoper that provide a start inline as the start of the selection
     * and checks if a block falls in the selection (isBlockInScope)
     * last trimInlineElement to trim any inline element to return a partial that falls in the selection
     */
    var SelectionScoper = /** @class */ (function () {
        /**
         * Create a new instance of SelectionScoper class
         * @param rootNode The root node of the content
         * @param range The selection range to scope to
         */
        function SelectionScoper(rootNode, range) {
            this.rootNode = rootNode;
            this.startBlock = null;
            this.startInline = null;
            this.start = Position_1$7.default.getStart(range).normalize();
            this.end = Position_1$7.default.getEnd(range).normalize();
        }
        /**
         * Provide a start block as the first block after the cursor
         */
        SelectionScoper.prototype.getStartBlockElement = function () {
            if (!this.startBlock) {
                this.startBlock = (0, getBlockElementAtNode_1$4.default)(this.rootNode, this.start.node);
            }
            return this.startBlock;
        };
        /**
         * Provide a start inline as the first inline after the cursor
         */
        SelectionScoper.prototype.getStartInlineElement = function () {
            if (!this.startInline) {
                this.startInline = this.trimInlineElement((0, getInlineElementBeforeAfter_1$1.getInlineElementAfter)(this.rootNode, this.start));
            }
            return this.startInline;
        };
        /**
         * Checks if a block completely falls in the selection
         * @param block The BlockElement to check
         */
        SelectionScoper.prototype.isBlockInScope = function (block) {
            if (!block) {
                return false;
            }
            var inScope = false;
            var selStartBlock = this.getStartBlockElement();
            if (this.start.equalTo(this.end)) {
                inScope = !!selStartBlock && selStartBlock.equals(block);
            }
            else {
                var selEndBlock = (0, getBlockElementAtNode_1$4.default)(this.rootNode, this.end.node);
                // There are three cases that are considered as "block in scope"
                // 1) The start of selection falls on the block
                // 2) The end of selection falls on the block
                // 3) the block falls in-between selection start and end
                inScope =
                    !!selStartBlock &&
                        !!selEndBlock &&
                        (block.equals(selStartBlock) ||
                            block.equals(selEndBlock) ||
                            (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));
            }
            return inScope;
        };
        /**
         * Trim an incoming inline. If it falls completely outside selection, return null
         * otherwise return a partial that represents the portion that falls in the selection
         * @param inline The InlineElement to check
         */
        SelectionScoper.prototype.trimInlineElement = function (inline) {
            if (!inline || this.start.equalTo(this.end)) {
                return null;
            }
            // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon
            var start = inline.getStartPosition();
            var end = inline.getEndPosition();
            if (start.isAfter(this.end) || this.start.isAfter(end)) {
                return null;
            }
            var startPartial = false;
            var endPartial = false;
            if (this.start.isAfter(start)) {
                start = this.start;
                startPartial = true;
            }
            if (end.isAfter(this.end)) {
                end = this.end;
                endPartial = true;
            }
            return start.isAfter(end) || start.equalTo(end)
                ? null
                : startPartial || endPartial
                    ? new PartialInlineElement_1$1.default(inline, startPartial ? start : undefined, endPartial ? end : undefined)
                    : inline;
        };
        return SelectionScoper;
    }());
    SelectionScoper$1.default = SelectionScoper;

    Object.defineProperty(ContentTraverser$1, "__esModule", { value: true });
    var BodyScoper_1 = BodyScoper$1;
    var EmptyInlineElement_1 = EmptyInlineElement$1;
    var getBlockElementAtNode_1$3 = getBlockElementAtNode$1;
    var getInlineElementAtNode_1 = getInlineElementAtNode$1;
    var PartialInlineElement_1 = PartialInlineElement$1;
    var SelectionBlockScoper_1 = SelectionBlockScoper$1;
    var SelectionScoper_1 = SelectionScoper$1;
    var getInlineElementBeforeAfter_1 = getInlineElementBeforeAfter$1;
    var getLeafSibling_1$3 = getLeafSibling$1;
    /**
     * The provides traversing of content inside editor.
     * There are two ways to traverse, block by block, or inline element by inline element
     * Block and inline traversing is independent from each other, meaning if you traverse block by block, it does not change
     * the current inline element position
     */
    var ContentTraverser = /** @class */ (function () {
        /**
         * Create a content traverser for the whole body of given root node
         * @param scoper Traversing scoper object to help scope the traversing
         * @param skipTags (Optional) tags that child elements will be skipped
         */
        function ContentTraverser(scoper, skipTags) {
            this.scoper = scoper;
            this.skipTags = skipTags;
            this.currentInline = null;
            this.currentBlock = null;
        }
        /**
         * Create a content traverser for the whole body of given root node
         * @param rootNode The root node to traverse in
         * @param startNode The node to start from. If not passed, it will start from the beginning of the body
         * @param skipTags (Optional) tags that child elements will be skipped
         */
        ContentTraverser.createBodyTraverser = function (rootNode, startNode, skipTags) {
            return new ContentTraverser(new BodyScoper_1.default(rootNode, startNode));
        };
        /**
         * Create a content traverser for the given selection
         * @param rootNode The root node to traverse in
         * @param range The selection range to scope the traversing
         * @param skipTags (Optional) tags that child elements will be skipped
         */
        ContentTraverser.createSelectionTraverser = function (rootNode, range, skipTags) {
            return new ContentTraverser(new SelectionScoper_1.default(rootNode, range), skipTags);
        };
        /**
         * Create a content traverser for a block element which contains the given position
         * @param rootNode The root node to traverse in
         * @param position A position inside a block, traversing will be scoped within this block.
         * If passing a range, the start position of this range will be used
         * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart
         * @param skipTags (Optional) tags that child elements will be skipped
         */
        ContentTraverser.createBlockTraverser = function (rootNode, position, start, skipTags) {
            if (start === void 0) { start = 3 /* SelectionStart */; }
            return new ContentTraverser(new SelectionBlockScoper_1.default(rootNode, position, start));
        };
        Object.defineProperty(ContentTraverser.prototype, "currentBlockElement", {
            /**
             * Get current block
             */
            get: function () {
                // Prepare currentBlock from the scoper
                if (!this.currentBlock) {
                    this.currentBlock = this.scoper.getStartBlockElement();
                }
                return this.currentBlock;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Get next block element
         */
        ContentTraverser.prototype.getNextBlockElement = function () {
            return this.getPreviousNextBlockElement(true /*isNext*/);
        };
        /**
         * Get previous block element
         */
        ContentTraverser.prototype.getPreviousBlockElement = function () {
            return this.getPreviousNextBlockElement(false /*isNext*/);
        };
        ContentTraverser.prototype.getPreviousNextBlockElement = function (isNext) {
            var current = this.currentBlockElement;
            if (!current) {
                return null;
            }
            var leaf = (0, getLeafSibling_1$3.getLeafSibling)(this.scoper.rootNode, isNext ? current.getEndNode() : current.getStartNode(), isNext, this.skipTags);
            var newBlock = leaf ? (0, getBlockElementAtNode_1$3.default)(this.scoper.rootNode, leaf) : null;
            // Make sure this is right block:
            // 1) the block is in scope per scoper
            // 2) the block is after (for next) or before (for previous) the current block
            // Then:
            // 1) Re-position current block to newly found block
            if (newBlock &&
                this.scoper.isBlockInScope(newBlock) &&
                ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))) {
                this.currentBlock = newBlock;
                return this.currentBlock;
            }
            return null;
        };
        Object.defineProperty(ContentTraverser.prototype, "currentInlineElement", {
            /**
             * Current inline element getter
             */
            get: function () {
                // Retrieve a start inline from scoper
                if (!this.currentInline) {
                    this.currentInline = this.scoper.getStartInlineElement();
                }
                return this.currentInline instanceof EmptyInlineElement_1.default ? null : this.currentInline;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Get next inline element
         */
        ContentTraverser.prototype.getNextInlineElement = function () {
            return this.getPreviousNextInlineElement(true /*isNext*/);
        };
        /**
         * Get previous inline element
         */
        ContentTraverser.prototype.getPreviousInlineElement = function () {
            return this.getPreviousNextInlineElement(false /*isNext*/);
        };
        ContentTraverser.prototype.getPreviousNextInlineElement = function (isNext) {
            var current = this.currentInlineElement || this.currentInline;
            var newInline;
            if (!current) {
                return null;
            }
            if (current instanceof EmptyInlineElement_1.default) {
                newInline = (0, getInlineElementBeforeAfter_1.getInlineElementBeforeAfter)(this.scoper.rootNode, current.getStartPosition(), isNext);
                if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {
                    newInline = null;
                }
            }
            else {
                newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);
                newInline =
                    newInline &&
                        current &&
                        ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))
                        ? newInline
                        : null;
            }
            // For inline, we need to make sure:
            // 1) it is really next/previous to current
            // 2) pass on the new inline to this.scoper to do the trimming and we still get back an inline
            // Then
            // 1) re-position current inline
            if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {
                this.currentInline = newInline;
                return this.currentInline;
            }
            return null;
        };
        return ContentTraverser;
    }());
    ContentTraverser$1.default = ContentTraverser;
    function getNextPreviousInlineElement(rootNode, current, isNext) {
        if (!current) {
            return null;
        }
        if (current instanceof PartialInlineElement_1.default) {
            // if current is partial, get the other half of the inline unless it is no more
            var result = isNext ? current.nextInlineElement : current.previousInlineElement;
            if (result) {
                return result;
            }
        }
        // Get a leaf node after startNode and use that base to find next inline
        var startNode = current.getContainerNode();
        startNode = (0, getLeafSibling_1$3.getLeafSibling)(rootNode, startNode, isNext);
        return (0, getInlineElementAtNode_1.default)(rootNode, startNode);
    }

    var PositionContentSearcher$1 = {};

    Object.defineProperty(PositionContentSearcher$1, "__esModule", { value: true });
    var ContentTraverser_1$4 = ContentTraverser$1;
    var createRange_1$4 = createRange$1;
    // White space matching regex. It matches following chars:
    // \s: white space
    // \u00A0: no-breaking white space
    // \u200B: zero width space
    // \u3000: full width space (which can come from JPN IME)
    var WHITESPACE_REGEX = /[\s\u00A0\u200B\u3000]+([^\s\u00A0\u200B\u3000]*)$/i;
    /**
     * The class that helps search content around a position
     */
    var PositionContentSearcher = /** @class */ (function () {
        /**
         * Create a new CursorData instance
         * @param rootNode Root node of the whole scope
         * @param position Start position
         */
        function PositionContentSearcher(rootNode, position) {
            this.rootNode = rootNode;
            this.position = position;
            // The cached text before position that has been read so far
            this.text = '';
            // The cached word before position
            this.word = '';
            // The inline element before position
            this.inlineBefore = null;
            // The inline element after position
            this.inlineAfter = null;
            // The content traverser used to traverse backwards
            this.traverser = null;
            // Backward parsing has completed
            this.traversingComplete = false;
            // All inline elements before position that have been read so far
            this.inlineElements = [];
            // First non-text inline before position
            this.nearestNonTextInlineElement = null;
        }
        /**
         * Get the word before position. The word is determined by scanning backwards till the first white space, the portion
         * between position and the white space is the word before position
         * @returns The word before position
         */
        PositionContentSearcher.prototype.getWordBefore = function () {
            var _this = this;
            if (!this.word) {
                this.traverse(function () { return _this.word; });
            }
            return this.word || '';
        };
        /**
         * Get the inline element before position
         * @returns The inlineElement before position
         */
        PositionContentSearcher.prototype.getInlineElementBefore = function () {
            if (!this.inlineBefore) {
                this.traverse(null);
            }
            return this.inlineBefore;
        };
        /**
         * Get the inline element after position
         * @returns The inline element after position
         */
        PositionContentSearcher.prototype.getInlineElementAfter = function () {
            if (!this.inlineAfter) {
                this.inlineAfter = ContentTraverser_1$4.default.createBlockTraverser(this.rootNode, this.position).currentInlineElement;
            }
            return this.inlineAfter;
        };
        /**
         * Get X number of chars before position
         * The actual returned chars may be less than what is requested.
         * @param length The length of string user want to get, the string always ends at the position,
         * so this length determines the start position of the string
         * @returns The actual string we get as a sub string, or the whole string before position when
         * there is not enough chars in the string
         */
        PositionContentSearcher.prototype.getSubStringBefore = function (length) {
            var _this = this;
            if (this.text.length < length) {
                this.traverse(function () { return _this.text.length >= length; });
            }
            return this.text.substr(Math.max(0, this.text.length - length));
        };
        /**
         * Try to get a range matches the given text before the position
         * @param text The text to match against
         * @param exactMatch Whether it is an exact match
         * @returns The range for the matched text, null if unable to find a match
         */
        PositionContentSearcher.prototype.getRangeFromText = function (text, exactMatch) {
            if (!text) {
                return null;
            }
            var startPosition = null;
            var endPosition = null;
            var textIndex = text.length - 1;
            this.forEachTextInlineElement(function (textInline) {
                var nodeContent = textInline.getTextContent() || '';
                var nodeIndex = nodeContent.length - 1;
                for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {
                    if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {
                        textIndex--;
                        // on first time when end is matched, set the end of range
                        if (!endPosition) {
                            endPosition = textInline.getStartPosition().move(nodeIndex + 1);
                        }
                    }
                    else if (exactMatch || endPosition) {
                        // Mismatch found when exact match or end already match, so return since matching failed
                        return true;
                    }
                }
                // when textIndex == -1, we have a successful complete match
                if (textIndex == -1) {
                    startPosition = textInline.getStartPosition().move(nodeIndex + 1);
                    return true;
                }
                return false;
            });
            return startPosition && endPosition && (0, createRange_1$4.default)(startPosition, endPosition);
        };
        /**
         * Get text section before position till stop condition is met.
         * This offers consumers to retrieve text section by section
         * The section essentially is just an inline element which has Container element
         * so that the consumer can remember it for anchoring popup or verification purpose
         * when position moves out of context etc.
         * @param stopFunc The callback stop function
         */
        PositionContentSearcher.prototype.forEachTextInlineElement = function (callback) {
            // We cache all text sections read so far
            // Every time when you ask for textSection, we start with the cached first
            // and resort to further reading once we exhausted with the cache
            if (!this.inlineElements.some(callback)) {
                this.traverse(callback);
            }
        };
        /**
         * Get first non textual inline element before position
         * @returns First non textual inline element before position or null if no such element exists
         */
        PositionContentSearcher.prototype.getNearestNonTextInlineElement = function () {
            var _this = this;
            if (!this.nearestNonTextInlineElement) {
                this.traverse(function () { return _this.nearestNonTextInlineElement; });
            }
            return this.nearestNonTextInlineElement;
        };
        /**
         * Continue traversing backward till stop condition is met or begin of block is reached
         */
        PositionContentSearcher.prototype.traverse = function (callback) {
            this.traverser =
                this.traverser || ContentTraverser_1$4.default.createBlockTraverser(this.rootNode, this.position);
            if (!this.traverser || this.traversingComplete) {
                return;
            }
            var previousInline = this.traverser.getPreviousInlineElement();
            while (!this.traversingComplete) {
                this.inlineBefore = this.inlineBefore || previousInline;
                if (previousInline && previousInline.isTextualInlineElement()) {
                    var textContent = previousInline.getTextContent();
                    // build the word before position if it is not built yet
                    if (!this.word) {
                        // Match on the white space, the portion after space is on the index of 1 of the matched result
                        // (index at 0 is whole match result, index at 1 is the word)
                        var matches = WHITESPACE_REGEX.exec(textContent);
                        if (matches && matches.length == 2) {
                            this.word = matches[1] + this.text;
                        }
                    }
                    this.text = textContent + this.text;
                    this.inlineElements.push(previousInline);
                    // Check if stop condition is met
                    if (callback && callback(previousInline)) {
                        break;
                    }
                }
                else {
                    this.nearestNonTextInlineElement = previousInline;
                    this.traversingComplete = true;
                    if (!this.word) {
                        // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor
                        this.word = this.text;
                    }
                    // When a non-textual inline element, or null is seen, we consider parsing complete
                    // TODO: we may need to change this if there is a future need to parse beyond text, i.e.
                    // we have aaa @someone bbb<position>, and we want to read the text before @someone
                    break;
                }
                previousInline = this.traverser.getPreviousInlineElement();
            }
        };
        return PositionContentSearcher;
    }());
    PositionContentSearcher$1.default = PositionContentSearcher;

    var addDelimiters$1 = {};

    var getDelimiterFromElement$1 = {};

    Object.defineProperty(getDelimiterFromElement$1, "__esModule", { value: true });
    var safeInstanceOf_1$b = safeInstanceOf$1;
    var ZERO_WIDTH_SPACE$5 = '\u200B';
    /**
     * Retrieves Delimiter information from a provided element.
     * @param element element to try to retrieve a delimiter
     * @returns delimiter info if it is a Delimiter, else null
     */
    function getDelimiterFromElement(element) {
        if (!element) {
            return null;
        }
        if ((0, safeInstanceOf_1$b.default)(element, 'HTMLSpanElement') &&
            (element.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */) ||
                element.classList.contains("entityDelimiterBefore" /* DELIMITER_BEFORE */)) &&
            element.textContent === ZERO_WIDTH_SPACE$5) {
            return element;
        }
        return null;
    }
    getDelimiterFromElement$1.default = getDelimiterFromElement;

    Object.defineProperty(addDelimiters$1, "__esModule", { value: true });
    addDelimiters$1.addDelimiterBefore = addDelimiters$1.addDelimiterAfter = void 0;
    var createElement_1$3 = createElement;
    var getDelimiterFromElement_1 = getDelimiterFromElement$1;
    var ZERO_WIDTH_SPACE$4 = '\u200B';
    /**
     * Adds delimiters to the element provided. If the delimiters already exists, will not be added
     * @param node the node to add the delimiters
     */
    function addDelimiters(node) {
        var _a = getDelimiters(node), delimiterAfter = _a[0], delimiterBefore = _a[1];
        if (!delimiterAfter) {
            delimiterAfter = addDelimiterAfter(node);
        }
        if (!delimiterBefore) {
            delimiterBefore = addDelimiterBefore(node);
        }
        return [delimiterAfter, delimiterBefore];
    }
    addDelimiters$1.default = addDelimiters;
    /**
     * Adds delimiter after the element provided.
     * @param element element to use
     */
    function addDelimiterAfter(element) {
        return insertDelimiter(element, "entityDelimiterAfter" /* DELIMITER_AFTER */);
    }
    addDelimiters$1.addDelimiterAfter = addDelimiterAfter;
    /**
     * Adds delimiter before the element provided.
     * @param element element to use
     */
    function addDelimiterBefore(element) {
        return insertDelimiter(element, "entityDelimiterBefore" /* DELIMITER_BEFORE */);
    }
    addDelimiters$1.addDelimiterBefore = addDelimiterBefore;
    function getDelimiters(entityWrapper) {
        var result = [];
        var nextElementSibling = entityWrapper.nextElementSibling, previousElementSibling = entityWrapper.previousElementSibling;
        result.push(isDelimiter(nextElementSibling, "entityDelimiterAfter" /* DELIMITER_AFTER */), isDelimiter(previousElementSibling, "entityDelimiterBefore" /* DELIMITER_BEFORE */));
        return result;
    }
    function isDelimiter(el, className) {
        return el && (0, getDelimiterFromElement_1.default)(el) && el.classList.contains(className) ? el : undefined;
    }
    function insertDelimiter(element, delimiterClass) {
        var span = (0, createElement_1$3.default)({
            tag: 'span',
            className: delimiterClass,
            children: [ZERO_WIDTH_SPACE$4],
        }, element.ownerDocument);
        if (span) {
            var insertPosition = delimiterClass == "entityDelimiterAfter" /* DELIMITER_AFTER */ ? 'afterend' : 'beforebegin';
            element.insertAdjacentElement(insertPosition, span);
        }
        return span;
    }

    var extractClipboardEvent$1 = {};

    var extractClipboardItems$1 = {};

    var readFile$1 = {};

    Object.defineProperty(readFile$1, "__esModule", { value: true });
    /**
     * Read a file object and invoke a callback function with the data url of this file
     * @param file The file to read
     * @param callback the callback to invoke with data url of the file.
     * If fail to read, dataUrl will be null
     */
    function readFile(file, callback) {
        if (file) {
            var reader_1 = new FileReader();
            reader_1.onload = function () {
                callback(reader_1.result);
            };
            reader_1.onerror = function () {
                callback(null);
            };
            reader_1.readAsDataURL(file);
        }
    }
    readFile$1.default = readFile;

    var _a$7;
    Object.defineProperty(extractClipboardItems$1, "__esModule", { value: true });
    var readFile_1$1 = readFile$1;
    var Browser_1$3 = Browser;
    // HTML header to indicate where is the HTML content started from.
    // Sample header:
    // Version:0.9
    // StartHTML:71
    // EndHTML:170
    // StartFragment:140
    // EndFragment:160
    // StartSelection:140
    // EndSelection:160
    var CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\.]+\s+StartHTML:\s*([0-9]+)\s+EndHTML:\s*([0-9]+)\s+/i;
    var OTHER_TEXT_TYPE = "text/" /* Text */ + '*';
    var EDGE_LINK_PREVIEW = 'link-preview';
    var ContentHandlers = (_a$7 = {},
        _a$7["text/html" /* HTML */] = function (data, value) {
            return (data.rawHtml = Browser_1$3.Browser.isEdge ? workaroundForEdge(value) : value);
        },
        _a$7["text/plain" /* PlainText */] = function (data, value) { return (data.text = value); },
        _a$7[OTHER_TEXT_TYPE] = function (data, value, type) { return !!type && (data.customValues[type] = value); },
        _a$7["text/" /* Text */ + EDGE_LINK_PREVIEW] = tryParseLinkPreview,
        _a$7);
    /**
     * Extract clipboard items to be a ClipboardData object for IE
     * @param items The clipboard items retrieve from a DataTransfer object
     * @param callback Callback function when data is ready
     * @returns An object with the following properties:
     *  types: Available types from the clipboard event
     *  text: Plain text from the clipboard event
     *  image: Image file from the clipboard event
     *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.
     *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is
     *   not supported by browser.
     */
    function extractClipboardItems(items, options) {
        var data = {
            types: [],
            text: '',
            image: null,
            files: [],
            rawHtml: null,
            customValues: {},
        };
        return Promise.all((items || []).map(function (item) {
            var type = item.type;
            if (type.indexOf("image/" /* Image */) == 0 && !data.image && item.kind == 'file') {
                data.types.push(type);
                data.image = item.getAsFile();
                return new Promise(function (resolve) {
                    if (data.image) {
                        (0, readFile_1$1.default)(data.image, function (dataUrl) {
                            data.imageDataUri = dataUrl;
                            resolve();
                        });
                    }
                    else {
                        resolve();
                    }
                });
            }
            else if (item.kind == 'file') {
                return new Promise(function (resolve) {
                    var file = item.getAsFile();
                    if (!!file) {
                        data.types.push(type);
                        data.files.push(file);
                    }
                    resolve();
                });
            }
            else {
                var customType_1 = getAllowedCustomType(type, options === null || options === void 0 ? void 0 : options.allowedCustomPasteType);
                var handler_1 = ContentHandlers[type] || (customType_1 ? ContentHandlers[OTHER_TEXT_TYPE] : null);
                return new Promise(function (resolve) {
                    return handler_1
                        ? item.getAsString(function (value) {
                            data.types.push(type);
                            handler_1(data, value, customType_1);
                            resolve();
                        })
                        : resolve();
                });
            }
        })).then(function () { return data; });
    }
    extractClipboardItems$1.default = extractClipboardItems;
    /**
     * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.
     * So we need to remove it in our code
     * @param html The HTML string got from clipboard
     */
    function workaroundForEdge(html) {
        var headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);
        if ((headerValues === null || headerValues === void 0 ? void 0 : headerValues.length) == 3) {
            var start = parseInt(headerValues[1]);
            var end = parseInt(headerValues[2]);
            if (start > 0 && end > start) {
                html = html.substring(start, end);
            }
        }
        return html;
    }
    function tryParseLinkPreview(data, value) {
        try {
            data.customValues[EDGE_LINK_PREVIEW] = value;
            data.linkPreview = JSON.parse(value);
        }
        catch (_a) { }
    }
    function getAllowedCustomType(type, allowedCustomPasteType) {
        var textType = type.indexOf("text/" /* Text */) == 0
            ? type.substring("text/" /* Text */.length)
            : null;
        var index = allowedCustomPasteType && textType ? allowedCustomPasteType.indexOf(textType) : -1;
        return textType && index >= 0 ? textType : undefined;
    }

    var extractClipboardItemsForIE$1 = {};

    Object.defineProperty(extractClipboardItemsForIE$1, "__esModule", { value: true });
    var readFile_1 = readFile$1;
    var toArray_1$7 = toArray$1;
    /**
     * Extract clipboard items to be a ClipboardData object for IE
     * @param dataTransfer The clipboard items retrieve from a DataTransfer object
     * @param callback Callback function when data is ready
     * @returns An object with the following properties:
     *  types: Available types from the clipboard event
     *  text: Plain text from the clipboard event
     *  image: Image file from the clipboard event
     *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.
     *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is
     *   not supported by browser.
     */
    function extractClipboardItemsForIE(dataTransfer, callback, options) {
        var _a, _b, _c;
        var clipboardData = {
            types: dataTransfer.types ? (0, toArray_1$7.default)(dataTransfer.types) : [],
            text: dataTransfer.getData('text'),
            image: null,
            files: [],
            rawHtml: null,
            customValues: {},
        };
        for (var i = 0; i < (dataTransfer.files ? dataTransfer.files.length : 0); i++) {
            var file = dataTransfer.files.item(i);
            if (((_a = file === null || file === void 0 ? void 0 : file.type) === null || _a === void 0 ? void 0 : _a.indexOf("image/" /* Image */)) == 0) {
                clipboardData.image = file;
                break;
            }
        }
        var nextStep = function () {
            if (clipboardData.image) {
                (0, readFile_1.default)(clipboardData.image, function (dataUrl) {
                    clipboardData.imageDataUri = dataUrl;
                    callback(clipboardData);
                });
            }
            else {
                callback(clipboardData);
            }
        };
        if ((options === null || options === void 0 ? void 0 : options.getTempDiv) && (options === null || options === void 0 ? void 0 : options.removeTempDiv)) {
            var div_1 = options.getTempDiv();
            div_1.contentEditable = 'true';
            div_1.innerHTML = '';
            div_1.focus();
            (_c = (_b = div_1.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) === null || _c === void 0 ? void 0 : _c.setTimeout(function () {
                var _a;
                clipboardData.rawHtml = div_1.innerHTML;
                (_a = options.removeTempDiv) === null || _a === void 0 ? void 0 : _a.call(options, div_1);
                nextStep();
            }, 0);
        }
        else {
            clipboardData.rawHtml = undefined;
            nextStep();
        }
    }
    extractClipboardItemsForIE$1.default = extractClipboardItemsForIE;

    Object.defineProperty(extractClipboardEvent$1, "__esModule", { value: true });
    var extractClipboardItems_1 = extractClipboardItems$1;
    var extractClipboardItemsForIE_1 = extractClipboardItemsForIE$1;
    var toArray_1$6 = toArray$1;
    var Browser_1$2 = Browser;
    /**
     * @deprecated Use extractClipboardItems and extractClipboardItemsForIE instead
     * Extract a Clipboard event
     * @param event The paste event
     * @param callback Callback function when data is ready
     * @param options Options to retrieve more items from the event, including HTML string and other customized items
     * @param rangeBeforePaste Optional range to be removed when pasting in Android
     * @returns An object with the following properties:
     *  types: Available types from the clipboard event
     *  text: Plain text from the clipboard event
     *  image: Image file from the clipboard event
     *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.
     *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is
     *   not supported by browser.
     */
    function extractClipboardEvent(event, callback, options, rangeBeforePaste) {
        var _a;
        var dataTransfer = event.clipboardData ||
            ((_a = event.target.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView).clipboardData;
        if (dataTransfer.items) {
            event.preventDefault();
            (0, extractClipboardItems_1.default)((0, toArray_1$6.default)(dataTransfer.items), options).then(function (clipboardData) {
                removeContents(rangeBeforePaste);
                callback(clipboardData);
            });
        }
        else {
            (0, extractClipboardItemsForIE_1.default)(dataTransfer, callback, options);
        }
    }
    extractClipboardEvent$1.default = extractClipboardEvent;
    function removeContents(range) {
        if (Browser_1$2.Browser.isAndroid && range) {
            range.deleteContents();
        }
    }

    var applyFormat$1 = {};

    var setColor$1 = {};

    var parseColor$1 = {};

    Object.defineProperty(parseColor$1, "__esModule", { value: true });
    var HEX3_REGEX = /^#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/;
    var HEX6_REGEX = /^#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/;
    var RGB_REGEX = /^rgb\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*\)$/;
    var RGBA_REGEX = /^rgba\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*\)$/;
    /**
     * Parse color string to r/g/b value.
     * If the given color is not in a recognized format, return null
     */
    function parseColor(color) {
        color = (color || '').trim();
        var match;
        if ((match = color.match(HEX3_REGEX))) {
            return [
                parseInt(match[1] + match[1], 16),
                parseInt(match[2] + match[2], 16),
                parseInt(match[3] + match[3], 16),
            ];
        }
        else if ((match = color.match(HEX6_REGEX))) {
            return [parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16)];
        }
        else if ((match = color.match(RGB_REGEX) || color.match(RGBA_REGEX))) {
            return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
        }
        else {
            // CSS color names such as red, green is not included for now.
            // If need, we can add those colors from https://www.w3.org/wiki/CSS/Properties/color/keywords
            return null;
        }
    }
    parseColor$1.default = parseColor;

    Object.defineProperty(setColor$1, "__esModule", { value: true });
    var parseColor_1 = parseColor$1;
    var WHITE = '#ffffff';
    var GRAY = '#333333';
    var BLACK = '#000000';
    var TRANSPARENT$1 = 'transparent';
    var ColorTones;
    (function (ColorTones) {
        ColorTones[ColorTones["BRIGHT"] = 0] = "BRIGHT";
        ColorTones[ColorTones["DARK"] = 1] = "DARK";
        ColorTones[ColorTones["NONE"] = 2] = "NONE";
    })(ColorTones || (ColorTones = {}));
    //Using the HSL (hue, saturation and lightness) representation for RGB color values, if the value of the lightness is less than 20, the color is dark
    var DARK_COLORS_LIGHTNESS = 20;
    //If the value of the lightness is more than 80, the color is bright
    var BRIGHT_COLORS_LIGHTNESS = 80;
    var TRANSPARENT_COLOR = 'transparent';
    /**
     * Set text color or background color to the given element
     * @param element The element to set color to
     * @param color The color to set, it can be a string of color name/value or a ModeIndependentColor object
     * @param isBackgroundColor Whether set background color or text color
     * @param isDarkMode Whether current mode is dark mode. @default false
     * @param shouldAdaptTheFontColor Whether the font color needs to be adapted to be visible in a dark or bright background color. @default false
     * @param darkColorHandler An optional dark color handler object. When it is passed, we will use this handler to do variable-based dark color instead of original dataset base dark color
     */
    function setColor(element, color, isBackgroundColor, isDarkMode, shouldAdaptTheFontColor, darkColorHandler) {
        var colorString = typeof color === 'string' ? color.trim() : '';
        var modeIndependentColor = typeof color === 'string' ? null : color;
        var cssName = isBackgroundColor ? 'background-color' : 'color';
        if (colorString || modeIndependentColor) {
            if (darkColorHandler) {
                var colorValue = darkColorHandler.registerColor((modeIndependentColor === null || modeIndependentColor === void 0 ? void 0 : modeIndependentColor.lightModeColor) || colorString, !!isDarkMode, modeIndependentColor === null || modeIndependentColor === void 0 ? void 0 : modeIndependentColor.darkModeColor);
                element.style.setProperty(cssName, colorValue);
            }
            else {
                element.style.setProperty(cssName, (isDarkMode
                    ? modeIndependentColor === null || modeIndependentColor === void 0 ? void 0 : modeIndependentColor.darkModeColor
                    : modeIndependentColor === null || modeIndependentColor === void 0 ? void 0 : modeIndependentColor.lightModeColor) || colorString);
                if (element.dataset) {
                    var dataSetName = isBackgroundColor
                        ? "ogsb" /* OriginalStyleBackgroundColor */
                        : "ogsc" /* OriginalStyleColor */;
                    if (!isDarkMode || color == TRANSPARENT_COLOR) {
                        delete element.dataset[dataSetName];
                    }
                    else if (modeIndependentColor) {
                        element.dataset[dataSetName] = modeIndependentColor.lightModeColor;
                    }
                }
            }
            if (isBackgroundColor && shouldAdaptTheFontColor) {
                adaptFontColorToBackgroundColor(element, (modeIndependentColor === null || modeIndependentColor === void 0 ? void 0 : modeIndependentColor.lightModeColor) || colorString, isDarkMode, darkColorHandler);
            }
        }
    }
    setColor$1.default = setColor;
    /**
     * Change the font color to white or some other color, so the text can be visible with a darker background
     * @param element The element that contains text.
     * @param lightModeBackgroundColor Existing background color in light mode
     * @param isDarkMode Whether the content is in dark mode
     * @param darkColorHandler An optional dark color handler object. When it is passed, we will use this handler to do variable-based dark color instead of original dataset base dark color
     */
    function adaptFontColorToBackgroundColor(element, lightModeBackgroundColor, isDarkMode, darkColorHandler) {
        if (!lightModeBackgroundColor || lightModeBackgroundColor === TRANSPARENT$1) {
            return;
        }
        var isADarkOrBrightOrNone = isADarkOrBrightColor(lightModeBackgroundColor);
        switch (isADarkOrBrightOrNone) {
            case 1 /* DARK */:
                var fontForDark = {
                    lightModeColor: WHITE,
                    darkModeColor: GRAY,
                };
                setColor(element, fontForDark, false /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
                break;
            case 0 /* BRIGHT */:
                var fontForLight = {
                    lightModeColor: BLACK,
                    darkModeColor: WHITE,
                };
                setColor(element, fontForLight, false /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
                break;
        }
    }
    function isADarkOrBrightColor(color) {
        var lightness = calculateLightness(color);
        if (lightness < DARK_COLORS_LIGHTNESS) {
            return 1 /* DARK */;
        }
        else if (lightness > BRIGHT_COLORS_LIGHTNESS) {
            return 0 /* BRIGHT */;
        }
        return 2 /* NONE */;
    }
    /**
     * Calculate the lightness of HSL (hue, saturation and lightness) representation
     * @param color a RBG or RGBA COLOR
     * @returns
     */
    function calculateLightness(color) {
        var colorValues = (0, parseColor_1.default)(color);
        // Use the values of r,g,b to calculate the lightness in the HSl representation
        //First calculate the fraction of the light in each color, since in css the value of r,g,b is in the interval of [0,255], we have
        if (colorValues) {
            var red = colorValues[0] / 255;
            var green = colorValues[1] / 255;
            var blue = colorValues[2] / 255;
            //Then the lightness in the HSL representation is the average between maximum fraction of r,g,b and the minimum fraction
            return (Math.max(red, green, blue) + Math.min(red, green, blue)) * 50;
        }
        else {
            return 255;
        }
    }

    Object.defineProperty(applyFormat$1, "__esModule", { value: true });
    var setColor_1$1 = setColor$1;
    /**
     * Apply format to an HTML element
     * @param element The HTML element to apply format to
     * @param format The format to apply
     * @param isDarkMode Whether the content should be formatted in dark mode
     * @param darkColorHandler An optional dark color handler object. When it is passed, we will use this handler to do variable-based dark color instead of original dataset base dark color
     */
    function applyFormat(element, format, isDarkMode, darkColorHandler) {
        if (format) {
            var elementStyle = element.style;
            var fontFamily = format.fontFamily, fontSize = format.fontSize, textColor = format.textColor, textColors = format.textColors, backgroundColor = format.backgroundColor, backgroundColors = format.backgroundColors, bold = format.bold, italic = format.italic, underline = format.underline;
            if (fontFamily) {
                elementStyle.fontFamily = fontFamily;
            }
            if (fontSize) {
                elementStyle.fontSize = fontSize;
            }
            if (textColors) {
                (0, setColor_1$1.default)(element, textColors, false /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
            }
            else if (textColor) {
                (0, setColor_1$1.default)(element, textColor, false /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
            }
            if (backgroundColors) {
                (0, setColor_1$1.default)(element, backgroundColors, true /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
            }
            else if (backgroundColor) {
                (0, setColor_1$1.default)(element, backgroundColor, true /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
            }
            if (bold) {
                elementStyle.fontWeight = 'bold';
            }
            if (italic) {
                elementStyle.fontStyle = 'italic';
            }
            if (underline) {
                elementStyle.textDecoration = 'underline';
            }
        }
    }
    applyFormat$1.default = applyFormat;

    var changeElementTag$1 = {};

    var moveChildNodes$1 = {};

    Object.defineProperty(moveChildNodes$1, "__esModule", { value: true });
    /**
     * Replace all child nodes of the given target node to the child nodes of source node.
     * @param target Target node, all child nodes of this node will be removed if keepExistingChildren is not set to true
     * @param source (Optional) source node, all child nodes of this node will be move to target node
     * @param keepExistingChildren (Optional) When set to true, all existing child nodes of target will be kept
     */
    function moveChildNodes(target, source, keepExistingChildren) {
        if (!target) {
            return;
        }
        while (!keepExistingChildren && target.firstChild) {
            target.removeChild(target.firstChild);
        }
        while (source === null || source === void 0 ? void 0 : source.firstChild) {
            target.appendChild(source.firstChild);
        }
    }
    moveChildNodes$1.default = moveChildNodes;

    Object.defineProperty(changeElementTag$1, "__esModule", { value: true });
    var getComputedStyles_1 = getComputedStyles$1;
    var getTagOfNode_1$9 = getTagOfNode$1;
    var moveChildNodes_1$3 = moveChildNodes$1;
    function changeElementTag(element, newTag) {
        var _a;
        if (!element || !newTag) {
            return null;
        }
        var origianlTag = (0, getTagOfNode_1$9.default)(element);
        if (origianlTag == newTag.toUpperCase()) {
            // Already in the target tag, no need to change
            return element;
        }
        var newElement = element.ownerDocument.createElement(newTag);
        for (var i = 0; i < element.attributes.length; i++) {
            var attr = element.attributes[i];
            newElement.setAttribute(attr.name, attr.value);
        }
        (0, moveChildNodes_1$3.default)(newElement, element);
        if (origianlTag == 'P' || (0, getTagOfNode_1$9.default)(newElement) == 'P') {
            _a = (0, getComputedStyles_1.default)(element, [
                'margin-top',
                'margin-bottom',
            ]), newElement.style.marginTop = _a[0], newElement.style.marginBottom = _a[1];
        }
        if (element.parentNode) {
            element.parentNode.replaceChild(newElement, element);
        }
        return newElement;
    }
    changeElementTag$1.default = changeElementTag;

    var getPendableFormatState$2 = {};

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PendableFormatCommandMap = void 0;
    var getObjectKeys_1 = getObjectKeys$1;
    /**
     * A map from pendable format name to document command
     */
    exports.PendableFormatCommandMap = {
        /**
         * Bold
         */
        isBold: "bold" /* Bold */,
        /**
         * Italic
         */
        isItalic: "italic" /* Italic */,
        /**
         * Underline
         */
        isUnderline: "underline" /* Underline */,
        /**
         * StrikeThrough
         */
        isStrikeThrough: "strikeThrough" /* StrikeThrough */,
        /**
         * Subscript
         */
        isSubscript: "subscript" /* Subscript */,
        /**
         * Superscript
         */
        isSuperscript: "superscript" /* Superscript */,
    };
    /**
     * Get Pendable Format State at cursor.
     * @param document The HTML Document to get format state from
     * @returns A PendableFormatState object which contains the values of pendable format states
     */
    function getPendableFormatState(document) {
        var keys = (0, getObjectKeys_1.default)(exports.PendableFormatCommandMap);
        return keys.reduce(function (state, key) {
            state[key] = document.queryCommandState(exports.PendableFormatCommandMap[key]);
            return state;
        }, {});
    }
    exports.default = getPendableFormatState;

    }(getPendableFormatState$2));

    var isNodeEmpty$1 = {};

    Object.defineProperty(isNodeEmpty$1, "__esModule", { value: true });
    var getTagOfNode_1$8 = getTagOfNode$1;
    var VISIBLE_ELEMENT_TAGS = ['IMG'];
    var VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');
    var ZERO_WIDTH_SPACE$3 = /\u200b/g;
    /**
     * Check if a given node has no visible content
     * @param node The node to check
     * @param trimContent Whether trim the text content so that spaces will be treated as empty.
     * Default value is false
     * @returns True if there isn't any visible element inside node, otherwise false
     */
    function isNodeEmpty(node, trimContent, shouldCountBrAsVisible) {
        if (!node) {
            return false;
        }
        else if (node.nodeType == 3 /* Text */) {
            return trim(node.nodeValue || '', trimContent) == '';
        }
        else if (node.nodeType == 1 /* Element */) {
            var element = node;
            var textContent = trim(element.textContent || '', trimContent);
            var visibleSelector = shouldCountBrAsVisible
                ? VISIBLE_CHILD_ELEMENT_SELECTOR + ",BR"
                : VISIBLE_CHILD_ELEMENT_SELECTOR;
            if (textContent != '' ||
                VISIBLE_ELEMENT_TAGS.indexOf((0, getTagOfNode_1$8.default)(element)) >= 0 ||
                element.querySelectorAll(visibleSelector)[0]) {
                return false;
            }
        }
        return true;
    }
    isNodeEmpty$1.default = isNodeEmpty;
    function trim(s, trim) {
        s = s.replace(ZERO_WIDTH_SPACE$3, '');
        return trim ? s.trim() : s;
    }

    var matchLink$1 = {};

    Object.defineProperty(matchLink$1, "__esModule", { value: true });
    var getObjectKeys_1$6 = getObjectKeys$1;
    // http exclude matching regex
    // invalid URL example (in particular on IE and Edge):
    // - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception
    // - http://www.bing.com%1, %1 is invalid
    // - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)
    // - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)
    // All above % cases if they're after ? (question mark) is then considered valid again
    // Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception
    // - http://www.bing.com@name, @name before ? (question mark) is considered invalid
    // - http://www.bing.com/@name, is valid sine it is after / (forward slash)
    // - http://www.bing.com?@name, is also valid since it is after ? (question mark)
    // The regex below is essentially a break down of:
    // ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%
    // ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1
    // ^[^?]+%00 => to exclude URL like www.bing.com%00
    // ^[^?]+%$ => to exclude URL like www.bing.com%
    // ^https?:\/\/[^?\/]+@ => to exclude URL like http://www.bing.com@name
    // ^www\.[^?\/]+@ => to exclude URL like www.bing.com@name
    // , => to exclude url like www.bing,,com
    var httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\/\/[^?\/]+@|^www\.[^?\/]+@/i;
    // via https://tools.ietf.org/html/rfc1035 Page 7
    var labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexps below so don't bother including A-Z
    var domainNameRegEx = "(?:" + labelRegEx + "\\.)*" + labelRegEx;
    var domainPortRegEx = domainNameRegEx + "(?:\\:[0-9]+)?";
    var domainPortWithUrlRegEx = domainPortRegEx + "(?:[\\/\\?]\\S*)?";
    var linkMatchRules = {
        http: {
            match: new RegExp("^(?:microsoft-edge:)?http:\\/\\/" + domainPortWithUrlRegEx + "|www\\." + domainPortWithUrlRegEx, 'i'),
            except: httpExcludeRegEx,
            normalizeUrl: function (url) {
                return new RegExp('^(?:microsoft-edge:)?http:\\/\\/', 'i').test(url) ? url : 'http://' + url;
            },
        },
        https: {
            match: new RegExp("^(?:microsoft-edge:)?https:\\/\\/" + domainPortWithUrlRegEx, 'i'),
            except: httpExcludeRegEx,
        },
        mailto: { match: new RegExp('^mailto:\\S+@\\S+\\.\\S+', 'i') },
        notes: { match: new RegExp('^notes:\\/\\/\\S+', 'i') },
        file: { match: new RegExp('^file:\\/\\/\\/?\\S+', 'i') },
        unc: { match: new RegExp('^\\\\\\\\\\S+', 'i') },
        ftp: {
            match: new RegExp("^ftp:\\/\\/" + domainPortWithUrlRegEx + "|ftp\\." + domainPortWithUrlRegEx, 'i'),
            normalizeUrl: function (url) { return (new RegExp('^ftp:\\/\\/', 'i').test(url) ? url : 'ftp://' + url); },
        },
        news: { match: new RegExp("^news:(\\/\\/)?" + domainPortWithUrlRegEx, 'i') },
        telnet: { match: new RegExp("^telnet:(\\/\\/)?" + domainPortWithUrlRegEx, 'i') },
        gopher: { match: new RegExp("^gopher:\\/\\/" + domainPortWithUrlRegEx, 'i') },
        wais: { match: new RegExp("^wais:(\\/\\/)?" + domainPortWithUrlRegEx, 'i') },
    };
    /**
     * Try to match a given string with link match rules, return matched link
     * @param url Input url to match
     * @param option Link match option, exact or partial. If it is exact match, we need
     * to check the length of matched link and url
     * @param rules Optional link match rules, if not passed, only the default link match
     * rules will be applied
     * @returns The matched link data, or null if no match found.
     * The link data includes an original url and a normalized url
     */
    function matchLink(url) {
        if (url) {
            for (var _i = 0, _a = (0, getObjectKeys_1$6.default)(linkMatchRules); _i < _a.length; _i++) {
                var schema = _a[_i];
                var rule = linkMatchRules[schema];
                var matches = url.match(rule.match);
                if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {
                    return {
                        scheme: schema,
                        originalUrl: url,
                        normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,
                    };
                }
            }
        }
        return null;
    }
    matchLink$1.default = matchLink;

    var queryElements$1 = {};

    Object.defineProperty(queryElements$1, "__esModule", { value: true });
    var toArray_1$5 = toArray$1;
    /**
     * Query HTML elements in the container by a selector string
     * @param container Container element to query from
     * @param selector Selector string to query
     * @param forEachCallback An optional callback to be invoked on each node in query result
     * @param scope The scope of the query, default value is QueryScope.Body
     * @param range The selection range to query with. This is required when scope is not Body
     * @returns HTML Element array of the query result
     */
    function queryElements(container, selector, forEachCallback, scope, range) {
        if (scope === void 0) { scope = 0 /* Body */; }
        if (!container || !selector) {
            return [];
        }
        var elements = (0, toArray_1$5.default)(container.querySelectorAll(selector));
        if (scope != 0 /* Body */ && range) {
            var startContainer_1 = range.startContainer, startOffset = range.startOffset, endContainer_1 = range.endContainer, endOffset = range.endOffset;
            if (startContainer_1.nodeType == 1 /* Element */ && startContainer_1.firstChild) {
                var child = startContainer_1.childNodes[startOffset];
                // range.startOffset can give a value of child.length+1 when selection is after the last child
                // In that case we will use the last child instead
                startContainer_1 = child || startContainer_1.lastChild;
            }
            endContainer_1 =
                endContainer_1.nodeType == 1 /* Element */ && endContainer_1.firstChild && endOffset > 0
                    ? endContainer_1.childNodes[endOffset - 1]
                    : endContainer_1;
            elements = elements.filter(function (element) {
                return isIntersectWithNodeRange(element, startContainer_1, endContainer_1, scope == 2 /* InSelection */);
            });
        }
        if (forEachCallback) {
            elements.forEach(forEachCallback);
        }
        return elements;
    }
    queryElements$1.default = queryElements;
    function isIntersectWithNodeRange(node, startNode, endNode, nodeContainedByRangeOnly) {
        var startPosition = node.compareDocumentPosition(startNode);
        var endPosition = node.compareDocumentPosition(endNode);
        var targetPositions = [0 /* Same */, 8 /* Contains */];
        if (!nodeContainedByRangeOnly) {
            targetPositions.push(16 /* ContainedBy */);
        }
        return (checkPosition(startPosition, targetPositions) || // intersectStart
            checkPosition(endPosition, targetPositions) || // intersectEnd
            (checkPosition(startPosition, [2 /* Preceding */]) && // Contains
                checkPosition(endPosition, [4 /* Following */]) &&
                !checkPosition(endPosition, [16 /* ContainedBy */])));
    }
    function checkPosition(position, targets) {
        return targets.some(function (target) {
            return target == 0 /* Same */
                ? position == 0 /* Same */
                : (position & target) == target;
        });
    }

    var unwrap$1 = {};

    Object.defineProperty(unwrap$1, "__esModule", { value: true });
    /**
     * Removes the node and keep all children in place, return the parentNode where the children are attached
     * @param node the node to remove
     */
    function unwrap(node) {
        // Unwrap requires a parentNode
        var parentNode = node ? node.parentNode : null;
        if (!parentNode) {
            return null;
        }
        while (node.firstChild) {
            parentNode.insertBefore(node.firstChild, node);
        }
        parentNode.removeChild(node);
        return parentNode;
    }
    unwrap$1.default = unwrap;

    var normalizeRect$1 = {};

    Object.defineProperty(normalizeRect$1, "__esModule", { value: true });
    /**
     * A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p
     * We validate that and only return a rect when the passed in ClientRect is valid
     */
    function normalizeRect(clientRect) {
        var _a = clientRect || { left: 0, right: 0, top: 0, bottom: 0 }, left = _a.left, right = _a.right, top = _a.top, bottom = _a.bottom;
        return left === 0 && right === 0 && top === 0 && bottom === 0
            ? null
            : {
                left: Math.round(left),
                right: Math.round(right),
                top: Math.round(top),
                bottom: Math.round(bottom),
            };
    }
    normalizeRect$1.default = normalizeRect;

    var getInnerHTML$1 = {};

    Object.defineProperty(getInnerHTML$1, "__esModule", { value: true });
    var safeInstanceOf_1$a = safeInstanceOf$1;
    /**
     * Get innerHTML of the given node
     * @param node The DOM node to get innerHTML from
     */
    function getInnerHTML(node) {
        if ((0, safeInstanceOf_1$a.default)(node, 'HTMLElement')) {
            return node.innerHTML;
        }
        else if (node) {
            var tempNode = node.ownerDocument.createElement('span');
            tempNode.appendChild(node.cloneNode(true /*deep*/));
            return tempNode.innerHTML;
        }
        else {
            return '';
        }
    }
    getInnerHTML$1.default = getInnerHTML;

    var getIntersectedRect$1 = {};

    Object.defineProperty(getIntersectedRect$1, "__esModule", { value: true });
    var normalizeRect_1$2 = normalizeRect$1;
    /**
     * Get the intersected Rect of elements provided
     *
     * @example
     * The result of the following Elements Rects would be:
        {
            top: Element2.top,
            bottom: Element1.bottom,
            left: Element2.left,
            right: Element2.right
        }
        +-------------------------+
        | Element 1               |
        |   +-----------------+   |
        |   | Element2        |   |
        |   |                 |   |
        |   |                 |   |
        +-------------------------+
            |                 |
            +-----------------+

     * @param elements Elements to use.
     * @param additionalRects additional rects to use
     * @returns If the Rect is valid return the rect, if not, return null.
     */
    function getIntersectedRect(elements, additionalRects) {
        if (additionalRects === void 0) { additionalRects = []; }
        var rects = elements
            .map(function (element) { return (0, normalizeRect_1$2.default)(element.getBoundingClientRect()); })
            .concat(additionalRects)
            .filter(function (element) { return !!element; });
        var result = {
            top: Math.max.apply(Math, rects.map(function (r) { return r.top; })),
            bottom: Math.min.apply(Math, rects.map(function (r) { return r.bottom; })),
            left: Math.max.apply(Math, rects.map(function (r) { return r.left; })),
            right: Math.min.apply(Math, rects.map(function (r) { return r.right; })),
        };
        return result.top < result.bottom && result.left < result.right ? result : null;
    }
    getIntersectedRect$1.default = getIntersectedRect;

    var VTable$1 = {};

    var applyTableFormat$1 = {};

    var tableCellInfo = {};

    var definitionCreators = {};

    Object.defineProperty(definitionCreators, "__esModule", { value: true });
    definitionCreators.createObjectDefinition = definitionCreators.createArrayDefinition = definitionCreators.createStringDefinition = definitionCreators.createBooleanDefinition = definitionCreators.createNumberDefinition = void 0;
    /**
     * Create a number definition
     * @param isOptional Whether this property is optional
     * @param value Optional value of the number
     * @param minValue Optional minimum value
     * @param maxValue Optional maximum value
     * @param allowNull Allow the property to be null
     * @returns The number definition object
     */
    function createNumberDefinition(isOptional, value, minValue, maxValue, allowNull) {
        return {
            type: 1 /* Number */,
            isOptional: isOptional,
            value: value,
            maxValue: maxValue,
            minValue: minValue,
            allowNull: allowNull,
        };
    }
    definitionCreators.createNumberDefinition = createNumberDefinition;
    /**
     * Create a boolean definition
     * @param isOptional  Whether this property is optional
     * @param value Optional expected boolean value
     * @param allowNull Allow the property to be null
     * @returns  The boolean definition object
     */
    function createBooleanDefinition(isOptional, value, allowNull) {
        return {
            type: 0 /* Boolean */,
            isOptional: isOptional,
            value: value,
            allowNull: allowNull,
        };
    }
    definitionCreators.createBooleanDefinition = createBooleanDefinition;
    /**
     * Create a string definition
     * @param isOptional  Whether this property is optional
     * @param value Optional expected string value
     * @param allowNull Allow the property to be null
     * @returns  The string definition object
     */
    function createStringDefinition(isOptional, value, allowNull) {
        return {
            type: 2 /* String */,
            isOptional: isOptional,
            value: value,
            allowNull: allowNull,
        };
    }
    definitionCreators.createStringDefinition = createStringDefinition;
    /**
     * Create an array definition
     * @param itemDef Definition of each item of the related array
     * @param isOptional  Whether this property is optional
     * @param allowNull Allow the property to be null
     * @returns  The array definition object
     */
    function createArrayDefinition(itemDef, isOptional, minLength, maxLength, allowNull) {
        return {
            type: 3 /* Array */,
            isOptional: isOptional,
            itemDef: itemDef,
            minLength: minLength,
            maxLength: maxLength,
            allowNull: allowNull,
        };
    }
    definitionCreators.createArrayDefinition = createArrayDefinition;
    /**
     * Create an object definition
     * @param propertyDef Definition of each property of the related object
     * @param isOptional  Whether this property is optional
     * @param allowNull Allow the property to be null
     * @returns  The object definition object
     */
    function createObjectDefinition(propertyDef, isOptional, allowNull) {
        return {
            type: 4 /* Object */,
            isOptional: isOptional,
            propertyDef: propertyDef,
            allowNull: allowNull,
        };
    }
    definitionCreators.createObjectDefinition = createObjectDefinition;

    var metadata = {};

    var validate$1 = {};

    Object.defineProperty(validate$1, "__esModule", { value: true });
    var getObjectKeys_1$5 = getObjectKeys$1;
    /**
     * Validate the given object with a type definition object
     * @param input The object to validate
     * @param def The type definition object used for validation
     * @returns True if the object passed the validation, otherwise false
     */
    function validate(input, def) {
        var result = false;
        if ((def.isOptional && typeof input === 'undefined') || (def.allowNull && input === null)) {
            result = true;
        }
        else if ((!def.isOptional && typeof input === 'undefined') ||
            (!def.allowNull && input === null)) {
            return false;
        }
        else {
            switch (def.type) {
                case 2 /* String */:
                    result =
                        typeof input === 'string' &&
                            (typeof def.value === 'undefined' || input === def.value);
                    break;
                case 1 /* Number */:
                    result =
                        typeof input === 'number' &&
                            (typeof def.value === 'undefined' || areSameNumbers(def.value, input)) &&
                            (typeof def.minValue === 'undefined' || input >= def.minValue) &&
                            (typeof def.maxValue === 'undefined' || input <= def.maxValue);
                    break;
                case 0 /* Boolean */:
                    result =
                        typeof input === 'boolean' &&
                            (typeof def.value === 'undefined' || input === def.value);
                    break;
                case 3 /* Array */:
                    result =
                        Array.isArray(input) &&
                            (typeof def.minLength === 'undefined' || input.length >= def.minLength) &&
                            (typeof def.maxLength === 'undefined' || input.length <= def.maxLength) &&
                            input.every(function (x) { return validate(x, def.itemDef); });
                    break;
                case 4 /* Object */:
                    result =
                        typeof input === 'object' &&
                            (0, getObjectKeys_1$5.default)(def.propertyDef).every(function (x) {
                                return validate(input[x], def.propertyDef[x]);
                            });
                    break;
                case 5 /* Customize */:
                    result = def.validator(input);
                    break;
            }
        }
        return result;
    }
    validate$1.default = validate;
    function areSameNumbers(n1, n2) {
        return Math.abs(n1 - n2) < 1e-3;
    }

    Object.defineProperty(metadata, "__esModule", { value: true });
    metadata.removeMetadata = metadata.setMetadata = metadata.getMetadata = void 0;
    var validate_1$1 = validate$1;
    var MetadataDataSetName = 'editingInfo';
    /**
     * Get metadata object from an HTML element
     * @param element The HTML element to get metadata object from
     * @param definition The type definition of this metadata used for validate this metadata object.
     * If not specified, no validation will be performed and always return whatever we get from the element
     * @param defaultValue The default value to return if the retrieved object cannot pass the validation,
     * or there is no metadata object at all
     * @returns The strong-type metadata object if it can be validated, or null
     */
    function getMetadata(element, definition, defaultValue) {
        var str = element.dataset[MetadataDataSetName];
        var obj;
        try {
            obj = str ? JSON.parse(str) : null;
        }
        catch (_a) { }
        if (typeof obj !== 'undefined') {
            if (!definition) {
                return obj;
            }
            else if ((0, validate_1$1.default)(obj, definition)) {
                return obj;
            }
        }
        if (defaultValue) {
            return defaultValue;
        }
        else {
            return null;
        }
    }
    metadata.getMetadata = getMetadata;
    /**
     * Set metadata object into an HTML element
     * @param element The HTML element to set metadata object to
     * @param metadata The metadata object to set
     * @param def An optional type definition object used for validate this metadata object.
     * If not specified, metadata will be set without validation
     * @returns True if metadata is set, otherwise false
     */
    function setMetadata(element, metadata, def) {
        if (!def || (0, validate_1$1.default)(metadata, def)) {
            element.dataset[MetadataDataSetName] = JSON.stringify(metadata);
            return true;
        }
        else {
            return false;
        }
    }
    metadata.setMetadata = setMetadata;
    /**
     * Remove metadata from the given element if any
     * @param element The element to remove metadata from
     */
    function removeMetadata(element) {
        delete element.dataset[MetadataDataSetName];
    }
    metadata.removeMetadata = removeMetadata;

    Object.defineProperty(tableCellInfo, "__esModule", { value: true });
    tableCellInfo.saveTableCellMetadata = tableCellInfo.getTableCellMetadata = void 0;
    var definitionCreators_1$2 = definitionCreators;
    var metadata_1$3 = metadata;
    var BooleanDefinition$1 = (0, definitionCreators_1$2.createBooleanDefinition)(false /** isOptional */, undefined /** value */, true /** allowNull */);
    var TableCellFormatMetadata = (0, definitionCreators_1$2.createObjectDefinition)({
        bgColorOverride: BooleanDefinition$1,
    }, false /* isOptional */, true /** allowNull */);
    /**
     * @internal
     * Get the format info of a table cell
     * @param cell The table cell to use
     */
    function getTableCellMetadata(cell) {
        return (0, metadata_1$3.getMetadata)(cell, TableCellFormatMetadata);
    }
    tableCellInfo.getTableCellMetadata = getTableCellMetadata;
    /**
     * Add metadata to a cell
     * @param cell The table cell to add the metadata
     * @param format The format of the table
     */
    function saveTableCellMetadata(cell, format) {
        if (cell && format) {
            (0, metadata_1$3.setMetadata)(cell, format, TableCellFormatMetadata);
        }
    }
    tableCellInfo.saveTableCellMetadata = saveTableCellMetadata;

    Object.defineProperty(applyTableFormat$1, "__esModule", { value: true });
    var changeElementTag_1$4 = changeElementTag$1;
    var setColor_1 = setColor$1;
    var tableCellInfo_1$1 = tableCellInfo;
    var TRANSPARENT = 'transparent';
    var TABLE_CELL_TAG_NAME = 'TD';
    var TABLE_HEADER_TAG_NAME = 'TH';
    /**
     * @internal
     * Apply the given table format to this virtual table
     * @param format Table format to apply
     */
    function applyTableFormat(table, cells, format) {
        if (!format) {
            return;
        }
        table.style.borderCollapse = 'collapse';
        setBordersType(cells, format);
        setCellColor(cells, format);
        setFirstColumnFormat(cells, format);
        setHeaderRowFormat(cells, format);
    }
    applyTableFormat$1.default = applyTableFormat;
    /**
     * Check if the cell has shade
     * @param cell
     * @returns
     */
    function hasCellShade(cell) {
        var _a;
        if (!cell.td) {
            return false;
        }
        return !!((_a = (0, tableCellInfo_1$1.getTableCellMetadata)(cell.td)) === null || _a === void 0 ? void 0 : _a.bgColorOverride);
    }
    /**
     * Set color to the table
     * @param format the format that must be applied
     */
    function setCellColor(cells, format) {
        var color = function (index) { return (index % 2 === 0 ? format.bgColorEven : format.bgColorOdd); };
        var hasBandedRows = format.hasBandedRows, hasBandedColumns = format.hasBandedColumns, bgColorOdd = format.bgColorOdd, bgColorEven = format.bgColorEven;
        var shouldColorWholeTable = !hasBandedRows && bgColorOdd === bgColorEven ? true : false;
        cells.forEach(function (row, index) {
            row.forEach(function (cell) {
                if (cell.td && !hasCellShade(cell)) {
                    if (hasBandedRows) {
                        var backgroundColor = color(index);
                        (0, setColor_1.default)(cell.td, backgroundColor || TRANSPARENT, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */);
                    }
                    else if (shouldColorWholeTable) {
                        (0, setColor_1.default)(cell.td, format.bgColorOdd || TRANSPARENT, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */);
                    }
                    else {
                        (0, setColor_1.default)(cell.td, TRANSPARENT, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */);
                    }
                }
            });
        });
        if (hasBandedColumns) {
            cells.forEach(function (row) {
                row.forEach(function (cell, index) {
                    var backgroundColor = color(index);
                    if (cell.td && backgroundColor && !hasCellShade(cell)) {
                        (0, setColor_1.default)(cell.td, backgroundColor, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */);
                    }
                });
            });
        }
    }
    /**
     * Set color to borders of an table
     * @param format
     * @returns
     */
    function setBorderColors(td, format) {
        td.style.borderTop = getBorderStyle(format.topBorderColor);
        td.style.borderLeft = getBorderStyle(format.verticalBorderColor);
        td.style.borderRight = getBorderStyle(format.verticalBorderColor);
        td.style.borderBottom = getBorderStyle(format.bottomBorderColor);
    }
    /**
     * Format the border type
     * @returns
     */
    function formatBorders(format, td, isFirstRow, isLastRow, isFirstColumn, isLastColumn) {
        setBorderColors(td, format);
        switch (format.tableBorderFormat) {
            case 0 /* DEFAULT */:
                return;
            case 1 /* LIST_WITH_SIDE_BORDERS */:
                if (!isFirstColumn) {
                    td.style.borderLeftColor = TRANSPARENT;
                }
                if (!isLastColumn) {
                    td.style.borderRightColor = TRANSPARENT;
                }
                break;
            case 4 /* FIRST_COLUMN_HEADER_EXTERNAL */:
                if (!isFirstRow) {
                    td.style.borderTopColor = TRANSPARENT;
                }
                if (!isLastRow && !isFirstRow) {
                    td.style.borderBottomColor = TRANSPARENT;
                }
                if (!isFirstColumn) {
                    td.style.borderLeftColor = TRANSPARENT;
                }
                if (!isLastColumn && !isFirstColumn) {
                    td.style.borderRightColor = TRANSPARENT;
                }
                if (isFirstColumn && isFirstRow) {
                    td.style.borderRightColor = TRANSPARENT;
                }
                break;
            case 2 /* NO_HEADER_BORDERS */:
                if (isFirstRow) {
                    td.style.borderTopColor = TRANSPARENT;
                    td.style.borderRightColor = TRANSPARENT;
                    td.style.borderLeftColor = TRANSPARENT;
                }
                if (isFirstColumn) {
                    td.style.borderLeftColor = TRANSPARENT;
                }
                if (isLastColumn) {
                    td.style.borderRightColor = TRANSPARENT;
                }
                break;
            case 3 /* NO_SIDE_BORDERS */:
                if (isFirstColumn) {
                    td.style.borderLeftColor = TRANSPARENT;
                }
                if (isLastColumn) {
                    td.style.borderRightColor = TRANSPARENT;
                }
                break;
            case 5 /* ESPECIAL_TYPE_1 */:
                if (isFirstRow) {
                    td.style.borderRightColor = TRANSPARENT;
                    td.style.borderLeftColor = TRANSPARENT;
                }
                if (isFirstColumn) {
                    td.style.borderBottomColor = TRANSPARENT;
                    td.style.borderTopColor = TRANSPARENT;
                }
                if (isFirstRow && isFirstColumn) {
                    td.style.borderLeftColor = format.verticalBorderColor || TRANSPARENT;
                    td.style.borderBottomColor = format.bottomBorderColor || TRANSPARENT;
                    td.style.borderTopColor = format.topBorderColor || TRANSPARENT;
                }
                break;
            case 6 /* ESPECIAL_TYPE_2 */:
                if (isFirstRow) {
                    td.style.borderRightColor = TRANSPARENT;
                    td.style.borderLeftColor = TRANSPARENT;
                }
                if (isFirstColumn) {
                    td.style.borderBottomColor = TRANSPARENT;
                    td.style.borderTopColor = TRANSPARENT;
                }
                if (isFirstRow && isFirstColumn) {
                    td.style.borderLeftColor = format.verticalBorderColor || TRANSPARENT;
                    td.style.borderBottomColor = format.bottomBorderColor || TRANSPARENT;
                    td.style.borderTopColor = format.topBorderColor || TRANSPARENT;
                }
                if (!isFirstRow && !isFirstColumn) {
                    td.style.borderLeftColor = TRANSPARENT;
                    td.style.borderBottomColor = TRANSPARENT;
                    td.style.borderTopColor = TRANSPARENT;
                    td.style.borderRightColor = TRANSPARENT;
                }
                break;
            case 7 /* ESPECIAL_TYPE_3 */:
                if (isFirstRow) {
                    td.style.borderLeftColor = TRANSPARENT;
                    td.style.borderTopColor = TRANSPARENT;
                    td.style.borderRightColor = TRANSPARENT;
                }
                if (isFirstColumn) {
                    td.style.borderLeftColor = TRANSPARENT;
                    td.style.borderTopColor = TRANSPARENT;
                    td.style.borderBottomColor = TRANSPARENT;
                }
                if (!isFirstRow && !isFirstColumn) {
                    td.style.borderLeftColor = TRANSPARENT;
                    td.style.borderBottomColor = TRANSPARENT;
                    td.style.borderTopColor = TRANSPARENT;
                    td.style.borderRightColor = TRANSPARENT;
                }
                if (isFirstRow && isFirstColumn) {
                    td.style.borderBottomColor = format.bottomBorderColor || TRANSPARENT;
                }
                break;
        }
    }
    /**
     * Organize the borders of table according to a border type
     * @param format
     * @returns
     */
    function setBordersType(cells, format) {
        cells.forEach(function (row, rowIndex) {
            row.forEach(function (cell, cellIndex) {
                if (cell.td) {
                    formatBorders(format, cell.td, rowIndex === 0, rowIndex === cells.length - 1, cellIndex === 0, cellIndex === row.length - 1);
                }
            });
        });
    }
    /**
     * Apply custom design to the first table column
     * @param format
     * @returns
     */
    function setFirstColumnFormat(cells, format) {
        if (!format.hasFirstColumn) {
            cells.forEach(function (row) {
                row.forEach(function (cell, cellIndex) {
                    if (cell.td && cellIndex === 0) {
                        cell.td = (0, changeElementTag_1$4.default)(cell.td, TABLE_CELL_TAG_NAME);
                        cell.td.scope = '';
                    }
                });
            });
            return;
        }
        cells.forEach(function (row, rowIndex) {
            row.forEach(function (cell, cellIndex) {
                if (cell.td && cellIndex === 0) {
                    if (rowIndex !== 0 && !hasCellShade(cell)) {
                        cell.td.style.borderTopColor = TRANSPARENT;
                        (0, setColor_1.default)(cell.td, TRANSPARENT, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */);
                    }
                    if (rowIndex !== cells.length - 1 && rowIndex !== 0) {
                        cell.td.style.borderBottomColor = TRANSPARENT;
                    }
                    cell.td = (0, changeElementTag_1$4.default)(cell.td, TABLE_HEADER_TAG_NAME);
                    cell.td.scope = 'col';
                }
            });
        });
    }
    /**
     * Apply custom design to the Header Row
     * @param format
     * @returns
     */
    function setHeaderRowFormat(cells, format) {
        var _a, _b;
        if (!format.hasHeaderRow) {
            (_a = cells[0]) === null || _a === void 0 ? void 0 : _a.forEach(function (cell) {
                if (cell.td) {
                    cell.td = (0, changeElementTag_1$4.default)(cell.td, TABLE_CELL_TAG_NAME);
                    cell.td.scope = '';
                }
            });
            return;
        }
        (_b = cells[0]) === null || _b === void 0 ? void 0 : _b.forEach(function (cell) {
            if (cell.td && format.headerRowColor) {
                if (!hasCellShade(cell)) {
                    (0, setColor_1.default)(cell.td, format.headerRowColor, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */);
                }
                cell.td.style.borderRightColor = format.headerRowColor;
                cell.td.style.borderLeftColor = format.headerRowColor;
                cell.td.style.borderTopColor = format.headerRowColor;
                cell.td = (0, changeElementTag_1$4.default)(cell.td, TABLE_HEADER_TAG_NAME);
                cell.td.scope = 'row';
            }
        });
    }
    function getBorderStyle(style) {
        var color = style ? style : 'transparent';
        return 'solid 1px ' + color;
    }

    var tableFormatInfo = {};

    Object.defineProperty(tableFormatInfo, "__esModule", { value: true });
    tableFormatInfo.saveTableInfo = tableFormatInfo.getTableFormatInfo = void 0;
    var metadata_1$2 = metadata;
    var definitionCreators_1$1 = definitionCreators;
    var NullStringDefinition = (0, definitionCreators_1$1.createStringDefinition)(false /** isOptional */, undefined /** value */, true /** allowNull */);
    var BooleanDefinition = (0, definitionCreators_1$1.createBooleanDefinition)(false /** isOptional */);
    var TableFormatMetadata = (0, definitionCreators_1$1.createObjectDefinition)({
        topBorderColor: NullStringDefinition,
        bottomBorderColor: NullStringDefinition,
        verticalBorderColor: NullStringDefinition,
        hasHeaderRow: BooleanDefinition,
        headerRowColor: NullStringDefinition,
        hasFirstColumn: BooleanDefinition,
        hasBandedColumns: BooleanDefinition,
        hasBandedRows: BooleanDefinition,
        bgColorEven: NullStringDefinition,
        bgColorOdd: NullStringDefinition,
        tableBorderFormat: (0, definitionCreators_1$1.createNumberDefinition)(false /** isOptional */, undefined /* value */, 0 /* DEFAULT */, 8 /* CLEAR */),
        keepCellShade: (0, definitionCreators_1$1.createBooleanDefinition)(true /** isOptional */),
    }, false /* isOptional */, true /** allowNull */);
    /**
     * Get the format info of a table
     * If the table does not have a info saved, it will be retrieved from the css styles
     * @param table The table that has the info
     */
    function getTableFormatInfo(table) {
        return (0, metadata_1$2.getMetadata)(table, TableFormatMetadata);
    }
    tableFormatInfo.getTableFormatInfo = getTableFormatInfo;
    /**
     * @internal
     * Save the format info of a table
     * @param table The table the info will be saved
     * @param format The format of the table
     */
    function saveTableInfo(table, format) {
        if (table && format) {
            (0, metadata_1$2.setMetadata)(table, format, TableFormatMetadata);
        }
    }
    tableFormatInfo.saveTableInfo = saveTableInfo;

    var __assign$i = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$i = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$i.apply(this, arguments);
    };
    Object.defineProperty(VTable$1, "__esModule", { value: true });
    var applyTableFormat_1 = applyTableFormat$1;
    var getTagOfNode_1$7 = getTagOfNode$1;
    var moveChildNodes_1$2 = moveChildNodes$1;
    var normalizeRect_1$1 = normalizeRect$1;
    var safeInstanceOf_1$9 = safeInstanceOf$1;
    var toArray_1$4 = toArray$1;
    var tableFormatInfo_1 = tableFormatInfo;
    var metadata_1$1 = metadata;
    var DEFAULT_FORMAT = {
        topBorderColor: '#ABABAB',
        bottomBorderColor: '#ABABAB',
        verticalBorderColor: '#ABABAB',
        hasHeaderRow: false,
        hasFirstColumn: false,
        hasBandedRows: false,
        hasBandedColumns: false,
        bgColorEven: null,
        bgColorOdd: '#ABABAB20',
        headerRowColor: '#ABABAB',
        tableBorderFormat: 0 /* DEFAULT */,
        keepCellShade: false,
    };
    /**
     * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells
     */
    var VTable = /** @class */ (function () {
        /**
         * Create a new instance of VTable object using HTML TABLE or TD node
         * @param node The HTML Table or TD node
         * @param normalizeSize Whether table size needs to be normalized
         * @param zoomScale When the table is under a zoomed container, pass in the zoom scale here
         */
        function VTable(node, normalizeSize, zoomScale) {
            var _this = this;
            /**
             * Virtual cells
             */
            this.cells = null;
            /**
             * Current format of the table
             */
            this.formatInfo = null;
            this.trs = [];
            this.tableSelection = null;
            this.table = (0, safeInstanceOf_1$9.default)(node, 'HTMLTableElement') ? node : getTableFromTd(node);
            if (this.table) {
                var currentTd_1 = (0, safeInstanceOf_1$9.default)(node, 'HTMLTableElement') ? null : node;
                var trs = (0, toArray_1$4.default)(this.table.rows);
                this.cells = trs.map(function (row) { return []; });
                trs.forEach(function (tr, rowIndex) {
                    var _a;
                    _this.trs[rowIndex % 2] = tr;
                    for (var sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {
                        // Skip the cells which already initialized
                        for (; _this.cells[rowIndex][targetCol]; targetCol++) { }
                        var td = tr.cells[sourceCol];
                        if (td == currentTd_1) {
                            _this.col = targetCol;
                            _this.row = rowIndex;
                        }
                        for (var colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {
                            for (var rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {
                                var hasTd = colSpan + rowSpan == 0;
                                var rect = td.getBoundingClientRect();
                                if ((_a = _this.cells) === null || _a === void 0 ? void 0 : _a[rowIndex + rowSpan]) {
                                    _this.cells[rowIndex + rowSpan][targetCol] = {
                                        td: hasTd ? td : null,
                                        spanLeft: colSpan > 0,
                                        spanAbove: rowSpan > 0,
                                        width: hasTd ? rect.width : undefined,
                                        height: hasTd ? rect.height : undefined,
                                    };
                                }
                            }
                        }
                    }
                });
                this.formatInfo = (0, tableFormatInfo_1.getTableFormatInfo)(this.table);
                if (normalizeSize) {
                    this.normalizeSize(typeof zoomScale == 'number' ? function (n) { return n / zoomScale; } : zoomScale);
                }
            }
        }
        Object.defineProperty(VTable.prototype, "selection", {
            /**
             * Selected range of cells with the coordinates of the first and last cell selected.
             */
            get: function () {
                return this.tableSelection || null;
            },
            set: function (value) {
                if (value) {
                    var firstCell = value.firstCell;
                    this.row = firstCell === null || firstCell === void 0 ? void 0 : firstCell.y;
                    this.col = firstCell === null || firstCell === void 0 ? void 0 : firstCell.x;
                }
                this.tableSelection = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Write the virtual table back to DOM tree to represent the change of VTable
         * @param skipApplyFormat Do not reapply table format when write back.
         * Only use this parameter when you are pretty sure there is no format or table structure change during the process.
         */
        VTable.prototype.writeBack = function (skipApplyFormat) {
            var _this = this;
            var _a;
            if (this.cells) {
                (0, moveChildNodes_1$2.default)(this.table);
                this.cells.forEach(function (row, r) {
                    var tr = cloneNode$1(_this.trs[r % 2] || _this.trs[0]);
                    if (tr) {
                        _this.table.appendChild(tr);
                        row.forEach(function (cell, c) {
                            if (cell.td) {
                                _this.recalculateSpans(r, c);
                                _this.recalculateCellHeight(cell.td);
                                tr.appendChild(cell.td);
                            }
                        });
                    }
                });
                if (this.formatInfo && !skipApplyFormat) {
                    (0, tableFormatInfo_1.saveTableInfo)(this.table, this.formatInfo);
                    (0, applyTableFormat_1.default)(this.table, this.cells, this.formatInfo);
                }
            }
            else if (this.table) {
                (_a = this.table.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.table);
            }
        };
        VTable.prototype.recalculateCellHeight = function (td) {
            if (this.isEmptyCell(td) && td.rowSpan > 1) {
                for (var i = 1; i < td.rowSpan; i++) {
                    var br = document.createElement('br');
                    td.appendChild(br);
                }
            }
        };
        /**
         * Apply the given table format to this virtual table
         * @param format Table format to apply
         */
        VTable.prototype.applyFormat = function (format) {
            if (!this.table) {
                return;
            }
            this.formatInfo = __assign$i(__assign$i(__assign$i({}, DEFAULT_FORMAT), (this.formatInfo || {})), (format || {}));
            if (!this.formatInfo.keepCellShade) {
                this.deleteCellShadeDataset(this.cells);
            }
        };
        /**
         * Remove the cellShade dataset to apply a new style format at the cell.
         * @param cells
         */
        VTable.prototype.deleteCellShadeDataset = function (cells) {
            cells === null || cells === void 0 ? void 0 : cells.forEach(function (row) {
                row.forEach(function (cell) {
                    if (cell.td) {
                        (0, metadata_1$1.removeMetadata)(cell.td);
                    }
                });
            });
        };
        /**
         * Edit table with given operation.
         * @param operation Table operation
         */
        VTable.prototype.edit = function (operation) {
            var _this = this;
            var _a, _b;
            if (!this.table || !this.cells || this.row === undefined || this.col == undefined) {
                return;
            }
            var currentRow = this.cells[this.row];
            var currentCell = currentRow[this.col];
            var firstRow = this.selection ? this.selection.firstCell.y : this.row;
            var lastRow = this.selection ? this.selection.lastCell.y : this.row;
            var firstColumn = this.selection ? this.selection.firstCell.x : this.col;
            var lastColumn = this.selection ? this.selection.lastCell.x : this.col;
            switch (operation) {
                case 0 /* InsertAbove */:
                    for (var i = firstRow; i <= lastRow; i++) {
                        this.cells.splice(firstRow, 0, currentRow.map(cloneCell));
                    }
                    break;
                case 1 /* InsertBelow */:
                    var _loop_1 = function (i) {
                        var newRow = lastRow + this_1.countSpanAbove(lastRow, this_1.col);
                        this_1.cells.splice(newRow, 0, this_1.cells[newRow - 1].map(function (cell, colIndex) {
                            var nextCell = _this.getCell(newRow, colIndex);
                            if (nextCell.spanAbove) {
                                return cloneCell(nextCell);
                            }
                            else if (cell.spanLeft) {
                                var newCell = cloneCell(cell);
                                newCell.spanAbove = false;
                                return newCell;
                            }
                            else {
                                return {
                                    td: cloneNode$1(_this.getTd(_this.row, colIndex)),
                                };
                            }
                        }));
                    };
                    var this_1 = this;
                    for (var i = firstRow; i <= lastRow; i++) {
                        _loop_1(i);
                    }
                    break;
                case 2 /* InsertLeft */:
                    var _loop_2 = function (i) {
                        this_2.forEachCellOfCurrentColumn(function (cell, row) {
                            row.splice(i, 0, cloneCell(cell));
                        });
                    };
                    var this_2 = this;
                    for (var i = firstColumn; i <= lastColumn; i++) {
                        _loop_2(i);
                    }
                    break;
                case 3 /* InsertRight */:
                    var _loop_3 = function (i) {
                        var newCol = lastColumn + this_3.countSpanLeft(this_3.row, lastColumn);
                        this_3.forEachCellOfColumn(newCol - 1, function (cell, row, i) {
                            var nextCell = _this.getCell(i, newCol);
                            var newCell;
                            if (nextCell.spanLeft) {
                                newCell = cloneCell(nextCell);
                            }
                            else if (cell.spanAbove) {
                                newCell = cloneCell(cell);
                                newCell.spanLeft = false;
                            }
                            else {
                                newCell = {
                                    td: cloneNode$1(_this.getTd(i, _this.col)),
                                };
                            }
                            row.splice(newCol, 0, newCell);
                        });
                    };
                    var this_3 = this;
                    for (var i = firstColumn; i <= lastColumn; i++) {
                        _loop_3(i);
                    }
                    break;
                case 6 /* DeleteRow */:
                    var _loop_4 = function (rowIndex) {
                        this_4.forEachCellOfRow(rowIndex, function (cell, i) {
                            var nextCell = _this.getCell(rowIndex + 1, i);
                            if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {
                                nextCell.td = cell.td;
                            }
                        });
                    };
                    var this_4 = this;
                    for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {
                        _loop_4(rowIndex);
                    }
                    var removedRows = this.selection
                        ? this.selection.lastCell.y - this.selection.firstCell.y
                        : 0;
                    this.cells.splice(firstRow, removedRows + 1);
                    if (this.cells.length === 0) {
                        this.cells = null;
                    }
                    break;
                case 5 /* DeleteColumn */:
                    var deletedColumns_1 = 0;
                    var _loop_5 = function (colIndex) {
                        this_5.forEachCellOfColumn(colIndex, function (cell, row, i) {
                            var nextCell = _this.getCell(i, colIndex + 1);
                            if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {
                                nextCell.td = cell.td;
                            }
                            var removedColumns = _this.selection
                                ? colIndex - deletedColumns_1
                                : _this.col;
                            row.splice(removedColumns, 1);
                        });
                        deletedColumns_1++;
                    };
                    var this_5 = this;
                    for (var colIndex = firstColumn; colIndex <= lastColumn; colIndex++) {
                        _loop_5(colIndex);
                    }
                    if (((_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) === 0 || ((_b = this.cells) === null || _b === void 0 ? void 0 : _b.every(function (row) { return row.length === 0; }))) {
                        this.cells = null;
                    }
                    break;
                case 7 /* MergeAbove */:
                case 8 /* MergeBelow */:
                    var rowStep = operation == 7 /* MergeAbove */ ? -1 : 1;
                    for (var rowIndex = this.row + rowStep; rowIndex >= 0 && rowIndex < this.cells.length; rowIndex += rowStep) {
                        var cell = this.getCell(rowIndex, this.col);
                        if (cell.td && !cell.spanAbove) {
                            var aboveCell = rowIndex < this.row ? cell : currentCell;
                            var belowCell = rowIndex < this.row ? currentCell : cell;
                            this.mergeCells(aboveCell, belowCell);
                            break;
                        }
                    }
                    break;
                case 9 /* MergeLeft */:
                case 10 /* MergeRight */:
                    var colStep = operation == 9 /* MergeLeft */ ? -1 : 1;
                    for (var colIndex = this.col + colStep; colIndex >= 0 && colIndex < this.cells[this.row].length; colIndex += colStep) {
                        var cell = this.getCell(this.row, colIndex);
                        if (cell.td && !cell.spanLeft) {
                            var leftCell = colIndex < this.col ? cell : currentCell;
                            var rightCell = colIndex < this.col ? currentCell : cell;
                            this.mergeCells(leftCell, rightCell, true /** horizontally */);
                            break;
                        }
                    }
                    break;
                case 11 /* MergeCells */:
                    for (var colIndex = firstColumn; colIndex <= lastColumn; colIndex++) {
                        for (var rowIndex = firstRow + 1; rowIndex <= lastRow; rowIndex++) {
                            var cell = this.getCell(firstRow, colIndex);
                            var nextCellBelow = this.getCell(rowIndex, colIndex);
                            this.mergeCells(cell, nextCellBelow);
                        }
                    }
                    for (var colIndex = firstColumn + 1; colIndex <= lastColumn; colIndex++) {
                        var cell = this.getCell(firstRow, firstColumn);
                        var nextCellRight = this.getCell(firstRow, colIndex);
                        this.mergeCells(cell, nextCellRight, true /** horizontally */);
                    }
                    break;
                case 4 /* DeleteTable */:
                    this.cells = null;
                    break;
                case 13 /* SplitVertically */:
                    if (currentCell.td && currentCell.td.rowSpan > 1) {
                        this.getCell(this.row + 1, this.col).td = cloneNode$1(currentCell.td);
                    }
                    else {
                        var splitRow = currentRow.map(function (cell) {
                            return {
                                td: cell == currentCell ? cloneNode$1(cell.td) : null,
                                spanAbove: cell != currentCell,
                                spanLeft: cell.spanLeft,
                            };
                        });
                        this.cells.splice(this.row + 1, 0, splitRow);
                    }
                    break;
                case 12 /* SplitHorizontally */:
                    if (currentCell.td && currentCell.td.colSpan > 1) {
                        this.getCell(this.row, this.col + 1).td = cloneNode$1(currentCell.td);
                    }
                    else {
                        this.forEachCellOfCurrentColumn(function (cell, row) {
                            row.splice(_this.col + 1, 0, {
                                td: row == currentRow ? cloneNode$1(cell.td) : null,
                                spanAbove: cell.spanAbove,
                                spanLeft: row != currentRow,
                            });
                        });
                    }
                    break;
                case 14 /* AlignCenter */:
                    this.table.style.marginLeft = 'auto';
                    this.table.style.marginRight = 'auto';
                    break;
                case 15 /* AlignLeft */:
                    this.table.style.marginLeft = '';
                    this.table.style.marginRight = 'auto';
                    break;
                case 16 /* AlignRight */:
                    this.table.style.marginLeft = 'auto';
                    this.table.style.marginRight = '';
                    break;
                case 18 /* AlignCellCenter */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'center');
                    break;
                case 17 /* AlignCellLeft */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'left');
                    break;
                case 19 /* AlignCellRight */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'right');
                    break;
                case 20 /* AlignCellTop */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'top', true /** isVertical */);
                    break;
                case 21 /* AlignCellMiddle */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'middle', true /** isVertical */);
                    break;
                case 22 /* AlignCellBottom */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'bottom', true /** isVertical */);
                    break;
            }
        };
        VTable.prototype.setAlignmentToSelectedCells = function (firstRow, lastRow, firstColumn, lastColumn, alignmentType, isVertical) {
            var _a, _b;
            for (var i = firstRow; i <= lastRow; i++) {
                for (var j = firstColumn; j <= lastColumn; j++) {
                    if (this.cells) {
                        var cell = this.cells[i][j].td;
                        if (isVertical && cell) {
                            (_a = cell.style) === null || _a === void 0 ? void 0 : _a.setProperty('vertical-align', alignmentType);
                        }
                        else if (cell) {
                            (_b = cell.style) === null || _b === void 0 ? void 0 : _b.setProperty('text-align', alignmentType);
                        }
                    }
                }
            }
        };
        VTable.prototype.mergeCells = function (cell, nextCell, horizontally) {
            var _a, _b, _c, _d;
            var checkSpans = horizontally
                ? ((_a = cell.td) === null || _a === void 0 ? void 0 : _a.rowSpan) === ((_b = nextCell.td) === null || _b === void 0 ? void 0 : _b.rowSpan) && !cell.spanLeft
                : ((_c = cell.td) === null || _c === void 0 ? void 0 : _c.colSpan) === ((_d = nextCell.td) === null || _d === void 0 ? void 0 : _d.colSpan) && !cell.spanAbove;
            if (cell.td && nextCell.td && checkSpans) {
                this.mergeCellContents(cell.td, nextCell.td);
                nextCell.td = null;
                if (horizontally) {
                    nextCell.spanLeft = true;
                }
                else {
                    nextCell.spanAbove = true;
                }
            }
        };
        VTable.prototype.isEmptyCell = function (td) {
            return td.childElementCount === 1 && (0, getTagOfNode_1$7.default)(td.firstChild) === 'BR';
        };
        VTable.prototype.mergeCellContents = function (cellTd, nextCellTd) {
            if (this.isEmptyCell(nextCellTd)) {
                (0, moveChildNodes_1$2.default)(cellTd, nextCellTd, false /*keepExistingChildren*/);
            }
            else {
                var br = document.createElement('br');
                cellTd.appendChild(br);
                (0, moveChildNodes_1$2.default)(cellTd, nextCellTd, true /*keepExistingChildren*/);
            }
        };
        /**
         * Loop each cell of current column and invoke a callback function
         * @param callback The callback function to invoke
         */
        VTable.prototype.forEachCellOfCurrentColumn = function (callback) {
            this.forEachCellOfColumn(this.col, callback);
        };
        /**
         * Loop each table cell and get all the cells that share the same border from one side
         * The result is an array of table cell elements
         * @param borderPos The position of the border
         * @param getLeftCells Get left-hand-side or right-hand-side cells of the border
         *
         * Example, consider having a 3 by 4 table as below with merged and split cells
         *
         *     | 1 | 4 | 7 | 8 |
         *     |   5   |   9   |
         *     |   3   |   10  |
         *
         *  input => borderPos: the 3rd border, getLeftCells: true
         *  output => [4, 5, 3]
         *
         *  input => borderPos: the 3rd border, getLeftCells: false
         *  output => [7, 9, 10]
         *
         *  input => borderPos: the 2nd border, getLeftCells: true
         *  output => [1]
         *
         *  input => borderPos: the 2nd border, getLeftCells: false
         *  output => [4]
         */
        VTable.prototype.getCellsWithBorder = function (borderPos, getLeftCells) {
            var cells = [];
            for (var i = 0; this.cells && i < this.cells.length; i++) {
                for (var j = 0; j < this.cells[i].length; j++) {
                    var cell = this.getCell(i, j);
                    if (cell.td) {
                        var cellRect = (0, normalizeRect_1$1.default)(cell.td.getBoundingClientRect());
                        if (cellRect) {
                            var found = false;
                            if (getLeftCells) {
                                if (cellRect.right == borderPos) {
                                    found = true;
                                    cells.push(cell.td);
                                }
                                else if (found) {
                                    break;
                                }
                            }
                            else {
                                if (cellRect.left == borderPos) {
                                    found = true;
                                    cells.push(cell.td);
                                }
                                else if (found) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            return cells;
        };
        /**
         * Loop each cell of current row and invoke a callback function
         * @param callback The callback function to invoke
         */
        VTable.prototype.forEachCellOfCurrentRow = function (callback) {
            this.forEachCellOfRow(this.row, callback);
        };
        /**
         * Get a table cell using its row and column index. This function will always return an object
         * even if the given indexes don't exist in table.
         * @param row The row index
         * @param col The column index
         */
        VTable.prototype.getCell = function (row, col) {
            return (this.cells && this.cells[row] && this.cells[row][col]) || {};
        };
        /**
         * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell
         */
        VTable.prototype.getCurrentTd = function () {
            return this.getTd(this.row, this.col);
        };
        /**
         * Get the Table Cell in a provided coordinate
         * @param row row of the cell
         * @param col column of the cell
         */
        VTable.prototype.getTd = function (row, col) {
            if (this.cells && row !== undefined && col !== undefined) {
                row = Math.min(this.cells.length - 1, row);
                col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;
                if (!isNaN(row) && !isNaN(col)) {
                    while (row >= 0 && col >= 0) {
                        var cell = this.getCell(row, col);
                        if (cell.td) {
                            return cell.td;
                        }
                        else if (cell.spanLeft) {
                            col--;
                        }
                        else if (cell.spanAbove) {
                            row--;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
            return null;
        };
        VTable.prototype.forEachCellOfColumn = function (col, callback) {
            if (col !== undefined) {
                for (var i = 0; this.cells && i < this.cells.length; i++) {
                    callback(this.getCell(i, col), this.cells[i], i);
                }
            }
        };
        VTable.prototype.forEachCellOfRow = function (row, callback) {
            if (row !== undefined) {
                for (var i = 0; this.cells && i < this.cells[row].length; i++) {
                    callback(this.getCell(row, i), i);
                }
            }
        };
        VTable.prototype.recalculateSpans = function (row, col) {
            var td = this.getCell(row, col).td;
            if (td) {
                td.colSpan = this.countSpanLeft(row, col);
                td.rowSpan = this.countSpanAbove(row, col);
                if (td.colSpan == 1) {
                    td.removeAttribute('colSpan');
                }
                if (td.rowSpan == 1) {
                    td.removeAttribute('rowSpan');
                }
            }
        };
        VTable.prototype.countSpanLeft = function (row, col) {
            var result = 1;
            for (var i = col + 1; this.cells && i < this.cells[row].length; i++) {
                var cell = this.getCell(row, i);
                if (cell.td || !cell.spanLeft) {
                    break;
                }
                result++;
            }
            return result;
        };
        VTable.prototype.countSpanAbove = function (row, col) {
            var result = 1;
            for (var i = row + 1; this.cells && i < this.cells.length; i++) {
                var cell = this.getCell(i, col);
                if (cell.td || !cell.spanAbove) {
                    break;
                }
                result++;
            }
            return result;
        };
        VTable.prototype.normalizeEmptyTableCells = function () {
            for (var i = 0, row = void 0; (row = this.table.rows[i]); i++) {
                for (var j = 0, cell = void 0; (cell = row.cells[j]); j++) {
                    if (cell) {
                        if (!cell.innerHTML || !cell.innerHTML.trim()) {
                            cell.appendChild(document.createElement('br'));
                        }
                    }
                }
            }
        };
        /* normalize width/height for each cell in the table */
        VTable.prototype.normalizeTableCellSize = function (zoomScale) {
            // remove width/height for each row
            for (var i = 0, row = void 0; (row = this.table.rows[i]); i++) {
                row.removeAttribute('width');
                row.style.setProperty('width', null);
                row.removeAttribute('height');
                row.style.setProperty('height', null);
            }
            // set width/height for each cell
            for (var i = 0; this.cells && i < this.cells.length; i++) {
                for (var j = 0; j < this.cells[i].length; j++) {
                    var cell = this.cells[i][j];
                    if (cell) {
                        var func = typeof zoomScale == 'number' ? function (n) { return n / zoomScale; } : zoomScale;
                        var width = cell.width || 0;
                        var height = cell.height || 0;
                        setHTMLElementSizeInPx(cell.td, (func === null || func === void 0 ? void 0 : func(width)) || width, (func === null || func === void 0 ? void 0 : func(height)) || height);
                    }
                }
            }
        };
        VTable.prototype.normalizeSize = function (sizeTransformer) {
            this.normalizeEmptyTableCells();
            this.normalizeTableCellSize(sizeTransformer);
            var rect = this.table.getBoundingClientRect();
            // Make sure table width/height is fixed to avoid shifting effect
            setHTMLElementSizeInPx(this.table, (sizeTransformer === null || sizeTransformer === void 0 ? void 0 : sizeTransformer(rect.width)) || rect.width, (sizeTransformer === null || sizeTransformer === void 0 ? void 0 : sizeTransformer(rect.height)) || rect.height);
        };
        return VTable;
    }());
    VTable$1.default = VTable;
    function setHTMLElementSizeInPx(element, newWidth, newHeight) {
        if (!!element) {
            element.removeAttribute('width');
            element.removeAttribute('height');
            element.style.boxSizing = 'border-box';
            element.style.width = newWidth + "px";
            element.style.height = newHeight + "px";
        }
    }
    function getTableFromTd(td) {
        var result = td;
        for (; result && result.tagName != 'TABLE'; result = result.parentElement) { }
        return result;
    }
    /**
     * Clone a table cell
     * @param cell The cell to clone
     */
    function cloneCell(cell) {
        return {
            td: cloneNode$1(cell.td),
            spanAbove: cell.spanAbove,
            spanLeft: cell.spanLeft,
        };
    }
    /**
     * Clone a node without its children.
     * @param node The node to clone
     */
    function cloneNode$1(node) {
        var newNode = node ? node.cloneNode(false /*deep*/) : null;
        if ((0, safeInstanceOf_1$9.default)(newNode, 'HTMLTableCellElement')) {
            newNode.removeAttribute('id');
            if (!newNode.firstChild) {
                newNode.appendChild(node.ownerDocument.createElement('br'));
            }
        }
        return newNode;
    }

    var isWholeTableSelected$1 = {};

    Object.defineProperty(isWholeTableSelected$1, "__esModule", { value: true });
    /**
     * Check if the whole table is selected
     * @param vTable VTable to check whether all cells are selected
     * @param selection Table selection with first cell selected and last cell selected coordinates.
     * @returns
     */
    function isWholeTableSelected(vTable, selection) {
        if (!selection || !vTable.cells) {
            return false;
        }
        var firstCell = selection.firstCell, lastCell = selection.lastCell;
        var rowsLength = vTable.cells.length - 1;
        var colIndex = vTable.cells[rowsLength].length - 1;
        var firstX = firstCell.x;
        var firstY = firstCell.y;
        var lastX = lastCell.x;
        var lastY = lastCell.y;
        return firstX == 0 && firstY == 0 && lastX == colIndex && lastY == rowsLength;
    }
    isWholeTableSelected$1.default = isWholeTableSelected;

    var VList$1 = {};

    var getListTypeFromNode$1 = {};

    Object.defineProperty(getListTypeFromNode$1, "__esModule", { value: true });
    getListTypeFromNode$1.isListElement = void 0;
    var getTagOfNode_1$6 = getTagOfNode$1;
    function getListTypeFromNode(node) {
        switch ((0, getTagOfNode_1$6.default)(node)) {
            case 'OL':
                return 1 /* Ordered */;
            case 'UL':
                return 2 /* Unordered */;
            default:
                return 0 /* None */;
        }
    }
    getListTypeFromNode$1.default = getListTypeFromNode;
    /**
     * @internal
     * Check if the given DOM node is a list element (OL or UL)
     * @param node The node to check
     */
    function isListElement(node) {
        return getListTypeFromNode(node) != 0 /* None */;
    }
    getListTypeFromNode$1.isListElement = isListElement;

    var VListItem = {};

    var getStyles$1 = {};

    Object.defineProperty(getStyles$1, "__esModule", { value: true });
    /**
     * Get CSS styles of a given element in name-value pair format
     * @param element The element to get styles from
     */
    function getStyles(element) {
        var result = {};
        var style = (element === null || element === void 0 ? void 0 : element.getAttribute('style')) || '';
        style.split(';').forEach(function (pair) {
            var valueIndex = pair.indexOf(':');
            var name = pair.slice(0, valueIndex);
            var value = pair.slice(valueIndex + 1);
            if (name && value) {
                result[name.trim()] = value.trim();
            }
        });
        return result;
    }
    getStyles$1.default = getStyles;

    var setBulletListMarkers$1 = {};

    var _a$6;
    Object.defineProperty(setBulletListMarkers$1, "__esModule", { value: true });
    /**
     * @internal
     * Set the marker of a bullet list
     * @param li
     * @param listStyleType
     */
    function setBulletListMarkers(li, listStyleType) {
        var marker = bulletListStyle[listStyleType];
        var isDisc = listStyleType === 1 /* Disc */;
        li.style.listStyleType = isDisc ? marker : "\"" + marker + "\"";
    }
    setBulletListMarkers$1.default = setBulletListMarkers;
    var bulletListStyle = (_a$6 = {},
        _a$6[1 /* Disc */] = 'disc',
        _a$6[3 /* Square */] = ' ',
        _a$6[2 /* Dash */] = '- ',
        _a$6[5 /* LongArrow */] = ' ',
        _a$6[8 /* DoubleLongArrow */] = ' ',
        _a$6[4 /* ShortArrow */] = ' ',
        _a$6[6 /* UnfilledArrow */] = ' ',
        _a$6[7 /* Hyphen */] = ' ',
        _a$6);

    var setListItemStyle$1 = {};

    Object.defineProperty(setListItemStyle$1, "__esModule", { value: true });
    var ContentTraverser_1$3 = ContentTraverser$1;
    var findClosestElementAncestor_1$3 = findClosestElementAncestor$1;
    var safeInstanceOf_1$8 = safeInstanceOf$1;
    /**
     * Set the Style of a List Item provided, with the styles that the inline child elements have
     * If the child inline elements have different styles, it will not modify the styles of the list item
     * @param element the LI Element to set the styles
     * @param styles The styles that should be applied to the element.
     * @param isCssStyle True means the given styles are CSS style names, false means they are HTML attributes @default true
     */
    function setListItemStyle(element, styles, isCssStyle) {
        if (isCssStyle === void 0) { isCssStyle = true; }
        var elementsStyles = getInlineChildElementsStyle(element, styles, isCssStyle);
        styles.forEach(function (styleName) {
            var styleValues = elementsStyles.map(function (style) {
                return style[styleName] !== undefined ? style[styleName] : '';
            });
            if (styleValues &&
                (styleValues.length == 1 || new Set(styleValues).size == 1) &&
                styleValues[0]) {
                if (isCssStyle) {
                    element.style.setProperty(styleName, styleValues[0]);
                }
                else {
                    element.setAttribute(styleName, styleValues[0]);
                }
            }
        });
    }
    setListItemStyle$1.default = setListItemStyle;
    function getInlineChildElementsStyle(element, styles, isCssStyle) {
        var _a, _b;
        var result = [];
        var contentTraverser = ContentTraverser_1$3.default.createBodyTraverser(element);
        var currentInlineElement = null;
        var _loop_1 = function () {
            currentInlineElement = contentTraverser.currentInlineElement;
            var currentNode = (currentInlineElement === null || currentInlineElement === void 0 ? void 0 : currentInlineElement.getContainerNode()) || null;
            var currentStyle = null;
            currentNode = currentNode ? (0, findClosestElementAncestor_1$3.default)(currentNode) : null;
            var _loop_2 = function () {
                var element_1 = currentNode;
                styles.forEach(function (styleName) {
                    var styleValue = isCssStyle
                        ? element_1.style.getPropertyValue(styleName)
                        : element_1.getAttribute(styleName);
                    if (!currentStyle) {
                        currentStyle = {};
                    }
                    if (styleValue && !currentStyle[styleName]) {
                        currentStyle[styleName] = styleValue;
                    }
                });
                if (((_b = currentNode === null || currentNode === void 0 ? void 0 : currentNode.parentNode) === null || _b === void 0 ? void 0 : _b.childNodes.length) === 1) {
                    currentNode = currentNode.parentNode;
                }
                else {
                    currentNode = null;
                }
            };
            // we should consider of when it is the single child node of element, the parentNode's style should add
            // such as the "i", "b", "span" node in <li><span><b><i>aa</i></b></span></li>
            while (currentNode &&
                currentNode !== element &&
                (0, safeInstanceOf_1$8.default)(currentNode, 'HTMLElement') &&
                (result.length == 0 || (((_a = currentNode.textContent) === null || _a === void 0 ? void 0 : _a.trim().length) || 0) > 0)) {
                _loop_2();
            }
            if (currentStyle) {
                result.push(currentStyle);
            }
            contentTraverser.getNextInlineElement();
        };
        while (contentTraverser.currentInlineElement != currentInlineElement) {
            _loop_1();
        }
        return result;
    }

    var setNumberingListMarkers$1 = {};

    var convertDecimalsToAlpha$1 = {};

    Object.defineProperty(convertDecimalsToAlpha$1, "__esModule", { value: true });
    var ALPHABET = {
        0: 'A',
        1: 'B',
        2: 'C',
        3: 'D',
        4: 'E',
        5: 'F',
        6: 'G',
        7: 'H',
        8: 'I',
        9: 'J',
        10: 'K',
        11: 'L',
        12: 'M',
        13: 'N',
        14: 'O',
        15: 'P',
        16: 'Q',
        17: 'R',
        18: 'S',
        19: 'T',
        20: 'U',
        21: 'V',
        22: 'W',
        23: 'X',
        24: 'Y',
        25: 'Z',
    };
    /**
     * @internal
     * Convert decimal numbers into english alphabet letters
     * @param decimal The decimal number that needs to be converted
     * @param isLowerCase if true the roman value will appear in lower case
     * @returns
     */
    function convertDecimalsToAlpha(decimal, isLowerCase) {
        var alpha = '';
        while (decimal >= 0) {
            alpha = ALPHABET[decimal % 26] + alpha;
            decimal = Math.floor(decimal / 26) - 1;
        }
        return isLowerCase ? alpha.toLowerCase() : alpha;
    }
    convertDecimalsToAlpha$1.default = convertDecimalsToAlpha;

    var convertDecimalsToRomans = {};

    Object.defineProperty(convertDecimalsToRomans, "__esModule", { value: true });
    var getObjectKeys_1$4 = getObjectKeys$1;
    var RomanValues = {
        M: 1000,
        CM: 900,
        D: 500,
        CD: 400,
        C: 100,
        XC: 90,
        L: 50,
        XL: 40,
        X: 10,
        IX: 9,
        V: 5,
        IV: 4,
        I: 1,
    };
    /**
     * @internal
     * Convert decimal numbers into roman numbers
     * @param decimal The decimal number that needs to be converted
     * @param isLowerCase if true the roman value will appear in lower case
     * @returns
     */
    function convertDecimalsToRoman(decimal, isLowerCase) {
        var romanValue = '';
        for (var _i = 0, _a = (0, getObjectKeys_1$4.default)(RomanValues); _i < _a.length; _i++) {
            var i = _a[_i];
            var timesRomanCharAppear = Math.floor(decimal / RomanValues[i]);
            decimal = decimal - timesRomanCharAppear * RomanValues[i];
            romanValue = romanValue + i.repeat(timesRomanCharAppear);
        }
        return isLowerCase ? romanValue.toLocaleLowerCase() : romanValue;
    }
    convertDecimalsToRomans.default = convertDecimalsToRoman;

    var _a$5;
    Object.defineProperty(setNumberingListMarkers$1, "__esModule", { value: true });
    var convertDecimalsToAlpha_1 = convertDecimalsToAlpha$1;
    var convertDecimalsToRomans_1 = convertDecimalsToRomans;
    var MarkerTypes;
    (function (MarkerTypes) {
        MarkerTypes[MarkerTypes["Decimal"] = 0] = "Decimal";
        MarkerTypes[MarkerTypes["Roman"] = 1] = "Roman";
        MarkerTypes[MarkerTypes["Alpha"] = 2] = "Alpha";
    })(MarkerTypes || (MarkerTypes = {}));
    /**
     * @internal
     * Set marker style of a numbering list
     * @param listStyleType
     * @param li
     */
    function setNumberingListMarkers(li, listStyleType, level) {
        var _a = numberingListStyle[listStyleType], markerSeparator = _a.markerSeparator, markerSecondSeparator = _a.markerSecondSeparator, markerType = _a.markerType, lowerCase = _a.lowerCase;
        var markerNumber = level.toString();
        if (markerType === MarkerTypes.Roman) {
            markerNumber = (0, convertDecimalsToRomans_1.default)(level, lowerCase);
        }
        else if (markerType === MarkerTypes.Alpha) {
            markerNumber = (0, convertDecimalsToAlpha_1.default)(level - 1, lowerCase);
        }
        var marker = markerSecondSeparator
            ? markerSecondSeparator + markerNumber + markerSeparator
            : markerNumber + markerSeparator;
        li.style.listStyleType = "\"" + marker + "\"";
    }
    setNumberingListMarkers$1.default = setNumberingListMarkers;
    var numberingListStyle = (_a$5 = {},
        _a$5[1 /* Decimal */] = {
            markerType: MarkerTypes.Decimal,
            markerSeparator: '. ',
        },
        _a$5[2 /* DecimalDash */] = {
            markerType: MarkerTypes.Decimal,
            markerSeparator: '- ',
        },
        _a$5[3 /* DecimalParenthesis */] = {
            markerType: MarkerTypes.Decimal,
            markerSeparator: ') ',
        },
        _a$5[4 /* DecimalDoubleParenthesis */] = {
            markerType: MarkerTypes.Decimal,
            markerSeparator: ') ',
            markerSecondSeparator: '(',
        },
        _a$5[5 /* LowerAlpha */] = {
            markerType: MarkerTypes.Alpha,
            markerSeparator: '. ',
            lowerCase: true,
        },
        _a$5[8 /* LowerAlphaDash */] = {
            markerType: MarkerTypes.Alpha,
            markerSeparator: '- ',
            lowerCase: true,
        },
        _a$5[6 /* LowerAlphaParenthesis */] = {
            markerType: MarkerTypes.Alpha,
            markerSeparator: ') ',
            lowerCase: true,
        },
        _a$5[7 /* LowerAlphaDoubleParenthesis */] = {
            markerType: MarkerTypes.Alpha,
            markerSeparator: ') ',
            markerSecondSeparator: '(',
            lowerCase: true,
        },
        _a$5[9 /* UpperAlpha */] = {
            markerType: MarkerTypes.Alpha,
            markerSeparator: '. ',
        },
        _a$5[12 /* UpperAlphaDash */] = {
            markerType: MarkerTypes.Alpha,
            markerSeparator: '- ',
        },
        _a$5[10 /* UpperAlphaParenthesis */] = {
            markerType: MarkerTypes.Alpha,
            markerSeparator: ') ',
        },
        _a$5[11 /* UpperAlphaDoubleParenthesis */] = {
            markerType: MarkerTypes.Alpha,
            markerSeparator: ') ',
            markerSecondSeparator: '(',
        },
        _a$5[13 /* LowerRoman */] = {
            markerType: MarkerTypes.Roman,
            markerSeparator: '. ',
            lowerCase: true,
        },
        _a$5[16 /* LowerRomanDash */] = {
            markerType: MarkerTypes.Roman,
            markerSeparator: '- ',
            lowerCase: true,
        },
        _a$5[14 /* LowerRomanParenthesis */] = {
            markerType: MarkerTypes.Roman,
            markerSeparator: ') ',
            lowerCase: true,
        },
        _a$5[15 /* LowerRomanDoubleParenthesis */] = {
            markerType: MarkerTypes.Roman,
            markerSeparator: ') ',
            markerSecondSeparator: '(',
            lowerCase: true,
        },
        _a$5[17 /* UpperRoman */] = {
            markerType: MarkerTypes.Roman,
            markerSeparator: '. ',
        },
        _a$5[20 /* UpperRomanDash */] = {
            markerType: MarkerTypes.Roman,
            markerSeparator: '- ',
        },
        _a$5[18 /* UpperRomanParenthesis */] = {
            markerType: MarkerTypes.Roman,
            markerSeparator: ') ',
        },
        _a$5[19 /* UpperRomanDoubleParenthesis */] = {
            markerType: MarkerTypes.Roman,
            markerSeparator: ') ',
            markerSecondSeparator: '(',
        },
        _a$5);

    var setStyles$1 = {};

    Object.defineProperty(setStyles$1, "__esModule", { value: true });
    var getObjectKeys_1$3 = getObjectKeys$1;
    /**
     * Set styles to an HTML element. If styles are empty, remove 'style' attribute
     * @param element The element to set styles
     * @param styles The styles to set, in name-value pair format
     */
    function setStyles(element, styles) {
        if (element) {
            var style = (0, getObjectKeys_1$3.default)(styles || {})
                .map(function (name) {
                var value = styles[name];
                var trimmedName = name ? name.trim() : null;
                var trimmedValue = value ? value.trim() : null;
                return trimmedName && trimmedValue ? trimmedName + ":" + trimmedValue : null;
            })
                .filter(function (x) { return x; })
                .join(';');
            if (style) {
                element.setAttribute('style', style);
            }
            else {
                element.removeAttribute('style');
            }
        }
    }
    setStyles$1.default = setStyles;

    (function (exports) {
    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListStyleDefinitionMetadata = void 0;
    var contains_1 = contains$1;
    var getListTypeFromNode_1 = getListTypeFromNode$1;
    var getStyles_1 = getStyles$1;
    var getTagOfNode_1 = getTagOfNode$1;
    var isBlockElement_1 = isBlockElement$1;
    var moveChildNodes_1 = moveChildNodes$1;
    var safeInstanceOf_1 = safeInstanceOf$1;
    var setBulletListMarkers_1 = setBulletListMarkers$1;
    var setListItemStyle_1 = setListItemStyle$1;
    var setNumberingListMarkers_1 = setNumberingListMarkers$1;
    var setStyles_1 = setStyles$1;
    var toArray_1 = toArray$1;
    var unwrap_1 = unwrap$1;
    var wrap_1 = wrap$1;
    var definitionCreators_1 = definitionCreators;
    var metadata_1 = metadata;
    var orderListStyles = [null, 'lower-alpha', 'lower-roman'];
    var unorderedListStyles = ['disc', 'circle', 'square'];
    var MARGIN_BASE = '0in 0in 0in 0.5in';
    var NEGATIVE_MARGIN = '-.25in';
    var stylesToInherit = ['font-size', 'font-family', 'color'];
    var attrsToInherit = ['data-ogsc', 'data-ogsb', 'data-ogac', 'data-ogab'];
    /**
     * @internal
     * The definition for the number of BulletListType or NumberingListType
     */
    exports.ListStyleDefinitionMetadata = (0, definitionCreators_1.createObjectDefinition)({
        orderedStyleType: (0, definitionCreators_1.createNumberDefinition)(true /** isOptional */, undefined /** value **/, 1 /* Min */, 20 /* Max */),
        unorderedStyleType: (0, definitionCreators_1.createNumberDefinition)(true /** isOptional */, undefined /** value **/, 1 /* Min */, 9 /* Max */),
    }, true /** isOptional */, true /** allowNull */);
    /**
     * !!! Never directly create instance of this class. It should be created within VList class !!!
     *
     * Represent a list item.
     *
     * A list item is normally wrapped using a LI tag. But this class is only a logical item,
     * it can be a LI tag, or another other type of node which means it is actually not a list item.
     * That can happen after we do "outdent" on a 1-level list item, then it becomes not a list item.
     */
    var VListItem = /** @class */ (function () {
        /**
         * Construct a new instance of VListItem class
         * @param node The DOM node for this item
         * @param listTypes An array represents list types of all parent and current level.
         * Skip this parameter for a non-list item.
         */
        function VListItem(node) {
            var listTypes = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                listTypes[_i - 1] = arguments[_i];
            }
            this.newListStart = undefined;
            if (!node) {
                throw new Error('node must not be null');
            }
            this.node = (0, safeInstanceOf_1.default)(node, 'HTMLLIElement')
                ? node
                : (0, wrap_1.default)(node, 4 /* BlockListItem */);
            var display = this.node.style.display;
            this.dummy = display != 'list-item' && display != '';
            // Always add a None list type in front of all other types to represent non-list scenario.
            this.listTypes = __spreadArray([0 /* None */], listTypes, true);
        }
        /**
         * Get type of current list item
         */
        VListItem.prototype.getListType = function () {
            return this.listTypes[this.listTypes.length - 1];
        };
        /**
         * Get the levels of this list item.
         */
        VListItem.prototype.getLevel = function () {
            return this.listTypes.length - 1;
        };
        /**
         * Get DOM node of this list item
         */
        VListItem.prototype.getNode = function () {
            return this.node;
        };
        /**
         * Get the Start Number of the new List
         */
        VListItem.prototype.getNewListStart = function () {
            return this.newListStart;
        };
        /**
         * Check if a given node is contained by this list item
         * @param node The node to check
         */
        VListItem.prototype.contains = function (node) {
            return (0, contains_1.default)(this.node, node, true /*treatSameNodeAsContain*/);
        };
        /**
         * Check if this item is a dummy item.
         * A dummy item is also represented by LI tag, but it won't render a bullet (for Unordered list) or a number (for Ordered list)
         * normally it has CSS style display set to a value other than "list-item"
         */
        VListItem.prototype.isDummy = function () {
            return this.dummy;
        };
        /**
         * @deprecated Always return false
         */
        VListItem.prototype.isOrphanItem = function () {
            return false;
        };
        /**
         * @deprecated
         */
        VListItem.prototype.canMerge = function (item) {
            if (!(item === null || item === void 0 ? void 0 : item.isOrphanItem()) || this.listTypes.length != item.listTypes.length) {
                return false;
            }
            return this.listTypes.every(function (type, index) { return item.listTypes[index] == type; });
        };
        /**
         * @deprecated
         */
        VListItem.prototype.mergeItems = function (items) {
            var _this = this;
            var nodesToWrap = (items === null || items === void 0 ? void 0 : items.map(function (item) { return item.node; })) || [];
            var targetNodes = wrapIfNotBlockNode(nodesToWrap, true /*checkFirst*/, false /*checkLast*/);
            targetNodes.forEach(function (node) { return _this.node.appendChild(node); });
        };
        /**
         * Indent this item
         * If this is not an list item, it will be no op
         */
        VListItem.prototype.indent = function () {
            if (this.node.style.marginLeft == NEGATIVE_MARGIN) {
                this.node.style.margin = '';
                this.node.style.marginLeft = '';
                return;
            }
            var listType = this.getListType();
            if (listType != 0 /* None */) {
                this.listTypes.push(listType);
            }
        };
        /**
         * Outdent this item
         * If this item is already not an list item, it will be no op
         * @param preventItemRemoval Whether prevent the list item to be removed for the listItem by default false
         */
        VListItem.prototype.outdent = function (preventItemRemoval) {
            if (preventItemRemoval === void 0) { preventItemRemoval = false; }
            var expectedLength = preventItemRemoval ? 2 : 1;
            if (this.listTypes.length > expectedLength) {
                this.listTypes.pop();
            }
        };
        /**
         * Add negative margin to the List item
         */
        VListItem.prototype.addNegativeMargins = function () {
            this.node.style.margin = MARGIN_BASE;
            this.node.style.marginLeft = NEGATIVE_MARGIN;
        };
        /**
         * Change list type of this item
         * @param targetType The target list type to change to
         */
        VListItem.prototype.changeListType = function (targetType) {
            if (targetType == 0 /* None */) {
                this.listTypes = [targetType];
            }
            else {
                this.outdent();
                this.listTypes.push(targetType);
            }
        };
        /**
         * Set whether the item is a dummy item
         * @param isDummy Whether the item is a dummy item
         */
        VListItem.prototype.setIsDummy = function (isDummy) {
            this.dummy = isDummy;
        };
        /**
         * Set the start Number of the new list
         * @param isDummy Whether the item is a dummy item
         */
        VListItem.prototype.setNewListStart = function (startNumber) {
            this.newListStart = startNumber;
        };
        /**
         * Apply the list style type
         * @param rootList the vList that receives the style
         * @param index the list item index
         */
        VListItem.prototype.applyListStyle = function (rootList, index) {
            var style = (0, metadata_1.getMetadata)(rootList, exports.ListStyleDefinitionMetadata);
            // The list just need to be styled if it is at top level, so the listType length for this Vlist must be 2.
            var isFirstLevel = this.listTypes.length < 3;
            if (style) {
                if (isFirstLevel &&
                    this.listTypes[1] === 2 /* Unordered */ &&
                    style.unorderedStyleType) {
                    (0, setBulletListMarkers_1.default)(this.node, style.unorderedStyleType);
                }
                else if (isFirstLevel &&
                    this.listTypes[1] === 1 /* Ordered */ &&
                    style.orderedStyleType) {
                    (0, setNumberingListMarkers_1.default)(this.node, style.orderedStyleType, index);
                }
                else {
                    this.node.style.removeProperty('list-style-type');
                }
            }
        };
        /**
         * Write the change result back into DOM
         * @param listStack current stack of list elements
         * @param originalRoot Original list root element. It will be reused when write back if possible
         * @param shouldReuseAllAncestorListElements Optional - defaults to false. If true, only make
         *              sure the direct parent of this list matches the list types when writing back.
         */
        VListItem.prototype.writeBack = function (listStack, originalRoot, shouldReuseAllAncestorListElements) {
            var _this = this;
            var _a;
            if (shouldReuseAllAncestorListElements === void 0) { shouldReuseAllAncestorListElements = false; }
            var nextLevel = 1;
            if (shouldReuseAllAncestorListElements) {
                // Remove any un-needed lists from the stack.
                if (listStack.length > this.listTypes.length) {
                    listStack.splice(this.listTypes.length);
                }
                // 1. If the listStack is the same length as the listTypes for this item, check
                // if the last item needs to change, and remove it if needed. We can always re-use
                // the other lists even if the type doesn't match - since the display is the same
                // as long as the list immediately surrounding the item is correct.
                var listStackEndIndex = listStack.length - 1;
                if (listStackEndIndex === this.listTypes.length - 1 && // they are the same length
                    (0, getListTypeFromNode_1.default)(listStack[listStackEndIndex]) !==
                        this.listTypes[listStackEndIndex]) {
                    listStack.splice(listStackEndIndex);
                }
                nextLevel = listStack.length;
            }
            else {
                // 1. Determine list elements that we can reuse
                // e.g.:
                //    passed in listStack: Fragment > OL > UL > OL
                //    local listTypes:     null     > OL > UL > UL > OL
                //    then Fragment > OL > UL can be reused
                for (; nextLevel < listStack.length; nextLevel++) {
                    if ((0, getListTypeFromNode_1.default)(listStack[nextLevel]) !== this.listTypes[nextLevel]) {
                        listStack.splice(nextLevel);
                        break;
                    }
                }
            }
            // 2. Add new list elements
            // e.g.:
            //    passed in listStack: Fragment > OL > UL
            //    local listTypes:     null     > OL > UL > UL > OL
            //    then we need to create a UL and a OL tag
            for (; nextLevel < this.listTypes.length; nextLevel++) {
                var stackLength = listStack.length - 1;
                var newList = createListElement(listStack[0], this.listTypes[nextLevel], nextLevel, originalRoot);
                listStack[stackLength].appendChild(newList);
                listStack.push(newList);
                //If the current node parent is in the same deep child index,
                //apply the styles of the current parent list to the new list
                if (this.getDeepChildIndex(originalRoot) == stackLength) {
                    var listStyleType = (_a = this.node.parentElement) === null || _a === void 0 ? void 0 : _a.style.listStyleType;
                    if (listStyleType &&
                        (0, getTagOfNode_1.default)(this.node.parentElement) === (0, getTagOfNode_1.default)(newList)) {
                        newList.style.listStyleType = listStyleType;
                    }
                }
            }
            // 3. Add current node into deepest list element
            listStack[listStack.length - 1].appendChild(this.node);
            this.node.style.setProperty('display', this.dummy ? 'block' : null);
            // 4. Inherit styles of the child element to the li, so we are able to apply the styles to the ::marker
            if (this.listTypes.length > 1) {
                (0, setListItemStyle_1.default)(this.node, stylesToInherit, true /*isCssStyle*/);
                (0, setListItemStyle_1.default)(this.node, attrsToInherit, false /*isCssStyle*/);
            }
            // 5. If this is not a list item now, need to unwrap the LI node and do proper handling
            if (this.listTypes.length <= 1) {
                // If original <LI> node has styles for font and color, we need to apply it to new parent
                var isLi = (0, getTagOfNode_1.default)(this.node) == 'LI';
                var stylesToApply = isLi
                    ? {
                        'font-family': this.node.style.fontFamily,
                        'font-size': this.node.style.fontSize,
                        color: this.node.style.color,
                    }
                    : undefined;
                var childNodes = isLi ? getChildrenAndUnwrap(this.node) : [this.node];
                if (stylesToApply) {
                    var _loop_1 = function (i) {
                        if ((0, safeInstanceOf_1.default)(childNodes[i], 'Text')) {
                            childNodes[i] = (0, wrap_1.default)(childNodes[i], 'span');
                        }
                        var node = childNodes[i];
                        if ((0, safeInstanceOf_1.default)(node, 'HTMLElement')) {
                            var styles = __assign(__assign({}, stylesToApply), (0, getStyles_1.default)(node));
                            (0, setStyles_1.default)(node, styles);
                            attrsToInherit.forEach(function (attr) {
                                var attrValue = _this.node.getAttribute(attr);
                                if (attrValue) {
                                    node.setAttribute(attr, attrValue);
                                }
                            });
                        }
                    };
                    for (var i = 0; i < childNodes.length; i++) {
                        _loop_1(i);
                    }
                }
                wrapIfNotBlockNode(childNodes, true /*checkFirst*/, true /*checkLast*/);
            }
        };
        /**
         * Get the index of how deep is the current node parent list inside of the original root list.
         * @example In the following structure this function would return 2
         * ```html
         *  <ol> <!-- original Root -->
         *      <ol>
         *          <ol>
         *              <li></li> <!-- this.node  -->
         *          </ol>
         *      </ol>
         *  </ol>
         * ```
         * @param originalRoot The root list
         * @returns -1  if the node does not have parent element or if original root was not provided,
         *              else, how deep is the parent element inside of the original root.
         */
        VListItem.prototype.getDeepChildIndex = function (originalRoot) {
            var parentElement = this.node.parentElement;
            if (originalRoot && parentElement) {
                var deepIndex = 0;
                while (parentElement && parentElement != originalRoot) {
                    deepIndex++;
                    parentElement = (parentElement === null || parentElement === void 0 ? void 0 : parentElement.parentElement) || null;
                }
                return deepIndex;
            }
            return -1;
        };
        return VListItem;
    }());
    exports.default = VListItem;
    function createListElement(newRoot, listType, nextLevel, originalRoot) {
        var doc = newRoot.ownerDocument;
        var result;
        // Try to reuse the existing root element
        // It can be reused when
        // 1. Current list item is level 1 (top level), AND
        // 2. Original root exists, AND
        // 3. They have the same list type AND
        // 4. The original root is not used yet
        if (nextLevel == 1 && originalRoot && listType == (0, getListTypeFromNode_1.default)(originalRoot)) {
            if ((0, contains_1.default)(newRoot, originalRoot)) {
                // If it is already used, let's clone one and remove ID to avoid duplicating ID
                result = originalRoot.cloneNode(false /*deep*/);
                result.removeAttribute('id');
            }
            else {
                // Remove all child nodes, they will be added back later when write back other items
                (0, moveChildNodes_1.default)(originalRoot);
                result = originalRoot;
            }
        }
        else {
            // Can't be reused, can't clone, let's create a new one
            result = doc.createElement(listType == 1 /* Ordered */ ? 'ol' : 'ul');
        }
        // Always maintain the metadata saved in the list
        if (originalRoot && nextLevel == 1 && listType != (0, getListTypeFromNode_1.default)(originalRoot)) {
            var style = (0, metadata_1.getMetadata)(originalRoot, exports.ListStyleDefinitionMetadata);
            if (style) {
                (0, metadata_1.setMetadata)(result, style, exports.ListStyleDefinitionMetadata);
            }
        }
        if (listType == 1 /* Ordered */ && nextLevel > 1) {
            result.style.setProperty('list-style-type', orderListStyles[(nextLevel - 1) % orderListStyles.length]);
        }
        if (listType == 2 /* Unordered */ && nextLevel > 1) {
            result.style.setProperty('list-style-type', unorderedListStyles[(nextLevel - 1) % unorderedListStyles.length]);
        }
        return result;
    }
    function wrapIfNotBlockNode(nodes, checkFirst, checkLast) {
        if (nodes.length > 0 &&
            (!checkFirst || !(0, isBlockElement_1.default)(nodes[0])) &&
            (!checkLast || !(0, isBlockElement_1.default)(nodes[nodes.length]))) {
            nodes = [(0, wrap_1.default)(nodes)];
        }
        return nodes;
    }
    function getChildrenAndUnwrap(node) {
        var result = (0, toArray_1.default)(node.childNodes);
        (0, unwrap_1.default)(node);
        return result;
    }

    }(VListItem));

    var __spreadArray$1 = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(VList$1, "__esModule", { value: true });
    var changeElementTag_1$3 = changeElementTag$1;
    var getListTypeFromNode_1$1 = getListTypeFromNode$1;
    var getTagOfNode_1$5 = getTagOfNode$1;
    var isBlockElement_1 = isBlockElement$1;
    var isNodeEmpty_1$2 = isNodeEmpty$1;
    var Position_1$6 = Position$1;
    var queryElements_1$4 = queryElements$1;
    var safeInstanceOf_1$7 = safeInstanceOf$1;
    var splitParentNode_1$1 = splitParentNode$1;
    var toArray_1$3 = toArray$1;
    var unwrap_1$1 = unwrap$1;
    var VListItem_1 = VListItem;
    var wrap_1$2 = wrap$1;
    var metadata_1 = metadata;
    /**
     * Represent a bullet or a numbering list
     *
     * @example
     * A VList is a logical representation of list items, it contains an item array with node and list type stack.
     * e.g. We have a list like this
     * ```html
     * <ol>
     *   <li>item 1</li>
     *   <li>item 2</li>
     *   <ul>
     *     <li>item 2.1</li>
     *     <li>item 2.2</li>
     *   <ul>
     * </ol>
     * ```
     *
     * A VList of this list will be like this:
     * ```javascript
     * {
     *   rootList: (OL node),
     *   items: [{
     *       node: (LI node with 'item 1'),
     *       listTypes: [null, OL],
     *     }, {
     *       node: (LI node with 'item 2'),
     *       listTypes: [null, OL],
     *     }, {
     *       node: (LI node with 'item 2.1),
     *       listTypes: [null, OL, UL],
     *     }, {
     *       node: (LI node with 'item 2.2'),
     *       listTypes: [null, OL, UL],
     *     }
     *   ]
     * }
     * ```
     *
     * When we want to outdent item 2.1, we just need to remove the last "UL" from listTypes of item 2.1, then
     * the writeBack() function will handle everything related to DOM change
     */
    var VList = /** @class */ (function () {
        /**
         * Create a new instance of VList class
         * @param rootList The root list element, can be either OL or UL tag
         */
        function VList(rootList) {
            this.rootList = rootList;
            this.items = [];
            if (!rootList) {
                throw new Error('rootList must not be null');
            }
            // Before populate items, we need to normalize the list to make sure it is in a correct format
            // otherwise further action may mass thing up.
            //
            // There are two kinds of normalization to perform.
            // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node
            // Please see comment for VListItem.isOrphanItem() for more information about orphan node
            // e.g.:
            // ```HTML
            // <ol>
            //   <li>item 1</li>
            //   <div>item 2</div>
            // </ol>
            // ```
            // After this step, it should become:
            // ```html
            // <ol>
            //   <li>item 1
            //     <div>item 2</div>
            //   <li>
            // </ol>
            // ```
            moveChildNodesToLi(this.rootList);
            (0, queryElements_1$4.default)(this.rootList, 'ol,ul', moveChildNodesToLi);
            // 2. Move LI node embedded into another LI node out to directly under OL/UL node
            // Ideally browser we do this for us automatically when out the HTML into DOM. However after
            // step 1, it is possible that we move some LI node into another one. e.g:
            // ```HTML
            // <ol>
            //   <li>item 1</li>
            //   <div>
            //     item 1.1
            //     <li>item 3</li>
            //   </div>
            // </ol>
            // ```
            // See that the second LI tag is not directly under OL, so after step 1, this will become:
            // ```html
            // <ol>
            //   <li>item 1
            //     <div>
            //       item 1.1
            //       <li>item 2</li>
            //     </div>
            //   <li>
            // </ol>
            // ```
            // Now we have a LI tag embedded into another LI tag. So we need step 2 to move the inner LI tag out to be:
            // ```html
            // <ol>
            //   <li>item1
            //     <div>item 1.1</div>
            //   </li>
            //   <li><div>item2</div></li>
            // </ol>
            // ```
            (0, queryElements_1$4.default)(this.rootList, 'li', moveLiToList);
            this.populateItems(this.rootList);
        }
        /**
         * Check if this list contains the given node
         * @param node The node to check
         */
        VList.prototype.contains = function (node) {
            // We don't check if the node is contained by this.rootList here, because after some operation,
            // it is possible a node is logically contained by this list but the container list item hasn't
            // been put under this.rootList in DOM tree yet.
            return this.items.some(function (item) { return item.contains(node); });
        };
        /**
         * Get list number of the last item in this VList.
         * If there is no order list item, result will be undefined
         */
        VList.prototype.getLastItemNumber = function () {
            var start = this.getStart();
            return start === undefined
                ? start
                : start -
                    1 +
                    this.items.filter(function (item) {
                        return item.getListType() == 1 /* Ordered */ &&
                            item.getLevel() == 1 &&
                            !item.isDummy();
                    }).length;
        };
        /**
         * Write the result back into DOM tree
         * After that, this VList becomes unavailable because we set this.rootList to null
         *
         * @param shouldReuseAllAncestorListElements Optional - defaults to false.
         */
        VList.prototype.writeBack = function (shouldReuseAllAncestorListElements) {
            var _this = this;
            if (!this.rootList) {
                throw new Error('rootList must not be null');
            }
            var doc = this.rootList.ownerDocument;
            var listStack = [doc.createDocumentFragment()];
            var placeholder = doc.createTextNode('');
            var start = this.getStart() || 1;
            var lastList;
            // Use a placeholder to hold the position since the root list may be moved into document fragment later
            this.rootList.parentNode.replaceChild(placeholder, this.rootList);
            this.items.forEach(function (item) {
                var newListStart = item.getNewListStart();
                if (newListStart && newListStart != start) {
                    listStack.splice(1, listStack.length - 1);
                    start = newListStart;
                }
                item.writeBack(listStack, _this.rootList, shouldReuseAllAncestorListElements);
                var topList = listStack[1];
                if ((0, safeInstanceOf_1$7.default)(topList, 'HTMLOListElement')) {
                    if (lastList != topList) {
                        if (start == 1) {
                            topList.removeAttribute('start');
                        }
                        else {
                            topList.start = start;
                        }
                    }
                    if (item.getLevel() == 1) {
                        start++;
                    }
                }
                var itemIndex = _this.getListItemIndex(item.getNode());
                item.applyListStyle(_this.rootList, itemIndex);
                lastList = topList;
            });
            // Restore the content to the position of placeholder
            placeholder.parentNode.replaceChild(listStack[0], placeholder);
        };
        /**
         * Sets the New List Start Property, that is going to be used to create a new List in the WriteBack function
         * @param separator The HTML element that indicates when to split the VList
         * @param startNumber The start number of the new List
         */
        VList.prototype.split = function (separator, startNumber) {
            if (!this.rootList) {
                throw new Error('rootList must not be null');
            }
            //Traverse the items of the VList, when the separator is found, set the New List Start Property
            for (var index = 0; index < this.items.length; index++) {
                if (this.items[index].getNode() == separator) {
                    this.items[index].setNewListStart(startNumber);
                    return;
                }
            }
        };
        VList.prototype.setIndentation = function (start, end, indentation, softOutdent, preventItemRemoval) {
            var _this = this;
            if (preventItemRemoval === void 0) { preventItemRemoval = false; }
            var shouldAddMargin = false;
            this.findListItems(start, end, function (item) {
                shouldAddMargin = shouldAddMargin || _this.items.indexOf(item) == 0;
                indentation == 1 /* Decrease */
                    ? softOutdent && !item.isDummy()
                        ? item.setIsDummy(true /*isDummy*/)
                        : item.outdent(preventItemRemoval)
                    : item.indent();
            });
            if (shouldAddMargin && preventItemRemoval) {
                for (var index = 0; index < this.items.length; index++) {
                    this.items[index].addNegativeMargins();
                }
            }
        };
        /**
         * Set alignment of the given range of this list
         * @param start Start position to operate from
         * @param end End position to operate to
         * @param alignment Align items left, center or right
         */
        VList.prototype.setAlignment = function (start, end, alignment) {
            this.rootList.style.display = 'flex';
            this.rootList.style.flexDirection = 'column';
            this.findListItems(start, end, function (item) {
                var align = 'start';
                if (alignment == 1 /* Center */) {
                    align = 'center';
                }
                else if (alignment == 2 /* Right */) {
                    align = 'end';
                }
                item.getNode().style.alignSelf = align;
            });
        };
        /**
         * Change list type of the given range of this list.
         * If some of the items are not real list item yet, this will make them to be list item with given type
         * If all items in the given range are already in the type to change to, this becomes an outdent operation
         * @param start Start position to operate from
         * @param end End position to operate to
         * @param targetType Target list type
         */
        VList.prototype.changeListType = function (start, end, targetType) {
            var needChangeType = false;
            this.findListItems(start, end, function (item) {
                needChangeType = needChangeType || item.getListType() != targetType;
            });
            this.findListItems(start, end, function (item) {
                return needChangeType ? item.changeListType(targetType) : item.outdent();
            });
        };
        /**
         * Change list style of the given range of this list.
         * If some of the items are not real list item yet, this will make them to be list item with given style
         * @param orderedStyle The style of ordered list
         * @param unorderedStyle The style of unordered list
         */
        VList.prototype.setListStyleType = function (orderedStyle, unorderedStyle) {
            var style = (0, metadata_1.getMetadata)(this.rootList, VListItem_1.ListStyleDefinitionMetadata);
            var styleMetadata = createListStyleMetadata(style, orderedStyle, unorderedStyle);
            (0, metadata_1.setMetadata)(this.rootList, styleMetadata, VListItem_1.ListStyleDefinitionMetadata);
        };
        /**
         * Append a new item to this VList
         * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped
         * @param type Type of this list item, can be ListType.None
         */
        VList.prototype.appendItem = function (node, type) {
            var nodeTag = (0, getTagOfNode_1$5.default)(node);
            // Change DIV tag to SPAN. Otherwise we cannot create new list item by Enter key in Safari
            if (nodeTag == 'DIV') {
                node = (0, changeElementTag_1$3.default)(node, 'LI');
            }
            else if (nodeTag != 'LI') {
                node = (0, wrap_1$2.default)(node, 'LI');
            }
            this.items.push(type == 0 /* None */
                ? new VListItem_1.default(node)
                : new VListItem_1.default(node, type));
        };
        /**
         * Merge the given VList into current VList.
         * - All list items will be removed from the given VList and added into this list.
         * - The root node of the given VList will be removed from DOM tree
         * - If there are orphan items in the given VList, they will be merged into the last item
         *   of this list if any.
         * @param list The vList to merge from
         */
        VList.prototype.mergeVList = function (list) {
            var _this = this;
            var _a;
            if (list && list != this) {
                list.items.forEach(function (item) { return _this.items.push(item); });
                list.items.splice(0, list.items.length);
                (_a = list.rootList.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(list.rootList);
            }
        };
        /**
         * Get the index of the List Item in the current List
         * If the root list is:
         * Ordered list, the listIndex start count is going to be the start property of the OL - 1,
         * @example For example if we want to find the index of Item 2 in the list below, the returned index is going to be 6
         *  * ```html
         * <ol start="5">
         *   <li>item 1</li>
         *   <li>item 2</li> <!-- Node to find -->
         *   <li>item 3</li>
         * </ol>
         * ```
         * Unordered list, the listIndex start count starts from 0
         * @example For example if we want to find the index of Item 2 in the list below, the returned index is going to be 2
         * ```html
         * <ul>
         *   <li>item 1</li>
         *   <li>item 2</li> <!-- Node to find -->
         *   <li>item 3</li>
         * </ul>
         * ```
         * @param input List item to find in the root list
         */
        VList.prototype.getListItemIndex = function (input) {
            if (this.items) {
                var listIndex = (this.getStart() || 1) - 1;
                for (var index = 0; index < this.items.length; index++) {
                    var child = this.items[index];
                    if (child.getLevel() == 1 && !child.isDummy()) {
                        listIndex++;
                    }
                    if (child.getNode() == input) {
                        return listIndex;
                    }
                }
            }
            return -1;
        };
        /**
         * Get the Start property of the root list of this VList
         * @returns Start number of the list
         */
        VList.prototype.getStart = function () {
            return (0, safeInstanceOf_1$7.default)(this.rootList, 'HTMLOListElement') ? this.rootList.start : undefined;
        };
        VList.prototype.findListItems = function (start, end, callback) {
            if (this.items.length == 0) {
                return [];
            }
            var listStartPos = new Position_1$6.default(this.items[0].getNode(), 0 /* Begin */);
            var listEndPos = new Position_1$6.default(this.items[this.items.length - 1].getNode(), -1 /* End */);
            var startIndex = listStartPos.isAfter(start) ? 0 : -1;
            var endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);
            this.items.forEach(function (item, index) {
                startIndex = item.contains(start.node) ? index : startIndex;
                endIndex = item.contains(end.node) ? index : endIndex;
            });
            startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;
            endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;
            var result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];
            if (callback) {
                result.forEach(callback);
            }
            return result;
        };
        VList.prototype.populateItems = function (list, listTypes) {
            var _this = this;
            if (listTypes === void 0) { listTypes = []; }
            var type = (0, getListTypeFromNode_1$1.default)(list);
            var items = (0, toArray_1$3.default)(list.childNodes);
            items.forEach(function (item) {
                var newListTypes = __spreadArray$1(__spreadArray$1([], listTypes, true), [type], false);
                if ((0, getListTypeFromNode_1$1.isListElement)(item)) {
                    _this.populateItems(item, newListTypes);
                }
                else if (item.nodeType != 3 /* Text */ || (item.nodeValue || '').trim() != '') {
                    _this.items.push(new (VListItem_1.default.bind.apply(VListItem_1.default, __spreadArray$1([void 0, item], newListTypes, false)))());
                }
            });
        };
        return VList;
    }());
    VList$1.default = VList;
    //Normalization
    // Step 1: Move all non-LI direct children under list into LI
    // e.g.
    // From: <ul><li>line 1</li>line 2</ul>
    // To:   <ul><li>line 1<div>line 2</div></li></ul>
    function moveChildNodesToLi(list) {
        var currentItem = null;
        (0, toArray_1$3.default)(list.childNodes).forEach(function (child) {
            if ((0, getTagOfNode_1$5.default)(child) == 'LI') {
                currentItem = child;
            }
            else if ((0, getListTypeFromNode_1$1.isListElement)(child)) {
                currentItem = null;
            }
            else if (currentItem && !(0, isNodeEmpty_1$2.default)(child, true /*trimContent*/)) {
                currentItem.appendChild((0, isBlockElement_1.default)(child) ? child : (0, wrap_1$2.default)(child));
            }
        });
    }
    // Step 2: Move nested LI up to under list directly
    // e.g.
    // From: <ul><li>line 1<li>line 2</li>line 3</li></ul>
    // To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>
    function moveLiToList(li) {
        while (!(0, getListTypeFromNode_1$1.isListElement)(li.parentNode)) {
            (0, splitParentNode_1$1.default)(li, true /*splitBefore*/);
            var furtherNodes = (0, toArray_1$3.default)(li.parentNode.childNodes).slice(1);
            if (furtherNodes.length > 0) {
                if (!(0, isBlockElement_1.default)(furtherNodes[0])) {
                    furtherNodes = [(0, wrap_1$2.default)(furtherNodes)];
                }
                furtherNodes.forEach(function (node) { return li.appendChild(node); });
            }
            (0, unwrap_1$1.default)(li.parentNode);
        }
    }
    function getValidValue() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        return values.filter(function (x) { return x !== undefined; })[0];
    }
    function createListStyleMetadata(style, orderedStyle, unorderedStyle) {
        return {
            orderedStyleType: getValidValue(orderedStyle, style === null || style === void 0 ? void 0 : style.orderedStyleType, 1 /* Decimal */),
            unorderedStyleType: getValidValue(unorderedStyle, style === null || style === void 0 ? void 0 : style.unorderedStyleType, 1 /* Disc */),
        };
    }

    var createVListFromRegion$1 = {};

    var getRootListNode$1 = {};

    Object.defineProperty(getRootListNode$1, "__esModule", { value: true });
    var findClosestElementAncestor_1$2 = findClosestElementAncestor$1;
    /**
     * @internal
     * Get Root list node from the given node within the given region
     * @param region Region to scope the search into
     * @param selector The selector to search
     * @param node The start node
     */
    function getRootListNode(region, selector, node) {
        var list = region &&
            (0, findClosestElementAncestor_1$2.default)(node, region.rootNode, selector);
        if (list) {
            var ancestor = void 0;
            while ((ancestor = (0, findClosestElementAncestor_1$2.default)(list.parentNode, region.rootNode, selector))) {
                list = ancestor;
            }
        }
        return list;
    }
    getRootListNode$1.default = getRootListNode;

    var getSelectedBlockElementsInRegion$1 = {};

    var getSelectionRangeInRegion$1 = {};

    Object.defineProperty(getSelectionRangeInRegion$1, "__esModule", { value: true });
    var createRange_1$3 = createRange$1;
    var Position_1$5 = Position$1;
    var getLeafSibling_1$2 = getLeafSibling$1;
    /**
     * Get the selection range in the given region.
     * The original range can cover multiple regions, this function will narrow the original selection
     * of a region into current region
     * @param regionBase The region to get range from
     */
    function getSelectionRangeInRegion(regionBase) {
        if (!regionBase) {
            return null;
        }
        var nodeBefore = regionBase.nodeBefore, nodeAfter = regionBase.nodeAfter, rootNode = regionBase.rootNode, skipTags = regionBase.skipTags;
        var startNode = nodeBefore
            ? (0, getLeafSibling_1$2.getNextLeafSibling)(regionBase.rootNode, nodeBefore, regionBase.skipTags)
            : rootNode.firstChild;
        var endNode = nodeAfter
            ? (0, getLeafSibling_1$2.getPreviousLeafSibling)(rootNode, nodeAfter, skipTags)
            : rootNode.lastChild;
        var regionRange = startNode && endNode && (0, createRange_1$3.default)(startNode, endNode);
        if (!isRegion(regionBase)) {
            return regionRange;
        }
        else if (regionRange) {
            var regionStart = Position_1$5.default.getStart(regionRange).normalize();
            var regionEnd = Position_1$5.default.getEnd(regionRange).normalize();
            var fullSelectionEnd = regionBase.fullSelectionEnd, fullSelectionStart = regionBase.fullSelectionStart;
            if (!fullSelectionStart.isAfter(regionEnd) && !regionStart.isAfter(fullSelectionEnd)) {
                var start = fullSelectionStart.isAfter(regionStart)
                    ? fullSelectionStart
                    : regionStart;
                var end = fullSelectionEnd.isAfter(regionEnd) ? regionEnd : fullSelectionEnd;
                return (0, createRange_1$3.default)(start, end);
            }
        }
        return null;
    }
    getSelectionRangeInRegion$1.default = getSelectionRangeInRegion;
    function isRegion(regionBase) {
        var region = regionBase;
        return !!region.fullSelectionEnd && !!region.fullSelectionStart;
    }

    Object.defineProperty(getSelectedBlockElementsInRegion$1, "__esModule", { value: true });
    var ContentTraverser_1$2 = ContentTraverser$1;
    var createElement_1$2 = createElement;
    var getBlockElementAtNode_1$2 = getBlockElementAtNode$1;
    var getSelectionRangeInRegion_1$1 = getSelectionRangeInRegion$1;
    var shouldSkipNode_1$1 = shouldSkipNode$1;
    /**
     * Get all block elements covered by the selection under this region
     * @param regionBase The region to get block elements from
     * @param createBlockIfEmpty When set to true, a new empty block element will be created if there is not
     * any blocks in the region. Default value is false
     */
    function getSelectedBlockElementsInRegion(regionBase, createBlockIfEmpty, shouldApplyFormatToSpan) {
        var range = (0, getSelectionRangeInRegion_1$1.default)(regionBase);
        var blocks = [];
        if (range) {
            var rootNode = regionBase.rootNode, skipTags = regionBase.skipTags;
            var traverser = ContentTraverser_1$2.default.createSelectionTraverser(rootNode, range, skipTags);
            for (var block = traverser === null || traverser === void 0 ? void 0 : traverser.currentBlockElement; !!block; block = traverser.getNextBlockElement()) {
                blocks.push(block);
            }
            // Remove meaningless nodes
            blocks = blocks.filter(function (block) {
                var _a;
                var startNode = block.getStartNode();
                var endNode = block.getEndNode();
                if (startNode == endNode && (0, shouldSkipNode_1$1.default)(startNode, true /*ignoreSpace*/)) {
                    (_a = startNode.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(startNode);
                    return false;
                }
                else {
                    return true;
                }
            });
        }
        if (blocks.length == 0 && regionBase && !regionBase.rootNode.firstChild && createBlockIfEmpty) {
            var newNode = (0, createElement_1$2.default)(shouldApplyFormatToSpan
                ? 12 /* EmptyLineFormatInSpan */
                : 1 /* EmptyLine */, regionBase.rootNode.ownerDocument);
            regionBase.rootNode.appendChild(newNode);
            var block = (0, getBlockElementAtNode_1$2.default)(regionBase.rootNode, newNode);
            if (block) {
                blocks.push(block);
            }
        }
        return blocks;
    }
    getSelectedBlockElementsInRegion$1.default = getSelectedBlockElementsInRegion;

    var isNodeInRegion$1 = {};

    Object.defineProperty(isNodeInRegion$1, "__esModule", { value: true });
    var contains_1$5 = contains$1;
    /**
     * Check if a given node is contained by the given region
     * @param region The region to check from
     * @param node The node or block element to check
     */
    function isNodeInRegion(region, node) {
        return !!(region &&
            (0, contains_1$5.default)(region.rootNode, node) &&
            (!region.nodeBefore ||
                region.nodeBefore.compareDocumentPosition(node) == 4 /* Following */) &&
            (!region.nodeAfter ||
                region.nodeAfter.compareDocumentPosition(node) == 2 /* Preceding */));
    }
    isNodeInRegion$1.default = isNodeInRegion;

    Object.defineProperty(createVListFromRegion$1, "__esModule", { value: true });
    var createElement_1$1 = createElement;
    var getRootListNode_1$1 = getRootListNode$1;
    var getSelectedBlockElementsInRegion_1 = getSelectedBlockElementsInRegion$1;
    var isNodeInRegion_1$3 = isNodeInRegion$1;
    var Position_1$4 = Position$1;
    var safeInstanceOf_1$6 = safeInstanceOf$1;
    var shouldSkipNode_1 = shouldSkipNode$1;
    var toArray_1$2 = toArray$1;
    var VList_1$1 = VList$1;
    var wrap_1$1 = wrap$1;
    var getLeafSibling_1$1 = getLeafSibling$1;
    var getListTypeFromNode_1 = getListTypeFromNode$1;
    var ListSelector = 'ol,ul';
    /**
     * Create a VList object from the given region.
     * @param region The region to get VList from
     * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,
     * false to only include the list for the selected blocks
     * @param startNode (Optional) When specified, try get VList which will contain this node.
     * If not specified, get VList from selection of this region
     */
    function createVListFromRegion(region, includeSiblingLists, startNode) {
        if (!region) {
            return null;
        }
        var nodes = [];
        if (startNode) {
            var list = (0, getRootListNode_1$1.default)(region, ListSelector, startNode);
            if (list) {
                nodes.push(list);
            }
        }
        else {
            var blocks = (0, getSelectedBlockElementsInRegion_1.default)(region, undefined, true /* shouldApplyFormatToSpan */);
            blocks.forEach(function (block) {
                var list = (0, getRootListNode_1$1.default)(region, ListSelector, block.getStartNode());
                if (list) {
                    if (nodes[nodes.length - 1] != list) {
                        nodes.push(list);
                    }
                    if (nodes.length == 1 &&
                        (0, safeInstanceOf_1$6.default)(list, 'HTMLOListElement') &&
                        list.start > 1) {
                        // Do not include sibling lists if this list is not start from 1
                        includeSiblingLists = false;
                    }
                }
                else {
                    nodes.push(block.collapseToSingleElement());
                }
            });
            if (nodes.length == 0 && !region.rootNode.firstChild) {
                var newNode = (0, createElement_1$1.default)(12 /* EmptyLineFormatInSpan */, region.rootNode.ownerDocument);
                region.rootNode.appendChild(newNode);
                nodes.push(newNode);
                region.fullSelectionStart = new Position_1$4.default(newNode, 0 /* Begin */);
                region.fullSelectionEnd = new Position_1$4.default(newNode, -1 /* End */);
            }
            if (includeSiblingLists) {
                tryIncludeSiblingNode(region, nodes, false /*isNext*/);
                tryIncludeSiblingNode(region, nodes, true /*isNext*/);
            }
            nodes = nodes.filter(function (node) { return !(0, shouldSkipNode_1.default)(node, true /*ignoreSpace*/); });
        }
        var vList = null;
        if (nodes.length > 0) {
            var firstNode = nodes.shift() || null;
            vList = (0, getListTypeFromNode_1.isListElement)(firstNode)
                ? new VList_1$1.default(firstNode)
                : firstNode
                    ? createVListFromItemNode(firstNode)
                    : null;
            if (vList) {
                nodes.forEach(function (node) {
                    if ((0, getListTypeFromNode_1.isListElement)(node)) {
                        vList.mergeVList(new VList_1$1.default(node));
                    }
                    else {
                        vList.appendItem(node, 0 /* None */);
                    }
                });
            }
        }
        return vList;
    }
    createVListFromRegion$1.default = createVListFromRegion;
    function tryIncludeSiblingNode(region, nodes, isNext) {
        var node = nodes[isNext ? nodes.length - 1 : 0];
        node = (0, getLeafSibling_1$1.getLeafSibling)(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);
        node = (0, getRootListNode_1$1.default)(region, ListSelector, node);
        if ((0, isNodeInRegion_1$3.default)(region, node) && (0, getListTypeFromNode_1.isListElement)(node)) {
            if (isNext) {
                if (!(0, safeInstanceOf_1$6.default)(node, 'HTMLOListElement') || node.start == 1) {
                    // Only include sibling list when
                    // 1. This is a unordered list, OR
                    // 2. This list starts from 1
                    nodes.push(node);
                }
            }
            else {
                nodes.unshift(node);
            }
        }
    }
    function createVListFromItemNode(node) {
        // Wrap all child nodes under a single one, and put the new list under original root node
        // so that the list can carry over styles under the root node.
        var childNodes = (0, toArray_1$2.default)(node.childNodes);
        var nodeForItem = childNodes.length == 1 ? childNodes[0] : (0, wrap_1$1.default)(childNodes, 'SPAN');
        // Create a temporary OL root element for this list.
        var listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here
        node.appendChild(listNode);
        // Create the VList and append items
        var vList = new VList_1$1.default(listNode);
        vList.appendItem(nodeForItem, 0 /* None */);
        return vList;
    }

    var VListChain$1 = {};

    var arrayPush$1 = {};

    Object.defineProperty(arrayPush$1, "__esModule", { value: true });
    /**
     * A type-safe wrapper for Array.prototype.push.apply()
     * @param mainArray The main array to push items into
     * @param itemsArray The items to push to main array
     */
    function arrayPush(mainArray, itemsArray) {
        Array.prototype.push.apply(mainArray, itemsArray);
    }
    arrayPush$1.default = arrayPush;

    Object.defineProperty(VListChain$1, "__esModule", { value: true });
    var arrayPush_1$1 = arrayPush$1;
    var getRootListNode_1 = getRootListNode$1;
    var isNodeAfter_1 = isNodeAfter$1;
    var isNodeInRegion_1$2 = isNodeInRegion$1;
    var queryElements_1$3 = queryElements$1;
    var VList_1 = VList$1;
    var CHAIN_NAME_PREFIX = '__List_Chain_';
    var CHAIN_DATASET_NAME = 'listchain';
    var AFTER_CURSOR_DATASET_NAME = 'listchainafter';
    var lastChainIndex = 0;
    /**
     * Represent a chain of list nodes.
     * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,
     * all others should also be updated in order to main the list number to be continuous.
     */
    var VListChain = /** @class */ (function () {
        /**
         * Construct a new instance of VListChain class
         * @param editor Editor object
         */
        function VListChain(region, name) {
            this.region = region;
            this.name = name;
            this.lastNumber = 0;
            this.lastNumberBeforeCursor = 0;
        }
        /**
         * Create an array of VListChain from current region in editor
         * @param region The region to create VListChain from
         * @param currentNode Optional current node, used for mark lists that are after this node
         * @param nameGenerator Used by test code only
         */
        VListChain.createListChains = function (region, currentNode, nameGenerator) {
            var regions = Array.isArray(region) ? region : region ? [region] : [];
            var result = [];
            regions.forEach(function (region) {
                var chains = [];
                var lastList;
                (0, queryElements_1$3.default)(region.rootNode, 'ol', function (ol) {
                    var list = (0, getRootListNode_1.default)(region, 'ol', ol);
                    if (lastList != list) {
                        var chain = chains.filter(function (c) { return c.canAppendToTail(list); })[0] ||
                            new VListChain(region, (nameGenerator || createListChainName)());
                        var index = chains.indexOf(chain);
                        var afterCurrentNode = !!currentNode && (0, isNodeAfter_1.default)(list, currentNode);
                        if (!afterCurrentNode) {
                            // Make sure current one is at the front if current block has not been met, so that
                            // the first chain is always the nearest one from current node
                            if (index >= 0) {
                                chains.splice(index, 1);
                            }
                            chains.unshift(chain);
                        }
                        else if (index < 0) {
                            chains.push(chain);
                        }
                        chain.append(list, afterCurrentNode);
                        lastList = list;
                    }
                });
                (0, arrayPush_1$1.default)(result, chains);
            });
            return result;
        };
        /**
         * Check if a list with the given start number can be appended next to the last list before cursor
         * @param startNumber The start number of the new list
         */
        VListChain.prototype.canAppendAtCursor = function (startNumber) {
            return startNumber > 1 && this.lastNumberBeforeCursor + 1 == startNumber;
        };
        /**
         * Create a VList to wrap the block of the given node, and append to current chain
         * @param container The container node to create list at
         * @param startNumber Start number of the new list
         */
        VListChain.prototype.createVListAtBlock = function (container, startNumber) {
            if (container && container.parentNode) {
                var list = container.ownerDocument.createElement('ol');
                list.start = startNumber;
                this.applyChainName(list);
                container.parentNode.insertBefore(list, container);
                var vList = new VList_1.default(list);
                vList.appendItem(container, 0 /* None */);
                return vList;
            }
            else {
                return null;
            }
        };
        /**
         * After change the lists, commit the change to all lists in this chain to update the list number,
         * and clear the temporary dataset values added to list node
         */
        VListChain.prototype.commit = function (shouldReuseAllAncestorListElements) {
            var lists = this.getLists();
            var lastNumber = 0;
            for (var i = 0; i < lists.length; i++) {
                var list = lists[i];
                list.start = list.start > 1 ? list.start : lastNumber + 1;
                var vlist = new VList_1.default(list);
                lastNumber = vlist.getLastItemNumber() || 0;
                delete list.dataset[CHAIN_DATASET_NAME];
                delete list.dataset[AFTER_CURSOR_DATASET_NAME];
                vlist.writeBack(shouldReuseAllAncestorListElements);
            }
        };
        /**
         * Check if the given list node is can be appended into current list chain
         * @param list The list node to check
         */
        VListChain.prototype.canAppendToTail = function (list) {
            return this.lastNumber + 1 == list.start;
        };
        /**
         * Append the given list node into this VListChain
         * @param list The list node to append
         * @param isAfterCurrentNode Whether this list is after current node
         */
        VListChain.prototype.append = function (list, isAfterCurrentNode) {
            this.applyChainName(list);
            this.lastNumber = new VList_1.default(list).getLastItemNumber() || 0;
            if (isAfterCurrentNode) {
                list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';
            }
            else {
                this.lastNumberBeforeCursor = this.lastNumber;
            }
        };
        VListChain.prototype.applyChainName = function (list) {
            list.dataset[CHAIN_DATASET_NAME] = this.name;
        };
        VListChain.prototype.getLists = function () {
            var _this = this;
            return (0, queryElements_1$3.default)(this.region.rootNode, "ol[data-" + CHAIN_DATASET_NAME + "=" + this.name + "]").filter(function (node) { return (0, isNodeInRegion_1$2.default)(_this.region, node); });
        };
        return VListChain;
    }());
    VListChain$1.default = VListChain;
    function createListChainName() {
        return CHAIN_NAME_PREFIX + lastChainIndex++;
    }

    var getRegionsFromRange$1 = {};

    var _a$4;
    Object.defineProperty(getRegionsFromRange$1, "__esModule", { value: true });
    getRegionsFromRange$1.getRegionCreator = void 0;
    var contains_1$4 = contains$1;
    var findClosestElementAncestor_1$1 = findClosestElementAncestor$1;
    var Position_1$3 = Position$1;
    var queryElements_1$2 = queryElements$1;
    var getLeafSibling_1 = getLeafSibling$1;
    var regionTypeData = (_a$4 = {},
        _a$4[0 /* Table */] = {
            skipTags: ['TABLE'],
            outerSelector: 'table',
            innerSelector: 'td,th',
        },
        _a$4);
    /**
     * Get regions impacted by the given range under the root node
     * @param root Root node to get regions from
     * @param range A selection range. Regions will be created according to this range. Each region will be
     * fully or partially covered by this range.
     * @param type Type of region. Currently we only support TABLE region.
     */
    function getRegionsFromRange(root, range, type) {
        var regions = [];
        if (root && range) {
            var _a = regionTypeData[type], innerSelector = _a.innerSelector, skipTags = _a.skipTags;
            var boundaryTree = buildBoundaryTree(root, range, type);
            var start = (0, findClosestElementAncestor_1$1.default)(range.startContainer, root, innerSelector) || root;
            var end = (0, findClosestElementAncestor_1$1.default)(range.endContainer, root, innerSelector) || root;
            var creator = getRegionCreator(range, skipTags);
            regions = iterateNodes(creator, boundaryTree, start, end)[0];
        }
        return regions.filter(function (r) { return !!r; });
    }
    getRegionsFromRange$1.default = getRegionsFromRange;
    /**
     * @internal export for test only
     */
    function getRegionCreator(fullRange, skipTags) {
        var fullSelectionStart = Position_1$3.default.getStart(fullRange).normalize();
        var fullSelectionEnd = Position_1$3.default.getEnd(fullRange).normalize();
        return function (rootNode, nodeBefore, nodeAfter) {
            return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)
                ? {
                    rootNode: rootNode,
                    nodeBefore: nodeBefore,
                    nodeAfter: nodeAfter,
                    skipTags: skipTags,
                    fullSelectionStart: fullSelectionStart,
                    fullSelectionEnd: fullSelectionEnd,
                }
                : null;
        };
    }
    getRegionsFromRange$1.getRegionCreator = getRegionCreator;
    /**
     * Step 1: Build boundary tree
     * @param root Root node of the whole scope, normally this will be the root of editable scope
     * @param range Existing selected full range
     * @param type Type of region to create
     */
    function buildBoundaryTree(root, range, type) {
        var allBoundaries = [{ innerNode: root, children: [] }];
        var _a = regionTypeData[type], outerSelector = _a.outerSelector, innerSelector = _a.innerSelector;
        var inSelectionOuterNode = (0, queryElements_1$2.default)(root, outerSelector, null /*callback*/, 2 /* InSelection */, range);
        // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll
        // is in document order, which is what we expect. So we don't need to sort the result here.
        (0, queryElements_1$2.default)(root, innerSelector, function (thisInnerNode) {
            var thisOuterNode = (0, findClosestElementAncestor_1$1.default)(thisInnerNode, root, outerSelector);
            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {
                var boundary = { innerNode: thisInnerNode, children: [] };
                for (var i = allBoundaries.length - 1; i >= 0; i--) {
                    var _a = allBoundaries[i], innerNode = _a.innerNode, children = _a.children;
                    if ((0, contains_1$4.default)(innerNode, thisOuterNode)) {
                        var child = children.filter(function (c) { return c.outerNode == thisOuterNode; })[0];
                        if (!child) {
                            child = { outerNode: thisOuterNode, boundaries: [] };
                            children.push(child);
                        }
                        child.boundaries.push(boundary);
                        break;
                    }
                }
                allBoundaries.push(boundary);
            }
        }, 1 /* OnSelection */, range);
        return allBoundaries[0];
    }
    /**
     * Step 2: Recursively iterate all boundaries and create regions
     * @param creator A region creator function to help create region
     * @param boundary Current root boundary
     * @param start A node where full range start from. This may not be the direct node container of range.startContainer.
     * It is the nearest ancestor which satisfies the InnerSelector of the given region type
     * @param end A node where full range end from. This may not be the direct node container of range.endContainer.
     * It is the nearest ancestor which satisfies the InnerSelector of the given region type
     * @param started Whether we have already hit the start node
     */
    function iterateNodes(creator, boundary, start, end, started) {
        var _a;
        started = started || boundary.innerNode == start;
        var ended = false;
        var children = boundary.children, innerNode = boundary.innerNode;
        var regions = [];
        if (children.length == 0) {
            var region = creator(innerNode);
            if (region) {
                regions.push(region);
            }
        }
        else {
            // Need to run one more time to add region after all children
            for (var i = 0; i <= children.length && !ended; i++) {
                var _b = children[i] || {}, outerNode = _b.outerNode, boundaries = _b.boundaries;
                var previousOuterNode = (_a = children[i - 1]) === null || _a === void 0 ? void 0 : _a.outerNode;
                if (started) {
                    var region = creator(innerNode, previousOuterNode, outerNode);
                    if (region) {
                        regions.push(region);
                    }
                }
                boundaries === null || boundaries === void 0 ? void 0 : boundaries.forEach(function (child) {
                    var _a;
                    var newRegions;
                    _a = iterateNodes(creator, child, start, end, started), newRegions = _a[0], started = _a[1], ended = _a[2];
                    regions = regions.concat(newRegions);
                });
            }
        }
        return [regions, started, ended || innerNode == end];
    }
    /**
     * Check if the given nodes combination is valid to create a region.
     * A combination is valid when:
     * 1. Root node is not null and is not empty. And
     * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And
     * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be
     * node between them.
     * @param root Root node of region
     * @param nodeBefore The boundary node before the region under root
     * @param nodeAfter The boundary node after the region under root
     * @param skipTags Tags to skip
     */
    function areNodesValid(root, nodeBefore, nodeAfter, skipTags) {
        if (!root) {
            return false;
        }
        else {
            var firstNodeOfRegion = nodeBefore && (0, getLeafSibling_1.getNextLeafSibling)(root, nodeBefore, skipTags);
            var lastNodeOfRegion = nodeAfter && (0, getLeafSibling_1.getPreviousLeafSibling)(root, nodeAfter, skipTags);
            var firstNodeValid = !nodeBefore || ((0, contains_1$4.default)(root, nodeBefore) && (0, contains_1$4.default)(root, firstNodeOfRegion));
            var lastNodeValid = !nodeAfter || ((0, contains_1$4.default)(root, nodeAfter) && (0, contains_1$4.default)(root, lastNodeOfRegion));
            var bothValid = !nodeBefore ||
                !nodeAfter ||
                (!(0, contains_1$4.default)(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&
                    !(0, contains_1$4.default)(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&
                    !(0, contains_1$4.default)(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&
                    !(0, contains_1$4.default)(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));
            return firstNodeValid && lastNodeValid && bothValid;
        }
    }

    var collapseNodesInRegion$1 = {};

    Object.defineProperty(collapseNodesInRegion$1, "__esModule", { value: true });
    var collapseNodes_1$1 = collapseNodes$1;
    var isNodeInRegion_1$1 = isNodeInRegion$1;
    var safeInstanceOf_1$5 = safeInstanceOf$1;
    /**
     * Collapse nodes within this region to their common ancestor node under this region
     * @param region The region to collapse nodes in.
     * @param nodesOrBlockElements Nodes or block elements to collapse. When take BlockElement[] as input,
     * start node of the first BlockElement and end node of the last BlockElement will be used as the nodes.
     * All nodes not contained by the given region will be ignored.
     */
    function collapseNodesInRegion(region, nodesOrBlockElements) {
        if (!nodesOrBlockElements || nodesOrBlockElements.length == 0) {
            return [];
        }
        var nodes = (0, safeInstanceOf_1$5.default)(nodesOrBlockElements[0], 'Node')
            ? nodesOrBlockElements
            : [
                nodesOrBlockElements[0].getStartNode(),
                nodesOrBlockElements[nodesOrBlockElements.length - 1].getEndNode(),
            ];
        nodes = nodes && nodes.filter(function (node) { return (0, isNodeInRegion_1$1.default)(region, node); });
        var firstNode = nodes[0];
        var lastNode = nodes[nodes.length - 1];
        if ((0, isNodeInRegion_1$1.default)(region, firstNode) && (0, isNodeInRegion_1$1.default)(region, lastNode)) {
            return (0, collapseNodes_1$1.default)(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);
        }
        else {
            return [];
        }
    }
    collapseNodesInRegion$1.default = collapseNodesInRegion;

    var mergeBlocksInRegion$1 = {};

    var getPredefinedCssForElement$1 = {};

    Object.defineProperty(getPredefinedCssForElement$1, "__esModule", { value: true });
    var getTagOfNode_1$4 = getTagOfNode$1;
    var PREDEFINED_CSS_FOR_ELEMENT = {
        B: {
            'font-weight': 'bold',
        },
        EM: {
            'font-style': 'italic',
        },
        I: {
            'font-style': 'italic',
        },
        U: {
            'text-decoration': 'underline',
        },
        P: {
            'margin-top': '1em',
            'margin-bottom': '1em',
        },
        PRE: {
            'white-space': 'pre',
        },
        S: {
            'text-decoration': 'line-through',
        },
        STRIKE: {
            'text-decoration': 'line-through',
        },
        SUB: {
            'vertical-align': 'sub',
            'font-size': 'smaller',
        },
        SUP: {
            'vertical-align': 'super',
            'font-size': 'smaller',
        },
    };
    /**
     * @internal
     * Get a map for browser built-in CSS definitions of elements
     */
    function getPredefinedCssForElement(element, additionalPredefinedCssForElement) {
        var tag = (0, getTagOfNode_1$4.default)(element);
        return PREDEFINED_CSS_FOR_ELEMENT[tag] || (additionalPredefinedCssForElement || {})[tag];
    }
    getPredefinedCssForElement$1.default = getPredefinedCssForElement;

    var __assign$h = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$h = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$h.apply(this, arguments);
    };
    Object.defineProperty(mergeBlocksInRegion$1, "__esModule", { value: true });
    var changeElementTag_1$2 = changeElementTag$1;
    var contains_1$3 = contains$1;
    var getBlockElementAtNode_1$1 = getBlockElementAtNode$1;
    var getPredefinedCssForElement_1$1 = getPredefinedCssForElement$1;
    var getStyles_1$2 = getStyles$1;
    var isNodeInRegion_1 = isNodeInRegion$1;
    var safeInstanceOf_1$4 = safeInstanceOf$1;
    var setStyles_1$2 = setStyles$1;
    var collapseNodes_1 = collapseNodes$1;
    /**
     * Merge a BlockElement of given node after another node
     * @param region Region to operate in
     * @param refNode The node to merge after
     * @param targetNode The node of target block element
     */
    function mergeBlocksInRegion(region, refNode, targetNode) {
        var _a, _b, _c;
        var block;
        if (!(0, isNodeInRegion_1.default)(region, refNode) ||
            !(0, isNodeInRegion_1.default)(region, targetNode) ||
            !(block = (0, getBlockElementAtNode_1$1.default)(region.rootNode, targetNode)) ||
            block.contains(refNode)) {
            return;
        }
        var blockRoot = block.collapseToSingleElement();
        var commonContainer = (0, collapseNodes_1.collapse)(region.rootNode, blockRoot, refNode, false /*isStart*/, true /*canSplitParent*/);
        // Copy styles of parent nodes into blockRoot
        for (var node = blockRoot; (0, contains_1$3.default)(commonContainer, node);) {
            var parent_1 = node.parentNode;
            if ((0, safeInstanceOf_1$4.default)(parent_1, 'HTMLElement')) {
                var styles = __assign$h(__assign$h(__assign$h({}, ((0, getPredefinedCssForElement_1$1.default)(parent_1) || {})), (0, getStyles_1$2.default)(parent_1)), (0, getStyles_1$2.default)(blockRoot));
                (0, setStyles_1$2.default)(blockRoot, styles);
            }
            node = parent_1;
        }
        var nodeToRemove = null;
        var nodeToMerge = blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0
            ? blockRoot.firstChild
            : (0, changeElementTag_1$2.default)(blockRoot, 'SPAN');
        // Remove empty node
        for (var node = nodeToMerge; (0, contains_1$3.default)(commonContainer, node) && ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes.length) == 1; node = node.parentNode) {
            // If the only child is the one which is about to be removed, this node should also be removed
            nodeToRemove = node.parentNode;
        }
        // Finally, merge blocks, and remove empty nodes
        (_b = refNode.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(nodeToMerge, refNode.nextSibling);
        (_c = nodeToRemove === null || nodeToRemove === void 0 ? void 0 : nodeToRemove.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(nodeToRemove);
    }
    mergeBlocksInRegion$1.default = mergeBlocksInRegion;

    var getPositionRect$1 = {};

    Object.defineProperty(getPositionRect$1, "__esModule", { value: true });
    var createElement_1 = createElement;
    var createRange_1$2 = createRange$1;
    var normalizeRect_1 = normalizeRect$1;
    /**
     * Get bounding rect of this position
     * @param position The position to get rect from
     */
    function getPositionRect(position) {
        var _a;
        if (!position) {
            return null;
        }
        var range = (0, createRange_1$2.default)(position);
        // 1) try to get rect using range.getBoundingClientRect()
        var rect = range.getBoundingClientRect && (0, normalizeRect_1.default)(range.getBoundingClientRect());
        if (rect) {
            return rect;
        }
        // 2) try to get rect using range.getClientRects
        position = position.normalize();
        var rects = range.getClientRects && range.getClientRects();
        rect = rects && rects.length == 1 ? (0, normalizeRect_1.default)(rects[0]) : null;
        if (rect) {
            return rect;
        }
        // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others
        if (position.node.nodeType == 3 /* Text */ && position.node.ownerDocument) {
            var span = (0, createElement_1.default)({ tag: 'span', children: ['\u200b'] }, position.node.ownerDocument);
            range = (0, createRange_1$2.default)(position);
            range.insertNode(span);
            rect = span.getBoundingClientRect && (0, normalizeRect_1.default)(span.getBoundingClientRect());
            (_a = span.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(span);
            if (rect) {
                return rect;
            }
        }
        // 4) try getBoundingClientRect on element
        var element = position.element;
        if (element && element.getBoundingClientRect) {
            rect = (0, normalizeRect_1.default)(element.getBoundingClientRect());
            if (rect) {
                return rect;
            }
        }
        return null;
    }
    getPositionRect$1.default = getPositionRect;

    var isPositionAtBeginningOf$1 = {};

    Object.defineProperty(isPositionAtBeginningOf$1, "__esModule", { value: true });
    var contains_1$2 = contains$1;
    var getTagOfNode_1$3 = getTagOfNode$1;
    var isNodeEmpty_1$1 = isNodeEmpty$1;
    /**
     * Check if this position is at beginning of the given node.
     * This will return true if all nodes between the beginning of target node and the position are empty.
     * @param position The position to check
     * @param targetNode The node to check
     * @returns True if position is at beginning of the node, otherwise false
     */
    function isPositionAtBeginningOf(position, targetNode) {
        if (position) {
            position = position.normalize();
            var node = position.node;
            var offset = position.offset;
            if (offset == 0) {
                while (node && (0, contains_1$2.default)(targetNode, node) && areAllPreviousNodesEmpty(node)) {
                    node = (node === null || node === void 0 ? void 0 : node.parentNode) || null;
                }
                return node == targetNode;
            }
        }
        return false;
    }
    isPositionAtBeginningOf$1.default = isPositionAtBeginningOf;
    function areAllPreviousNodesEmpty(node) {
        while (node.previousSibling) {
            node = node.previousSibling;
            if ((0, getTagOfNode_1$3.default)(node) == 'BR' || !(0, isNodeEmpty_1$1.default)(node)) {
                return false;
            }
        }
        return true;
    }

    var getSelectionPath$1 = {};

    Object.defineProperty(getSelectionPath$1, "__esModule", { value: true });
    var contains_1$1 = contains$1;
    var Position_1$2 = Position$1;
    /**
     * Get path of the given selection range related to the given rootNode
     * @param rootNode The root node where the path start from
     * @param range The range of selection
     */
    function getSelectionPath(rootNode, range) {
        if (!range) {
            return null;
        }
        var selectionPath = {
            start: getPositionPath(Position_1$2.default.getStart(range), rootNode),
            end: getPositionPath(Position_1$2.default.getEnd(range), rootNode),
        };
        return selectionPath;
    }
    getSelectionPath$1.default = getSelectionPath;
    /**
     * Get the path of the node relative to rootNode.
     * The path of the node is an array of integer indices into the childNodes of the given node.
     *
     * The node path will be what the node path will be on a _normalized_ dom
     * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)
     *
     * @param rootNode the node the path will be relative to
     * @param position the position to get indexes from. Follows the same semantics
     * as selectionRange (if node is of type Text, it is an offset into the text of that node.
     * If node is of type Element, it is the index of a child in that Element node.)
     */
    function getPositionPath(position, rootNode) {
        var _a, _b;
        if (!position || !rootNode) {
            return [];
        }
        var node = position.node;
        var offset = position.offset;
        var result = [];
        var parent;
        if (!(0, contains_1$1.default)(rootNode, node, true)) {
            return [];
        }
        if (node.nodeType == 3 /* Text */) {
            parent = node.parentNode;
            while (node.previousSibling && node.previousSibling.nodeType == 3 /* Text */) {
                offset += ((_a = node.previousSibling.nodeValue) === null || _a === void 0 ? void 0 : _a.length) || 0;
                node = node.previousSibling;
            }
            result.unshift(offset);
        }
        else {
            parent = node;
            node = node.childNodes[offset];
        }
        do {
            offset = 0;
            var isPreviousText = false;
            for (var c = (parent === null || parent === void 0 ? void 0 : parent.firstChild) || null; c && c != node; c = c.nextSibling) {
                if (c.nodeType == 3 /* Text */) {
                    if (((_b = c.nodeValue) === null || _b === void 0 ? void 0 : _b.length) === 0 || isPreviousText) {
                        continue;
                    }
                    isPreviousText = true;
                }
                else {
                    isPreviousText = false;
                }
                offset++;
            }
            result.unshift(offset);
            node = parent;
            parent = (parent === null || parent === void 0 ? void 0 : parent.parentNode) || null;
        } while (node && node != rootNode);
        return result;
    }

    var getHtmlWithSelectionPath$1 = {};

    Object.defineProperty(getHtmlWithSelectionPath$1, "__esModule", { value: true });
    var getInnerHTML_1 = getInnerHTML$1;
    var getSelectionPath_1 = getSelectionPath$1;
    /**
     * Get inner Html of a root node with a selection path which can be used for restore selection.
     * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.
     * @param rootNode Root node to get inner Html from
     * @param range The range of selection. If pass null, no selection path will be added
     * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid
     */
    function getHtmlWithSelectionPath(rootNode, range) {
        if (!rootNode) {
            return '';
        }
        var content = (0, getInnerHTML_1.default)(rootNode);
        var selectionPath = range && (0, getSelectionPath_1.default)(rootNode, range);
        return selectionPath ? content + "<!--" + JSON.stringify(selectionPath) + "-->" : content;
    }
    getHtmlWithSelectionPath$1.default = getHtmlWithSelectionPath;

    var setHtmlWithSelectionPath$1 = {};

    Object.defineProperty(setHtmlWithSelectionPath$1, "__esModule", { value: true });
    setHtmlWithSelectionPath$1.setHtmlWithMetadata = void 0;
    var createRange_1$1 = createRange$1;
    var safeInstanceOf_1$3 = safeInstanceOf$1;
    var validate_1 = validate$1;
    var definitionCreators_1 = definitionCreators;
    var NumberArrayDefinition = (0, definitionCreators_1.createArrayDefinition)((0, definitionCreators_1.createNumberDefinition)());
    var CoordinatesDefinition = (0, definitionCreators_1.createObjectDefinition)({
        x: (0, definitionCreators_1.createNumberDefinition)(),
        y: (0, definitionCreators_1.createNumberDefinition)(),
    });
    var IsDarkModeDefinition = (0, definitionCreators_1.createBooleanDefinition)(true /*isOptional*/);
    var NormalContentMetadataDefinition = (0, definitionCreators_1.createObjectDefinition)({
        type: (0, definitionCreators_1.createNumberDefinition)(true /*isOptional*/, 0 /* Normal */),
        isDarkMode: IsDarkModeDefinition,
        start: NumberArrayDefinition,
        end: NumberArrayDefinition,
    });
    var TableContentMetadataDefinition = (0, definitionCreators_1.createObjectDefinition)({
        type: (0, definitionCreators_1.createNumberDefinition)(false /*isOptional*/, 1 /* TableSelection */),
        isDarkMode: IsDarkModeDefinition,
        tableId: (0, definitionCreators_1.createStringDefinition)(),
        firstCell: CoordinatesDefinition,
        lastCell: CoordinatesDefinition,
    });
    var ImageContentMetadataDefinition = (0, definitionCreators_1.createObjectDefinition)({
        type: (0, definitionCreators_1.createNumberDefinition)(false /*isOptional*/, 2 /* ImageSelection */),
        isDarkMode: IsDarkModeDefinition,
        imageId: (0, definitionCreators_1.createStringDefinition)(),
    });
    /**
     * @deprecated Use setHtmlWithMetadata instead
     * Restore inner HTML of a root element from given html string. If the string contains selection path,
     * remove the selection path and return a range represented by the path
     * @param root The root element
     * @param html The HTML to restore
     * @param trustedHTMLHandler An optional trusted HTML handler to convert HTML string to security string
     * @returns A selection range if the html contains a valid selection path, otherwise null
     */
    function setHtmlWithSelectionPath(rootNode, html, trustedHTMLHandler) {
        var metadata = setHtmlWithMetadata(rootNode, html, trustedHTMLHandler);
        return (metadata === null || metadata === void 0 ? void 0 : metadata.type) == 0 /* Normal */
            ? (0, createRange_1$1.default)(rootNode, metadata.start, metadata.end)
            : null;
    }
    setHtmlWithSelectionPath$1.default = setHtmlWithSelectionPath;
    /**
     * Restore inner HTML of a root element from given html string. If the string contains metadata,
     * remove it from DOM tree and return the metadata
     * @param root The root element
     * @param html The HTML to restore
     * @param trustedHTMLHandler An optional trusted HTML handler to convert HTML string to security string
     * @returns Content metadata if any, or undefined
     */
    function setHtmlWithMetadata(rootNode, html, trustedHTMLHandler) {
        if (!rootNode) {
            return undefined;
        }
        html = html || '';
        rootNode.innerHTML = (trustedHTMLHandler === null || trustedHTMLHandler === void 0 ? void 0 : trustedHTMLHandler(html)) || html;
        var potentialMetadataComment = rootNode.lastChild;
        if ((0, safeInstanceOf_1$3.default)(potentialMetadataComment, 'Comment')) {
            try {
                var obj = JSON.parse(potentialMetadataComment.nodeValue || '');
                if ((0, validate_1.default)(obj, NormalContentMetadataDefinition) ||
                    (0, validate_1.default)(obj, TableContentMetadataDefinition) ||
                    (0, validate_1.default)(obj, ImageContentMetadataDefinition)) {
                    rootNode.removeChild(potentialMetadataComment);
                    obj.type = typeof obj.type === 'undefined' ? 0 /* Normal */ : obj.type;
                    obj.isDarkMode = obj.isDarkMode || false;
                    return obj;
                }
            }
            catch (_a) { }
        }
        return undefined;
    }
    setHtmlWithSelectionPath$1.setHtmlWithMetadata = setHtmlWithMetadata;

    var addRangeToSelection$1 = {};

    Object.defineProperty(addRangeToSelection$1, "__esModule", { value: true });
    var Browser_1$1 = Browser;
    /**
     * Add the given range into selection of the given document
     * @param range The range to select
     * @param skipSameRange When set to true, do nothing if the given range is the same with current selection,
     * otherwise it will always remove current selection range and set to the given one.
     * This parameter is always treat as true in Edge to avoid some weird runtime exception.
     */
    function addRangeToSelection(range, skipSameRange) {
        var _a, _b, _c;
        var selection = (_c = (_b = (_a = range === null || range === void 0 ? void 0 : range.commonAncestorContainer) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) === null || _c === void 0 ? void 0 : _c.getSelection();
        if (selection) {
            var needAddRange = true;
            if (selection.rangeCount > 0) {
                // Workaround IE exception 800a025e
                try {
                    var currentRange = null;
                    // Do not remove/add range if current selection is the same with target range
                    // Without this check, execCommand() may fail in Edge since we changed the selection
                    if ((skipSameRange || Browser_1$1.Browser.isEdge) &&
                        (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&
                        currentRange.startContainer == range.startContainer &&
                        currentRange.startOffset == range.startOffset &&
                        currentRange.endContainer == range.endContainer &&
                        currentRange.endOffset == range.endOffset) {
                        needAddRange = false;
                    }
                    else {
                        selection.removeAllRanges();
                    }
                }
                catch (e) { }
            }
            if (needAddRange) {
                selection.addRange(range);
            }
        }
    }
    addRangeToSelection$1.default = addRangeToSelection;

    var addSnapshot$1 = {};

    var clearProceedingSnapshots$1 = {};

    var canMoveCurrentSnapshot$1 = {};

    Object.defineProperty(canMoveCurrentSnapshot$1, "__esModule", { value: true });
    /**
     * Check whether can move current snapshot with the given step
     * @param snapshots The snapshots data structure to check
     * @param step The step to check, can be positive, negative or 0
     * @returns True if can move current snapshot with the given step, otherwise false
     */
    function canMoveCurrentSnapshot(snapshots, step) {
        var newIndex = snapshots.currentIndex + step;
        return newIndex >= 0 && newIndex < snapshots.snapshots.length;
    }
    canMoveCurrentSnapshot$1.default = canMoveCurrentSnapshot;

    Object.defineProperty(clearProceedingSnapshots$1, "__esModule", { value: true });
    clearProceedingSnapshots$1.clearProceedingSnapshotsV2 = void 0;
    var canMoveCurrentSnapshot_1$1 = canMoveCurrentSnapshot$1;
    /**
     * Clear all snapshots after the current one
     * @param snapshots The snapshots data structure to clear
     */
    function clearProceedingSnapshots(snapshots, getLength) {
        getLength = getLength || (function (str) { var _a; return ((_a = str) === null || _a === void 0 ? void 0 : _a.length) || 0; });
        if ((0, canMoveCurrentSnapshot_1$1.default)(snapshots, 1)) {
            var removedSize = 0;
            for (var i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {
                removedSize += getLength(snapshots.snapshots[i]);
            }
            snapshots.snapshots.splice(snapshots.currentIndex + 1);
            snapshots.totalSize -= removedSize;
            snapshots.autoCompleteIndex = -1;
        }
    }
    clearProceedingSnapshots$1.default = clearProceedingSnapshots;
    /**
     * Clear all snapshots after the current one
     * @param snapshots The snapshots data structure to clear
     */
    function clearProceedingSnapshotsV2(snapshots) {
        clearProceedingSnapshots(snapshots, function (s) { var _a; return ((_a = s.html) === null || _a === void 0 ? void 0 : _a.length) || 0; });
    }
    clearProceedingSnapshots$1.clearProceedingSnapshotsV2 = clearProceedingSnapshotsV2;

    Object.defineProperty(addSnapshot$1, "__esModule", { value: true });
    addSnapshot$1.addSnapshotV2 = void 0;
    var clearProceedingSnapshots_1 = clearProceedingSnapshots$1;
    function addSnapshot(snapshots, snapshot, isAutoCompleteSnapshot, getLength, compare) {
        getLength = getLength || (function (str) { var _a; return ((_a = str) === null || _a === void 0 ? void 0 : _a.length) || 0; });
        compare = compare || defaultCompare;
        var currentSnapshot = snapshots.snapshots[snapshots.currentIndex];
        if (snapshots.currentIndex < 0 || !currentSnapshot || !compare(snapshot, currentSnapshot)) {
            (0, clearProceedingSnapshots_1.default)(snapshots, getLength);
            snapshots.snapshots.push(snapshot);
            snapshots.currentIndex++;
            snapshots.totalSize += getLength(snapshot);
            var removeCount = 0;
            while (removeCount < snapshots.snapshots.length &&
                snapshots.totalSize > snapshots.maxSize) {
                snapshots.totalSize -= getLength(snapshots.snapshots[removeCount]);
                removeCount++;
            }
            if (removeCount > 0) {
                snapshots.snapshots.splice(0, removeCount);
                snapshots.currentIndex -= removeCount;
                snapshots.autoCompleteIndex -= removeCount;
            }
            if (isAutoCompleteSnapshot) {
                snapshots.autoCompleteIndex = snapshots.currentIndex;
            }
        }
        else if (currentSnapshot && compare(snapshot, currentSnapshot)) {
            // replace the currentSnapshot, to update other data such as metadata
            snapshots.snapshots.splice(snapshots.currentIndex, 1, snapshot);
        }
    }
    addSnapshot$1.default = addSnapshot;
    /**
     * Add a new snapshot to the given snapshots data structure
     * @param snapshots The snapshots data structure to add new snapshot into
     * @param snapshot The snapshot object to add
     * @param isAutoCompleteSnapshot Whether this is a snapshot before auto complete action
     */
    function addSnapshotV2(snapshots, snapshot, isAutoCompleteSnapshot) {
        addSnapshot(snapshots, snapshot, isAutoCompleteSnapshot, function (s) { var _a; return ((_a = s.html) === null || _a === void 0 ? void 0 : _a.length) || 0; }, compareSnapshots);
    }
    addSnapshot$1.addSnapshotV2 = addSnapshotV2;
    function compareSnapshots(s1, s2) {
        return s1.html == s2.html;
    }
    function defaultCompare(s1, s2) {
        return s1 == s2;
    }

    var moveCurrentSnapshot$1 = {};

    Object.defineProperty(moveCurrentSnapshot$1, "__esModule", { value: true });
    moveCurrentSnapshot$1.moveCurrentSnapsnot = void 0;
    var canMoveCurrentSnapshot_1 = canMoveCurrentSnapshot$1;
    /**
     * Move current snapshot with the given step if can move this step. Otherwise no action and return null
     * @param snapshots The snapshots data structure to move
     * @param step The step to move
     * @returns If can move with the given step, returns the snapshot after move, otherwise null
     */
    function moveCurrentSnapshot(snapshots, step) {
        if ((0, canMoveCurrentSnapshot_1.default)(snapshots, step)) {
            snapshots.currentIndex += step;
            snapshots.autoCompleteIndex = -1;
            return snapshots.snapshots[snapshots.currentIndex];
        }
        else {
            return null;
        }
    }
    moveCurrentSnapshot$1.default = moveCurrentSnapshot;
    /**
     * @deprecated
     * For backward compatibility only
     */
    moveCurrentSnapshot$1.moveCurrentSnapsnot = moveCurrentSnapshot;

    var createSnapshots$1 = {};

    Object.defineProperty(createSnapshots$1, "__esModule", { value: true });
    /**
     * Create initial snapshots
     * @param maxSize max size of all snapshots
     */
    function createSnapshots(maxSize) {
        return {
            snapshots: [],
            totalSize: 0,
            currentIndex: -1,
            autoCompleteIndex: -1,
            maxSize: maxSize,
        };
    }
    createSnapshots$1.default = createSnapshots;

    var canUndoAutoComplete$1 = {};

    Object.defineProperty(canUndoAutoComplete$1, "__esModule", { value: true });
    /**
     * Whether there is a snapshot added before auto complete and it can be undone now
     */
    function canUndoAutoComplete(snapshots) {
        return (snapshots.autoCompleteIndex >= 0 &&
            snapshots.currentIndex - snapshots.autoCompleteIndex == 1);
    }
    canUndoAutoComplete$1.default = canUndoAutoComplete;

    var HtmlSanitizer$1 = {};

    var getInheritableStyles$1 = {};

    Object.defineProperty(getInheritableStyles$1, "__esModule", { value: true });
    // Inheritable CSS properties
    // Ref: https://www.w3.org/TR/CSS21/propidx.html
    var INHERITABLE_PROPERTIES = ('border-spacing,caption-side,color,' +
        'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +
        'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +
        'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +
        'widows,word-spacing').split(',');
    /**
     * Get inheritable CSS style values from the given element
     * @param element The element to get style from
     */
    function getInheritableStyles(element) {
        var win = element && element.ownerDocument && element.ownerDocument.defaultView;
        var styles = win && element && win.getComputedStyle(element);
        var result = {};
        INHERITABLE_PROPERTIES.forEach(function (name) { return (result[name] = (styles && styles.getPropertyValue(name)) || ''); });
        return result;
    }
    getInheritableStyles$1.default = getInheritableStyles;

    var cloneObject$1 = {};

    Object.defineProperty(cloneObject$1, "__esModule", { value: true });
    cloneObject$1.cloneObject = void 0;
    var getObjectKeys_1$2 = getObjectKeys$1;
    function nativeClone(source, existingObj) {
        return Object.assign(existingObj || {}, source);
    }
    function customClone(source, existingObj) {
        var result = existingObj || {};
        if (source) {
            for (var _i = 0, _a = (0, getObjectKeys_1$2.default)(source); _i < _a.length; _i++) {
                var key = _a[_i];
                result[key] = source[key];
            }
        }
        return result;
    }
    // @ts-ignore Ignore this error for IE compatibility
    var cloneObjectImpl = Object.assign ? nativeClone : customClone;
    /**
     * @internal
     */
    function cloneObject(source, existingObj) {
        return cloneObjectImpl(source, existingObj);
    }
    cloneObject$1.cloneObject = cloneObject;

    var processCssVariable$1 = {};

    Object.defineProperty(processCssVariable$1, "__esModule", { value: true });
    processCssVariable$1.isCssVariable = processCssVariable$1.processCssVariable = void 0;
    var VARIABLE_REGEX$1 = /^\s*var\(\s*[a-zA-Z0-9-_]+\s*(,\s*(.*))?\)\s*$/;
    var VARIABLE_PREFIX$1 = 'var(';
    /**
     * @internal
     * Handle CSS variable format. e.g.: var(--name, fallbackValue)
     */
    function processCssVariable(value) {
        var match = VARIABLE_REGEX$1.exec(value);
        return (match === null || match === void 0 ? void 0 : match[2]) || ''; // Without fallback value, we don't know what does the original value mean, so ignore it
    }
    processCssVariable$1.processCssVariable = processCssVariable;
    /**
     * @internal
     */
    function isCssVariable(value) {
        return value.indexOf(VARIABLE_PREFIX$1) == 0;
    }
    processCssVariable$1.isCssVariable = isCssVariable;

    var getAllowedValues = {};

    var __assign$g = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$g = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$g.apply(this, arguments);
    };
    Object.defineProperty(getAllowedValues, "__esModule", { value: true });
    getAllowedValues.getStyleCallbacks = getAllowedValues.getDefaultStyleValues = getAllowedValues.getAllowedCssClassesRegex = getAllowedValues.getAllowedAttributes = getAllowedValues.getTagReplacement = void 0;
    var getObjectKeys_1$1 = getObjectKeys$1;
    var cloneObject_1$1 = cloneObject$1;
    var HTML_TAG_REPLACEMENT = {
        // Allowed tags
        a: '*',
        abbr: '*',
        address: '*',
        area: '*',
        article: '*',
        aside: '*',
        b: '*',
        bdi: '*',
        bdo: '*',
        blockquote: '*',
        body: '*',
        br: '*',
        button: '*',
        canvas: '*',
        caption: '*',
        center: '*',
        cite: '*',
        code: '*',
        col: '*',
        colgroup: '*',
        data: '*',
        datalist: '*',
        dd: '*',
        del: '*',
        details: '*',
        dfn: '*',
        dialog: '*',
        dir: '*',
        div: '*',
        dl: '*',
        dt: '*',
        em: '*',
        fieldset: '*',
        figcaption: '*',
        figure: '*',
        font: '*',
        footer: '*',
        h1: '*',
        h2: '*',
        h3: '*',
        h4: '*',
        h5: '*',
        h6: '*',
        head: '*',
        header: '*',
        hgroup: '*',
        hr: '*',
        html: '*',
        i: '*',
        img: '*',
        input: '*',
        ins: '*',
        kbd: '*',
        label: '*',
        legend: '*',
        li: '*',
        main: '*',
        map: '*',
        mark: '*',
        menu: '*',
        menuitem: '*',
        meter: '*',
        nav: '*',
        ol: '*',
        optgroup: '*',
        option: '*',
        output: '*',
        p: '*',
        picture: '*',
        pre: '*',
        progress: '*',
        q: '*',
        rp: '*',
        rt: '*',
        ruby: '*',
        s: '*',
        samp: '*',
        section: '*',
        select: '*',
        small: '*',
        span: '*',
        strike: '*',
        strong: '*',
        sub: '*',
        summary: '*',
        sup: '*',
        table: '*',
        tbody: '*',
        td: '*',
        textarea: '*',
        tfoot: '*',
        th: '*',
        thead: '*',
        time: '*',
        tr: '*',
        tt: '*',
        u: '*',
        ul: '*',
        var: '*',
        wbr: '*',
        xmp: '*',
        // Replaced tags:
        form: 'SPAN',
        // Disallowed tags
        applet: null,
        audio: null,
        base: null,
        basefont: null,
        embed: null,
        frame: null,
        frameset: null,
        iframe: null,
        link: null,
        meta: null,
        noscript: null,
        object: null,
        param: null,
        script: null,
        slot: null,
        source: null,
        style: null,
        template: null,
        title: null,
        track: null,
        video: null,
    };
    var ALLOWED_HTML_ATTRIBUTES = ('accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +
        'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +
        'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +
        'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +
        'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,valign,value,' +
        'width,wrap').split(',');
    var DEFAULT_STYLE_VALUES = {
        'background-color': 'transparent',
        'border-bottom-color': 'rgb(0, 0, 0)',
        'border-bottom-style': 'none',
        'border-bottom-width': '0px',
        'border-image-outset': '0',
        'border-image-repeat': 'stretch',
        'border-image-slice': '100%',
        'border-image-source': 'none',
        'border-image-width': '1',
        'border-left-color': 'rgb(0, 0, 0)',
        'border-left-style': 'none',
        'border-left-width': '0px',
        'border-right-color': 'rgb(0, 0, 0)',
        'border-right-style': 'none',
        'border-right-width': '0px',
        'border-top-color': 'rgb(0, 0, 0)',
        'border-top-style': 'none',
        'border-top-width': '0px',
        'outline-color': 'transparent',
        'outline-style': 'none',
        'outline-width': '0px',
        overflow: 'visible',
        '-webkit-text-stroke-width': '0px',
        'word-wrap': 'break-word',
        'margin-left': '0px',
        'margin-right': '0px',
        padding: '0px',
        'padding-top': '0px',
        'padding-left': '0px',
        'padding-right': '0px',
        'padding-bottom': '0px',
        border: '0px',
        'border-top': '0px',
        'border-left': '0px',
        'border-right': '0px',
        'border-bottom': '0px',
        'vertical-align': 'baseline',
        float: 'none',
    };
    // This is to preserve entity related CSS classes when paste.
    var ALLOWED_CSS_CLASSES$1 = [];
    /**
     * @internal
     */
    function getTagReplacement(additionalReplacements) {
        var result = __assign$g({}, HTML_TAG_REPLACEMENT);
        var replacements = additionalReplacements || {};
        (0, getObjectKeys_1$1.default)(replacements).forEach(function (key) {
            if (key) {
                result[key.toLowerCase()] = replacements[key];
            }
        });
        return result;
    }
    getAllowedValues.getTagReplacement = getTagReplacement;
    /**
     * @internal
     */
    function getAllowedAttributes(additionalAttributes) {
        return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(function (attr) {
            return attr.toLocaleLowerCase();
        });
    }
    getAllowedValues.getAllowedAttributes = getAllowedAttributes;
    /**
     * @internal
     */
    function getAllowedCssClassesRegex(additionalCssClasses) {
        var patterns = ALLOWED_CSS_CLASSES$1.concat(additionalCssClasses || []);
        return patterns.length > 0 ? new RegExp(patterns.join('|')) : null;
    }
    getAllowedValues.getAllowedCssClassesRegex = getAllowedCssClassesRegex;
    /**
     * @internal
     */
    function getDefaultStyleValues(additionalDefaultStyles) {
        var result = (0, cloneObject_1$1.cloneObject)(DEFAULT_STYLE_VALUES);
        if (additionalDefaultStyles) {
            Object.keys(additionalDefaultStyles).forEach(function (name) {
                var value = additionalDefaultStyles[name];
                if (value !== null && value !== undefined) {
                    result[name] = value;
                }
                else {
                    delete result[name];
                }
            });
        }
        return result;
    }
    getAllowedValues.getDefaultStyleValues = getDefaultStyleValues;
    /**
     * @internal
     */
    function getStyleCallbacks(callbacks) {
        var result = (0, cloneObject_1$1.cloneObject)(callbacks);
        result.position = result.position || removeValue;
        result.width = result.width || removeWidthForLiAndDiv;
        return result;
    }
    getAllowedValues.getStyleCallbacks = getStyleCallbacks;
    function removeValue() {
        return null;
    }
    function removeWidthForLiAndDiv(value, element) {
        var tag = element.tagName;
        return !(tag == 'LI' || tag == 'DIV');
    }
    function unique(array) {
        return array.filter(function (value, index, self) { return self.indexOf(value) == index; });
    }

    Object.defineProperty(HtmlSanitizer$1, "__esModule", { value: true });
    var changeElementTag_1$1 = changeElementTag$1;
    var getInheritableStyles_1 = getInheritableStyles$1;
    var getObjectKeys_1 = getObjectKeys$1;
    var getPredefinedCssForElement_1 = getPredefinedCssForElement$1;
    var getStyles_1$1 = getStyles$1;
    var getTagOfNode_1$2 = getTagOfNode$1;
    var safeInstanceOf_1$2 = safeInstanceOf$1;
    var setStyles_1$1 = setStyles$1;
    var toArray_1$1 = toArray$1;
    var cloneObject_1 = cloneObject$1;
    var processCssVariable_1 = processCssVariable$1;
    var getAllowedValues_1 = getAllowedValues;
    /**
     * HTML sanitizer class provides two features:
     * 1. Convert global CSS to inline CSS
     * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes
     */
    var HtmlSanitizer = /** @class */ (function () {
        /**
         * Construct a new instance of HtmlSanitizer
         * @param options Options for HtmlSanitizer
         */
        function HtmlSanitizer(options) {
            options = options || {};
            this.elementCallbacks = (0, cloneObject_1.cloneObject)(options.elementCallbacks);
            this.styleCallbacks = (0, getAllowedValues_1.getStyleCallbacks)(options.cssStyleCallbacks);
            this.attributeCallbacks = (0, cloneObject_1.cloneObject)(options.attributeCallbacks);
            this.tagReplacements = (0, getAllowedValues_1.getTagReplacement)(options.additionalTagReplacements);
            this.allowedAttributes = (0, getAllowedValues_1.getAllowedAttributes)(options.additionalAllowedAttributes);
            this.allowedCssClassesRegex = (0, getAllowedValues_1.getAllowedCssClassesRegex)(options.additionalAllowedCssClasses);
            this.defaultStyleValues = (0, getAllowedValues_1.getDefaultStyleValues)(options.additionalDefaultStyleValues);
            this.additionalPredefinedCssForElement = options.additionalPredefinedCssForElement || null;
            this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];
            this.preserveHtmlComments = options.preserveHtmlComments || false;
            this.unknownTagReplacement = options.unknownTagReplacement || null;
        }
        /**
         * @deprecated Use new HtmlSanitizer().convertGlobalCssToInlineCss() instead
         * Convert global CSS to inline CSS if any
         * @param html HTML source
         * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS
         */
        HtmlSanitizer.convertInlineCss = function (html, additionalStyleNodes) {
            var sanitizer = new HtmlSanitizer({
                additionalGlobalStyleNodes: additionalStyleNodes,
            });
            return sanitizer.exec(html, true /*convertCssOnly*/);
        };
        /**
         * @deprecated Use new HtmlSanitizer().sanitize() instead
         * Sanitize HTML string, remove any unused HTML node/attribute/CSS.
         * @param html HTML source string
         * @param options Options used for this sanitizing process
         */
        HtmlSanitizer.sanitizeHtml = function (html, options) {
            options = options || {};
            var sanitizer = new HtmlSanitizer(options);
            var currentStyles = (0, safeInstanceOf_1$2.default)(options.currentElementOrStyle, 'HTMLElement')
                ? (0, getInheritableStyles_1.default)(options.currentElementOrStyle)
                : options.currentElementOrStyle;
            return sanitizer.exec(html, options.convertCssOnly, currentStyles);
        };
        /**
         * @deprecated Use HtmlSanitizer.convertGlobalCssToInlineCss() and HtmlSanitizer.sanitize() instead
         * Sanitize HTML string
         * This function will do the following work:
         * 1. Convert global CSS into inline CSS
         * 2. Remove dangerous HTML tags and attributes
         * 3. Remove useless CSS properties
         * @param html The input HTML
         * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing
         * @param currentStyles Current inheritable CSS styles
         */
        HtmlSanitizer.prototype.exec = function (html, convertCssOnly, currentStyles) {
            var parser = new DOMParser();
            var doc = parser.parseFromString(html || '', 'text/html');
            if (doc && doc.body && doc.body.firstChild) {
                this.convertGlobalCssToInlineCss(doc);
                if (!convertCssOnly) {
                    this.sanitize(doc.body, currentStyles);
                }
            }
            return (doc && doc.body && doc.body.innerHTML) || '';
        };
        /**
         * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules
         * @param rootNode Root node to sanitize
         * @param currentStyles Current CSS styles. Inheritable styles in the given node which has
         * the same value with current styles will be ignored.
         */
        HtmlSanitizer.prototype.sanitize = function (rootNode, currentStyles) {
            if (!rootNode) {
                return '';
            }
            currentStyles = (0, cloneObject_1.cloneObject)(currentStyles, (0, getInheritableStyles_1.default)(null));
            this.processNode(rootNode, currentStyles, {});
        };
        /**
         * Convert global CSS into inline CSS
         * @param rootNode The HTML Document
         */
        HtmlSanitizer.prototype.convertGlobalCssToInlineCss = function (rootNode) {
            var styleNodes = (0, toArray_1$1.default)(rootNode.querySelectorAll('style'));
            var styleSheets = this.additionalGlobalStyleNodes
                .reverse()
                .map(function (node) { return node.sheet; })
                .concat(styleNodes.map(function (node) { return node.sheet; }).reverse())
                .filter(function (sheet) { return sheet; });
            for (var _i = 0, styleSheets_1 = styleSheets; _i < styleSheets_1.length; _i++) {
                var styleSheet = styleSheets_1[_i];
                var _loop_1 = function (j) {
                    // Skip any none-style rule, i.e. @page
                    var styleRule = styleSheet.cssRules[j];
                    var text = styleRule && styleRule.style ? styleRule.style.cssText : null;
                    if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {
                        return "continue";
                    }
                    // Make sure the selector is not empty
                    for (var _a = 0, _b = styleRule.selectorText.split(','); _a < _b.length; _a++) {
                        var selector = _b[_a];
                        if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {
                            continue;
                        }
                        var nodes = (0, toArray_1$1.default)(rootNode.querySelectorAll(selector));
                        // Always put existing styles after so that they have higher priority
                        // Which means if both global style and inline style apply to the same element,
                        // inline style will have higher priority
                        nodes.forEach(function (node) {
                            return node.setAttribute('style', text + (node.getAttribute('style') || ''));
                        });
                    }
                };
                for (var j = styleSheet.cssRules.length - 1; j >= 0; j--) {
                    _loop_1(j);
                }
            }
            styleNodes.forEach(function (node) {
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
            });
        };
        HtmlSanitizer.prototype.processNode = function (node, currentStyle, context) {
            var _a;
            var nodeType = node.nodeType;
            var isElement = nodeType == 1 /* Element */;
            var isText = nodeType == 3 /* Text */;
            var isFragment = nodeType == 11 /* DocumentFragment */;
            var isComment = nodeType == 8 /* Comment */;
            var shouldKeep = false;
            if (isElement) {
                var tag = (0, getTagOfNode_1$2.default)(node);
                var callback = this.elementCallbacks[tag];
                var replacement = this.tagReplacements[tag.toLowerCase()];
                if (replacement === undefined) {
                    replacement = this.unknownTagReplacement;
                }
                if (callback) {
                    shouldKeep = callback(node, context);
                }
                else if (tag.indexOf(':') > 0) {
                    shouldKeep = true;
                }
                else if (tag == replacement || replacement == '*') {
                    shouldKeep = true;
                }
                else if (replacement && /^[a-zA-Z][\w\-]*$/.test(replacement)) {
                    node = (0, changeElementTag_1$1.default)(node, replacement);
                    shouldKeep = true;
                }
            }
            else if (isText) {
                var whiteSpace = currentStyle['white-space'];
                shouldKeep =
                    whiteSpace == 'pre' ||
                        whiteSpace == 'pre-line' ||
                        whiteSpace == 'pre-wrap' ||
                        !/^[\r\n]*$/g.test(node.nodeValue || '');
            }
            else if (isFragment) {
                shouldKeep = true;
            }
            else if (isComment) {
                shouldKeep = this.preserveHtmlComments;
            }
            else {
                shouldKeep = false;
            }
            if (!shouldKeep) {
                (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
            }
            else if (isText &&
                (currentStyle['white-space'] == 'pre' || currentStyle['white-space'] == 'pre-wrap')) {
                node.nodeValue = (node.nodeValue || '')
                    .replace(/^ /gm, '\u00A0')
                    .replace(/ {2}/g, ' \u00A0');
            }
            else if (isElement || isFragment) {
                var thisStyle = (0, cloneObject_1.cloneObject)(currentStyle);
                var element = node;
                if (isElement) {
                    this.processAttributes(element, context);
                    this.preprocessCss(element, thisStyle);
                    this.processCss(element, thisStyle, context);
                }
                var child = element.firstChild;
                var next = void 0;
                for (; child; child = next) {
                    next = child.nextSibling;
                    this.processNode(child, thisStyle, context);
                }
            }
        };
        HtmlSanitizer.prototype.preprocessCss = function (element, thisStyle) {
            var predefinedStyles = (0, getPredefinedCssForElement_1.default)(element, this.additionalPredefinedCssForElement);
            if (predefinedStyles) {
                (0, getObjectKeys_1.default)(predefinedStyles).forEach(function (name) {
                    thisStyle[name] = predefinedStyles[name];
                });
            }
        };
        HtmlSanitizer.prototype.processCss = function (element, thisStyle, context) {
            var _this = this;
            var styles = (0, getStyles_1$1.default)(element);
            (0, getObjectKeys_1.default)(styles).forEach(function (name) {
                var value = styles[name];
                var callback = _this.styleCallbacks[name];
                var isInheritable = thisStyle[name] != undefined;
                var keep = true;
                if (keep && !!callback) {
                    keep = callback(value, element, thisStyle, context);
                }
                if (keep && (0, processCssVariable_1.isCssVariable)(value)) {
                    value = (0, processCssVariable_1.processCssVariable)(value);
                    keep = !!value;
                }
                keep =
                    keep &&
                        value != 'inherit' &&
                        value.indexOf('expression') < 0 &&
                        name.substr(0, 1) != '-' &&
                        _this.defaultStyleValues[name] != value &&
                        ((isInheritable && value != thisStyle[name]) ||
                            (!isInheritable && value != 'initial' && value != 'normal'));
                if (keep && isInheritable) {
                    thisStyle[name] = value;
                }
                if (keep) {
                    styles[name] = value;
                }
                else {
                    delete styles[name];
                }
            });
            (0, setStyles_1$1.default)(element, styles);
        };
        HtmlSanitizer.prototype.processAttributes = function (element, context) {
            for (var i = element.attributes.length - 1; i >= 0; i--) {
                var attribute = element.attributes[i];
                var name_1 = attribute.name.toLowerCase().trim();
                var value = attribute.value;
                var callback = this.attributeCallbacks[name_1];
                var newValue = callback
                    ? callback(value, element, context)
                    : this.allowedAttributes.indexOf(name_1) >= 0 || name_1.indexOf('data-') == 0
                        ? value
                        : null;
                if (name_1 == 'class' && this.allowedCssClassesRegex) {
                    newValue = this.processCssClass(value, newValue);
                }
                if (newValue === null ||
                    newValue === undefined ||
                    newValue.match(/s\n*c\n*r\n*i\n*p\n*t\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix
                ) {
                    element.removeAttribute(name_1);
                }
                else {
                    attribute.value = newValue;
                }
            }
        };
        HtmlSanitizer.prototype.processCssClass = function (originalValue, calculatedValue) {
            var _this = this;
            var originalClasses = originalValue ? originalValue.split(' ') : [];
            var calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];
            originalClasses.forEach(function (className) {
                var _a;
                if (((_a = _this.allowedCssClassesRegex) === null || _a === void 0 ? void 0 : _a.test(className)) &&
                    calculatedClasses.indexOf(className) < 0) {
                    calculatedClasses.push(className);
                }
            });
            return (calculatedClasses === null || calculatedClasses === void 0 ? void 0 : calculatedClasses.length) > 0 ? calculatedClasses.join(' ') : null;
        };
        return HtmlSanitizer;
    }());
    HtmlSanitizer$1.default = HtmlSanitizer;

    var createDefaultHtmlSanitizerOptions$1 = {};

    Object.defineProperty(createDefaultHtmlSanitizerOptions$1, "__esModule", { value: true });
    /**
     * Create default value of HtmlSanitizerOptions with every property set
     */
    function createDefaultHtmlSanitizerOptions() {
        return {
            elementCallbacks: {},
            attributeCallbacks: {},
            cssStyleCallbacks: {},
            additionalTagReplacements: {},
            additionalAllowedAttributes: [],
            additionalAllowedCssClasses: [],
            additionalDefaultStyleValues: {},
            additionalGlobalStyleNodes: [],
            additionalPredefinedCssForElement: {},
            preserveHtmlComments: false,
            unknownTagReplacement: null,
        };
    }
    createDefaultHtmlSanitizerOptions$1.default = createDefaultHtmlSanitizerOptions;

    var chainSanitizerCallback$1 = {};

    Object.defineProperty(chainSanitizerCallback$1, "__esModule", { value: true });
    /**
     * Chain all callback for an attribute together
     * @param map The source callback map
     * @param name Name of the property to chain
     * @param newCallback A new callback to process the given name on the given map.
     * If the same property got multiple callbacks, the final return value will be the return
     * value of the latest callback
     */
    function chainSanitizerCallback(map, name, newCallback) {
        if (!map[name]) {
            map[name] = newCallback;
        }
        else {
            var originalCallback_1 = map[name];
            map[name] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                originalCallback_1.apply(void 0, args);
                return newCallback.apply(void 0, args);
            };
        }
    }
    chainSanitizerCallback$1.default = chainSanitizerCallback;

    var commitEntity$1 = {};

    Object.defineProperty(commitEntity$1, "__esModule", { value: true });
    var CONTENT_EDITABLE = 'contenteditable';
    /**
     * Commit information of an entity (type, isReadonly, id) into the wrapper node as CSS Classes
     * @param wrapper The entity wrapper element
     * @param type Entity type
     * @param isReadonly Whether this is a readonly entity
     * @param id Optional Id of the entity
     */
    function commitEntity(wrapper, type, isReadonly, id) {
        if (wrapper) {
            wrapper.className = "_Entity" /* ENTITY_INFO_NAME */ + " " + "_EType_" /* ENTITY_TYPE_PREFIX */ + type + " " + (id ? "" + "_EId_" /* ENTITY_ID_PREFIX */ + id + " " : '') + "_EReadonly_" /* ENTITY_READONLY_PREFIX */ + (isReadonly ? '1' : '0');
            if (isReadonly) {
                wrapper.contentEditable = 'false';
            }
            else if (wrapper.getAttribute(CONTENT_EDITABLE)) {
                wrapper.removeAttribute(CONTENT_EDITABLE);
            }
        }
    }
    commitEntity$1.default = commitEntity;

    var getEntityFromElement$1 = {};

    Object.defineProperty(getEntityFromElement$1, "__esModule", { value: true });
    /**
     * Get Entity object from an entity root element
     * @param element The entity root element. If this element is not an entity root element,
     * it will return null
     */
    function getEntityFromElement(element) {
        var _a;
        var isEntity = false;
        var type = '';
        var id = '';
        var isReadonly = false;
        (_a = element === null || element === void 0 ? void 0 : element.className) === null || _a === void 0 ? void 0 : _a.split(' ').forEach(function (name) {
            if (name == "_Entity" /* ENTITY_INFO_NAME */) {
                isEntity = true;
            }
            else if (name.indexOf("_EType_" /* ENTITY_TYPE_PREFIX */) == 0) {
                type = name.substr("_EType_" /* ENTITY_TYPE_PREFIX */.length);
            }
            else if (name.indexOf("_EId_" /* ENTITY_ID_PREFIX */) == 0) {
                id = name.substr("_EId_" /* ENTITY_ID_PREFIX */.length);
            }
            else if (name.indexOf("_EReadonly_" /* ENTITY_READONLY_PREFIX */) == 0) {
                isReadonly = name.substr("_EReadonly_" /* ENTITY_READONLY_PREFIX */.length) == '1';
            }
        });
        return isEntity
            ? {
                wrapper: element,
                id: id,
                type: type,
                isReadonly: isReadonly,
            }
            : null;
    }
    getEntityFromElement$1.default = getEntityFromElement;

    var getEntitySelector$1 = {};

    Object.defineProperty(getEntitySelector$1, "__esModule", { value: true });
    /**
     * Get a selector string for specified entity type and id
     * @param type (Optional) Type of entity
     * @param id (Optional) Id of entity
     */
    function getEntitySelector(type, id) {
        var typeSelector = type ? "." + "_EType_" /* ENTITY_TYPE_PREFIX */ + type : '';
        var idSelector = id ? "." + "_EId_" /* ENTITY_ID_PREFIX */ + id : '';
        return '.' + "_Entity" /* ENTITY_INFO_NAME */ + typeSelector + idSelector;
    }
    getEntitySelector$1.default = getEntitySelector;

    var entityPlaceholderUtils = {};

    Object.defineProperty(entityPlaceholderUtils, "__esModule", { value: true });
    entityPlaceholderUtils.restoreContentWithEntityPlaceholder = entityPlaceholderUtils.moveContentWithEntityPlaceholders = entityPlaceholderUtils.createEntityPlaceholder = void 0;
    var getEntityFromElement_1 = getEntityFromElement$1;
    var getEntitySelector_1 = getEntitySelector$1;
    var getTagOfNode_1$1 = getTagOfNode$1;
    var safeInstanceOf_1$1 = safeInstanceOf$1;
    var EntityPlaceHolderTagName = 'ENTITY-PLACEHOLDER';
    /**
     * Create a placeholder comment node for entity
     * @param entity The entity to create placeholder from
     * @returns A placeholder comment node as
     */
    function createEntityPlaceholder(entity) {
        var placeholder = entity.wrapper.ownerDocument.createElement(EntityPlaceHolderTagName);
        placeholder.id = entity.id;
        return placeholder;
    }
    entityPlaceholderUtils.createEntityPlaceholder = createEntityPlaceholder;
    /**
     * Move content from a container into a new Document fragment, and try keep entities to be reusable by creating placeholder
     * for them in the document fragment.
     * If an entity is directly under root container, the whole entity can be reused and no need to move it at all.
     * If an entity is not directly under root container, it is still reusable, but it may need some movement.
     * In any case, entities will be replaced with a placeholder in the target document fragment.
     * We will use an entity map (the "entities" parameter) to save the map from entity id to its wrapper element.
     * @param root The root element
     * @param entities A map from entity id to entity wrapper element
     * @returns A new document fragment contains all the content and entity placeholders
     */
    function moveContentWithEntityPlaceholders(root, entities) {
        var entitySelector = (0, getEntitySelector_1.default)();
        var fragment = root.ownerDocument.createDocumentFragment();
        var next = null;
        var _loop_1 = function (child) {
            var entity;
            var nodeToAppend = child;
            next = child.nextSibling;
            if ((0, safeInstanceOf_1$1.default)(child, 'HTMLElement')) {
                if ((entity = (0, getEntityFromElement_1.default)(child))) {
                    nodeToAppend = getPlaceholder(entity, entities);
                }
                else {
                    child.querySelectorAll(entitySelector).forEach(function (wrapper) {
                        var _a;
                        if ((entity = (0, getEntityFromElement_1.default)(wrapper))) {
                            var placeholder = getPlaceholder(entity, entities);
                            (_a = wrapper.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(placeholder, wrapper);
                        }
                    });
                }
            }
            fragment.appendChild(nodeToAppend);
        };
        for (var child = root.firstChild; child; child = next) {
            _loop_1(child);
        }
        fragment.normalize();
        return fragment;
    }
    entityPlaceholderUtils.moveContentWithEntityPlaceholders = moveContentWithEntityPlaceholders;
    /**
     * Restore HTML content from a document fragment that may contain entity placeholders.
     * @param source Source document fragment that contains HTML content and entity placeholders
     * @param target Target container, usually to be editor root container
     * @param entities A map from entity id to entity wrapper, used for reusing existing DOM structure for entity
     * @param insertClonedNode When pass true, merge with a cloned copy of the nodes from source fragment rather than the nodes themselves @default false
     */
    function restoreContentWithEntityPlaceholder(source, target, entities, insertClonedNode) {
        var anchor = target.firstChild;
        entities = entities || {};
        var _loop_2 = function (current) {
            var wrapper = null;
            var next = current.nextSibling;
            var id = tryGetIdFromEntityPlaceholder(current);
            if (id && (wrapper = entities[current.id])) {
                anchor = removeUntil(anchor, wrapper);
                if (anchor) {
                    anchor = anchor.nextSibling;
                }
                else {
                    target.appendChild(wrapper);
                }
            }
            else {
                var nodeToInsert = insertClonedNode ? current.cloneNode(true /*deep*/) : current;
                target.insertBefore(nodeToInsert, anchor);
                if ((0, safeInstanceOf_1$1.default)(nodeToInsert, 'HTMLElement')) {
                    nodeToInsert.querySelectorAll(EntityPlaceHolderTagName).forEach(function (placeholder) {
                        var _a;
                        wrapper = entities[placeholder.id];
                        if (wrapper) {
                            (_a = placeholder.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(wrapper, placeholder);
                        }
                    });
                }
            }
            current = next;
            out_current_1 = current;
        };
        var out_current_1;
        for (var current = source.firstChild; current;) {
            _loop_2(current);
            current = out_current_1;
        }
        removeUntil(anchor);
    }
    entityPlaceholderUtils.restoreContentWithEntityPlaceholder = restoreContentWithEntityPlaceholder;
    function removeUntil(anchor, nodeToStop) {
        var _a;
        while (anchor && (!nodeToStop || anchor != nodeToStop)) {
            var nodeToRemove = anchor;
            anchor = anchor.nextSibling;
            (_a = nodeToRemove.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(nodeToRemove);
        }
        return anchor;
    }
    function tryGetIdFromEntityPlaceholder(node) {
        return (0, getTagOfNode_1$1.default)(node) == EntityPlaceHolderTagName ? node.id : null;
    }
    function getPlaceholder(entity, entities) {
        var placeholder = createEntityPlaceholder(entity);
        entities[entity.id] = entity.wrapper;
        return placeholder;
    }

    var cacheGetEventData$1 = {};

    Object.defineProperty(cacheGetEventData$1, "__esModule", { value: true });
    /**
     * Gets the cached event data by cache key from event object if there is already one.
     * Otherwise, call getter function to create one, and cache it.
     * @param event The event object
     * @param key Cache key string, need to be unique
     * @param getter Getter function to get the object when it is not in cache yet
     */
    function cacheGetEventData(event, key, getter) {
        var result = event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)
            ? event.eventDataCache[key]
            : getter();
        if (event) {
            event.eventDataCache = event.eventDataCache || {};
            event.eventDataCache[key] = result;
        }
        return result;
    }
    cacheGetEventData$1.default = cacheGetEventData;

    var clearEventDataCache$1 = {};

    Object.defineProperty(clearEventDataCache$1, "__esModule", { value: true });
    /**
     * Clear a cached object by its key from an event object
     * @param event The event object
     * @param key The cache key
     */
    function clearEventDataCache(event, key) {
        if (event && event.eventDataCache) {
            if (key && event.eventDataCache.hasOwnProperty(key)) {
                delete event.eventDataCache[key];
            }
            else if (!key) {
                event.eventDataCache = {};
            }
        }
    }
    clearEventDataCache$1.default = clearEventDataCache;

    var isModifierKey$1 = {};

    Object.defineProperty(isModifierKey$1, "__esModule", { value: true });
    var CTRL_CHAR_CODE = 'Control';
    var ALT_CHAR_CODE = 'Alt';
    var META_CHAR_CODE = 'Meta';
    /**
     * Returns true when the event was fired from a modifier key, otherwise false
     * @param event The keyboard event object
     */
    function isModifierKey(event) {
        var isCtrlKey = event.ctrlKey || event.key === CTRL_CHAR_CODE;
        var isAltKey = event.altKey || event.key === ALT_CHAR_CODE;
        var isMetaKey = event.metaKey || event.key === META_CHAR_CODE;
        return isCtrlKey || isAltKey || isMetaKey;
    }
    isModifierKey$1.default = isModifierKey;

    var isCharacterValue$1 = {};

    Object.defineProperty(isCharacterValue$1, "__esModule", { value: true });
    var isModifierKey_1 = isModifierKey$1;
    /**
     * Returns true when the event was fired from a key that produces a character value, otherwise false
     * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),
     * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.
     * So if we missed some case here it is still acceptable.
     * @param event The keyboard event object
     */
    function isCharacterValue(event) {
        return !(0, isModifierKey_1.default)(event) && !!event.key && event.key.length == 1;
    }
    isCharacterValue$1.default = isCharacterValue;

    var isCtrlOrMetaPressed$1 = {};

    Object.defineProperty(isCtrlOrMetaPressed$1, "__esModule", { value: true });
    var Browser_1 = Browser;
    var isCtrlOrMetaPressedImpl = Browser_1.Browser.isMac
        ? function (event) { return event.metaKey; }
        : function (event) { return event.ctrlKey; };
    /**
     * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event
     * @param event A Keyboard event or Mouse event object
     * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac
     */
    function isCtrlOrMetaPressed(event) {
        return isCtrlOrMetaPressedImpl(event);
    }
    isCtrlOrMetaPressed$1.default = isCtrlOrMetaPressed;

    var removeImportantStyleRule$1 = {};

    Object.defineProperty(removeImportantStyleRule$1, "__esModule", { value: true });
    var getStyles_1 = getStyles$1;
    var setStyles_1 = setStyles$1;
    /**
     * Removes the css important rule from some css properties
     * @param element The HTMLElement
     * @param styleProperties The css properties that important must be removed. Ex: ['background-color', 'background']
     */
    function removeImportantStyleRule(element, styleProperties) {
        var styles = (0, getStyles_1.default)(element);
        var modifiedStyles = 0;
        styleProperties.forEach(function (style) {
            var _a;
            if (((_a = styles[style]) === null || _a === void 0 ? void 0 : _a.indexOf('!important')) > -1) {
                var index = styles[style].indexOf('!');
                styles[style] = styles[style].substring(0, index);
                modifiedStyles++;
            }
        });
        if (modifiedStyles > 0) {
            (0, setStyles_1.default)(element, styles);
        }
    }
    removeImportantStyleRule$1.default = removeImportantStyleRule;

    var setGlobalCssStyles$1 = {};

    /**
     * Add global css styles
     * @param doc The document object
     * @param cssRule The css rule that must added to the selection
     * @param editorId Te id of the editor
     * @param styleId the ID of the style tag
     */
    Object.defineProperty(setGlobalCssStyles$1, "__esModule", { value: true });
    function setGlobalCssStyles(doc, cssRule, styleId) {
        var _a;
        var styleTag = doc.getElementById(styleId);
        if (!styleTag) {
            styleTag = doc.createElement('style');
            styleTag.id = styleId;
            doc.head.appendChild(styleTag);
        }
        (_a = styleTag.sheet) === null || _a === void 0 ? void 0 : _a.insertRule(cssRule);
    }
    setGlobalCssStyles$1.default = setGlobalCssStyles;

    var removeGlobalCssStyle$1 = {};

    /**
     * Remove a css rule style from a style sheet
     * @param doc The document object
     * @param styleId the ID of the style tag
     */
    Object.defineProperty(removeGlobalCssStyle$1, "__esModule", { value: true });
    function removeGlobalCssStyle(doc, styleId) {
        var _a;
        var styleTag = doc.getElementById(styleId);
        if (styleTag) {
            (_a = styleTag.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(styleTag);
        }
    }
    removeGlobalCssStyle$1.default = removeGlobalCssStyle;

    var adjustInsertPosition = {};

    var pasteTable$1 = {};

    var cloneCellStyles$1 = {};

    Object.defineProperty(cloneCellStyles$1, "__esModule", { value: true });
    var tableCellInfo_1 = tableCellInfo;
    /**
     * Clone css styles from a element an set to another.
     * @param cell cell that will receive the styles
     * @param styledCell cell where the styles will be clone
     */
    function cloneCellStyles(cell, styledCell) {
        var styles = styledCell.getAttribute('style');
        if (styles) {
            cell.setAttribute('style', styles);
            (0, tableCellInfo_1.saveTableCellMetadata)(cell, {
                bgColorOverride: true,
            });
        }
    }
    cloneCellStyles$1.default = cloneCellStyles;

    Object.defineProperty(pasteTable$1, "__esModule", { value: true });
    var cloneCellStyles_1 = cloneCellStyles$1;
    var moveChildNodes_1$1 = moveChildNodes$1;
    var VTable_1 = VTable$1;
    /**
     *
     * Pastes a table inside another, modifying the original to create a merged one
     * @param currentTd The cell where the cursor is in the table to paste into
     * @param rootNodeToInsert A Node containing the table to be inserted
     * @param position The position to paste the table
     * @param range The selected range of the table
     *
     * Position and range are here for when table selection allows to move pivot point
     */
    function pasteTable(currentTd, rootNodeToInsert, position, range) {
        var _a, _b, _c, _d;
        // This is the table on the clipboard
        var newTable = new VTable_1.default(rootNodeToInsert);
        // This table is already on the editor
        var currentTable = new VTable_1.default(currentTd);
        // Which cell in the currentTable is the cursor placed
        var cursorRow = currentTable.row;
        var cursorCol = currentTable.col;
        // Total rows and columns of the final table
        var rows = (_b = cursorRow + ((_a = newTable.cells) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0;
        var columns = (_d = cursorCol + ((_c = newTable.cells) === null || _c === void 0 ? void 0 : _c[0].length)) !== null && _d !== void 0 ? _d : 0;
        // Add new rows
        currentTable.row = currentTable.cells.length - 1;
        while (currentTable.cells.length < rows) {
            currentTable.edit(1 /* InsertBelow */);
        }
        // Add new columns
        currentTable.col = currentTable.cells[0].length - 1;
        while (currentTable.cells[0].length < columns) {
            currentTable.edit(3 /* InsertRight */);
        }
        // Create final table
        for (var i = cursorRow; i < rows; i++) {
            for (var j = cursorCol; j < columns; j++) {
                var cell = currentTable.getCell(i, j);
                var newCell = newTable.getTd(i - cursorRow, j - cursorCol);
                if (cell.td && newCell) {
                    (0, moveChildNodes_1$1.default)(cell.td, newCell);
                    (0, cloneCellStyles_1.default)(cell.td, newCell);
                }
                else {
                    cell.td = document.createElement('td');
                }
            }
        }
        currentTable.writeBack();
    }
    pasteTable$1.default = pasteTable;

    Object.defineProperty(adjustInsertPosition, "__esModule", { value: true });
    var changeElementTag_1 = changeElementTag$1;
    var contains_1 = contains$1;
    var ContentTraverser_1$1 = ContentTraverser$1;
    var createRange_1 = createRange$1;
    var findClosestElementAncestor_1 = findClosestElementAncestor$1;
    var getBlockElementAtNode_1 = getBlockElementAtNode$1;
    var getTagOfNode_1 = getTagOfNode$1;
    var isNodeEmpty_1 = isNodeEmpty$1;
    var isPositionAtBeginningOf_1 = isPositionAtBeginningOf$1;
    var isVoidHtmlElement_1 = isVoidHtmlElement$1;
    var LinkInlineElement_1 = LinkInlineElement$1;
    var moveChildNodes_1 = moveChildNodes$1;
    var pasteTable_1 = pasteTable$1;
    var Position_1$1 = Position$1;
    var PositionContentSearcher_1 = PositionContentSearcher$1;
    var queryElements_1$1 = queryElements$1;
    var splitTextNode_1$1 = splitTextNode$1;
    var toArray_1 = toArray$1;
    var unwrap_1 = unwrap$1;
    var wrap_1 = wrap$1;
    var splitParentNode_1 = splitParentNode$1;
    var NOT_EDITABLE_SELECTOR = '[contenteditable=false]';
    var adjustSteps = [
        adjustInsertPositionForHyperLink,
        adjustInsertPositionForStructuredNode,
        adjustInsertPositionForParagraph,
        adjustInsertPositionForVoidElement,
        adjustInsertPositionForMoveCursorOutOfALink,
        adjustInsertPositionForNotEditableNode,
        adjustInsertPositionForTable,
    ];
    /**
     * Adjust position for A tag don't be nested inside another A tag.
     */
    function adjustInsertPositionForHyperLink(root, nodeToInsert, position, range) {
        var _a, _b;
        var blockElement = (0, getBlockElementAtNode_1.default)(root, position.node);
        if (blockElement) {
            // Find the first <A> tag within current block which covers current selection
            // If there are more than one nested, let's handle the first one only since that is not a common scenario.
            var anchor = (0, queryElements_1$1.default)(root, 'a[href]', null /*forEachCallback*/, 1 /* OnSelection */, (0, createRange_1.default)(position)).filter(function (a) { return blockElement.contains(a); })[0];
            // If this is about to insert node to an empty A tag, clear the A tag and reset position
            if (anchor && (0, isNodeEmpty_1.default)(anchor)) {
                position = new Position_1$1.default(anchor, -2 /* Before */);
                safeRemove(anchor);
                anchor = null;
            }
            // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag
            // otherwise we will have nested A tags which is a wrong HTML structure
            if (anchor &&
                ((_a = nodeToInsert) === null || _a === void 0 ? void 0 : _a.querySelector) &&
                ((_b = nodeToInsert) === null || _b === void 0 ? void 0 : _b.querySelector('a[href]'))) {
                var normalizedPosition = position.normalize();
                var parentNode = normalizedPosition.node.parentNode;
                var nextNode = normalizedPosition.node.nodeType == 3 /* Text */
                    ? (0, splitTextNode_1$1.default)(normalizedPosition.node, normalizedPosition.offset, false /*returnFirstPart*/)
                    : normalizedPosition.isAtEnd
                        ? normalizedPosition.node.nextSibling
                        : normalizedPosition.node;
                var splitter = root.ownerDocument.createTextNode('');
                parentNode.insertBefore(splitter, nextNode);
                while (splitter && (0, contains_1.default)(anchor, splitter)) {
                    splitter = (0, splitParentNode_1.splitBalancedNodeRange)(splitter);
                }
                if (splitter) {
                    position = new Position_1$1.default(splitter, -2 /* Before */);
                    safeRemove(splitter);
                }
            }
        }
        return position;
    }
    /**
     * Adjust position for a node don't be nested inside tags like BR, LI, TD.
     */
    function adjustInsertPositionForStructuredNode(root, nodeToInsert, position, range) {
        var rootNodeToInsert = nodeToInsert;
        var isFragment = false;
        if (rootNodeToInsert.nodeType == 11 /* DocumentFragment */) {
            isFragment = true;
            var rootNodes = (0, toArray_1.default)(rootNodeToInsert.childNodes).filter(function (n) { return (0, getTagOfNode_1.default)(n) != 'BR'; });
            rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;
        }
        var tag = (0, getTagOfNode_1.default)(rootNodeToInsert);
        var hasBrNextToRoot = tag && rootNodeToInsert && (0, getTagOfNode_1.default)(rootNodeToInsert.nextSibling) == 'BR';
        var listItem = (0, findClosestElementAncestor_1.default)(position.node, root, 'LI');
        var listNode = listItem && (0, findClosestElementAncestor_1.default)(listItem, root, 'OL,UL');
        var tdNode = (0, findClosestElementAncestor_1.default)(position.node, root, 'TD,TH');
        if (tag == 'LI') {
            tag = listNode ? (0, getTagOfNode_1.default)(listNode) : 'UL';
            rootNodeToInsert = (0, wrap_1.default)(rootNodeToInsert, tag);
        }
        if ((tag == 'OL' || tag == 'UL') &&
            rootNodeToInsert &&
            (0, getTagOfNode_1.default)(rootNodeToInsert.firstChild) == 'LI') {
            var shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;
            if (hasBrNextToRoot && rootNodeToInsert.parentNode) {
                safeRemove(rootNodeToInsert.nextSibling);
            }
            if (shouldInsertListAsText) {
                (0, unwrap_1.default)(rootNodeToInsert.firstChild);
                (0, unwrap_1.default)(rootNodeToInsert);
            }
            else if ((0, getTagOfNode_1.default)(listNode) == tag) {
                (0, unwrap_1.default)(rootNodeToInsert);
                position = new Position_1$1.default(listItem, (0, isPositionAtBeginningOf_1.default)(position, listItem)
                    ? -2 /* Before */
                    : -3 /* After */);
            }
        }
        if (isFragment && tag == 'TABLE' && tdNode) {
            (0, pasteTable_1.default)(tdNode, rootNodeToInsert, position, range);
            position = new Position_1$1.default(rootNodeToInsert, 0);
            (0, moveChildNodes_1.default)(nodeToInsert);
        }
        return position;
    }
    /**
     * Change P tag to DIV, when a new node when insert node.
     */
    function adjustInsertPositionForParagraph(root, nodeToInsert, position, range) {
        if ((0, getTagOfNode_1.default)(position.node) == 'P') {
            // Insert into a P tag may cause issues when the inserted content contains any block element.
            // Change P tag to DIV to make sure it works well
            var pos = position.normalize();
            var div = (0, changeElementTag_1.default)(position.node, 'div');
            if (pos.node != div) {
                position = pos;
            }
        }
        return position;
    }
    /**
     * Adjust position for a node that can have children.
     */
    function adjustInsertPositionForVoidElement(root, nodeToInsert, position, range) {
        if ((0, isVoidHtmlElement_1.default)(position.node)) {
            position = new Position_1$1.default(position.node, position.isAtEnd ? -3 /* After */ : -2 /* Before */);
        }
        return position;
    }
    /**
     * Adjust the position cursor out of link when a new node is inserted.
     */
    function adjustInsertPositionForMoveCursorOutOfALink(root, nodeToInsert, position, range) {
        if (range && range.collapsed) {
            var searcher = new PositionContentSearcher_1.default(root, Position_1$1.default.getStart(range));
            var inlineElementBefore = searcher.getInlineElementBefore();
            var inlineElementAfter = searcher.getInlineElementAfter();
            if (inlineElementBefore instanceof LinkInlineElement_1.default) {
                position = new Position_1$1.default(inlineElementBefore.getContainerNode(), -3 /* After */);
            }
            else if (inlineElementAfter instanceof LinkInlineElement_1.default) {
                position = new Position_1$1.default(inlineElementAfter.getContainerNode(), -2 /* Before */);
            }
        }
        return position;
    }
    /**
     * Adjust the position cursor out of a not contenteditable element.
     */
    function adjustInsertPositionForNotEditableNode(root, nodeToInsert, position, range) {
        var _a;
        if (!((_a = position.element) === null || _a === void 0 ? void 0 : _a.isContentEditable)) {
            var nonEditableElement = void 0;
            var lastNonEditableElement = (0, findClosestElementAncestor_1.default)(position.node, root, NOT_EDITABLE_SELECTOR);
            while (lastNonEditableElement) {
                nonEditableElement = lastNonEditableElement;
                lastNonEditableElement = (nonEditableElement === null || nonEditableElement === void 0 ? void 0 : nonEditableElement.parentElement)
                    ? (0, findClosestElementAncestor_1.default)(nonEditableElement.parentElement, root, NOT_EDITABLE_SELECTOR)
                    : null;
            }
            if (nonEditableElement) {
                position = new Position_1$1.default(nonEditableElement, -3 /* After */);
                return adjustInsertPositionForNotEditableNode(root, nodeToInsert, position);
            }
        }
        return position;
    }
    /**
     * Adjust the position of a table to be one line after another table.
     */
    function adjustInsertPositionForTable(root, nodeToInsert, position, range) {
        if ((nodeToInsert.childNodes.length == 1 &&
            (0, getTagOfNode_1.default)(nodeToInsert.childNodes[0]) == 'TABLE') ||
            (0, getTagOfNode_1.default)(nodeToInsert) == 'TABLE') {
            var element = position.element;
            var posBefore = new Position_1$1.default(element, -2 /* Before */);
            var rangeToTraverse = (0, createRange_1.default)(posBefore, position);
            var contentTraverser = ContentTraverser_1$1.default.createSelectionTraverser(root, rangeToTraverse);
            var blockElement = contentTraverser && contentTraverser.currentBlockElement;
            if (blockElement) {
                var nextBlockElement = blockElement;
                while (!nextBlockElement) {
                    nextBlockElement = contentTraverser.getNextBlockElement();
                    if (nextBlockElement) {
                        blockElement = nextBlockElement;
                    }
                }
                var prevElement = blockElement === null || blockElement === void 0 ? void 0 : blockElement.getEndNode();
                if (prevElement && (0, findClosestElementAncestor_1.default)(prevElement, root, 'TABLE')) {
                    var tempRange = (0, createRange_1.default)(position);
                    tempRange.collapse(false /* toStart */);
                    var br = root.ownerDocument.createElement('br');
                    tempRange.insertNode(br);
                    tempRange = (0, createRange_1.default)(br);
                    position = Position_1$1.default.getEnd(tempRange);
                }
            }
        }
        return position;
    }
    /**
     *
     * @param root the contentDiv of the ditor
     * @param nodeToInsert the node to be inserted
     * @param position the position of the node to be inserted
     * @param range the range current or cached range of the editor
     * @returns the adjusted position of the inserted node
     */
    function adjustInsertPositionBySteps(root, nodeToInsert, position, range) {
        adjustSteps.forEach(function (handler) {
            position = handler(root, nodeToInsert, position, range);
        });
        return position;
    }
    adjustInsertPosition.default = adjustInsertPositionBySteps;
    function safeRemove(node) {
        var _a;
        (_a = node === null || node === void 0 ? void 0 : node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
    }

    var deleteSelectedContent$1 = {};

    Object.defineProperty(deleteSelectedContent$1, "__esModule", { value: true });
    var arrayPush_1 = arrayPush$1;
    var collapseNodesInRegion_1 = collapseNodesInRegion$1;
    var getRegionsFromRange_1 = getRegionsFromRange$1;
    var getSelectionRangeInRegion_1 = getSelectionRangeInRegion$1;
    var mergeBlocksInRegion_1 = mergeBlocksInRegion$1;
    var Position_1 = Position$1;
    var queryElements_1 = queryElements$1;
    var safeInstanceOf_1 = safeInstanceOf$1;
    var splitTextNode_1 = splitTextNode$1;
    /**
     * Delete selected content, and return the new position to select
     * @param core The EditorCore object.
     * @param range The range to delete
     */
    function deleteSelectedContent(root, range) {
        var nodeBefore = null;
        // 1. TABLE and TR node in selected should be deleted. It is possible we don't detect them from step 2
        // since table cells will fall in to different regions
        var nodesToDelete = (0, queryElements_1.default)(root, 'table,tr', null /*callback*/, 2 /* InSelection */, range);
        // 2. Loop all selected regions, find out those nodes need to be deleted and merged.
        // We don't delete them directly here because delete node from one region may cause selection range
        // another region becomes invalid. So we delay the process of deletion.
        var regions = (0, getRegionsFromRange_1.default)(root, range, 0 /* Table */);
        var nodesPairToMerge = regions
            .map(function (region) {
            var regionRange = (0, getSelectionRangeInRegion_1.default)(region);
            if (!regionRange) {
                return null;
            }
            var startContainer = regionRange.startContainer, endContainer = regionRange.endContainer, startOffset = regionRange.startOffset, endOffset = regionRange.endOffset, commonAncestorContainer = regionRange.commonAncestorContainer;
            // Disallow merging of readonly elements
            if ((0, safeInstanceOf_1.default)(commonAncestorContainer, 'HTMLElement') &&
                !commonAncestorContainer.isContentEditable) {
                return null;
            }
            // Make sure there are node before and after the merging point.
            // This is required by mergeBlocksInRegion API.
            // This may create some empty text node as anchor
            var _a = ensureBeforeAndAfter(endContainer, endOffset, false /*isStart*/), beforeEnd = _a[0], afterEnd = _a[1];
            var _b = ensureBeforeAndAfter(startContainer, startOffset, true /*isStart*/), beforeStart = _b[0], afterStart = _b[1];
            nodeBefore = nodeBefore || beforeStart;
            // Find out all nodes to be deleted
            var nodes = (0, collapseNodesInRegion_1.default)(region, [afterStart, beforeEnd]);
            (0, arrayPush_1.default)(nodesToDelete, nodes);
            return { region: region, beforeStart: beforeStart, afterEnd: afterEnd };
        })
            .filter(function (x) { return !!x; });
        // 3. Delete all nodes that we found, whose parent is editable
        nodesToDelete.forEach(function (node) { var _a; return ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.isContentEditable) && node.parentElement.removeChild(node); });
        // 4. Merge lines for each region, so that after we don't see extra line breaks
        nodesPairToMerge.forEach(function (nodes) {
            if (nodes) {
                (0, mergeBlocksInRegion_1.default)(nodes.region, nodes.beforeStart, nodes.afterEnd);
            }
        });
        return nodeBefore && new Position_1.default(nodeBefore, -1 /* End */);
    }
    deleteSelectedContent$1.default = deleteSelectedContent;
    function ensureBeforeAndAfter(node, offset, isStart) {
        var _a, _b;
        if ((0, safeInstanceOf_1.default)(node, 'Text')) {
            var newNode = (0, splitTextNode_1.default)(node, offset, isStart);
            return isStart ? [newNode, node] : [node, newNode];
        }
        else {
            var nodeBefore = node.childNodes[offset - 1];
            var nodeAfter = node.childNodes[offset];
            // Condition 1: node child nodes
            // ("I" means cursor; "o" means a DOM node, "[ ]" means a parent node)
            // [ I ]
            // need to use parent node instead to convert to condition 2
            if (!nodeBefore && !nodeAfter) {
                if (isStart) {
                    nodeAfter = node;
                    nodeBefore = nodeAfter.previousSibling;
                }
                else {
                    nodeBefore = node;
                    nodeAfter = nodeBefore.nextSibling;
                }
            }
            // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)
            // [ o I ]  or [ I o]
            // need to add empty text node to convert to condition 3
            if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {
                var emptyNode = node.ownerDocument.createTextNode('');
                (_b = (_a = (nodeBefore || nodeAfter)) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(emptyNode, nodeAfter);
                if (nodeBefore) {
                    nodeAfter = emptyNode;
                }
                else {
                    nodeBefore = emptyNode;
                }
            }
            // Condition 3: Both nodeBefore and nodeAfter are not null
            // [o I o]
            // return the nodes
            return [nodeBefore, nodeAfter];
        }
    }

    var getTextContent$1 = {};

    Object.defineProperty(getTextContent$1, "__esModule", { value: true });
    var ContentTraverser_1 = ContentTraverser$1;
    /**
     * get block element's text content.
     * @param rootNode Root node that the get the textContent of.
     * @returns text content of given text content.
     */
    function getTextContent(rootNode) {
        var traverser = ContentTraverser_1.default.createBodyTraverser(rootNode);
        var block = traverser && traverser.currentBlockElement;
        var textContent = [];
        while (block) {
            textContent.push(block.getTextContent());
            block = traverser.getNextBlockElement();
        }
        return textContent.join('\n');
    }
    getTextContent$1.default = getTextContent;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchesSelector = exports.setColor = exports.getInnerHTML = exports.readFile = exports.safeInstanceOf = exports.normalizeRect = exports.splitTextNode = exports.getLastLeafNode = exports.getFirstLeafNode = exports.getPreviousLeafSibling = exports.getNextLeafSibling = exports.wrap = exports.unwrap = exports.splitBalancedNodeRange = exports.splitParentNode = exports.queryElements = exports.matchLink = exports.isVoidHtmlElement = exports.isNodeEmpty = exports.isBlockElement = exports.getTagOfNode = exports.PendableFormatCommandMap = exports.getPendableFormatState = exports.getComputedStyle = exports.getComputedStyles = exports.fromHtml = exports.findClosestElementAncestor = exports.contains = exports.collapseNodes = exports.changeElementTag = exports.applyFormat = exports.getBrowserInfo = exports.Browser = exports.extractClipboardItemsForIE = exports.extractClipboardItems = exports.extractClipboardEvent = exports.applyTextStyle = exports.PartialInlineElement = exports.NodeInlineElement = exports.LinkInlineElement = exports.ImageInlineElement = exports.getInlineElementAtNode = exports.getDelimiterFromElement = exports.addDelimiterBefore = exports.addDelimiterAfter = exports.addDelimiters = exports.PositionContentSearcher = exports.ContentTraverser = exports.getFirstLastBlockElement = exports.getBlockElementAtNode = void 0;
    exports.cacheGetEventData = exports.restoreContentWithEntityPlaceholder = exports.moveContentWithEntityPlaceholders = exports.createEntityPlaceholder = exports.getEntitySelector = exports.getEntityFromElement = exports.commitEntity = exports.chainSanitizerCallback = exports.createDefaultHtmlSanitizerOptions = exports.getInheritableStyles = exports.HtmlSanitizer = exports.canUndoAutoComplete = exports.createSnapshots = exports.moveCurrentSnapsnot = exports.moveCurrentSnapshot = exports.clearProceedingSnapshotsV2 = exports.clearProceedingSnapshots = exports.canMoveCurrentSnapshot = exports.addSnapshotV2 = exports.addSnapshot = exports.addRangeToSelection = exports.setHtmlWithMetadata = exports.setHtmlWithSelectionPath = exports.getHtmlWithSelectionPath = exports.getSelectionPath = exports.isPositionAtBeginningOf = exports.getPositionRect = exports.createRange = exports.Position = exports.mergeBlocksInRegion = exports.getSelectionRangeInRegion = exports.isNodeInRegion = exports.collapseNodesInRegion = exports.getSelectedBlockElementsInRegion = exports.getRegionsFromRange = exports.saveTableCellMetadata = exports.getTableFormatInfo = exports.setListItemStyle = exports.VListChain = exports.createVListFromRegion = exports.VListItem = exports.VList = exports.isWholeTableSelected = exports.VTable = exports.parseColor = exports.isNodeAfter = exports.getIntersectedRect = exports.moveChildNodes = exports.KnownCreateElementData = exports.createElement = void 0;
    exports.toArray = exports.getObjectKeys = exports.arrayPush = exports.removeMetadata = exports.setMetadata = exports.getMetadata = exports.createObjectDefinition = exports.createArrayDefinition = exports.createStringDefinition = exports.createBooleanDefinition = exports.createNumberDefinition = exports.validate = exports.getTextContent = exports.deleteSelectedContent = exports.adjustInsertPosition = exports.removeGlobalCssStyle = exports.setGlobalCssStyles = exports.removeImportantStyleRule = exports.setStyles = exports.getStyles = exports.isCtrlOrMetaPressed = exports.isCharacterValue = exports.isModifierKey = exports.clearEventDataCache = void 0;
    var getBlockElementAtNode_1 = getBlockElementAtNode$1;
    Object.defineProperty(exports, "getBlockElementAtNode", { enumerable: true, get: function () { return getBlockElementAtNode_1.default; } });
    var getFirstLastBlockElement_1 = getFirstLastBlockElement$1;
    Object.defineProperty(exports, "getFirstLastBlockElement", { enumerable: true, get: function () { return getFirstLastBlockElement_1.default; } });
    var ContentTraverser_1 = ContentTraverser$1;
    Object.defineProperty(exports, "ContentTraverser", { enumerable: true, get: function () { return ContentTraverser_1.default; } });
    var PositionContentSearcher_1 = PositionContentSearcher$1;
    Object.defineProperty(exports, "PositionContentSearcher", { enumerable: true, get: function () { return PositionContentSearcher_1.default; } });
    var addDelimiters_1 = addDelimiters$1;
    Object.defineProperty(exports, "addDelimiters", { enumerable: true, get: function () { return addDelimiters_1.default; } });
    Object.defineProperty(exports, "addDelimiterAfter", { enumerable: true, get: function () { return addDelimiters_1.addDelimiterAfter; } });
    Object.defineProperty(exports, "addDelimiterBefore", { enumerable: true, get: function () { return addDelimiters_1.addDelimiterBefore; } });
    var getDelimiterFromElement_1 = getDelimiterFromElement$1;
    Object.defineProperty(exports, "getDelimiterFromElement", { enumerable: true, get: function () { return getDelimiterFromElement_1.default; } });
    var getInlineElementAtNode_1 = getInlineElementAtNode$1;
    Object.defineProperty(exports, "getInlineElementAtNode", { enumerable: true, get: function () { return getInlineElementAtNode_1.default; } });
    var ImageInlineElement_1 = ImageInlineElement$1;
    Object.defineProperty(exports, "ImageInlineElement", { enumerable: true, get: function () { return ImageInlineElement_1.default; } });
    var LinkInlineElement_1 = LinkInlineElement$1;
    Object.defineProperty(exports, "LinkInlineElement", { enumerable: true, get: function () { return LinkInlineElement_1.default; } });
    var NodeInlineElement_1 = NodeInlineElement$1;
    Object.defineProperty(exports, "NodeInlineElement", { enumerable: true, get: function () { return NodeInlineElement_1.default; } });
    var PartialInlineElement_1 = PartialInlineElement$1;
    Object.defineProperty(exports, "PartialInlineElement", { enumerable: true, get: function () { return PartialInlineElement_1.default; } });
    var applyTextStyle_1 = applyTextStyle$1;
    Object.defineProperty(exports, "applyTextStyle", { enumerable: true, get: function () { return applyTextStyle_1.default; } });
    var extractClipboardEvent_1 = extractClipboardEvent$1;
    Object.defineProperty(exports, "extractClipboardEvent", { enumerable: true, get: function () { return extractClipboardEvent_1.default; } });
    var extractClipboardItems_1 = extractClipboardItems$1;
    Object.defineProperty(exports, "extractClipboardItems", { enumerable: true, get: function () { return extractClipboardItems_1.default; } });
    var extractClipboardItemsForIE_1 = extractClipboardItemsForIE$1;
    Object.defineProperty(exports, "extractClipboardItemsForIE", { enumerable: true, get: function () { return extractClipboardItemsForIE_1.default; } });
    var Browser_1 = Browser;
    Object.defineProperty(exports, "Browser", { enumerable: true, get: function () { return Browser_1.Browser; } });
    Object.defineProperty(exports, "getBrowserInfo", { enumerable: true, get: function () { return Browser_1.getBrowserInfo; } });
    var applyFormat_1 = applyFormat$1;
    Object.defineProperty(exports, "applyFormat", { enumerable: true, get: function () { return applyFormat_1.default; } });
    var changeElementTag_1 = changeElementTag$1;
    Object.defineProperty(exports, "changeElementTag", { enumerable: true, get: function () { return changeElementTag_1.default; } });
    var collapseNodes_1 = collapseNodes$1;
    Object.defineProperty(exports, "collapseNodes", { enumerable: true, get: function () { return collapseNodes_1.default; } });
    var contains_1 = contains$1;
    Object.defineProperty(exports, "contains", { enumerable: true, get: function () { return contains_1.default; } });
    var findClosestElementAncestor_1 = findClosestElementAncestor$1;
    Object.defineProperty(exports, "findClosestElementAncestor", { enumerable: true, get: function () { return findClosestElementAncestor_1.default; } });
    var fromHtml_1 = fromHtml$1;
    Object.defineProperty(exports, "fromHtml", { enumerable: true, get: function () { return fromHtml_1.default; } });
    var getComputedStyles_1 = getComputedStyles$1;
    Object.defineProperty(exports, "getComputedStyles", { enumerable: true, get: function () { return getComputedStyles_1.default; } });
    Object.defineProperty(exports, "getComputedStyle", { enumerable: true, get: function () { return getComputedStyles_1.getComputedStyle; } });
    var getPendableFormatState_1 = getPendableFormatState$2;
    Object.defineProperty(exports, "getPendableFormatState", { enumerable: true, get: function () { return getPendableFormatState_1.default; } });
    Object.defineProperty(exports, "PendableFormatCommandMap", { enumerable: true, get: function () { return getPendableFormatState_1.PendableFormatCommandMap; } });
    var getTagOfNode_1 = getTagOfNode$1;
    Object.defineProperty(exports, "getTagOfNode", { enumerable: true, get: function () { return getTagOfNode_1.default; } });
    var isBlockElement_1 = isBlockElement$1;
    Object.defineProperty(exports, "isBlockElement", { enumerable: true, get: function () { return isBlockElement_1.default; } });
    var isNodeEmpty_1 = isNodeEmpty$1;
    Object.defineProperty(exports, "isNodeEmpty", { enumerable: true, get: function () { return isNodeEmpty_1.default; } });
    var isVoidHtmlElement_1 = isVoidHtmlElement$1;
    Object.defineProperty(exports, "isVoidHtmlElement", { enumerable: true, get: function () { return isVoidHtmlElement_1.default; } });
    var matchLink_1 = matchLink$1;
    Object.defineProperty(exports, "matchLink", { enumerable: true, get: function () { return matchLink_1.default; } });
    var queryElements_1 = queryElements$1;
    Object.defineProperty(exports, "queryElements", { enumerable: true, get: function () { return queryElements_1.default; } });
    var splitParentNode_1 = splitParentNode$1;
    Object.defineProperty(exports, "splitParentNode", { enumerable: true, get: function () { return splitParentNode_1.default; } });
    Object.defineProperty(exports, "splitBalancedNodeRange", { enumerable: true, get: function () { return splitParentNode_1.splitBalancedNodeRange; } });
    var unwrap_1 = unwrap$1;
    Object.defineProperty(exports, "unwrap", { enumerable: true, get: function () { return unwrap_1.default; } });
    var wrap_1 = wrap$1;
    Object.defineProperty(exports, "wrap", { enumerable: true, get: function () { return wrap_1.default; } });
    var getLeafSibling_1 = getLeafSibling$1;
    Object.defineProperty(exports, "getNextLeafSibling", { enumerable: true, get: function () { return getLeafSibling_1.getNextLeafSibling; } });
    Object.defineProperty(exports, "getPreviousLeafSibling", { enumerable: true, get: function () { return getLeafSibling_1.getPreviousLeafSibling; } });
    var getLeafNode_1 = getLeafNode$1;
    Object.defineProperty(exports, "getFirstLeafNode", { enumerable: true, get: function () { return getLeafNode_1.getFirstLeafNode; } });
    Object.defineProperty(exports, "getLastLeafNode", { enumerable: true, get: function () { return getLeafNode_1.getLastLeafNode; } });
    var splitTextNode_1 = splitTextNode$1;
    Object.defineProperty(exports, "splitTextNode", { enumerable: true, get: function () { return splitTextNode_1.default; } });
    var normalizeRect_1 = normalizeRect$1;
    Object.defineProperty(exports, "normalizeRect", { enumerable: true, get: function () { return normalizeRect_1.default; } });
    var safeInstanceOf_1 = safeInstanceOf$1;
    Object.defineProperty(exports, "safeInstanceOf", { enumerable: true, get: function () { return safeInstanceOf_1.default; } });
    var readFile_1 = readFile$1;
    Object.defineProperty(exports, "readFile", { enumerable: true, get: function () { return readFile_1.default; } });
    var getInnerHTML_1 = getInnerHTML$1;
    Object.defineProperty(exports, "getInnerHTML", { enumerable: true, get: function () { return getInnerHTML_1.default; } });
    var setColor_1 = setColor$1;
    Object.defineProperty(exports, "setColor", { enumerable: true, get: function () { return setColor_1.default; } });
    var matchesSelector_1 = matchesSelector$1;
    Object.defineProperty(exports, "matchesSelector", { enumerable: true, get: function () { return matchesSelector_1.default; } });
    var createElement_1 = createElement;
    Object.defineProperty(exports, "createElement", { enumerable: true, get: function () { return createElement_1.default; } });
    Object.defineProperty(exports, "KnownCreateElementData", { enumerable: true, get: function () { return createElement_1.KnownCreateElementData; } });
    var moveChildNodes_1 = moveChildNodes$1;
    Object.defineProperty(exports, "moveChildNodes", { enumerable: true, get: function () { return moveChildNodes_1.default; } });
    var getIntersectedRect_1 = getIntersectedRect$1;
    Object.defineProperty(exports, "getIntersectedRect", { enumerable: true, get: function () { return getIntersectedRect_1.default; } });
    var isNodeAfter_1 = isNodeAfter$1;
    Object.defineProperty(exports, "isNodeAfter", { enumerable: true, get: function () { return isNodeAfter_1.default; } });
    var parseColor_1 = parseColor$1;
    Object.defineProperty(exports, "parseColor", { enumerable: true, get: function () { return parseColor_1.default; } });
    var VTable_1 = VTable$1;
    Object.defineProperty(exports, "VTable", { enumerable: true, get: function () { return VTable_1.default; } });
    var isWholeTableSelected_1 = isWholeTableSelected$1;
    Object.defineProperty(exports, "isWholeTableSelected", { enumerable: true, get: function () { return isWholeTableSelected_1.default; } });
    var VList_1 = VList$1;
    Object.defineProperty(exports, "VList", { enumerable: true, get: function () { return VList_1.default; } });
    var VListItem_1 = VListItem;
    Object.defineProperty(exports, "VListItem", { enumerable: true, get: function () { return VListItem_1.default; } });
    var createVListFromRegion_1 = createVListFromRegion$1;
    Object.defineProperty(exports, "createVListFromRegion", { enumerable: true, get: function () { return createVListFromRegion_1.default; } });
    var VListChain_1 = VListChain$1;
    Object.defineProperty(exports, "VListChain", { enumerable: true, get: function () { return VListChain_1.default; } });
    var setListItemStyle_1 = setListItemStyle$1;
    Object.defineProperty(exports, "setListItemStyle", { enumerable: true, get: function () { return setListItemStyle_1.default; } });
    var tableFormatInfo_1 = tableFormatInfo;
    Object.defineProperty(exports, "getTableFormatInfo", { enumerable: true, get: function () { return tableFormatInfo_1.getTableFormatInfo; } });
    var tableCellInfo_1 = tableCellInfo;
    Object.defineProperty(exports, "saveTableCellMetadata", { enumerable: true, get: function () { return tableCellInfo_1.saveTableCellMetadata; } });
    var getRegionsFromRange_1 = getRegionsFromRange$1;
    Object.defineProperty(exports, "getRegionsFromRange", { enumerable: true, get: function () { return getRegionsFromRange_1.default; } });
    var getSelectedBlockElementsInRegion_1 = getSelectedBlockElementsInRegion$1;
    Object.defineProperty(exports, "getSelectedBlockElementsInRegion", { enumerable: true, get: function () { return getSelectedBlockElementsInRegion_1.default; } });
    var collapseNodesInRegion_1 = collapseNodesInRegion$1;
    Object.defineProperty(exports, "collapseNodesInRegion", { enumerable: true, get: function () { return collapseNodesInRegion_1.default; } });
    var isNodeInRegion_1 = isNodeInRegion$1;
    Object.defineProperty(exports, "isNodeInRegion", { enumerable: true, get: function () { return isNodeInRegion_1.default; } });
    var getSelectionRangeInRegion_1 = getSelectionRangeInRegion$1;
    Object.defineProperty(exports, "getSelectionRangeInRegion", { enumerable: true, get: function () { return getSelectionRangeInRegion_1.default; } });
    var mergeBlocksInRegion_1 = mergeBlocksInRegion$1;
    Object.defineProperty(exports, "mergeBlocksInRegion", { enumerable: true, get: function () { return mergeBlocksInRegion_1.default; } });
    var Position_1 = Position$1;
    Object.defineProperty(exports, "Position", { enumerable: true, get: function () { return Position_1.default; } });
    var createRange_1 = createRange$1;
    Object.defineProperty(exports, "createRange", { enumerable: true, get: function () { return createRange_1.default; } });
    var getPositionRect_1 = getPositionRect$1;
    Object.defineProperty(exports, "getPositionRect", { enumerable: true, get: function () { return getPositionRect_1.default; } });
    var isPositionAtBeginningOf_1 = isPositionAtBeginningOf$1;
    Object.defineProperty(exports, "isPositionAtBeginningOf", { enumerable: true, get: function () { return isPositionAtBeginningOf_1.default; } });
    var getSelectionPath_1 = getSelectionPath$1;
    Object.defineProperty(exports, "getSelectionPath", { enumerable: true, get: function () { return getSelectionPath_1.default; } });
    var getHtmlWithSelectionPath_1 = getHtmlWithSelectionPath$1;
    Object.defineProperty(exports, "getHtmlWithSelectionPath", { enumerable: true, get: function () { return getHtmlWithSelectionPath_1.default; } });
    var setHtmlWithSelectionPath_1 = setHtmlWithSelectionPath$1;
    Object.defineProperty(exports, "setHtmlWithSelectionPath", { enumerable: true, get: function () { return setHtmlWithSelectionPath_1.default; } });
    Object.defineProperty(exports, "setHtmlWithMetadata", { enumerable: true, get: function () { return setHtmlWithSelectionPath_1.setHtmlWithMetadata; } });
    var addRangeToSelection_1 = addRangeToSelection$1;
    Object.defineProperty(exports, "addRangeToSelection", { enumerable: true, get: function () { return addRangeToSelection_1.default; } });
    var addSnapshot_1 = addSnapshot$1;
    Object.defineProperty(exports, "addSnapshot", { enumerable: true, get: function () { return addSnapshot_1.default; } });
    Object.defineProperty(exports, "addSnapshotV2", { enumerable: true, get: function () { return addSnapshot_1.addSnapshotV2; } });
    var canMoveCurrentSnapshot_1 = canMoveCurrentSnapshot$1;
    Object.defineProperty(exports, "canMoveCurrentSnapshot", { enumerable: true, get: function () { return canMoveCurrentSnapshot_1.default; } });
    var clearProceedingSnapshots_1 = clearProceedingSnapshots$1;
    Object.defineProperty(exports, "clearProceedingSnapshots", { enumerable: true, get: function () { return clearProceedingSnapshots_1.default; } });
    Object.defineProperty(exports, "clearProceedingSnapshotsV2", { enumerable: true, get: function () { return clearProceedingSnapshots_1.clearProceedingSnapshotsV2; } });
    var moveCurrentSnapshot_1 = moveCurrentSnapshot$1;
    Object.defineProperty(exports, "moveCurrentSnapshot", { enumerable: true, get: function () { return moveCurrentSnapshot_1.default; } });
    Object.defineProperty(exports, "moveCurrentSnapsnot", { enumerable: true, get: function () { return moveCurrentSnapshot_1.moveCurrentSnapsnot; } });
    var createSnapshots_1 = createSnapshots$1;
    Object.defineProperty(exports, "createSnapshots", { enumerable: true, get: function () { return createSnapshots_1.default; } });
    var canUndoAutoComplete_1 = canUndoAutoComplete$1;
    Object.defineProperty(exports, "canUndoAutoComplete", { enumerable: true, get: function () { return canUndoAutoComplete_1.default; } });
    var HtmlSanitizer_1 = HtmlSanitizer$1;
    Object.defineProperty(exports, "HtmlSanitizer", { enumerable: true, get: function () { return HtmlSanitizer_1.default; } });
    var getInheritableStyles_1 = getInheritableStyles$1;
    Object.defineProperty(exports, "getInheritableStyles", { enumerable: true, get: function () { return getInheritableStyles_1.default; } });
    var createDefaultHtmlSanitizerOptions_1 = createDefaultHtmlSanitizerOptions$1;
    Object.defineProperty(exports, "createDefaultHtmlSanitizerOptions", { enumerable: true, get: function () { return createDefaultHtmlSanitizerOptions_1.default; } });
    var chainSanitizerCallback_1 = chainSanitizerCallback$1;
    Object.defineProperty(exports, "chainSanitizerCallback", { enumerable: true, get: function () { return chainSanitizerCallback_1.default; } });
    var commitEntity_1 = commitEntity$1;
    Object.defineProperty(exports, "commitEntity", { enumerable: true, get: function () { return commitEntity_1.default; } });
    var getEntityFromElement_1 = getEntityFromElement$1;
    Object.defineProperty(exports, "getEntityFromElement", { enumerable: true, get: function () { return getEntityFromElement_1.default; } });
    var getEntitySelector_1 = getEntitySelector$1;
    Object.defineProperty(exports, "getEntitySelector", { enumerable: true, get: function () { return getEntitySelector_1.default; } });
    var entityPlaceholderUtils_1 = entityPlaceholderUtils;
    Object.defineProperty(exports, "createEntityPlaceholder", { enumerable: true, get: function () { return entityPlaceholderUtils_1.createEntityPlaceholder; } });
    Object.defineProperty(exports, "moveContentWithEntityPlaceholders", { enumerable: true, get: function () { return entityPlaceholderUtils_1.moveContentWithEntityPlaceholders; } });
    Object.defineProperty(exports, "restoreContentWithEntityPlaceholder", { enumerable: true, get: function () { return entityPlaceholderUtils_1.restoreContentWithEntityPlaceholder; } });
    var cacheGetEventData_1 = cacheGetEventData$1;
    Object.defineProperty(exports, "cacheGetEventData", { enumerable: true, get: function () { return cacheGetEventData_1.default; } });
    var clearEventDataCache_1 = clearEventDataCache$1;
    Object.defineProperty(exports, "clearEventDataCache", { enumerable: true, get: function () { return clearEventDataCache_1.default; } });
    var isModifierKey_1 = isModifierKey$1;
    Object.defineProperty(exports, "isModifierKey", { enumerable: true, get: function () { return isModifierKey_1.default; } });
    var isCharacterValue_1 = isCharacterValue$1;
    Object.defineProperty(exports, "isCharacterValue", { enumerable: true, get: function () { return isCharacterValue_1.default; } });
    var isCtrlOrMetaPressed_1 = isCtrlOrMetaPressed$1;
    Object.defineProperty(exports, "isCtrlOrMetaPressed", { enumerable: true, get: function () { return isCtrlOrMetaPressed_1.default; } });
    var getStyles_1 = getStyles$1;
    Object.defineProperty(exports, "getStyles", { enumerable: true, get: function () { return getStyles_1.default; } });
    var setStyles_1 = setStyles$1;
    Object.defineProperty(exports, "setStyles", { enumerable: true, get: function () { return setStyles_1.default; } });
    var removeImportantStyleRule_1 = removeImportantStyleRule$1;
    Object.defineProperty(exports, "removeImportantStyleRule", { enumerable: true, get: function () { return removeImportantStyleRule_1.default; } });
    var setGlobalCssStyles_1 = setGlobalCssStyles$1;
    Object.defineProperty(exports, "setGlobalCssStyles", { enumerable: true, get: function () { return setGlobalCssStyles_1.default; } });
    var removeGlobalCssStyle_1 = removeGlobalCssStyle$1;
    Object.defineProperty(exports, "removeGlobalCssStyle", { enumerable: true, get: function () { return removeGlobalCssStyle_1.default; } });
    var adjustInsertPosition_1 = adjustInsertPosition;
    Object.defineProperty(exports, "adjustInsertPosition", { enumerable: true, get: function () { return adjustInsertPosition_1.default; } });
    var deleteSelectedContent_1 = deleteSelectedContent$1;
    Object.defineProperty(exports, "deleteSelectedContent", { enumerable: true, get: function () { return deleteSelectedContent_1.default; } });
    var getTextContent_1 = getTextContent$1;
    Object.defineProperty(exports, "getTextContent", { enumerable: true, get: function () { return getTextContent_1.default; } });
    var validate_1 = validate$1;
    Object.defineProperty(exports, "validate", { enumerable: true, get: function () { return validate_1.default; } });
    var definitionCreators_1 = definitionCreators;
    Object.defineProperty(exports, "createNumberDefinition", { enumerable: true, get: function () { return definitionCreators_1.createNumberDefinition; } });
    Object.defineProperty(exports, "createBooleanDefinition", { enumerable: true, get: function () { return definitionCreators_1.createBooleanDefinition; } });
    Object.defineProperty(exports, "createStringDefinition", { enumerable: true, get: function () { return definitionCreators_1.createStringDefinition; } });
    Object.defineProperty(exports, "createArrayDefinition", { enumerable: true, get: function () { return definitionCreators_1.createArrayDefinition; } });
    Object.defineProperty(exports, "createObjectDefinition", { enumerable: true, get: function () { return definitionCreators_1.createObjectDefinition; } });
    var metadata_1 = metadata;
    Object.defineProperty(exports, "getMetadata", { enumerable: true, get: function () { return metadata_1.getMetadata; } });
    Object.defineProperty(exports, "setMetadata", { enumerable: true, get: function () { return metadata_1.setMetadata; } });
    Object.defineProperty(exports, "removeMetadata", { enumerable: true, get: function () { return metadata_1.removeMetadata; } });
    var arrayPush_1 = arrayPush$1;
    Object.defineProperty(exports, "arrayPush", { enumerable: true, get: function () { return arrayPush_1.default; } });
    var getObjectKeys_1 = getObjectKeys$1;
    Object.defineProperty(exports, "getObjectKeys", { enumerable: true, get: function () { return getObjectKeys_1.default; } });
    var toArray_1 = toArray$1;
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.default; } });

    }(lib$3));

    var require$$12 = /*@__PURE__*/getAugmentedNamespace(Theme);

    var require$$4$1 = /*@__PURE__*/getAugmentedNamespace(WindowProvider);

    Object.defineProperty(createUIUtilities$1, "__esModule", { value: true });
    var React$f = react.exports;
    var ReactDOM = reactDom.exports;
    var roosterjs_editor_dom_1$1L = lib$3;
    var Theme_1$2 = require$$12;
    var WindowProvider_1 = require$$4$1;
    /**
     * Create the UI Utilities object for plugins to render additional react components
     * @param container Container DIV of editor
     * @param theme Current theme used by editor
     * @returns A UIUtilities object
     */
    function createUIUtilities(container, theme) {
        return {
            renderComponent: function (element) {
                var doc = container.ownerDocument;
                var div = doc.createElement('div');
                doc.body.appendChild(div);
                ReactDOM.render(React$f.createElement(WindowProvider_1.WindowProvider, { window: doc.defaultView },
                    React$f.createElement(Theme_1$2.ThemeProvider, { theme: theme }, element)), div);
                return function () {
                    ReactDOM.unmountComponentAtNode(div);
                    doc.body.removeChild(div);
                };
            },
            isRightToLeft: function () {
                var dir = container && (0, roosterjs_editor_dom_1$1L.getComputedStyles)(container, 'direction')[0];
                return dir == 'rtl';
            },
        };
    }
    createUIUtilities$1.default = createUIUtilities;

    var getLocalizedString$1 = {};

    Object.defineProperty(getLocalizedString$1, "__esModule", { value: true });
    /**
     * Get a localized string
     * @param strings The LocalizedStrings map
     * @param key Key of the string
     * @param defaultString Default unlocalized string, will be used if strings is not specified or the give key doesn't exist in strings
     * @returns A localized string from the string map, or defaultString
     */
    function getLocalizedString(strings, key, defaultString) {
        var str = strings === null || strings === void 0 ? void 0 : strings[key];
        if (typeof str == 'function') {
            return str();
        }
        else if (typeof str == 'string') {
            return str;
        }
        else {
            return defaultString;
        }
    }
    getLocalizedString$1.default = getLocalizedString;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalizedString = exports.createUIUtilities = void 0;
    var createUIUtilities_1 = createUIUtilities$1;
    Object.defineProperty(exports, "createUIUtilities", { enumerable: true, get: function () { return createUIUtilities_1.default; } });
    var getLocalizedString_1 = getLocalizedString$1;
    Object.defineProperty(exports, "getLocalizedString", { enumerable: true, get: function () { return getLocalizedString_1.default; } });

    }(common));

    var rooster = {};

    var UpdateMode = {};

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateMode = void 0;
    (function (UpdateMode) {
        /**
         * Force update, triggered from UpdateContentPlugin.forceUpdate()
         */
        UpdateMode[UpdateMode["Force"] = 0] = "Force";
        /**
         * Update when editor is initialized
         */
        UpdateMode[UpdateMode["OnInitialize"] = 1] = "OnInitialize";
        /**
         * Update when editor is about to be disposed
         */
        UpdateMode[UpdateMode["OnDispose"] = 2] = "OnDispose";
        /**
         * Update when user input in editor
         */
        UpdateMode[UpdateMode["OnUserInput"] = 4] = "OnUserInput";
        /**
         * Update when ContentChangedEvent is triggered from a plugin
         */
        UpdateMode[UpdateMode["OnContentChangedEvent"] = 8] = "OnContentChangedEvent";
        /**
         * Update when editor loses focus
         */
        UpdateMode[UpdateMode["OnBlur"] = 16] = "OnBlur";
    })(exports.UpdateMode || (exports.UpdateMode = {}));

    }(UpdateMode));

    var Rooster$1 = {};

    var require$$2$2 = /*@__PURE__*/getAugmentedNamespace(Utilities);

    var lib$2 = {};

    var Editor$1 = {};

    var createCorePlugins$1 = {};

    var CopyPastePlugin$1 = {};

    var forEachSelectedCell$1 = {};

    Object.defineProperty(forEachSelectedCell$1, "__esModule", { value: true });
    forEachSelectedCell$1.forEachSelectedCell = void 0;
    /**
     * @internal
     * Executes an action to all the cells within the selection range.
     * @param callback action to apply on each selected cell
     * @returns the amount of cells modified
     */
    var forEachSelectedCell = function (vTable, callback) {
        var _a;
        if (vTable.selection) {
            var _b = vTable.selection, lastCell = _b.lastCell, firstCell = _b.firstCell;
            for (var y = firstCell.y; y <= lastCell.y; y++) {
                for (var x = firstCell.x; x <= lastCell.x; x++) {
                    if (vTable.cells && ((_a = vTable.cells[y][x]) === null || _a === void 0 ? void 0 : _a.td)) {
                        callback(vTable.cells[y][x]);
                    }
                }
            }
        }
    };
    forEachSelectedCell$1.forEachSelectedCell = forEachSelectedCell;

    var removeCellsOutsideSelection$1 = {};

    Object.defineProperty(removeCellsOutsideSelection$1, "__esModule", { value: true });
    removeCellsOutsideSelection$1.removeCellsOutsideSelection = void 0;
    var roosterjs_editor_dom_1$1K = lib$3;
    /**
     * @internal
     * Remove the cells outside of the selection.
     * @param vTable VTable to remove selection
     */
    var removeCellsOutsideSelection = function (vTable) {
        if (vTable.selection) {
            if ((0, roosterjs_editor_dom_1$1K.isWholeTableSelected)(vTable, vTable.selection)) {
                return;
            }
            vTable.table.style.removeProperty('width');
            vTable.table.style.removeProperty('height');
            var _a = vTable.selection, firstCell = _a.firstCell, lastCell = _a.lastCell;
            var resultCells_1 = [];
            var firstX_1 = firstCell.x;
            var firstY_1 = firstCell.y;
            var lastX_1 = lastCell.x;
            var lastY_1 = lastCell.y;
            if (vTable.cells) {
                vTable.cells.forEach(function (row, y) {
                    row = row.filter(function (_, x) { return y >= firstY_1 && y <= lastY_1 && x >= firstX_1 && x <= lastX_1; });
                    if (row.length > 0) {
                        resultCells_1.push(row);
                    }
                });
                vTable.cells = resultCells_1;
            }
        }
    };
    removeCellsOutsideSelection$1.removeCellsOutsideSelection = removeCellsOutsideSelection;

    Object.defineProperty(CopyPastePlugin$1, "__esModule", { value: true });
    var forEachSelectedCell_1 = forEachSelectedCell$1;
    var removeCellsOutsideSelection_1 = removeCellsOutsideSelection$1;
    var roosterjs_editor_dom_1$1J = lib$3;
    /**
     * @internal
     * Copy and paste plugin for handling onCopy and onPaste event
     */
    var CopyPastePlugin = /** @class */ (function () {
        /**
         * Construct a new instance of CopyPastePlugin
         * @param options The editor options
         */
        function CopyPastePlugin(options) {
            var _this = this;
            this.editor = null;
            this.disposer = null;
            this.onPaste = function (event) {
                var _a;
                var range = null;
                if (_this.editor) {
                    var editor_1 = _this.editor;
                    (0, roosterjs_editor_dom_1$1J.extractClipboardEvent)(event, function (clipboardData) {
                        if (editor_1 && !editor_1.isDisposed()) {
                            editor_1.paste(clipboardData);
                        }
                    }, {
                        allowedCustomPasteType: _this.state.allowedCustomPasteType,
                        getTempDiv: function () {
                            var _a;
                            range = (_a = editor_1.getSelectionRange()) !== null && _a !== void 0 ? _a : null;
                            return _this.getTempDiv(editor_1);
                        },
                        removeTempDiv: function (div) {
                            if (range) {
                                _this.cleanUpAndRestoreSelection(div, range, false /* isCopy */);
                            }
                        },
                    }, (_a = _this.editor.getSelectionRange()) !== null && _a !== void 0 ? _a : undefined);
                }
            };
            this.state = {
                allowedCustomPasteType: options.allowedCustomPasteType || [],
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        CopyPastePlugin.prototype.getName = function () {
            return 'CopyPaste';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        CopyPastePlugin.prototype.initialize = function (editor) {
            var _this = this;
            this.editor = editor;
            this.disposer = this.editor.addDomEventHandler({
                paste: function (e) { return _this.onPaste(e); },
                copy: function (e) { return _this.onCutCopy(e, false /*isCut*/); },
                cut: function (e) { return _this.onCutCopy(e, true /*isCut*/); },
            });
        };
        /**
         * Dispose this plugin
         */
        CopyPastePlugin.prototype.dispose = function () {
            if (this.disposer) {
                this.disposer();
            }
            this.disposer = null;
            this.editor = null;
        };
        /**
         * Get plugin state object
         */
        CopyPastePlugin.prototype.getState = function () {
            return this.state;
        };
        CopyPastePlugin.prototype.onCutCopy = function (event, isCut) {
            var _this = this;
            if (this.editor) {
                var selection_1 = this.editor.getSelectionRangeEx();
                if (selection_1 && !selection_1.areAllCollapsed) {
                    var html = this.editor.getContent(2 /* RawHTMLWithSelection */);
                    var tempDiv_1 = this.getTempDiv(this.editor, true /*forceInLightMode*/);
                    var metadata = (0, roosterjs_editor_dom_1$1J.setHtmlWithMetadata)(tempDiv_1, html, this.editor.getTrustedHTMLHandler());
                    var newRange = null;
                    if (selection_1.type === 1 /* TableSelection */ &&
                        selection_1.coordinates) {
                        var table = tempDiv_1.querySelector("#" + selection_1.table.id);
                        newRange = this.createTableRange(table, selection_1.coordinates);
                        if (isCut) {
                            this.deleteTableContent(this.editor, selection_1.table, selection_1.coordinates);
                        }
                    }
                    else if (selection_1.type === 2 /* ImageSelection */) {
                        var image = tempDiv_1.querySelector('#' + selection_1.image.id);
                        if (image) {
                            newRange = (0, roosterjs_editor_dom_1$1J.createRange)(image);
                            if (isCut) {
                                this.deleteImage(this.editor, selection_1.image.id);
                            }
                        }
                    }
                    else {
                        newRange =
                            (metadata === null || metadata === void 0 ? void 0 : metadata.type) === 0 /* Normal */
                                ? (0, roosterjs_editor_dom_1$1J.createRange)(tempDiv_1, metadata.start, metadata.end)
                                : null;
                    }
                    if (newRange) {
                        var cutCopyEvent = this.editor.triggerPluginEvent(9 /* BeforeCutCopy */, {
                            clonedRoot: tempDiv_1,
                            range: newRange,
                            rawEvent: event,
                            isCut: isCut,
                        });
                        if (cutCopyEvent.range) {
                            (0, roosterjs_editor_dom_1$1J.addRangeToSelection)(newRange);
                        }
                        this.editor.runAsync(function (editor) {
                            _this.cleanUpAndRestoreSelection(tempDiv_1, selection_1, !isCut /* isCopy */);
                            if (isCut) {
                                editor.addUndoSnapshot(function () {
                                    var position = editor.deleteSelectedContent();
                                    editor.focus();
                                    editor.select(position);
                                }, "Cut" /* Cut */);
                            }
                        });
                    }
                }
            }
        };
        CopyPastePlugin.prototype.getTempDiv = function (editor, forceInLightMode) {
            var div = editor.getCustomData('CopyPasteTempDiv', function () {
                var tempDiv = (0, roosterjs_editor_dom_1$1J.createElement)(3 /* CopyPasteTempDiv */, editor.getDocument());
                editor.getDocument().body.appendChild(tempDiv);
                return tempDiv;
            }, function (tempDiv) { var _a; return (_a = tempDiv.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(tempDiv); });
            if (forceInLightMode) {
                div.style.backgroundColor = 'white';
                div.style.color = 'black';
            }
            div.style.display = '';
            div.focus();
            return div;
        };
        CopyPastePlugin.prototype.cleanUpAndRestoreSelection = function (tempDiv, range, isCopy) {
            var _a, _b, _c;
            if (!!((_a = range) === null || _a === void 0 ? void 0 : _a.type) || range.type == 0) {
                var selection = range;
                switch (selection.type) {
                    case 1 /* TableSelection */:
                    case 2 /* ImageSelection */:
                        (_b = this.editor) === null || _b === void 0 ? void 0 : _b.select(selection);
                        break;
                    case 0 /* Normal */:
                        var range_1 = (_c = selection.ranges) === null || _c === void 0 ? void 0 : _c[0];
                        this.restoreRange(range_1, isCopy);
                        break;
                }
            }
            else {
                this.restoreRange(range, isCopy);
            }
            tempDiv.style.backgroundColor = '';
            tempDiv.style.color = '';
            tempDiv.style.display = 'none';
            (0, roosterjs_editor_dom_1$1J.moveChildNodes)(tempDiv);
        };
        CopyPastePlugin.prototype.restoreRange = function (range, isCopy) {
            if (range && this.editor) {
                if (isCopy && roosterjs_editor_dom_1$1J.Browser.isAndroid) {
                    range.collapse();
                }
                this.editor.select(range);
            }
        };
        CopyPastePlugin.prototype.createTableRange = function (table, selection) {
            var clonedVTable = new roosterjs_editor_dom_1$1J.VTable(table);
            clonedVTable.selection = selection;
            (0, removeCellsOutsideSelection_1.removeCellsOutsideSelection)(clonedVTable);
            clonedVTable.writeBack();
            return (0, roosterjs_editor_dom_1$1J.createRange)(clonedVTable.table);
        };
        CopyPastePlugin.prototype.deleteTableContent = function (editor, table, selection) {
            var selectedVTable = new roosterjs_editor_dom_1$1J.VTable(table);
            selectedVTable.selection = selection;
            (0, forEachSelectedCell_1.forEachSelectedCell)(selectedVTable, function (cell) {
                if (cell === null || cell === void 0 ? void 0 : cell.td) {
                    cell.td.innerHTML = editor.getTrustedHTMLHandler()('<br>');
                }
            });
            var wholeTableSelected = (0, roosterjs_editor_dom_1$1J.isWholeTableSelected)(selectedVTable, selection);
            var isWholeColumnSelected = table.rows.length - 1 === selection.lastCell.y && selection.firstCell.y === 0;
            if (wholeTableSelected) {
                selectedVTable.edit(4 /* DeleteTable */);
                selectedVTable.writeBack();
            }
            else if (isWholeColumnSelected) {
                selectedVTable.edit(5 /* DeleteColumn */);
                selectedVTable.writeBack();
            }
            if (wholeTableSelected || isWholeColumnSelected) {
                table.style.removeProperty('width');
                table.style.removeProperty('height');
            }
        };
        CopyPastePlugin.prototype.deleteImage = function (editor, imageId) {
            editor.queryElements('#' + imageId, function (node) {
                editor.deleteNode(node);
            });
        };
        return CopyPastePlugin;
    }());
    CopyPastePlugin$1.default = CopyPastePlugin;

    var DOMEventPlugin$1 = {};

    Object.defineProperty(DOMEventPlugin$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$1I = lib$3;
    /**
     * @internal
     * DOMEventPlugin handles customized DOM events, including:
     * 1. Keyboard event
     * 2. Mouse event
     * 3. IME state
     * 4. Drop event
     * 5. Focus and blur event
     * 6. Input event
     * 7. Scroll event
     * It contains special handling for Safari since Safari cannot get correct selection when onBlur event is triggered in editor.
     */
    var DOMEventPlugin = /** @class */ (function () {
        /**
         * Construct a new instance of DOMEventPlugin
         * @param options The editor options
         * @param contentDiv The editor content DIV
         */
        function DOMEventPlugin(options, contentDiv) {
            var _this = this;
            var _a;
            this.editor = null;
            this.disposer = null;
            this.onDrop = function () {
                var _a;
                (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.runAsync(function (editor) {
                    editor.addUndoSnapshot(function () { }, "Drop" /* Drop */);
                });
            };
            this.onFocus = function () {
                var _a, _b, _c;
                var _d = _this.state.tableSelectionRange || {}, table = _d.table, coordinates = _d.coordinates;
                var image = (_this.state.imageSelectionRange || {}).image;
                if (table && coordinates) {
                    (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.select(table, coordinates);
                }
                else if (image) {
                    (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.select(image);
                }
                else if (_this.state.selectionRange) {
                    (_c = _this.editor) === null || _c === void 0 ? void 0 : _c.select(_this.state.selectionRange);
                }
                _this.state.selectionRange = null;
            };
            this.onKeyDownDocument = function (event) {
                if (event.which == 9 /* TAB */ && !event.defaultPrevented) {
                    _this.cacheSelection();
                }
            };
            this.onMouseDownDocument = function (event) {
                if (_this.editor &&
                    !_this.state.selectionRange &&
                    !_this.editor.contains(event.target)) {
                    _this.cacheSelection();
                }
            };
            this.cacheSelection = function () {
                if (!_this.state.selectionRange && _this.editor) {
                    _this.state.selectionRange = _this.editor.getSelectionRange(false /*tryGetFromCache*/);
                }
            };
            this.onScroll = function (e) {
                var _a;
                (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.triggerPluginEvent(14 /* Scroll */, {
                    rawEvent: e,
                    scrollContainer: _this.state.scrollContainer,
                });
            };
            this.onKeyboardEvent = function (event) {
                if ((0, roosterjs_editor_dom_1$1I.isCharacterValue)(event) || (event.which >= 33 /* PAGEUP */ && event.which <= 40 /* DOWN */)) {
                    // Stop propagation for Character keys and Up/Down/Left/Right/Home/End/PageUp/PageDown
                    // since editor already handles these keys and no need to propagate to parents
                    event.stopPropagation();
                }
            };
            this.onInputEvent = function (event) {
                event.stopPropagation();
            };
            this.onContextMenuEvent = function (event) {
                var _a, _b;
                var allItems = [];
                var searcher = (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getContentSearcherOfCursor();
                var elementBeforeCursor = searcher === null || searcher === void 0 ? void 0 : searcher.getInlineElementBefore();
                var eventTargetNode = event.target;
                if (event.button != 2 && elementBeforeCursor) {
                    eventTargetNode = elementBeforeCursor.getContainerNode();
                }
                _this.state.contextMenuProviders.forEach(function (provider) {
                    var _a;
                    var items = (_a = provider.getContextMenuItems(eventTargetNode)) !== null && _a !== void 0 ? _a : [];
                    if ((items === null || items === void 0 ? void 0 : items.length) > 0) {
                        if (allItems.length > 0) {
                            allItems.push(null);
                        }
                        (0, roosterjs_editor_dom_1$1I.arrayPush)(allItems, items);
                    }
                });
                (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.triggerPluginEvent(16 /* ContextMenu */, {
                    rawEvent: event,
                    items: allItems,
                });
            };
            this.state = {
                isInIME: false,
                scrollContainer: options.scrollContainer || contentDiv,
                selectionRange: null,
                stopPrintableKeyboardEventPropagation: !options.allowKeyboardEventPropagation,
                contextMenuProviders: ((_a = options.plugins) === null || _a === void 0 ? void 0 : _a.filter(isContextMenuProvider)) || [],
                tableSelectionRange: null,
                imageSelectionRange: null,
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        DOMEventPlugin.prototype.getName = function () {
            return 'DOMEvent';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        DOMEventPlugin.prototype.initialize = function (editor) {
            var _a;
            var _this = this;
            var _b, _c, _d;
            this.editor = editor;
            var document = this.editor.getDocument();
            //Record<string, DOMEventHandler>
            var eventHandlers = (_a = {
                    // 1. Keyboard event
                    keypress: this.getEventHandler(1 /* KeyPress */),
                    keydown: this.getEventHandler(0 /* KeyDown */),
                    keyup: this.getEventHandler(2 /* KeyUp */),
                    // 2. Mouse event
                    mousedown: 5 /* MouseDown */,
                    contextmenu: this.onContextMenuEvent,
                    // 3. IME state management
                    compositionstart: function () { return (_this.state.isInIME = true); },
                    compositionend: function (rawEvent) {
                        _this.state.isInIME = false;
                        editor.triggerPluginEvent(4 /* CompositionEnd */, {
                            rawEvent: rawEvent,
                        });
                    },
                    // 4. Drop event
                    drop: this.onDrop,
                    // 5. Focus management
                    focus: this.onFocus
                },
                // 6. Input event
                _a[roosterjs_editor_dom_1$1I.Browser.isIE ? 'textinput' : 'input'] = this.getEventHandler(3 /* Input */),
                _a);
            // 7. onBlur handlers
            if (roosterjs_editor_dom_1$1I.Browser.isSafari) {
                document.addEventListener('mousedown', this.onMouseDownDocument, true /*useCapture*/);
                document.addEventListener('keydown', this.onKeyDownDocument);
                (_b = document.defaultView) === null || _b === void 0 ? void 0 : _b.addEventListener('blur', this.cacheSelection);
            }
            else if (roosterjs_editor_dom_1$1I.Browser.isIEOrEdge) {
                eventHandlers.beforedeactivate = this.cacheSelection;
            }
            else {
                eventHandlers.blur = this.cacheSelection;
            }
            this.disposer = editor.addDomEventHandler(eventHandlers);
            // 8. Scroll event
            this.state.scrollContainer.addEventListener('scroll', this.onScroll);
            (_c = document.defaultView) === null || _c === void 0 ? void 0 : _c.addEventListener('scroll', this.onScroll);
            (_d = document.defaultView) === null || _d === void 0 ? void 0 : _d.addEventListener('resize', this.onScroll);
        };
        /**
         * Dispose this plugin
         */
        DOMEventPlugin.prototype.dispose = function () {
            var _a, _b, _c, _d, _e;
            var document = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getDocument();
            if (document && roosterjs_editor_dom_1$1I.Browser.isSafari) {
                document.removeEventListener('mousedown', this.onMouseDownDocument, true /*useCapture*/);
                document.removeEventListener('keydown', this.onKeyDownDocument);
                (_b = document.defaultView) === null || _b === void 0 ? void 0 : _b.removeEventListener('blur', this.cacheSelection);
            }
            (_c = document === null || document === void 0 ? void 0 : document.defaultView) === null || _c === void 0 ? void 0 : _c.removeEventListener('resize', this.onScroll);
            (_d = document === null || document === void 0 ? void 0 : document.defaultView) === null || _d === void 0 ? void 0 : _d.removeEventListener('scroll', this.onScroll);
            this.state.scrollContainer.removeEventListener('scroll', this.onScroll);
            (_e = this.disposer) === null || _e === void 0 ? void 0 : _e.call(this);
            this.disposer = null;
            this.editor = null;
        };
        /**
         * Get plugin state object
         */
        DOMEventPlugin.prototype.getState = function () {
            return this.state;
        };
        DOMEventPlugin.prototype.getEventHandler = function (eventType) {
            var _this = this;
            var beforeDispatch = function (event) {
                return eventType == 3 /* Input */
                    ? _this.onInputEvent(event)
                    : _this.onKeyboardEvent(event);
            };
            return this.state.stopPrintableKeyboardEventPropagation
                ? {
                    pluginEventType: eventType,
                    beforeDispatch: beforeDispatch,
                }
                : eventType;
        };
        return DOMEventPlugin;
    }());
    DOMEventPlugin$1.default = DOMEventPlugin;
    function isContextMenuProvider(source) {
        var _a;
        return !!((_a = source) === null || _a === void 0 ? void 0 : _a.getContextMenuItems);
    }

    var EditPlugin$1 = {};

    Object.defineProperty(EditPlugin$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$1H = lib$3;
    /**
     * @internal
     * Edit Component helps handle Content edit features
     */
    var EditPlugin = /** @class */ (function () {
        /**
         * Construct a new instance of EditPlugin
         * @param options The editor options
         */
        function EditPlugin() {
            this.editor = null;
            this.state = {
                features: {},
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        EditPlugin.prototype.getName = function () {
            return 'Edit';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        EditPlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        EditPlugin.prototype.dispose = function () {
            this.editor = null;
        };
        /**
         * Get plugin state object
         */
        EditPlugin.prototype.getState = function () {
            return this.state;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        EditPlugin.prototype.onPluginEvent = function (event) {
            var _a;
            var hasFunctionKey = false;
            var features = null;
            var ctrlOrMeta = false;
            if (event.eventType == 0 /* KeyDown */) {
                var rawEvent = event.rawEvent;
                var range = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
                ctrlOrMeta = (0, roosterjs_editor_dom_1$1H.isCtrlOrMetaPressed)(rawEvent);
                hasFunctionKey = ctrlOrMeta || rawEvent.altKey;
                features =
                    this.state.features[rawEvent.which] ||
                        (range && !range.collapsed && this.state.features[258 /* RANGE */]);
            }
            else if (event.eventType == 7 /* ContentChanged */) {
                features = this.state.features[257 /* CONTENTCHANGED */];
            }
            for (var i = 0; features && i < (features === null || features === void 0 ? void 0 : features.length); i++) {
                var feature = features[i];
                if ((feature.allowFunctionKeys || !hasFunctionKey) &&
                    this.editor &&
                    feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)) {
                    feature.handleEvent(event, this.editor);
                    break;
                }
            }
        };
        return EditPlugin;
    }());
    EditPlugin$1.default = EditPlugin;

    var EntityPlugin$1 = {};

    var inlineEntityOnPluginEvent$1 = {};

    Object.defineProperty(inlineEntityOnPluginEvent$1, "__esModule", { value: true });
    inlineEntityOnPluginEvent$1.normalizeDelimitersInEditor = inlineEntityOnPluginEvent$1.inlineEntityOnPluginEvent = void 0;
    var roosterjs_editor_dom_1$1G = lib$3;
    var DELIMITER_SELECTOR = '.' + "entityDelimiterAfter" /* DELIMITER_AFTER */ + ',.' + "entityDelimiterBefore" /* DELIMITER_BEFORE */;
    var ZERO_WIDTH_SPACE$2 = '\u200B';
    var INLINE_ENTITY_SELECTOR = 'span' + (0, roosterjs_editor_dom_1$1G.getEntitySelector)();
    function inlineEntityOnPluginEvent(event, editor) {
        switch (event.eventType) {
            case 7 /* ContentChanged */:
                if (event.source === "SetContent" /* SetContent */) {
                    normalizeDelimitersInEditor(editor);
                }
                break;
            case 11 /* EditorReady */:
                normalizeDelimitersInEditor(editor);
                break;
            case 10 /* BeforePaste */:
                var fragment = event.fragment, sanitizingOption = event.sanitizingOption;
                addDelimitersIfNeeded(fragment.querySelectorAll(INLINE_ENTITY_SELECTOR));
                if (sanitizingOption.additionalAllowedCssClasses) {
                    (0, roosterjs_editor_dom_1$1G.arrayPush)(sanitizingOption.additionalAllowedCssClasses, [
                        "entityDelimiterAfter" /* DELIMITER_AFTER */,
                        "entityDelimiterBefore" /* DELIMITER_BEFORE */,
                    ]);
                }
                break;
            case 8 /* ExtractContentWithDom */:
            case 9 /* BeforeCutCopy */:
                event.clonedRoot.querySelectorAll(DELIMITER_SELECTOR).forEach(removeNode);
                break;
            case 0 /* KeyDown */:
                handleKeyDownEvent(editor, event);
                break;
        }
    }
    inlineEntityOnPluginEvent$1.inlineEntityOnPluginEvent = inlineEntityOnPluginEvent;
    function preventTypeInDelimiter(delimiter) {
        var _a, _b, _c, _d;
        delimiter.normalize();
        var textNode = delimiter.firstChild;
        var index = (_b = (_a = textNode.nodeValue) === null || _a === void 0 ? void 0 : _a.indexOf(ZERO_WIDTH_SPACE$2)) !== null && _b !== void 0 ? _b : -1;
        if (index >= 0) {
            (0, roosterjs_editor_dom_1$1G.splitTextNode)(textNode, index == 0 ? 1 : index, false /* returnFirstPart */);
            var nodeToMove_1;
            delimiter.childNodes.forEach(function (node) {
                if (node.nodeValue !== ZERO_WIDTH_SPACE$2) {
                    nodeToMove_1 = node;
                }
            });
            if (nodeToMove_1) {
                (_c = delimiter.parentElement) === null || _c === void 0 ? void 0 : _c.insertBefore(nodeToMove_1, delimiter.className == "entityDelimiterBefore" /* DELIMITER_BEFORE */
                    ? delimiter
                    : delimiter.nextSibling);
                var selection = (_d = nodeToMove_1.ownerDocument) === null || _d === void 0 ? void 0 : _d.getSelection();
                if (selection) {
                    selection.setPosition(nodeToMove_1, new roosterjs_editor_dom_1$1G.Position(nodeToMove_1, -1 /* End */).offset);
                }
            }
        }
    }
    /**
     * @internal
     */
    function normalizeDelimitersInEditor(editor) {
        removeInvalidDelimiters(editor.queryElements(DELIMITER_SELECTOR));
        addDelimitersIfNeeded(editor.queryElements(INLINE_ENTITY_SELECTOR));
    }
    inlineEntityOnPluginEvent$1.normalizeDelimitersInEditor = normalizeDelimitersInEditor;
    function addDelimitersIfNeeded(nodes) {
        nodes.forEach(function (node) {
            if (isEntityElement(node)) {
                (0, roosterjs_editor_dom_1$1G.addDelimiters)(node);
            }
        });
    }
    function isEntityElement(node) {
        return !!(node &&
            (0, roosterjs_editor_dom_1$1G.safeInstanceOf)(node, 'HTMLElement') &&
            isReadOnly((0, roosterjs_editor_dom_1$1G.getEntityFromElement)(node)));
    }
    function removeNode(el) {
        var _a;
        (_a = el === null || el === void 0 ? void 0 : el.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(el);
    }
    function isReadOnly(entity) {
        return ((entity === null || entity === void 0 ? void 0 : entity.isReadonly) &&
            !(0, roosterjs_editor_dom_1$1G.isBlockElement)(entity.wrapper) &&
            (0, roosterjs_editor_dom_1$1G.safeInstanceOf)(entity.wrapper, 'HTMLElement'));
    }
    function removeInvalidDelimiters(nodes) {
        nodes.forEach(function (node) {
            if ((0, roosterjs_editor_dom_1$1G.getDelimiterFromElement)(node)) {
                var sibling = node.classList.contains("entityDelimiterBefore" /* DELIMITER_BEFORE */)
                    ? node.nextElementSibling
                    : node.previousElementSibling;
                if (!((0, roosterjs_editor_dom_1$1G.safeInstanceOf)(sibling, 'HTMLElement') && (0, roosterjs_editor_dom_1$1G.getEntityFromElement)(sibling))) {
                    removeNode(node);
                }
            }
            else {
                removeDelimiterAttr(node);
            }
        });
    }
    function removeDelimiterAttr(node, checkEntity) {
        if (checkEntity === void 0) { checkEntity = true; }
        if (!node) {
            return;
        }
        var isAfter = node.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */);
        var entitySibling = isAfter ? node.previousElementSibling : node.nextElementSibling;
        if (checkEntity && entitySibling && isEntityElement(entitySibling)) {
            return;
        }
        node.classList.remove("entityDelimiterAfter" /* DELIMITER_AFTER */, "entityDelimiterBefore" /* DELIMITER_BEFORE */);
        node.normalize();
        node.childNodes.forEach(function (cn) {
            var _a, _b, _c;
            var index = (_b = (_a = cn.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(ZERO_WIDTH_SPACE$2)) !== null && _b !== void 0 ? _b : -1;
            if (index >= 0) {
                (_c = (0, roosterjs_editor_dom_1$1G.createRange)(cn, index, cn, index + 1)) === null || _c === void 0 ? void 0 : _c.deleteContents();
            }
        });
    }
    function handleCollapsedEnter(editor, delimiter) {
        var _a;
        var isAfter = delimiter.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */);
        var entity = !isAfter ? delimiter.nextSibling : delimiter.previousSibling;
        var block = (_a = editor.getBlockElementAtNode(delimiter)) === null || _a === void 0 ? void 0 : _a.getStartNode();
        editor.runAsync(function () {
            if (!block) {
                return;
            }
            var blockToCheck = isAfter ? block.nextSibling : block.previousSibling;
            if (blockToCheck && (0, roosterjs_editor_dom_1$1G.safeInstanceOf)(blockToCheck, 'HTMLElement')) {
                var delimiters = blockToCheck.querySelectorAll(DELIMITER_SELECTOR);
                // Check if the last or first delimiter still contain the delimiter class and remove it.
                var delimiterToCheck = delimiters.item(isAfter ? 0 : delimiters.length - 1);
                removeDelimiterAttr(delimiterToCheck);
            }
            if (isEntityElement(entity)) {
                var nextElementSibling = entity.nextElementSibling, previousElementSibling = entity.previousElementSibling;
                [nextElementSibling, previousElementSibling].forEach(function (el) {
                    // Check if after Enter the ZWS got removed but we still have a element with the class
                    // Remove the attributes of the element if it is invalid now.
                    if (el && (0, roosterjs_editor_dom_1$1G.matchesSelector)(el, DELIMITER_SELECTOR) && !(0, roosterjs_editor_dom_1$1G.getDelimiterFromElement)(el)) {
                        removeDelimiterAttr(el, false /* checkEntity */);
                    }
                });
                // Add delimiters to the entity if needed because on Enter we can sometimes lose the ZWS of the element.
                (0, roosterjs_editor_dom_1$1G.addDelimiters)(entity);
            }
        });
    }
    var getPosition = function (container) {
        if (container && (0, roosterjs_editor_dom_1$1G.getDelimiterFromElement)(container)) {
            var isAfter = container.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */);
            return new roosterjs_editor_dom_1$1G.Position(container, isAfter ? -3 /* After */ : -2 /* Before */);
        }
        return undefined;
    };
    function handleSelectionNotCollapsed(editor, range, event) {
        var startContainer = range.startContainer, endContainer = range.endContainer, startOffset = range.startOffset, endOffset = range.endOffset;
        var startElement = editor.getElementAtCursor(DELIMITER_SELECTOR, startContainer);
        var endElement = editor.getElementAtCursor(DELIMITER_SELECTOR, endContainer);
        var startUpdate = getPosition(startElement);
        var endUpdate = getPosition(endElement);
        if (startUpdate || endUpdate) {
            editor.select(startUpdate !== null && startUpdate !== void 0 ? startUpdate : new roosterjs_editor_dom_1$1G.Position(startContainer, startOffset), endUpdate !== null && endUpdate !== void 0 ? endUpdate : new roosterjs_editor_dom_1$1G.Position(endContainer, endOffset));
        }
        editor.runAsync(function (aEditor) {
            var delimiter = aEditor.getElementAtCursor(DELIMITER_SELECTOR);
            if (delimiter) {
                preventTypeInDelimiter(delimiter);
                if (event.which === 13 /* ENTER */) {
                    removeDelimiterAttr(delimiter);
                }
            }
        });
    }
    function handleKeyDownEvent(editor, event) {
        var _a, _b;
        var range = editor.getSelectionRangeEx();
        var rawEvent = event.rawEvent;
        if (range.type != 0 /* Normal */) {
            return;
        }
        if (range.areAllCollapsed && ((0, roosterjs_editor_dom_1$1G.isCharacterValue)(rawEvent) || rawEvent.which === 13 /* ENTER */)) {
            var position = (_a = editor.getFocusedPosition()) === null || _a === void 0 ? void 0 : _a.normalize();
            if (!position) {
                return;
            }
            var element = position.element, node = position.node;
            var refNode = element == node ? element.childNodes.item(position.offset) : element;
            var delimiter_1 = editor.getElementAtCursor(DELIMITER_SELECTOR, refNode);
            if (!delimiter_1) {
                return;
            }
            if (rawEvent.which === 13 /* ENTER */) {
                handleCollapsedEnter(editor, delimiter_1);
            }
            else if (((_b = delimiter_1.firstChild) === null || _b === void 0 ? void 0 : _b.nodeType) == 3 /* Text */) {
                editor.runAsync(function () { return preventTypeInDelimiter(delimiter_1); });
            }
        }
        else if (!range.areAllCollapsed && !rawEvent.shiftKey && rawEvent.which != 16 /* SHIFT */) {
            var currentRange = range.ranges[0];
            if (!currentRange) {
                return;
            }
            handleSelectionNotCollapsed(editor, currentRange, rawEvent);
        }
    }

    Object.defineProperty(EntityPlugin$1, "__esModule", { value: true });
    var inlineEntityOnPluginEvent_1 = inlineEntityOnPluginEvent$1;
    var roosterjs_editor_dom_1$1F = lib$3;
    var ENTITY_ID_REGEX = /_(\d{1,8})$/;
    var ENTITY_CSS_REGEX = '^' + "_Entity" /* ENTITY_INFO_NAME */ + '$';
    var ENTITY_ID_CSS_REGEX = '^' + "_EId_" /* ENTITY_ID_PREFIX */;
    var ENTITY_TYPE_CSS_REGEX = '^' + "_EType_" /* ENTITY_TYPE_PREFIX */;
    var ENTITY_READONLY_CSS_REGEX = '^' + "_EReadonly_" /* ENTITY_READONLY_PREFIX */;
    var ALLOWED_CSS_CLASSES = [
        ENTITY_CSS_REGEX,
        ENTITY_ID_CSS_REGEX,
        ENTITY_TYPE_CSS_REGEX,
        ENTITY_READONLY_CSS_REGEX,
    ];
    var REMOVE_ENTITY_OPERATIONS = [
        6 /* Overwrite */,
        7 /* PartialOverwrite */,
        4 /* RemoveFromStart */,
        5 /* RemoveFromEnd */,
    ];
    /**
     * @internal
     * Entity Plugin helps handle all operations related to an entity and generate entity specified events
     */
    var EntityPlugin = /** @class */ (function () {
        /**
         * Construct a new instance of EntityPlugin
         */
        function EntityPlugin() {
            var _this = this;
            this.editor = null;
            this.cancelAsyncRun = null;
            this.handleCutEvent = function (event) {
                var _a;
                var range = (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
                if (range && !range.collapsed) {
                    _this.checkRemoveEntityForRange(event);
                }
            };
            this.state = {
                knownEntityElements: [],
                shadowEntityCache: {},
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        EntityPlugin.prototype.getName = function () {
            return 'Entity';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        EntityPlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Check if the plugin should handle the given event exclusively.
         * Handle an event exclusively means other plugin will not receive this event in
         * onPluginEvent method.
         * If two plugins will return true in willHandleEventExclusively() for the same event,
         * the final result depends on the order of the plugins are added into editor
         * @param event The event to check
         */
        EntityPlugin.prototype.willHandleEventExclusively = function (event) {
            var _a;
            return (event.eventType == 1 /* KeyPress */ &&
                !!((_a = event.rawEvent.target) === null || _a === void 0 ? void 0 : _a.shadowRoot));
        };
        /**
         * Dispose this plugin
         */
        EntityPlugin.prototype.dispose = function () {
            this.editor = null;
            this.state.knownEntityElements = [];
        };
        /**
         * Get plugin state object
         */
        EntityPlugin.prototype.getState = function () {
            return this.state;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        EntityPlugin.prototype.onPluginEvent = function (event) {
            var _a;
            switch (event.eventType) {
                case 6 /* MouseUp */:
                    this.handleMouseUpEvent(event);
                    break;
                case 0 /* KeyDown */:
                    this.handleKeyDownEvent(event.rawEvent);
                    break;
                case 9 /* BeforeCutCopy */:
                    if (event.isCut) {
                        this.handleCutEvent(event.rawEvent);
                    }
                    break;
                case 10 /* BeforePaste */:
                    this.handleBeforePasteEvent(event.sanitizingOption);
                    break;
                case 7 /* ContentChanged */:
                    this.handleContentChangedEvent(event);
                    break;
                case 11 /* EditorReady */:
                    this.handleContentChangedEvent();
                    break;
                case 8 /* ExtractContentWithDom */:
                    this.handleExtractContentWithDomEvent(event.clonedRoot);
                    break;
                case 16 /* ContextMenu */:
                    this.handleContextMenuEvent(event.rawEvent);
                    break;
                case 20 /* BeforeSetContent */:
                    this.handleBeforeSetContentEvent();
                    break;
                case 15 /* EntityOperation */:
                    this.handleEntityOperationEvent(event);
                    break;
            }
            if ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.isFeatureEnabled("InlineEntityReadOnlyDelimiters" /* InlineEntityReadOnlyDelimiters */)) {
                (0, inlineEntityOnPluginEvent_1.inlineEntityOnPluginEvent)(event, this.editor);
            }
        };
        EntityPlugin.prototype.handleContextMenuEvent = function (event) {
            var _a;
            var node = event.target;
            var entityElement = node && ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor((0, roosterjs_editor_dom_1$1F.getEntitySelector)(), node));
            if (entityElement) {
                event.preventDefault();
                this.triggerEvent(entityElement, 2 /* ContextMenu */, event);
            }
        };
        EntityPlugin.prototype.handleMouseUpEvent = function (event) {
            var rawEvent = event.rawEvent, isClicking = event.isClicking;
            var node = rawEvent.target;
            var entityElement;
            if (this.editor &&
                isClicking &&
                node &&
                !!(entityElement = this.editor.getElementAtCursor((0, roosterjs_editor_dom_1$1F.getEntitySelector)(), node))) {
                this.triggerEvent(entityElement, 1 /* Click */, rawEvent);
                workaroundSelectionIssueForIE(this.editor);
            }
        };
        EntityPlugin.prototype.handleKeyDownEvent = function (event) {
            var _a;
            if ((0, roosterjs_editor_dom_1$1F.isCharacterValue)(event) ||
                event.which == 8 /* BACKSPACE */ ||
                event.which == 46 /* DELETE */ ||
                event.which == 13 /* ENTER */) {
                var range = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
                if (range && !range.collapsed) {
                    this.checkRemoveEntityForRange(event);
                }
            }
        };
        EntityPlugin.prototype.handleBeforePasteEvent = function (sanitizingOption) {
            var _a;
            var range = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
            if (range && !range.collapsed) {
                this.checkRemoveEntityForRange(null /*rawEvent*/);
            }
            if (sanitizingOption.additionalAllowedCssClasses) {
                (0, roosterjs_editor_dom_1$1F.arrayPush)(sanitizingOption.additionalAllowedCssClasses, ALLOWED_CSS_CLASSES);
            }
        };
        EntityPlugin.prototype.handleBeforeSetContentEvent = function () {
            this.cacheShadowEntities(this.state.shadowEntityCache);
        };
        EntityPlugin.prototype.handleContentChangedEvent = function (event) {
            var _this = this;
            var _a;
            var shouldNormalizeDelimiters = false;
            // 1. find removed entities
            for (var i = this.state.knownEntityElements.length - 1; i >= 0; i--) {
                var element = this.state.knownEntityElements[i];
                if (this.editor && !this.editor.contains(element)) {
                    this.setIsEntityKnown(element, false /*isKnown*/);
                    if (element.shadowRoot) {
                        this.triggerEvent(element, 10 /* RemoveShadowRoot */);
                    }
                    if (!shouldNormalizeDelimiters &&
                        !element.isContentEditable &&
                        !(0, roosterjs_editor_dom_1$1F.isBlockElement)(element)) {
                        shouldNormalizeDelimiters = true;
                    }
                }
            }
            // 2. collect all new entities
            var knownIds = this.state.knownEntityElements
                .map(function (e) { var _a; return (_a = (0, roosterjs_editor_dom_1$1F.getEntityFromElement)(e)) === null || _a === void 0 ? void 0 : _a.id; })
                .filter(function (x) { return !!x; });
            var newEntities = (event === null || event === void 0 ? void 0 : event.source) == "InsertEntity" /* InsertEntity */ && event.data
                ? [event.data]
                : this.getExistingEntities().filter(function (_a) {
                    var wrapper = _a.wrapper;
                    return !_this.isEntityKnown(wrapper);
                });
            // 3. Add new entities to known entity list, and hydrate
            newEntities.forEach(function (entity) {
                var wrapper = entity.wrapper, type = entity.type, id = entity.id, isReadonly = entity.isReadonly;
                entity.id = _this.ensureUniqueId(type, id, knownIds);
                (0, roosterjs_editor_dom_1$1F.commitEntity)(wrapper, type, isReadonly, entity.id); // Use entity.id here because it is newly updated
                _this.handleNewEntity(entity);
            });
            (0, roosterjs_editor_dom_1$1F.getObjectKeys)(this.state.shadowEntityCache).forEach(function (id) {
                _this.triggerEvent(_this.state.shadowEntityCache[id], 6 /* Overwrite */);
                delete _this.state.shadowEntityCache[id];
            });
            if (shouldNormalizeDelimiters &&
                ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.isFeatureEnabled("InlineEntityReadOnlyDelimiters" /* InlineEntityReadOnlyDelimiters */))) {
                (0, inlineEntityOnPluginEvent_1.normalizeDelimitersInEditor)(this.editor);
            }
        };
        EntityPlugin.prototype.handleEntityOperationEvent = function (event) {
            var _this = this;
            var _a;
            if (this.editor && REMOVE_ENTITY_OPERATIONS.indexOf(event.operation) >= 0) {
                (_a = this.cancelAsyncRun) === null || _a === void 0 ? void 0 : _a.call(this);
                this.cancelAsyncRun = this.editor.runAsync(function () {
                    _this.cancelAsyncRun = null;
                    _this.handleContentChangedEvent();
                });
            }
        };
        EntityPlugin.prototype.handleExtractContentWithDomEvent = function (root) {
            var _this = this;
            (0, roosterjs_editor_dom_1$1F.toArray)(root.querySelectorAll((0, roosterjs_editor_dom_1$1F.getEntitySelector)())).forEach(function (element) {
                element.removeAttribute('contentEditable');
                _this.triggerEvent(element, 8 /* ReplaceTemporaryContent */);
            });
        };
        EntityPlugin.prototype.checkRemoveEntityForRange = function (event) {
            var _this = this;
            var _a;
            var editableEntityElements = [];
            var selector = (0, roosterjs_editor_dom_1$1F.getEntitySelector)();
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.queryElements(selector, 1 /* OnSelection */, function (element) {
                if (element.isContentEditable) {
                    editableEntityElements.push(element);
                }
                else {
                    _this.triggerEvent(element, 6 /* Overwrite */, event);
                }
            });
            // For editable entities, we need to check if it is fully or partially covered by current selection,
            // and trigger different events;
            if (this.editor && editableEntityElements.length > 0) {
                var inSelectionEntityElements_1 = this.editor.queryElements(selector, 2 /* InSelection */);
                editableEntityElements.forEach(function (element) {
                    var isFullyCovered = inSelectionEntityElements_1.indexOf(element) >= 0;
                    _this.triggerEvent(element, isFullyCovered ? 6 /* Overwrite */ : 7 /* PartialOverwrite */, event);
                });
            }
        };
        EntityPlugin.prototype.triggerEvent = function (element, operation, rawEvent, contentForShadowEntity) {
            var _a;
            var entity = element && (0, roosterjs_editor_dom_1$1F.getEntityFromElement)(element);
            if (entity) {
                (_a = this.editor) === null || _a === void 0 ? void 0 : _a.triggerPluginEvent(15 /* EntityOperation */, {
                    operation: operation,
                    rawEvent: rawEvent,
                    entity: entity,
                    contentForShadowEntity: contentForShadowEntity,
                });
            }
        };
        EntityPlugin.prototype.handleNewEntity = function (entity) {
            var _a, _b;
            var wrapper = entity.wrapper;
            var fragment = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getDocument().createDocumentFragment();
            var cache = this.state.shadowEntityCache[entity.id];
            delete this.state.shadowEntityCache[entity.id];
            if (fragment && (cache === null || cache === void 0 ? void 0 : cache.shadowRoot)) {
                (0, roosterjs_editor_dom_1$1F.moveChildNodes)(fragment, cache.shadowRoot);
            }
            this.triggerEvent(wrapper, 0 /* NewEntity */, undefined /*rawEvent*/, fragment);
            // If there is element to hydrate for shadow entity, create shadow root and mount these elements to shadow root
            // Then trigger AddShadowRoot so that plugins can do further actions
            if (fragment === null || fragment === void 0 ? void 0 : fragment.firstChild) {
                if (wrapper.shadowRoot) {
                    (0, roosterjs_editor_dom_1$1F.moveChildNodes)(wrapper.shadowRoot, fragment);
                }
                else {
                    this.createShadowRoot(wrapper, fragment);
                }
            }
            else if (wrapper.shadowRoot) {
                // If no elements to hydrate, remove existing shadow root by cloning a new node
                this.triggerEvent(wrapper, 10 /* RemoveShadowRoot */);
                var newWrapper = wrapper.cloneNode();
                (0, roosterjs_editor_dom_1$1F.moveChildNodes)(newWrapper, wrapper);
                (_b = this.editor) === null || _b === void 0 ? void 0 : _b.replaceNode(wrapper, newWrapper);
                entity.wrapper = newWrapper;
            }
            this.setIsEntityKnown(entity.wrapper, true /*isKnown*/);
        };
        EntityPlugin.prototype.getExistingEntities = function (shadowEntityOnly) {
            var _a, _b;
            return ((_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.queryElements((0, roosterjs_editor_dom_1$1F.getEntitySelector)()).map(roosterjs_editor_dom_1$1F.getEntityFromElement).filter(function (x) { return !!x && (!shadowEntityOnly || !!x.wrapper.shadowRoot); })) !== null && _b !== void 0 ? _b : []);
        };
        EntityPlugin.prototype.createShadowRoot = function (wrapper, shadowContentContainer) {
            if (wrapper.attachShadow) {
                var shadowRoot = wrapper.attachShadow({
                    mode: 'open',
                    delegatesFocus: true,
                });
                wrapper.contentEditable = 'false';
                this.triggerEvent(wrapper, 9 /* AddShadowRoot */);
                (0, roosterjs_editor_dom_1$1F.moveChildNodes)(shadowRoot, shadowContentContainer);
                return shadowRoot;
            }
        };
        EntityPlugin.prototype.cacheShadowEntities = function (cache) {
            this.getExistingEntities(true /*shadowEntityOnly*/).forEach(function (_a) {
                var wrapper = _a.wrapper, id = _a.id;
                cache[id] = wrapper;
            });
        };
        EntityPlugin.prototype.ensureUniqueId = function (type, id, knownIds) {
            var match = ENTITY_ID_REGEX.exec(id);
            var baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;
            // Make sure entity id is unique
            var newId = '';
            for (var num = (match && parseInt(match[1])) || 0;; num++) {
                newId = num > 0 ? baseId + "_" + num : baseId;
                if (knownIds.indexOf(newId) < 0) {
                    knownIds.push(newId);
                    break;
                }
            }
            return newId;
        };
        EntityPlugin.prototype.setIsEntityKnown = function (wrapper, isKnown) {
            var index = this.state.knownEntityElements.indexOf(wrapper);
            if (isKnown && index < 0) {
                this.state.knownEntityElements.push(wrapper);
            }
            else if (!isKnown && index >= 0) {
                this.state.knownEntityElements.splice(index, 1);
            }
        };
        EntityPlugin.prototype.isEntityKnown = function (wrapper) {
            return this.state.knownEntityElements.indexOf(wrapper) >= 0;
        };
        return EntityPlugin;
    }());
    EntityPlugin$1.default = EntityPlugin;
    /**
     * IE will show a resize border around the readonly content within content editable DIV
     * This is a workaround to remove it by temporarily move focus out of editor
     */
    var workaroundSelectionIssueForIE = roosterjs_editor_dom_1$1F.Browser.isIE
        ? function (editor) {
            editor.runAsync(function (editor) {
                var workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', function () {
                    var button = (0, roosterjs_editor_dom_1$1F.createElement)({
                        tag: 'button',
                        style: 'overflow:hidden;position:fixed;width:0;height:0;top:-1000px',
                    }, editor.getDocument());
                    button.onblur = function () {
                        button.style.display = 'none';
                    };
                    editor.insertNode(button, {
                        position: 4 /* Outside */,
                    });
                    return button;
                });
                workaroundButton.style.display = '';
                (0, roosterjs_editor_dom_1$1F.addRangeToSelection)((0, roosterjs_editor_dom_1$1F.createRange)(workaroundButton, 0));
            });
        }
        : function () { };

    var ImageSelection$1 = {};

    Object.defineProperty(ImageSelection$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$1E = lib$3;
    var Escape = 'Escape';
    var Delete = 'Delete';
    var mouseRightButton = 2;
    var mouseLeftButton = 0;
    /**
     * Detect image selection and help highlight the image
     */
    var ImageSelection = /** @class */ (function () {
        function ImageSelection() {
            this.editor = null;
        }
        /**
         * Get a friendly name of  this plugin
         */
        ImageSelection.prototype.getName = function () {
            return 'ImageSelection';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        ImageSelection.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        ImageSelection.prototype.dispose = function () {
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.select(null);
            this.editor = null;
        };
        ImageSelection.prototype.onPluginEvent = function (event) {
            var _a;
            if (this.editor) {
                switch (event.eventType) {
                    case 17 /* EnteredShadowEdit */:
                    case 18 /* LeavingShadowEdit */:
                        var selection = this.editor.getSelectionRangeEx();
                        if (selection.type == 2 /* ImageSelection */) {
                            this.editor.select(selection.image);
                        }
                        break;
                    case 6 /* MouseUp */:
                        var target = event.rawEvent.target;
                        if ((0, roosterjs_editor_dom_1$1E.safeInstanceOf)(target, 'HTMLImageElement')) {
                            if (event.rawEvent.button === mouseRightButton) {
                                var imageRange = (0, roosterjs_editor_dom_1$1E.createRange)(target);
                                this.editor.select(imageRange);
                            }
                            else if (event.rawEvent.button === mouseLeftButton) {
                                this.editor.select(target);
                            }
                        }
                        break;
                    case 5 /* MouseDown */:
                        var mouseTarget = event.rawEvent.target;
                        var mouseSelection = this.editor.getSelectionRangeEx();
                        if (mouseSelection &&
                            mouseSelection.type === 2 /* ImageSelection */ &&
                            mouseSelection.image !== mouseTarget) {
                            this.editor.select(null);
                        }
                        break;
                    case 2 /* KeyUp */:
                        var key = event.rawEvent.key;
                        var keyDownSelection = this.editor.getSelectionRangeEx();
                        if (keyDownSelection.type === 2 /* ImageSelection */) {
                            if (key === Escape) {
                                this.editor.select(keyDownSelection.image, -2 /* Before */);
                                (_a = this.editor.getSelectionRange()) === null || _a === void 0 ? void 0 : _a.collapse();
                                event.rawEvent.stopPropagation();
                            }
                            else if (key === Delete) {
                                this.editor.deleteNode(keyDownSelection.image);
                                event.rawEvent.preventDefault();
                            }
                            else {
                                this.editor.select(keyDownSelection.ranges[0]);
                            }
                        }
                        break;
                }
            }
        };
        return ImageSelection;
    }());
    ImageSelection$1.default = ImageSelection;

    var LifecyclePlugin$1 = {};

    var _a$3, _b$2;
    Object.defineProperty(LifecyclePlugin$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$1D = lib$3;
    var CONTENT_EDITABLE_ATTRIBUTE_NAME = 'contenteditable';
    var COMMANDS = roosterjs_editor_dom_1$1D.Browser.isFirefox
        ? (_a$3 = {},
            /**
             * Disable these object resizing for firefox since other browsers don't have these behaviors
             */
            _a$3["enableObjectResizing" /* EnableObjectResizing */] = false,
            _a$3["enableInlineTableEditing" /* EnableInlineTableEditing */] = false,
            _a$3) : roosterjs_editor_dom_1$1D.Browser.isIE
        ? (_b$2 = {},
            /**
             * Change the default paragraph separator to DIV. This is mainly for IE since its default setting is P
             */
            _b$2["defaultParagraphSeparator" /* DefaultParagraphSeparator */] = 'div',
            /**
             * Disable auto link feature in IE since we have our own implementation
             */
            _b$2["AutoUrlDetect" /* AutoUrlDetect */] = false,
            _b$2) : {};
    var DARK_MODE_DEFAULT_FORMAT = {
        backgroundColors: {
            darkModeColor: 'rgb(51,51,51)',
            lightModeColor: 'rgb(255,255,255)',
        },
        textColors: {
            darkModeColor: 'rgb(255,255,255)',
            lightModeColor: 'rgb(0,0,0)',
        },
    };
    /**
     * @internal
     * Lifecycle plugin handles editor initialization and disposing
     */
    var LifecyclePlugin = /** @class */ (function () {
        /**
         * Construct a new instance of LifecyclePlugin
         * @param options The editor options
         * @param contentDiv The editor content DIV
         */
        function LifecyclePlugin(options, contentDiv) {
            var _this = this;
            var _a, _b, _c;
            this.editor = null;
            this.initializer = null;
            this.disposer = null;
            this.initialContent = options.initialContent || contentDiv.innerHTML || '';
            this.contentDivFormat = (0, roosterjs_editor_dom_1$1D.getComputedStyles)(contentDiv);
            // Make the container editable and set its selection styles
            if (contentDiv.getAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME) === null) {
                this.initializer = function () {
                    contentDiv.contentEditable = 'true';
                    contentDiv.style.userSelect = 'text';
                    contentDiv.style.webkitUserSelect = 'text';
                };
                this.disposer = function () {
                    contentDiv.style.userSelect = '';
                    contentDiv.style.webkitUserSelect = '';
                    contentDiv.removeAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME);
                };
            }
            this.adjustColor = options.doNotAdjustEditorColor
                ? function () { }
                : function () {
                    var _a;
                    var textColors = DARK_MODE_DEFAULT_FORMAT.textColors, backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;
                    var isDarkMode = _this.state.isDarkMode;
                    var darkColorHandler = (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getDarkColorHandler();
                    (0, roosterjs_editor_dom_1$1D.setColor)(contentDiv, textColors, false /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
                    (0, roosterjs_editor_dom_1$1D.setColor)(contentDiv, backgroundColors, true /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
                };
            this.state = {
                customData: {},
                defaultFormat: (_a = options.defaultFormat) !== null && _a !== void 0 ? _a : null,
                isDarkMode: !!options.inDarkMode,
                getDarkColor: (_b = options.getDarkColor) !== null && _b !== void 0 ? _b : (function (color) { return color; }),
                onExternalContentTransform: (_c = options.onExternalContentTransform) !== null && _c !== void 0 ? _c : null,
                experimentalFeatures: options.experimentalFeatures || [],
                shadowEditFragment: null,
                shadowEditEntities: null,
                shadowEditSelectionPath: null,
                shadowEditTableSelectionPath: null,
                shadowEditImageSelectionPath: null,
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        LifecyclePlugin.prototype.getName = function () {
            return 'Lifecycle';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        LifecyclePlugin.prototype.initialize = function (editor) {
            var _a;
            this.editor = editor;
            // Calculate default format
            this.recalculateDefaultFormat();
            // Ensure initial content and its format
            this.editor.setContent(this.initialContent, false /*triggerContentChangedEvent*/);
            // Set content DIV to be editable
            (_a = this.initializer) === null || _a === void 0 ? void 0 : _a.call(this);
            // Set editor background color for dark mode
            this.adjustColor();
            // Do proper change for browsers to disable some browser-specified behaviors.
            this.adjustBrowserBehavior();
            // Let other plugins know that we are ready
            this.editor.triggerPluginEvent(11 /* EditorReady */, {}, true /*broadcast*/);
        };
        /**
         * Dispose this plugin
         */
        LifecyclePlugin.prototype.dispose = function () {
            var _this = this;
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.triggerPluginEvent(12 /* BeforeDispose */, {}, true /*broadcast*/);
            (0, roosterjs_editor_dom_1$1D.getObjectKeys)(this.state.customData).forEach(function (key) {
                var data = _this.state.customData[key];
                if (data && data.disposer) {
                    data.disposer(data.value);
                }
                delete _this.state.customData[key];
            });
            if (this.disposer) {
                this.disposer();
                this.disposer = null;
                this.initializer = null;
            }
            this.editor = null;
        };
        /**
         * Get plugin state object
         */
        LifecyclePlugin.prototype.getState = function () {
            return this.state;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        LifecyclePlugin.prototype.onPluginEvent = function (event) {
            if (event.eventType == 7 /* ContentChanged */ &&
                (event.source == "SwitchToDarkMode" /* SwitchToDarkMode */ ||
                    event.source == "SwitchToLightMode" /* SwitchToLightMode */)) {
                this.state.isDarkMode = event.source == "SwitchToDarkMode" /* SwitchToDarkMode */;
                this.recalculateDefaultFormat();
                this.adjustColor();
            }
        };
        LifecyclePlugin.prototype.adjustBrowserBehavior = function () {
            var _this = this;
            (0, roosterjs_editor_dom_1$1D.getObjectKeys)(COMMANDS).forEach(function (command) {
                var _a;
                // Catch any possible exception since this should not block the initialization of editor
                try {
                    (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getDocument().execCommand(command, false, COMMANDS[command]);
                }
                catch (_b) { }
            });
        };
        LifecyclePlugin.prototype.recalculateDefaultFormat = function () {
            var _a = this.state, baseFormat = _a.defaultFormat, isDarkMode = _a.isDarkMode;
            if (isDarkMode && baseFormat) {
                if (!baseFormat.backgroundColors) {
                    baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;
                }
                if (!baseFormat.textColors) {
                    baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;
                }
            }
            if (baseFormat && (0, roosterjs_editor_dom_1$1D.getObjectKeys)(baseFormat).length === 0) {
                return;
            }
            var _b = baseFormat || {}, fontFamily = _b.fontFamily, fontSize = _b.fontSize, textColor = _b.textColor, textColors = _b.textColors, backgroundColor = _b.backgroundColor, backgroundColors = _b.backgroundColors, bold = _b.bold, italic = _b.italic, underline = _b.underline;
            var defaultFormat = this.contentDivFormat;
            this.state.defaultFormat = {
                fontFamily: fontFamily || defaultFormat[0],
                fontSize: fontSize || defaultFormat[1],
                get textColor() {
                    return textColors
                        ? isDarkMode
                            ? textColors.darkModeColor
                            : textColors.lightModeColor
                        : textColor || defaultFormat[2];
                },
                textColors: textColors,
                get backgroundColor() {
                    return backgroundColors
                        ? isDarkMode
                            ? backgroundColors.darkModeColor
                            : backgroundColors.lightModeColor
                        : backgroundColor || '';
                },
                backgroundColors: backgroundColors,
                bold: bold,
                italic: italic,
                underline: underline,
            };
        };
        return LifecyclePlugin;
    }());
    LifecyclePlugin$1.default = LifecyclePlugin;

    var MouseUpPlugin$1 = {};

    Object.defineProperty(MouseUpPlugin$1, "__esModule", { value: true });
    /**
     * @internal
     * MouseUpPlugin help trigger MouseUp event even when mouse up happens outside editor
     * as long as the mouse was pressed within Editor before
     */
    var MouseUpPlugin = /** @class */ (function () {
        function MouseUpPlugin() {
            var _this = this;
            this.editor = null;
            this.mouseUpEventListerAdded = false;
            this.mouseDownX = null;
            this.mouseDownY = null;
            this.onMouseUp = function (rawEvent) {
                if (_this.editor) {
                    _this.removeMouseUpEventListener();
                    _this.editor.triggerPluginEvent(6 /* MouseUp */, {
                        rawEvent: rawEvent,
                        isClicking: _this.mouseDownX == rawEvent.pageX && _this.mouseDownY == rawEvent.pageY,
                    });
                }
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        MouseUpPlugin.prototype.getName = function () {
            return 'MouseUp';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        MouseUpPlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        MouseUpPlugin.prototype.dispose = function () {
            this.removeMouseUpEventListener();
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        MouseUpPlugin.prototype.onPluginEvent = function (event) {
            if (this.editor &&
                event.eventType == 5 /* MouseDown */ &&
                !this.mouseUpEventListerAdded) {
                this.editor
                    .getDocument()
                    .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);
                this.mouseUpEventListerAdded = true;
                this.mouseDownX = event.rawEvent.pageX;
                this.mouseDownY = event.rawEvent.pageY;
            }
        };
        MouseUpPlugin.prototype.removeMouseUpEventListener = function () {
            if (this.editor && this.mouseUpEventListerAdded) {
                this.mouseUpEventListerAdded = false;
                this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);
            }
        };
        return MouseUpPlugin;
    }());
    MouseUpPlugin$1.default = MouseUpPlugin;

    var NormalizeTablePlugin$1 = {};

    Object.defineProperty(NormalizeTablePlugin$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$1C = lib$3;
    /**
     * @internal
     * TODO: Rename this plugin since it is not only for table now
     *
     * NormalizeTable plugin makes sure each table in editor has TBODY/THEAD/TFOOT tag around TR tags
     *
     * When we retrieve HTML content using innerHTML, browser will always add TBODY around TR nodes if there is not.
     * This causes some issue when we restore the HTML content with selection path since the selection path is
     * deeply coupled with DOM structure. So we need to always make sure there is already TBODY tag whenever
     * new table is inserted, to make sure the selection path we created is correct.
     */
    var NormalizeTablePlugin = /** @class */ (function () {
        function NormalizeTablePlugin() {
            this.editor = null;
        }
        /**
         * Get a friendly name of this plugin
         */
        NormalizeTablePlugin.prototype.getName = function () {
            return 'NormalizeTable';
        };
        /**
         * The first method that editor will call to a plugin when editor is initializing.
         * It will pass in the editor instance, plugin should take this chance to save the
         * editor reference so that it can call to any editor method or format API later.
         * @param editor The editor object
         */
        NormalizeTablePlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * The last method that editor will call to a plugin before it is disposed.
         * Plugin can take this chance to clear the reference to editor. After this method is
         * called, plugin should not call to any editor method since it will result in error.
         */
        NormalizeTablePlugin.prototype.dispose = function () {
            this.editor = null;
        };
        /**
         * Core method for a plugin. Once an event happens in editor, editor will call this
         * method of each plugin to handle the event as long as the event is not handled
         * exclusively by another plugin.
         * @param event The event to handle:
         */
        NormalizeTablePlugin.prototype.onPluginEvent = function (event) {
            switch (event.eventType) {
                case 11 /* EditorReady */:
                case 7 /* ContentChanged */:
                    if (this.editor) {
                        this.normalizeTables(this.editor.queryElements('table'));
                    }
                    break;
                case 10 /* BeforePaste */:
                    this.normalizeTables((0, roosterjs_editor_dom_1$1C.toArray)(event.fragment.querySelectorAll('table')));
                    break;
                case 5 /* MouseDown */:
                    this.normalizeTableFromEvent(event.rawEvent);
                    break;
                case 0 /* KeyDown */:
                    if (event.rawEvent.shiftKey) {
                        this.normalizeTableFromEvent(event.rawEvent);
                    }
                    break;
                case 8 /* ExtractContentWithDom */:
                    normalizeListsForExport(event.clonedRoot);
                    break;
            }
        };
        NormalizeTablePlugin.prototype.normalizeTableFromEvent = function (event) {
            var _a;
            var table = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor('table', event.target);
            if (table) {
                this.normalizeTables([table]);
            }
        };
        NormalizeTablePlugin.prototype.normalizeTables = function (tables) {
            if (this.editor && tables.length > 0) {
                var rangeEx = this.editor.getSelectionRangeEx();
                var _a = ((rangeEx === null || rangeEx === void 0 ? void 0 : rangeEx.type) == 0 /* Normal */ && rangeEx.ranges[0]) || {}, startContainer = _a.startContainer, endContainer = _a.endContainer, startOffset = _a.startOffset, endOffset = _a.endOffset;
                var isChanged = normalizeTables(tables);
                if (isChanged) {
                    if (startContainer &&
                        endContainer &&
                        typeof startOffset === 'number' &&
                        typeof endOffset === 'number') {
                        this.editor.select(startContainer, startOffset, endContainer, endOffset);
                    }
                    else if ((rangeEx === null || rangeEx === void 0 ? void 0 : rangeEx.type) == 1 /* TableSelection */ &&
                        rangeEx.coordinates) {
                        this.editor.select(rangeEx.table, rangeEx.coordinates);
                    }
                }
            }
        };
        return NormalizeTablePlugin;
    }());
    NormalizeTablePlugin$1.default = NormalizeTablePlugin;
    function normalizeTables(tables) {
        var isDOMChanged = false;
        tables.forEach(function (table) {
            var _a;
            var tbody = null;
            for (var child = table.firstChild; child; child = child.nextSibling) {
                var tag = (0, roosterjs_editor_dom_1$1C.getTagOfNode)(child);
                switch (tag) {
                    case 'TR':
                        if (!tbody) {
                            tbody = table.ownerDocument.createElement('tbody');
                            table.insertBefore(tbody, child);
                        }
                        tbody.appendChild(child);
                        child = tbody;
                        isDOMChanged = true;
                        break;
                    case 'TBODY':
                        if (tbody) {
                            (0, roosterjs_editor_dom_1$1C.moveChildNodes)(tbody, child, true /*keepExistingChildren*/);
                            (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);
                            child = tbody;
                            isDOMChanged = true;
                        }
                        else {
                            tbody = child;
                        }
                        break;
                    default:
                        tbody = null;
                        break;
                }
            }
            var colgroups = table.querySelectorAll('colgroup');
            var thead = table.querySelector('thead');
            if (thead) {
                colgroups.forEach(function (colgroup) {
                    if (!thead.contains(colgroup)) {
                        thead.appendChild(colgroup);
                    }
                });
            }
        });
        return isDOMChanged;
    }
    function normalizeListsForExport(root) {
        (0, roosterjs_editor_dom_1$1C.toArray)(root.querySelectorAll('li')).forEach(function (li) {
            var prevElement = li.previousSibling;
            if (li.style.display == 'block' && (0, roosterjs_editor_dom_1$1C.safeInstanceOf)(prevElement, 'HTMLLIElement')) {
                li.style.removeProperty('display');
                prevElement.appendChild((0, roosterjs_editor_dom_1$1C.changeElementTag)(li, 'div'));
            }
        });
    }

    var PendingFormatStatePlugin$1 = {};

    Object.defineProperty(PendingFormatStatePlugin$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$1B = lib$3;
    var ZERO_WIDTH_SPACE$1 = '\u200B';
    /**
     * @internal
     * PendingFormatStatePlugin handles pending format state management
     */
    var PendingFormatStatePlugin = /** @class */ (function () {
        /**
         * Construct a new instance of PendingFormatStatePlugin
         * @param options The editor options
         * @param contentDiv The editor content DIV
         */
        function PendingFormatStatePlugin() {
            this.editor = null;
            this.state = {
                pendableFormatPosition: null,
                pendableFormatState: null,
                pendableFormatSpan: null,
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        PendingFormatStatePlugin.prototype.getName = function () {
            return 'PendingFormatState';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        PendingFormatStatePlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        PendingFormatStatePlugin.prototype.dispose = function () {
            this.editor = null;
            this.clear();
        };
        /**
         * Get plugin state object
         */
        PendingFormatStatePlugin.prototype.getState = function () {
            return this.state;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        PendingFormatStatePlugin.prototype.onPluginEvent = function (event) {
            switch (event.eventType) {
                case 13 /* PendingFormatStateChanged */:
                    // Got PendingFormatStateChanged event, cache current position and pending format if a format is passed in
                    // otherwise clear existing pending format.
                    if (event.formatState) {
                        this.state.pendableFormatPosition = this.getCurrentPosition();
                        this.state.pendableFormatState = event.formatState;
                        this.state.pendableFormatSpan = event.formatCallback
                            ? this.createPendingFormatSpan(event.formatCallback)
                            : null;
                    }
                    else {
                        this.clear();
                    }
                    break;
                case 0 /* KeyDown */:
                case 5 /* MouseDown */:
                case 7 /* ContentChanged */:
                    var currentPosition = null;
                    if (this.editor &&
                        event.eventType == 0 /* KeyDown */ &&
                        (0, roosterjs_editor_dom_1$1B.isCharacterValue)(event.rawEvent) &&
                        this.state.pendableFormatSpan) {
                        this.state.pendableFormatSpan.removeAttribute('contentEditable');
                        this.editor.insertNode(this.state.pendableFormatSpan);
                        this.editor.select(this.state.pendableFormatSpan, 0 /* Begin */, this.state.pendableFormatSpan, -1 /* End */);
                        this.clear();
                    }
                    else if ((event.eventType == 0 /* KeyDown */ &&
                        event.rawEvent.which >= 33 /* PAGEUP */ &&
                        event.rawEvent.which <= 40 /* DOWN */) ||
                        (this.state.pendableFormatPosition &&
                            (currentPosition = this.getCurrentPosition()) &&
                            !this.state.pendableFormatPosition.equalTo(currentPosition)) ||
                        (event.eventType == 7 /* ContentChanged */ &&
                            (event.source == "SwitchToDarkMode" /* SwitchToDarkMode */ ||
                                event.source == "SwitchToLightMode" /* SwitchToLightMode */))) {
                        // If content or position is changed (by keyboard, mouse, or code),
                        // check if current position is still the same with the cached one (if exist),
                        // and clear cached format if position is changed since it is out-of-date now
                        this.clear();
                    }
                    break;
            }
        };
        PendingFormatStatePlugin.prototype.clear = function () {
            this.state.pendableFormatPosition = null;
            this.state.pendableFormatState = null;
            this.state.pendableFormatSpan = null;
        };
        PendingFormatStatePlugin.prototype.getCurrentPosition = function () {
            var _a, _b;
            var range = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
            return (_b = (range && roosterjs_editor_dom_1$1B.Position.getStart(range).normalize())) !== null && _b !== void 0 ? _b : null;
        };
        PendingFormatStatePlugin.prototype.createPendingFormatSpan = function (callback) {
            var _a, _b;
            var span = this.state.pendableFormatSpan;
            if (!span && this.editor) {
                var currentStyle = this.editor.getStyleBasedFormatState();
                var doc = this.editor.getDocument();
                var isDarkMode = this.editor.isDarkMode();
                span = doc.createElement('span');
                span.contentEditable = 'true';
                span.appendChild(doc.createTextNode(ZERO_WIDTH_SPACE$1));
                span.style.setProperty('font-family', (_a = currentStyle.fontName) !== null && _a !== void 0 ? _a : null);
                span.style.setProperty('font-size', (_b = currentStyle.fontSize) !== null && _b !== void 0 ? _b : null);
                var darkColorHandler = this.editor.getDarkColorHandler();
                if (currentStyle.textColors || currentStyle.textColor) {
                    (0, roosterjs_editor_dom_1$1B.setColor)(span, (currentStyle.textColors || currentStyle.textColor), false /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
                }
                if (currentStyle.backgroundColors || currentStyle.backgroundColor) {
                    (0, roosterjs_editor_dom_1$1B.setColor)(span, (currentStyle.backgroundColors || currentStyle.backgroundColor), true /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
                }
            }
            if (span) {
                callback(span);
            }
            return span;
        };
        return PendingFormatStatePlugin;
    }());
    PendingFormatStatePlugin$1.default = PendingFormatStatePlugin;

    var TypeInContainerPlugin$1 = {};

    Object.defineProperty(TypeInContainerPlugin$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$1A = lib$3;
    /**
     * @internal
     * Typing Component helps to ensure typing is always happening under a DOM container
     */
    var TypeInContainerPlugin = /** @class */ (function () {
        function TypeInContainerPlugin() {
            this.editor = null;
        }
        /**
         * Get a friendly name of  this plugin
         */
        TypeInContainerPlugin.prototype.getName = function () {
            return 'TypeInContainer';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        TypeInContainerPlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        TypeInContainerPlugin.prototype.dispose = function () {
            this.editor = null;
        };
        TypeInContainerPlugin.prototype.isRangeEmpty = function (range) {
            if (range.collapsed &&
                range.startContainer.nodeType === Node.ELEMENT_NODE &&
                (0, roosterjs_editor_dom_1$1A.getTagOfNode)(range.startContainer) == 'DIV' &&
                !range.startContainer.firstChild) {
                return true;
            }
            return false;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        TypeInContainerPlugin.prototype.onPluginEvent = function (event) {
            var _this = this;
            var _a, _b, _c, _d, _e, _f;
            // We need to check if the ctrl key or the meta key is pressed,
            // browsers like Safari fire the "keypress" event when the meta key is pressed.
            if (event.eventType == 1 /* KeyPress */ &&
                this.editor &&
                !(event.rawEvent && (0, roosterjs_editor_dom_1$1A.isCtrlOrMetaPressed)(event.rawEvent))) {
                // If normalization was not possible before the keypress,
                // check again after the keyboard event has been processed by browser native behavior.
                //
                // This handles the case where the keyboard event that first inserts content happens when
                // there is already content under the selection (e.g. Ctrl+a -> type new content).
                //
                // Only schedule when the range is not collapsed to catch this edge case.
                var range = this.editor.getSelectionRange();
                var styledAncestor = range &&
                    (0, roosterjs_editor_dom_1$1A.findClosestElementAncestor)(range.startContainer, undefined /* root */, '[style]');
                if (!range || (!this.isRangeEmpty(range) && this.editor.contains(styledAncestor))) {
                    return;
                }
                if (range.collapsed) {
                    this.editor.ensureTypeInContainer(roosterjs_editor_dom_1$1A.Position.getStart(range), event.rawEvent);
                }
                else {
                    var callback = function () {
                        var _a, _b;
                        var focusedPosition = (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getFocusedPosition();
                        if (focusedPosition) {
                            (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.ensureTypeInContainer(focusedPosition, event.rawEvent);
                        }
                    };
                    if (roosterjs_editor_dom_1$1A.Browser.isMobileOrTablet) {
                        (_a = this.editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.setTimeout(callback, 100);
                    }
                    else {
                        this.editor.runAsync(callback);
                    }
                }
            }
            /**
             * Add a Span with default format to the previous element when pressing backspace
             */
            if (event.eventType == 0 /* KeyDown */ &&
                event.rawEvent.which == 8 /* BACKSPACE */ &&
                ((_b = this.editor) === null || _b === void 0 ? void 0 : _b.isFeatureEnabled("DefaultFormatInSpan" /* DefaultFormatInSpan */))) {
                var element = (_c = this.editor) === null || _c === void 0 ? void 0 : _c.getElementAtCursor();
                var block_1 = element &&
                    ((_e = (_d = this.editor) === null || _d === void 0 ? void 0 : _d.getBlockElementAtNode(element)) === null || _e === void 0 ? void 0 : _e.getStartNode().previousSibling);
                if (block_1) {
                    (_f = this.editor) === null || _f === void 0 ? void 0 : _f.runAsync(function (editor) {
                        var position = editor.getFocusedPosition();
                        if (position && block_1 == position.element) {
                            editor.ensureTypeInContainer(position, event.rawEvent);
                        }
                    });
                }
            }
        };
        return TypeInContainerPlugin;
    }());
    TypeInContainerPlugin$1.default = TypeInContainerPlugin;

    var UndoPlugin$1 = {};

    Object.defineProperty(UndoPlugin$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$1z = lib$3;
    // Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped
    // to keep size under limit. This is kept at 10MB
    var MAX_SIZE_LIMIT = 1e7;
    /**
     * @internal
     * Provides snapshot based undo service for Editor
     */
    var UndoPlugin = /** @class */ (function () {
        /**
         * Construct a new instance of UndoPlugin
         * @param options The wrapper of the state object
         */
        function UndoPlugin(options) {
            this.editor = null;
            this.lastKeyPress = null;
            this.state = {
                snapshotsService: options.undoMetadataSnapshotService ||
                    createUndoSnapshotServiceBridge(options.undoSnapshotService) ||
                    createUndoSnapshots(),
                isRestoring: false,
                hasNewContent: false,
                isNested: false,
                autoCompletePosition: null,
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        UndoPlugin.prototype.getName = function () {
            return 'Undo';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        UndoPlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        UndoPlugin.prototype.dispose = function () {
            this.editor = null;
        };
        /**
         * Get plugin state object
         */
        UndoPlugin.prototype.getState = function () {
            return this.state;
        };
        /**
         * Check if the plugin should handle the given event exclusively.
         * @param event The event to check
         */
        UndoPlugin.prototype.willHandleEventExclusively = function (event) {
            return (event.eventType == 0 /* KeyDown */ &&
                event.rawEvent.which == 8 /* BACKSPACE */ &&
                this.canUndoAutoComplete());
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        UndoPlugin.prototype.onPluginEvent = function (event) {
            // if editor is in IME, don't do anything
            if (!this.editor || this.editor.isInIME()) {
                return;
            }
            switch (event.eventType) {
                case 11 /* EditorReady */:
                    var undoState = this.editor.getUndoState();
                    if (!undoState.canUndo && !undoState.canRedo) {
                        // Only add initial snapshot when there is no existing snapshot
                        // Otherwise preserved undo/redo state may be ruined
                        this.addUndoSnapshot();
                    }
                    break;
                case 0 /* KeyDown */:
                    this.onKeyDown(event.rawEvent);
                    break;
                case 1 /* KeyPress */:
                    this.onKeyPress(event.rawEvent);
                    break;
                case 4 /* CompositionEnd */:
                    this.clearRedoForInput();
                    this.addUndoSnapshot();
                    break;
                case 7 /* ContentChanged */:
                    if (!(this.state.isRestoring ||
                        event.source == "SwitchToDarkMode" /* SwitchToDarkMode */ ||
                        event.source == "SwitchToLightMode" /* SwitchToLightMode */)) {
                        this.clearRedoForInput();
                    }
                    break;
            }
        };
        UndoPlugin.prototype.onKeyDown = function (evt) {
            var _a, _b;
            // Handle backspace/delete when there is a selection to take a snapshot
            // since we want the state prior to deletion restorable
            // Ignore if keycombo is ALT+BACKSPACE
            if ((evt.which == 8 /* BACKSPACE */ && !evt.altKey) || evt.which == 46 /* DELETE */) {
                if (evt.which == 8 /* BACKSPACE */ && this.canUndoAutoComplete()) {
                    evt.preventDefault();
                    (_a = this.editor) === null || _a === void 0 ? void 0 : _a.undo();
                    this.state.autoCompletePosition = null;
                    this.lastKeyPress = evt.which;
                }
                else {
                    var selectionRange = (_b = this.editor) === null || _b === void 0 ? void 0 : _b.getSelectionRange();
                    // Add snapshot when
                    // 1. Something has been selected (not collapsed), or
                    // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or
                    // 3. Ctrl/Meta key is pressed so that a whole word will be deleted
                    if (selectionRange &&
                        (!selectionRange.collapsed ||
                            this.lastKeyPress != evt.which ||
                            (0, roosterjs_editor_dom_1$1z.isCtrlOrMetaPressed)(evt))) {
                        this.addUndoSnapshot();
                    }
                    // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time
                    this.state.hasNewContent = true;
                    this.lastKeyPress = evt.which;
                }
            }
            else if (evt.which >= 33 /* PAGEUP */ && evt.which <= 40 /* DOWN */) {
                // PageUp, PageDown, Home, End, Left, Right, Up, Down
                if (this.state.hasNewContent) {
                    this.addUndoSnapshot();
                }
                this.lastKeyPress = 0;
            }
        };
        UndoPlugin.prototype.onKeyPress = function (evt) {
            var _a;
            if (evt.metaKey) {
                // if metaKey is pressed, simply return since no actual effect will be taken on the editor.
                // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.
                return;
            }
            var range = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
            if ((range && !range.collapsed) ||
                (evt.which == 32 /* SPACE */ && this.lastKeyPress != 32 /* SPACE */) ||
                evt.which == 13 /* ENTER */) {
                this.addUndoSnapshot();
                if (evt.which == 13 /* ENTER */) {
                    // Treat ENTER as new content so if there is no input after ENTER and undo,
                    // we restore the snapshot before ENTER
                    this.state.hasNewContent = true;
                }
            }
            else {
                this.clearRedoForInput();
            }
            this.lastKeyPress = evt.which;
        };
        UndoPlugin.prototype.clearRedoForInput = function () {
            this.state.snapshotsService.clearRedo();
            this.lastKeyPress = 0;
            this.state.hasNewContent = true;
        };
        UndoPlugin.prototype.canUndoAutoComplete = function () {
            var _a, _b;
            var focusedPosition = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getFocusedPosition();
            return (this.state.snapshotsService.canUndoAutoComplete() &&
                !!focusedPosition &&
                !!((_b = this.state.autoCompletePosition) === null || _b === void 0 ? void 0 : _b.equalTo(focusedPosition)));
        };
        UndoPlugin.prototype.addUndoSnapshot = function () {
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.addUndoSnapshot();
            this.state.autoCompletePosition = null;
        };
        return UndoPlugin;
    }());
    UndoPlugin$1.default = UndoPlugin;
    function createUndoSnapshots() {
        var snapshots = (0, roosterjs_editor_dom_1$1z.createSnapshots)(MAX_SIZE_LIMIT);
        return {
            canMove: function (delta) { return (0, roosterjs_editor_dom_1$1z.canMoveCurrentSnapshot)(snapshots, delta); },
            move: function (delta) { return (0, roosterjs_editor_dom_1$1z.moveCurrentSnapshot)(snapshots, delta); },
            addSnapshot: function (snapshot, isAutoCompleteSnapshot) {
                return (0, roosterjs_editor_dom_1$1z.addSnapshotV2)(snapshots, snapshot, isAutoCompleteSnapshot);
            },
            clearRedo: function () { return (0, roosterjs_editor_dom_1$1z.clearProceedingSnapshotsV2)(snapshots); },
            canUndoAutoComplete: function () { return (0, roosterjs_editor_dom_1$1z.canUndoAutoComplete)(snapshots); },
        };
    }
    function createUndoSnapshotServiceBridge(service) {
        var html;
        return service
            ? {
                canMove: function (delta) { return service.canMove(delta); },
                move: function (delta) {
                    return (html = service.move(delta)) ? { html: html, metadata: null, knownColors: [] } : null;
                },
                addSnapshot: function (snapshot, isAutoCompleteSnapshot) {
                    return service.addSnapshot(snapshot.html +
                        (snapshot.metadata ? "<!--" + JSON.stringify(snapshot.metadata) + "-->" : ''), isAutoCompleteSnapshot);
                },
                clearRedo: function () { return service.clearRedo(); },
                canUndoAutoComplete: function () { return service.canUndoAutoComplete(); },
            }
            : undefined;
    }

    Object.defineProperty(createCorePlugins$1, "__esModule", { value: true });
    createCorePlugins$1.getPluginState = void 0;
    var CopyPastePlugin_1 = CopyPastePlugin$1;
    var DOMEventPlugin_1 = DOMEventPlugin$1;
    var EditPlugin_1 = EditPlugin$1;
    var EntityPlugin_1 = EntityPlugin$1;
    var ImageSelection_1 = ImageSelection$1;
    var LifecyclePlugin_1 = LifecyclePlugin$1;
    var MouseUpPlugin_1 = MouseUpPlugin$1;
    var NormalizeTablePlugin_1 = NormalizeTablePlugin$1;
    var PendingFormatStatePlugin_1 = PendingFormatStatePlugin$1;
    var TypeInContainerPlugin_1 = TypeInContainerPlugin$1;
    var UndoPlugin_1 = UndoPlugin$1;
    /**
     * @internal
     * Create Core Plugins
     * @param contentDiv Content DIV of editor
     * @param options Editor options
     */
    function createCorePlugins(contentDiv, options) {
        var map = options.corePluginOverride || {};
        // The order matters, some plugin needs to be put before/after others to make sure event
        // can be handled in right order
        return {
            typeInContainer: map.typeInContainer || new TypeInContainerPlugin_1.default(),
            edit: map.edit || new EditPlugin_1.default(),
            pendingFormatState: map.pendingFormatState || new PendingFormatStatePlugin_1.default(),
            _placeholder: null,
            typeAfterLink: null,
            undo: map.undo || new UndoPlugin_1.default(options),
            domEvent: map.domEvent || new DOMEventPlugin_1.default(options, contentDiv),
            mouseUp: map.mouseUp || new MouseUpPlugin_1.default(),
            copyPaste: map.copyPaste || new CopyPastePlugin_1.default(options),
            entity: map.entity || new EntityPlugin_1.default(),
            imageSelection: map.imageSelection || new ImageSelection_1.default(),
            normalizeTable: map.normalizeTable || new NormalizeTablePlugin_1.default(),
            lifecycle: map.lifecycle || new LifecyclePlugin_1.default(options, contentDiv),
        };
    }
    createCorePlugins$1.default = createCorePlugins;
    /**
     * @internal
     * Get plugin state of core plugins
     * @param corePlugins CorePlugins object
     */
    function getPluginState(corePlugins) {
        return {
            domEvent: corePlugins.domEvent.getState(),
            pendingFormatState: corePlugins.pendingFormatState.getState(),
            edit: corePlugins.edit.getState(),
            lifecycle: corePlugins.lifecycle.getState(),
            undo: corePlugins.undo.getState(),
            entity: corePlugins.entity.getState(),
            copyPaste: corePlugins.copyPaste.getState(),
        };
    }
    createCorePlugins$1.getPluginState = getPluginState;

    var DarkColorHandlerImpl$1 = {};

    Object.defineProperty(DarkColorHandlerImpl$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$1y = lib$3;
    var VARIABLE_REGEX = /^\s*var\(\s*(\-\-[a-zA-Z0-9\-_]+)\s*(?:,\s*(.*))?\)\s*$/;
    var VARIABLE_PREFIX = 'var(';
    var COLOR_VAR_PREFIX = 'darkColor';
    /**
     * @internal
     */
    var DarkColorHandlerImpl = /** @class */ (function () {
        function DarkColorHandlerImpl(contentDiv, getDarkColor) {
            this.contentDiv = contentDiv;
            this.getDarkColor = getDarkColor;
            this.knownColors = {};
        }
        /**
         * Get a copy of known colors
         * @returns
         */
        DarkColorHandlerImpl.prototype.getKnownColorsCopy = function () {
            return Object.values(this.knownColors);
        };
        /**
         * Given a light mode color value and an optional dark mode color value, register this color
         * so that editor can handle it, then return the CSS color value for current color mode.
         * @param lightModeColor Light mode color value
         * @param isDarkMode Whether current color mode is dark mode
         * @param darkModeColor Optional dark mode color value. If not passed, we will calculate one.
         */
        DarkColorHandlerImpl.prototype.registerColor = function (lightModeColor, isDarkMode, darkModeColor) {
            var parsedColor = this.parseColorValue(lightModeColor);
            var colorKey;
            if (parsedColor) {
                lightModeColor = parsedColor.lightModeColor;
                darkModeColor = parsedColor.darkModeColor || darkModeColor;
                colorKey = parsedColor.key;
            }
            if (isDarkMode && lightModeColor) {
                colorKey =
                    colorKey || "--" + COLOR_VAR_PREFIX + "_" + lightModeColor.replace(/[^\d\w]/g, '_');
                if (!this.knownColors[colorKey]) {
                    darkModeColor = darkModeColor || this.getDarkColor(lightModeColor);
                    this.knownColors[colorKey] = { lightModeColor: lightModeColor, darkModeColor: darkModeColor };
                    this.contentDiv.style.setProperty(colorKey, darkModeColor);
                }
                return "var(" + colorKey + ", " + lightModeColor + ")";
            }
            else {
                return lightModeColor;
            }
        };
        /**
         * Reset known color record, clean up registered color variables.
         */
        DarkColorHandlerImpl.prototype.reset = function () {
            var _this = this;
            (0, roosterjs_editor_dom_1$1y.getObjectKeys)(this.knownColors).forEach(function (key) { return _this.contentDiv.style.removeProperty(key); });
            this.knownColors = {};
        };
        /**
         * Parse an existing color value, if it is in variable-based color format, extract color key,
         * light color and query related dark color if any
         * @param color The color string to parse
         * @param isInDarkMode Whether current content is in dark mode. When set to true, if the color value is not in dark var format,
         * we will treat is as a dark mode color and try to find a matched dark mode color.
         */
        DarkColorHandlerImpl.prototype.parseColorValue = function (color, isInDarkMode) {
            var _a;
            var key;
            var lightModeColor = '';
            var darkModeColor;
            if (color) {
                var match = color.startsWith(VARIABLE_PREFIX) ? VARIABLE_REGEX.exec(color) : null;
                if (match) {
                    if (match[2]) {
                        key = match[1];
                        lightModeColor = match[2];
                        darkModeColor = (_a = this.knownColors[key]) === null || _a === void 0 ? void 0 : _a.darkModeColor;
                    }
                    else {
                        lightModeColor = '';
                    }
                }
                else if (isInDarkMode) {
                    // If editor is in dark mode but the color is not in dark color format, it is possible the color was inserted from external code
                    // without any light color info. So we first try to see if there is a known dark color can match this color, and use its related
                    // light color as light mode color. Otherwise we need to drop this color to avoid show "white on white" content.
                    lightModeColor = this.findLightColorFromDarkColor(color) || '';
                    if (lightModeColor) {
                        darkModeColor = color;
                    }
                }
                else {
                    lightModeColor = color;
                }
            }
            return { key: key, lightModeColor: lightModeColor, darkModeColor: darkModeColor };
        };
        /**
         * Find related light mode color from dark mode color.
         * @param darkColor The existing dark color
         */
        DarkColorHandlerImpl.prototype.findLightColorFromDarkColor = function (darkColor) {
            var _this = this;
            var rgbSearch = (0, roosterjs_editor_dom_1$1y.parseColor)(darkColor);
            if (rgbSearch) {
                var key = (0, roosterjs_editor_dom_1$1y.getObjectKeys)(this.knownColors).find(function (key) {
                    var rgbCurrent = (0, roosterjs_editor_dom_1$1y.parseColor)(_this.knownColors[key].darkModeColor);
                    return (rgbCurrent &&
                        rgbCurrent[0] == rgbSearch[0] &&
                        rgbCurrent[1] == rgbSearch[1] &&
                        rgbCurrent[2] == rgbSearch[2]);
                });
                if (key) {
                    return this.knownColors[key].lightModeColor;
                }
            }
            return null;
        };
        return DarkColorHandlerImpl;
    }());
    DarkColorHandlerImpl$1.default = DarkColorHandlerImpl;

    var coreApiMap = {};

    var addUndoSnapshot$1 = {};

    var __assign$f = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$f = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$f.apply(this, arguments);
    };
    Object.defineProperty(addUndoSnapshot$1, "__esModule", { value: true });
    addUndoSnapshot$1.addUndoSnapshot = void 0;
    var roosterjs_editor_dom_1$1x = lib$3;
    /**
     * @internal
     * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.
     * Undo snapshot will not be added if this call is nested inside another addUndoSnapshot() call.
     * @param core The EditorCore object
     * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.
     * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent
     * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).
     * @param formatApiName Optional parameter to provide the ContentChangeEvent which FormatApi was invoked.
     */
    var addUndoSnapshot = function (core, callback, changeSource, canUndoByBackspace, additionalData) {
        var undoState = core.undo;
        var isNested = undoState.isNested;
        var data;
        if (!isNested) {
            undoState.isNested = true;
            addUndoSnapshotInternal(core, canUndoByBackspace);
        }
        try {
            if (callback) {
                var range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);
                data = callback(range && roosterjs_editor_dom_1$1x.Position.getStart(range).normalize(), range && roosterjs_editor_dom_1$1x.Position.getEnd(range).normalize());
                if (!isNested) {
                    addUndoSnapshotInternal(core, false /*isAutoCompleteSnapshot*/);
                }
            }
        }
        finally {
            if (!isNested) {
                undoState.isNested = false;
            }
        }
        if (callback && changeSource) {
            var event_1 = {
                eventType: 7 /* ContentChanged */,
                source: changeSource,
                data: data,
                additionalData: additionalData,
            };
            core.api.triggerEvent(core, event_1, true /*broadcast*/);
        }
        if (canUndoByBackspace) {
            var range = core.api.getSelectionRange(core, false /*tryGetFromCache*/);
            if (range) {
                core.undo.hasNewContent = false;
                core.undo.autoCompletePosition = roosterjs_editor_dom_1$1x.Position.getStart(range);
            }
        }
    };
    addUndoSnapshot$1.addUndoSnapshot = addUndoSnapshot;
    function addUndoSnapshotInternal(core, canUndoByBackspace) {
        var _a;
        if (!core.lifecycle.shadowEditFragment) {
            var rangeEx = core.api.getSelectionRangeEx(core);
            var isDarkMode = core.lifecycle.isDarkMode;
            var metadata = createContentMetadata(core.contentDiv, rangeEx, isDarkMode) || null;
            core.undo.snapshotsService.addSnapshot({
                html: core.contentDiv.innerHTML,
                metadata: metadata,
                knownColors: ((_a = core.darkColorHandler) === null || _a === void 0 ? void 0 : _a.getKnownColorsCopy()) || [],
            }, canUndoByBackspace);
            core.undo.hasNewContent = false;
        }
    }
    function createContentMetadata(root, rangeEx, isDarkMode) {
        switch (rangeEx === null || rangeEx === void 0 ? void 0 : rangeEx.type) {
            case 1 /* TableSelection */:
                return __assign$f({ type: 1 /* TableSelection */, tableId: rangeEx.table.id, isDarkMode: !!isDarkMode }, rangeEx.coordinates);
            case 2 /* ImageSelection */:
                return {
                    type: 2 /* ImageSelection */,
                    imageId: rangeEx.image.id,
                    isDarkMode: !!isDarkMode,
                };
            case 0 /* Normal */:
                return __assign$f({ type: 0 /* Normal */, isDarkMode: !!isDarkMode, start: [], end: [] }, ((0, roosterjs_editor_dom_1$1x.getSelectionPath)(root, rangeEx.ranges[0]) || {}));
        }
    }

    var attachDomEvent$1 = {};

    Object.defineProperty(attachDomEvent$1, "__esModule", { value: true });
    attachDomEvent$1.attachDomEvent = void 0;
    var roosterjs_editor_dom_1$1w = lib$3;
    /**
     * @internal
     * Attach a DOM event to the editor content DIV
     * @param core The EditorCore object
     * @param eventName The DOM event name
     * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered
     * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event
     */
    var attachDomEvent = function (core, eventMap) {
        var disposers = (0, roosterjs_editor_dom_1$1w.getObjectKeys)(eventMap || {}).map(function (key) {
            var _a = extractHandler(eventMap[key]), pluginEventType = _a.pluginEventType, beforeDispatch = _a.beforeDispatch;
            var eventName = key;
            var onEvent = function (event) {
                if (beforeDispatch) {
                    beforeDispatch(event);
                }
                if (pluginEventType != null) {
                    core.api.triggerEvent(core, {
                        eventType: pluginEventType,
                        rawEvent: event,
                    }, false /*broadcast*/);
                }
            };
            core.contentDiv.addEventListener(eventName, onEvent);
            return function () {
                core.contentDiv.removeEventListener(eventName, onEvent);
            };
        });
        return function () { return disposers.forEach(function (disposers) { return disposers(); }); };
    };
    attachDomEvent$1.attachDomEvent = attachDomEvent;
    function extractHandler(handlerObj) {
        var result = {
            pluginEventType: null,
            beforeDispatch: null,
        };
        if (typeof handlerObj === 'number') {
            result.pluginEventType = handlerObj;
        }
        else if (typeof handlerObj === 'function') {
            result.beforeDispatch = handlerObj;
        }
        else if (typeof handlerObj === 'object') {
            result = handlerObj;
        }
        return result;
    }

    var createPasteFragment$1 = {};

    Object.defineProperty(createPasteFragment$1, "__esModule", { value: true });
    createPasteFragment$1.transformTabCharacters = createPasteFragment$1.createPasteFragment = void 0;
    var roosterjs_editor_dom_1$1v = lib$3;
    var START_FRAGMENT = '<!--StartFragment-->';
    var END_FRAGMENT = '<!--EndFragment-->';
    var NBSP_HTML = '\u00A0';
    var ENSP_HTML = '\u2002';
    var TAB_SPACES$1 = 6;
    /**
     * @internal
     * Create a DocumentFragment for paste from a ClipboardData
     * @param core The EditorCore object.
     * @param clipboardData Clipboard data retrieved from clipboard
     * @param position The position to paste to
     * @param pasteAsText True to force use plain text as the content to paste, false to choose HTML or Image if any
     * @param applyCurrentStyle True if apply format of current selection to the pasted content,
     * false to keep original format
     */
    var createPasteFragment = function (core, clipboardData, position, pasteAsText, applyCurrentStyle) {
        var _a, _b;
        if (!clipboardData) {
            return null;
        }
        // Step 1: Prepare BeforePasteEvent object
        var event = createBeforePasteEvent(core, clipboardData);
        var fragment = event.fragment, sanitizingOption = event.sanitizingOption;
        var rawHtml = clipboardData.rawHtml, text = clipboardData.text, imageDataUri = clipboardData.imageDataUri;
        var document = core.contentDiv.ownerDocument;
        var doc = rawHtml
            ? new DOMParser().parseFromString(core.trustedHTMLHandler(rawHtml), 'text/html')
            : undefined;
        // Step 2: Retrieve Metadata from Html and the Html that was copied.
        if (rawHtml && (doc === null || doc === void 0 ? void 0 : doc.body)) {
            var attributes = (_a = doc.querySelector('html')) === null || _a === void 0 ? void 0 : _a.attributes;
            (attributes ? (0, roosterjs_editor_dom_1$1v.toArray)(attributes) : []).reduce(function (attrs, attr) {
                attrs[attr.name] = attr.value;
                return attrs;
            }, event.htmlAttributes);
            (0, roosterjs_editor_dom_1$1v.toArray)(doc.querySelectorAll('meta')).reduce(function (attrs, meta) {
                attrs[meta.name] = meta.content;
                return attrs;
            }, event.htmlAttributes);
            clipboardData.htmlFirstLevelChildTags = [];
            doc === null || doc === void 0 ? void 0 : doc.body.normalize();
            for (var i = 0; i < (doc === null || doc === void 0 ? void 0 : doc.body.childNodes.length); i++) {
                var node = doc === null || doc === void 0 ? void 0 : doc.body.childNodes.item(i);
                if (node.nodeType == Node.TEXT_NODE) {
                    var trimmedString = (_b = node.nodeValue) === null || _b === void 0 ? void 0 : _b.replace(/(\r\n|\r|\n)/gm, '').trim();
                    if (!trimmedString) {
                        continue;
                    }
                }
                var nodeTag = (0, roosterjs_editor_dom_1$1v.getTagOfNode)(node);
                if (node.nodeType != Node.COMMENT_NODE) {
                    clipboardData.htmlFirstLevelChildTags.push(nodeTag);
                }
            }
            // Move all STYLE nodes into header, and save them into sanitizing options.
            // Because if we directly move them into a fragment, all sheets under STYLE will be lost.
            processStyles(doc, function (style) {
                doc === null || doc === void 0 ? void 0 : doc.head.appendChild(style);
                sanitizingOption.additionalGlobalStyleNodes.push(style);
            });
            var startIndex = rawHtml.indexOf(START_FRAGMENT);
            var endIndex = rawHtml.lastIndexOf(END_FRAGMENT);
            if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {
                event.htmlBefore = rawHtml.substr(0, startIndex);
                event.htmlAfter = rawHtml.substr(endIndex + END_FRAGMENT.length);
                clipboardData.html = rawHtml.substring(startIndex + START_FRAGMENT.length, endIndex);
                doc.body.innerHTML = core.trustedHTMLHandler(clipboardData.html);
                // Remove style nodes just added by setting innerHTML of body since we already have all
                // style nodes in header.
                // Here we use doc.body instead of doc because we only want to remove STYLE nodes under BODY
                // and the nodes under HEAD are still used when convert global CSS to inline
                processStyles(doc.body, function (style) { var _a; return (_a = style.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(style); });
            }
        }
        // Step 3: Fill the BeforePasteEvent object, especially the fragment for paste
        if (!pasteAsText && !text && imageDataUri) {
            // Paste image
            var img = document.createElement('img');
            img.style.maxWidth = '100%';
            img.src = imageDataUri;
            fragment.appendChild(img);
        }
        else if (!pasteAsText && rawHtml && doc ? doc.body : false) {
            (0, roosterjs_editor_dom_1$1v.moveChildNodes)(fragment, doc === null || doc === void 0 ? void 0 : doc.body);
            if (applyCurrentStyle && position) {
                var format_1 = getCurrentFormat(core, position.node);
                (0, roosterjs_editor_dom_1$1v.applyTextStyle)(fragment, function (node) { return (0, roosterjs_editor_dom_1$1v.applyFormat)(node, format_1); });
            }
        }
        else if (text) {
            // Paste text
            text.split('\n').forEach(function (line, index, lines) {
                line = line
                    .replace(/^ /g, NBSP_HTML)
                    .replace(/\r/g, '')
                    .replace(/ {2}/g, ' ' + NBSP_HTML);
                if (line.includes('\t')) {
                    line = transformTabCharacters(line, index === 0 ? position === null || position === void 0 ? void 0 : position.offset : 0);
                }
                var textNode = document.createTextNode(line);
                // There are 3 scenarios:
                // 1. Single line: Paste as it is
                // 2. Two lines: Add <br> between the lines
                // 3. 3 or More lines, For first and last line, paste as it is. For middle lines, wrap with DIV, and add BR if it is empty line
                if (lines.length == 2 && index == 0) {
                    // 1 of 2 lines scenario, add BR
                    fragment.appendChild(textNode);
                    fragment.appendChild(document.createElement('br'));
                }
                else if (index > 0 && index < lines.length - 1) {
                    // Middle line of >=3 lines scenario, wrap with DIV
                    fragment.appendChild((0, roosterjs_editor_dom_1$1v.wrap)(line == '' ? document.createElement('br') : textNode));
                }
                else {
                    // All others, paste as it is
                    fragment.appendChild(textNode);
                }
            });
        }
        // Step 4: Trigger BeforePasteEvent so that plugins can do proper change before paste
        core.api.triggerEvent(core, event, true /*broadcast*/);
        // Step 5. Sanitize the fragment before paste to make sure the content is safe
        var sanitizer = new roosterjs_editor_dom_1$1v.HtmlSanitizer(event.sanitizingOption);
        sanitizer.convertGlobalCssToInlineCss(fragment);
        sanitizer.sanitize(fragment, position ? (0, roosterjs_editor_dom_1$1v.getInheritableStyles)(position.element) : undefined);
        return fragment;
    };
    createPasteFragment$1.createPasteFragment = createPasteFragment;
    /**
     * @internal
     * Transform \t characters into EN SPACE characters
     * @param input string NOT containing \n characters
     * @example t("\thello", 2) => "&ensp;&ensp;&ensp;&ensp;hello"
     */
    function transformTabCharacters(input, initialOffset) {
        if (initialOffset === void 0) { initialOffset = 0; }
        var line = input;
        var tIndex;
        while ((tIndex = line.indexOf('\t')) != -1) {
            var lineBefore = line.slice(0, tIndex);
            var lineAfter = line.slice(tIndex + 1);
            var tabCount = TAB_SPACES$1 - ((lineBefore.length + initialOffset) % TAB_SPACES$1);
            var tabStr = Array(tabCount).fill(ENSP_HTML).join('');
            line = lineBefore + tabStr + lineAfter;
        }
        return line;
    }
    createPasteFragment$1.transformTabCharacters = transformTabCharacters;
    function getCurrentFormat(core, node) {
        var pendableFormat = core.api.getPendableFormatState(core, true /** forceGetStateFromDOM*/);
        var styleBasedFormat = core.api.getStyleBasedFormatState(core, node);
        return {
            fontFamily: styleBasedFormat.fontName,
            fontSize: styleBasedFormat.fontSize,
            textColor: styleBasedFormat.textColor,
            backgroundColor: styleBasedFormat.backgroundColor,
            textColors: styleBasedFormat.textColors,
            backgroundColors: styleBasedFormat.backgroundColors,
            bold: pendableFormat.isBold,
            italic: pendableFormat.isItalic,
            underline: pendableFormat.isUnderline,
        };
    }
    function createBeforePasteEvent(core, clipboardData) {
        var options = (0, roosterjs_editor_dom_1$1v.createDefaultHtmlSanitizerOptions)();
        // Remove "caret-color" style generated by Safari to make sure caret shows in right color after paste
        options.cssStyleCallbacks['caret-color'] = function () { return false; };
        return {
            eventType: 10 /* BeforePaste */,
            clipboardData: clipboardData,
            fragment: core.contentDiv.ownerDocument.createDocumentFragment(),
            sanitizingOption: options,
            htmlBefore: '',
            htmlAfter: '',
            htmlAttributes: {},
        };
    }
    function processStyles(node, callback) {
        (0, roosterjs_editor_dom_1$1v.toArray)(node.querySelectorAll('style')).forEach(callback);
    }

    var ensureTypeInContainer$1 = {};

    Object.defineProperty(ensureTypeInContainer$1, "__esModule", { value: true });
    ensureTypeInContainer$1.ensureTypeInContainer = void 0;
    var roosterjs_editor_dom_1$1u = lib$3;
    /**
     * @internal
     * When typing goes directly under content div, many things can go wrong
     * We fix it by wrapping it with a div and reposition cursor within the div
     */
    var ensureTypeInContainer = function (core, position, keyboardEvent, applyFormatToSpan) {
        var table = (0, roosterjs_editor_dom_1$1u.findClosestElementAncestor)(position.node, core.contentDiv, 'table');
        var td;
        if (table && (td = table.querySelector('td,th'))) {
            position = new roosterjs_editor_dom_1$1u.Position(td, 0 /* Begin */);
        }
        position = position.normalize();
        var block = (0, roosterjs_editor_dom_1$1u.getBlockElementAtNode)(core.contentDiv, position.node);
        var formatNode;
        if (block) {
            formatNode = block.collapseToSingleElement();
            if ((0, roosterjs_editor_dom_1$1u.isNodeEmpty)(formatNode, false /* trimContent */, true /* shouldCountBrAsVisible */)) {
                var brEl = formatNode.ownerDocument.createElement('br');
                formatNode.append(brEl);
            }
            // if the block is empty, apply default format
            // Otherwise, leave it as it is as we don't want to change the style for existing data
            // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)
            var shouldSetNodeStyles = (0, roosterjs_editor_dom_1$1u.isNodeEmpty)(formatNode) ||
                (keyboardEvent && wasNodeJustCreatedByKeyboardEvent(keyboardEvent, formatNode));
            formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;
            if (formatNode && core.lifecycle.defaultFormat && applyFormatToSpan) {
                var firstChild = formatNode.firstChild;
                formatNode = (0, roosterjs_editor_dom_1$1u.safeInstanceOf)(firstChild, 'HTMLSpanElement')
                    ? firstChild
                    : (0, roosterjs_editor_dom_1$1u.wrap)((0, roosterjs_editor_dom_1$1u.toArray)(formatNode.childNodes), 'span');
            }
        }
        else {
            // Only reason we don't get the selection block is that we have an empty content div
            // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)
            // The fix is to add a DIV wrapping, apply default format and move cursor over
            formatNode = (0, roosterjs_editor_dom_1$1u.createElement)(applyFormatToSpan
                ? 12 /* EmptyLineFormatInSpan */
                : 1 /* EmptyLine */, core.contentDiv.ownerDocument);
            core.api.insertNode(core, formatNode, {
                position: 1 /* End */,
                updateCursor: false,
                replaceSelection: false,
                insertOnNewLine: false,
            });
            formatNode = applyFormatToSpan ? formatNode.firstChild : formatNode;
            // element points to a wrapping node we added "<div><br></div>". We should move the selection left to <br>
            position = new roosterjs_editor_dom_1$1u.Position(formatNode, 0 /* Begin */);
        }
        if (formatNode && core.lifecycle.defaultFormat) {
            (0, roosterjs_editor_dom_1$1u.applyFormat)(formatNode, core.lifecycle.defaultFormat, core.lifecycle.isDarkMode, core.darkColorHandler);
        }
        // If this is triggered by a keyboard event, let's select the new position
        if (keyboardEvent) {
            core.api.selectRange(core, (0, roosterjs_editor_dom_1$1u.createRange)(new roosterjs_editor_dom_1$1u.Position(position)));
        }
    };
    ensureTypeInContainer$1.ensureTypeInContainer = ensureTypeInContainer;
    function wasNodeJustCreatedByKeyboardEvent(event, formatNode) {
        return ((0, roosterjs_editor_dom_1$1u.safeInstanceOf)(event.target, 'Node') &&
            event.target.contains(formatNode) &&
            event.key === formatNode.innerText);
    }

    var focus$1 = {};

    Object.defineProperty(focus$1, "__esModule", { value: true });
    focus$1.focus = void 0;
    var roosterjs_editor_dom_1$1t = lib$3;
    /**
     * @internal
     * Focus to editor. If there is a cached selection range, use it as current selection
     * @param core The EditorCore object
     */
    var focus = function (core) {
        if (!core.lifecycle.shadowEditFragment) {
            if (!core.api.hasFocus(core) ||
                !core.api.getSelectionRange(core, false /*tryGetFromCache*/)) {
                // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.
                // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).
                // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body
                // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).
                // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset
                // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).
                // It should be better than the case you cannot type
                if (!core.domEvent.selectionRange ||
                    !core.api.selectRange(core, core.domEvent.selectionRange, true /*skipSameRange*/)) {
                    var node = (0, roosterjs_editor_dom_1$1t.getFirstLeafNode)(core.contentDiv) || core.contentDiv;
                    core.api.selectRange(core, (0, roosterjs_editor_dom_1$1t.createRange)(node, 0 /* Begin */), true /*skipSameRange*/);
                }
            }
            // remember to clear cached selection range
            core.domEvent.selectionRange = null;
            // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor
            if (!core.api.hasFocus(core)) {
                core.contentDiv.focus();
            }
        }
    };
    focus$1.focus = focus;

    var getContent$1 = {};

    Object.defineProperty(getContent$1, "__esModule", { value: true });
    getContent$1.getContent = void 0;
    var roosterjs_editor_dom_1$1s = lib$3;
    /**
     * @internal
     * Get current editor content as HTML string
     * @param core The EditorCore object
     * @param mode specify what kind of HTML content to retrieve
     * @returns HTML string representing current editor content
     */
    var getContent = function (core, mode) {
        var content = '';
        var triggerExtractContentEvent = mode == 0 /* CleanHTML */;
        var includeSelectionMarker = mode == 2 /* RawHTMLWithSelection */;
        // When there is fragment for shadow edit, always use the cached fragment as document since HTML node in editor
        // has been changed by uncommitted shadow edit which should be ignored.
        var root = core.lifecycle.shadowEditFragment || core.contentDiv;
        if (mode == 4 /* PlainTextFast */) {
            content = root.textContent;
        }
        else if (mode == 3 /* PlainText */) {
            content = (0, roosterjs_editor_dom_1$1s.getTextContent)(root);
        }
        else if (triggerExtractContentEvent || core.lifecycle.isDarkMode || core.darkColorHandler) {
            var clonedRoot = cloneNode(root);
            clonedRoot.normalize();
            var originalRange = core.api.getSelectionRange(core, true /*tryGetFromCache*/);
            var path = !includeSelectionMarker
                ? null
                : core.lifecycle.shadowEditFragment
                    ? core.lifecycle.shadowEditSelectionPath
                    : originalRange
                        ? (0, roosterjs_editor_dom_1$1s.getSelectionPath)(core.contentDiv, originalRange)
                        : null;
            var range = path && (0, roosterjs_editor_dom_1$1s.createRange)(clonedRoot, path.start, path.end);
            if (core.lifecycle.isDarkMode || core.darkColorHandler) {
                core.api.transformColor(core, clonedRoot, false /*includeSelf*/, null /*callback*/, 1 /* DarkToLight */, !!core.darkColorHandler, core.lifecycle.isDarkMode);
            }
            if (triggerExtractContentEvent) {
                core.api.triggerEvent(core, {
                    eventType: 8 /* ExtractContentWithDom */,
                    clonedRoot: clonedRoot,
                }, true /*broadcast*/);
                content = clonedRoot.innerHTML;
            }
            else if (range) {
                // range is not null, which means we want to include a selection path in the content
                content = (0, roosterjs_editor_dom_1$1s.getHtmlWithSelectionPath)(clonedRoot, range);
            }
            else {
                content = clonedRoot.innerHTML;
            }
        }
        else {
            content = (0, roosterjs_editor_dom_1$1s.getHtmlWithSelectionPath)(root, includeSelectionMarker
                ? core.api.getSelectionRange(core, true /*tryGetFromCache*/)
                : null);
        }
        return content !== null && content !== void 0 ? content : '';
    };
    getContent$1.getContent = getContent;
    function cloneNode(node) {
        var clonedNode;
        if ((0, roosterjs_editor_dom_1$1s.safeInstanceOf)(node, 'DocumentFragment')) {
            clonedNode = node.ownerDocument.createElement('div');
            clonedNode.appendChild(node.cloneNode(true /*deep*/));
        }
        else {
            clonedNode = node.cloneNode(true /*deep*/);
        }
        return clonedNode;
    }

    var getPendableFormatState$1 = {};

    Object.defineProperty(getPendableFormatState$1, "__esModule", { value: true });
    getPendableFormatState$1.getPendableFormatState = void 0;
    var roosterjs_editor_dom_1$1r = lib$3;
    /**
     * @internal
     * @param core The EditorCore object
     * @param forceGetStateFromDOM If set to true, will force get the format state from DOM tree.
     * @returns The cached format state if it exists. If the cached position do not exist, search for pendable elements in the DOM tree and return the pendable format state.
     */
    var getPendableFormatState = function (core, forceGetStateFromDOM) {
        var _a;
        var range = core.api.getSelectionRange(core, true /* tryGetFromCache*/);
        var cachedPendableFormatState = core.pendingFormatState.pendableFormatState;
        var cachedPosition = (_a = core.pendingFormatState.pendableFormatPosition) === null || _a === void 0 ? void 0 : _a.normalize();
        var currentPosition = range && roosterjs_editor_dom_1$1r.Position.getStart(range).normalize();
        var isSamePosition = currentPosition &&
            cachedPosition &&
            range.collapsed &&
            currentPosition.equalTo(cachedPosition);
        if (range && cachedPendableFormatState && isSamePosition && !forceGetStateFromDOM) {
            return cachedPendableFormatState;
        }
        else {
            return currentPosition ? queryCommandStateFromDOM(core, currentPosition) : {};
        }
    };
    getPendableFormatState$1.getPendableFormatState = getPendableFormatState;
    var PendableStyleCheckers = {
        isBold: function (tag, style) {
            return tag == 'B' ||
                tag == 'STRONG' ||
                tag == 'H1' ||
                tag == 'H2' ||
                tag == 'H3' ||
                tag == 'H4' ||
                tag == 'H5' ||
                tag == 'H6' ||
                parseInt(style.fontWeight) >= 700 ||
                ['bold', 'bolder'].indexOf(style.fontWeight) >= 0;
        },
        isUnderline: function (tag, style) { return tag == 'U' || style.textDecoration.indexOf('underline') >= 0; },
        isItalic: function (tag, style) { return tag == 'I' || tag == 'EM' || style.fontStyle === 'italic'; },
        isSubscript: function (tag, style) { return tag == 'SUB' || style.verticalAlign === 'sub'; },
        isSuperscript: function (tag, style) { return tag == 'SUP' || style.verticalAlign === 'super'; },
        isStrikeThrough: function (tag, style) {
            return tag == 'S' || tag == 'STRIKE' || style.textDecoration.indexOf('line-through') >= 0;
        },
    };
    /**
     * CssFalsyCheckers checks for non pendable format that might overlay a pendable format, then it can prevent getPendableFormatState return falsy pendable format states.
     */
    var CssFalsyCheckers = {
        isBold: function (style) {
            return (style.fontWeight !== '' && parseInt(style.fontWeight) < 700) ||
                style.fontWeight === 'normal';
        },
        isUnderline: function (style) {
            return style.textDecoration !== '' && style.textDecoration.indexOf('underline') < 0;
        },
        isItalic: function (style) { return style.fontStyle !== '' && style.fontStyle !== 'italic'; },
        isSubscript: function (style) { return style.verticalAlign !== '' && style.verticalAlign !== 'sub'; },
        isSuperscript: function (style) { return style.verticalAlign !== '' && style.verticalAlign !== 'super'; },
        isStrikeThrough: function (style) {
            return style.textDecoration !== '' && style.textDecoration.indexOf('line-through') < 0;
        },
    };
    function queryCommandStateFromDOM(core, currentPosition) {
        var node = currentPosition.node;
        var formatState = {};
        var pendableKeys = [];
        var _loop_1 = function () {
            var tag = (0, roosterjs_editor_dom_1$1r.getTagOfNode)(node);
            var style = node.nodeType == 1 /* Element */ && node.style;
            if (tag && style) {
                (0, roosterjs_editor_dom_1$1r.getObjectKeys)(PendableStyleCheckers).forEach(function (key) {
                    if (!(pendableKeys.indexOf(key) >= 0)) {
                        formatState[key] = formatState[key] || PendableStyleCheckers[key](tag, style);
                        if (CssFalsyCheckers[key](style)) {
                            pendableKeys.push(key);
                        }
                    }
                });
            }
            node = node.parentNode;
        };
        while (node && (0, roosterjs_editor_dom_1$1r.contains)(core.contentDiv, node)) {
            _loop_1();
        }
        return formatState;
    }

    var getSelectionRange$1 = {};

    Object.defineProperty(getSelectionRange$1, "__esModule", { value: true });
    getSelectionRange$1.getSelectionRange = void 0;
    var roosterjs_editor_dom_1$1q = lib$3;
    /**
     * @internal
     * Get current or cached selection range
     * @param core The EditorCore object
     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now
     * @returns A Range object of the selection range
     */
    var getSelectionRange = function (core, tryGetFromCache) {
        var _a;
        var result = null;
        if (core.lifecycle.shadowEditFragment) {
            result =
                core.lifecycle.shadowEditSelectionPath &&
                    (0, roosterjs_editor_dom_1$1q.createRange)(core.contentDiv, core.lifecycle.shadowEditSelectionPath.start, core.lifecycle.shadowEditSelectionPath.end);
            return result;
        }
        else {
            if (!tryGetFromCache || core.api.hasFocus(core)) {
                var selection = (_a = core.contentDiv.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
                if (selection && selection.rangeCount > 0) {
                    var range = selection.getRangeAt(0);
                    if ((0, roosterjs_editor_dom_1$1q.contains)(core.contentDiv, range)) {
                        result = range;
                    }
                }
            }
            if (!result && tryGetFromCache) {
                result = core.domEvent.selectionRange;
            }
            return result;
        }
    };
    getSelectionRange$1.getSelectionRange = getSelectionRange;

    var getSelectionRangeEx$1 = {};

    Object.defineProperty(getSelectionRangeEx$1, "__esModule", { value: true });
    getSelectionRangeEx$1.getSelectionRangeEx = void 0;
    var roosterjs_editor_dom_1$1p = lib$3;
    /**
     * @internal
     * Get current or cached selection range
     * @param core The EditorCore object
     * @returns A Range object of the selection range
     */
    var getSelectionRangeEx = function (core) {
        var _a, _b, _c;
        if (core.lifecycle.shadowEditFragment) {
            var _d = core.lifecycle, shadowEditTableSelectionPath = _d.shadowEditTableSelectionPath, shadowEditSelectionPath = _d.shadowEditSelectionPath, shadowEditImageSelectionPath = _d.shadowEditImageSelectionPath;
            if (((shadowEditTableSelectionPath === null || shadowEditTableSelectionPath === void 0 ? void 0 : shadowEditTableSelectionPath.length) || 0) > 0) {
                var ranges = core.lifecycle.shadowEditTableSelectionPath.map(function (path) {
                    return (0, roosterjs_editor_dom_1$1p.createRange)(core.contentDiv, path.start, path.end);
                });
                return {
                    type: 1 /* TableSelection */,
                    ranges: ranges,
                    areAllCollapsed: checkAllCollapsed(ranges),
                    table: (0, roosterjs_editor_dom_1$1p.findClosestElementAncestor)(ranges[0].startContainer, core.contentDiv, 'table'),
                    coordinates: undefined,
                };
            }
            else if (((shadowEditImageSelectionPath === null || shadowEditImageSelectionPath === void 0 ? void 0 : shadowEditImageSelectionPath.length) || 0) > 0) {
                var ranges = core.lifecycle.shadowEditImageSelectionPath.map(function (path) {
                    return (0, roosterjs_editor_dom_1$1p.createRange)(core.contentDiv, path.start, path.end);
                });
                return {
                    type: 2 /* ImageSelection */,
                    ranges: ranges,
                    areAllCollapsed: checkAllCollapsed(ranges),
                    image: (0, roosterjs_editor_dom_1$1p.findClosestElementAncestor)(ranges[0].startContainer, core.contentDiv, 'img'),
                    imageId: undefined,
                };
            }
            else {
                var shadowRange = shadowEditSelectionPath &&
                    (0, roosterjs_editor_dom_1$1p.createRange)(core.contentDiv, shadowEditSelectionPath.start, shadowEditSelectionPath.end);
                return createNormalSelectionEx(shadowRange ? [shadowRange] : []);
            }
        }
        else {
            if (core.api.hasFocus(core)) {
                if (core.domEvent.tableSelectionRange) {
                    return core.domEvent.tableSelectionRange;
                }
                if (core.domEvent.imageSelectionRange) {
                    return core.domEvent.imageSelectionRange;
                }
                var selection = (_a = core.contentDiv.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
                if (selection && selection.rangeCount > 0) {
                    var range = selection.getRangeAt(0);
                    if ((0, roosterjs_editor_dom_1$1p.contains)(core.contentDiv, range)) {
                        return createNormalSelectionEx([range]);
                    }
                }
            }
            return ((_c = (_b = core.domEvent.tableSelectionRange) !== null && _b !== void 0 ? _b : core.domEvent.imageSelectionRange) !== null && _c !== void 0 ? _c : createNormalSelectionEx(core.domEvent.selectionRange ? [core.domEvent.selectionRange] : []));
        }
    };
    getSelectionRangeEx$1.getSelectionRangeEx = getSelectionRangeEx;
    function createNormalSelectionEx(ranges) {
        return {
            type: 0 /* Normal */,
            ranges: ranges,
            areAllCollapsed: checkAllCollapsed(ranges),
        };
    }
    function checkAllCollapsed(ranges) {
        return ranges.filter(function (range) { return range === null || range === void 0 ? void 0 : range.collapsed; }).length == ranges.length;
    }

    var getStyleBasedFormatState$1 = {};

    Object.defineProperty(getStyleBasedFormatState$1, "__esModule", { value: true });
    getStyleBasedFormatState$1.getStyleBasedFormatState = void 0;
    var roosterjs_editor_dom_1$1o = lib$3;
    var ORIGINAL_STYLE_COLOR_SELECTOR = "[data-" + "ogsc" /* OriginalStyleColor */ + "],[data-" + "ogac" /* OriginalAttributeColor */ + "]";
    var ORIGINAL_STYLE_BACK_COLOR_SELECTOR = "[data-" + "ogsb" /* OriginalStyleBackgroundColor */ + "],[data-" + "ogab" /* OriginalAttributeBackgroundColor */ + "]";
    /**
     * @internal
     * Get style based format state from current selection, including font name/size and colors
     * @param core The EditorCore objects
     * @param node The node to get style from
     */
    var getStyleBasedFormatState = function (core, node) {
        if (!node) {
            return {};
        }
        var override = [];
        var pendableFormatSpan = core.pendingFormatState.pendableFormatSpan;
        if (pendableFormatSpan) {
            override = [
                pendableFormatSpan.style.fontFamily,
                pendableFormatSpan.style.fontSize,
                pendableFormatSpan.style.color,
                pendableFormatSpan.style.backgroundColor,
            ];
        }
        var styles = node
            ? (0, roosterjs_editor_dom_1$1o.getComputedStyles)(node, [
                'font-family',
                'font-size',
                'color',
                'background-color',
                'line-height',
                'margin-top',
                'margin-bottom',
                'text-align',
                'direction',
            ])
            : [];
        var contentDiv = core.contentDiv, darkColorHandler = core.darkColorHandler, isDarkMode = core.lifecycle.isDarkMode;
        if (darkColorHandler) {
            var styleTextColor = void 0;
            var styleBackColor = void 0;
            while (node &&
                (0, roosterjs_editor_dom_1$1o.contains)(contentDiv, node, true /*treatSameNodeAsContain*/) &&
                !(styleTextColor && styleBackColor)) {
                if (node.nodeType == 1 /* Element */) {
                    var element = node;
                    styleTextColor = styleTextColor || element.style.getPropertyValue('color');
                    styleBackColor =
                        styleBackColor || element.style.getPropertyValue('background-color');
                }
                node = node.parentNode;
            }
            if (!core.lifecycle.isDarkMode && node == core.contentDiv) {
                styleTextColor = styleTextColor || styles[2];
                styleBackColor = styleBackColor || styles[3];
            }
            var textColor = darkColorHandler.parseColorValue(override[2] || styleTextColor);
            var backColor = darkColorHandler.parseColorValue(override[3] || styleBackColor);
            return {
                fontName: override[0] || styles[0],
                fontSize: override[1] || styles[1],
                textColor: textColor.lightModeColor,
                backgroundColor: backColor.lightModeColor,
                textColors: textColor.darkModeColor
                    ? {
                        lightModeColor: textColor.lightModeColor,
                        darkModeColor: textColor.darkModeColor,
                    }
                    : undefined,
                backgroundColors: backColor.darkModeColor
                    ? {
                        lightModeColor: backColor.lightModeColor,
                        darkModeColor: backColor.darkModeColor,
                    }
                    : undefined,
                lineHeight: styles[4],
                marginTop: styles[5],
                marginBottom: styles[6],
                textAlign: styles[7],
                direction: styles[8],
            };
        }
        else {
            var ogTextColorNode = isDarkMode &&
                (override[2]
                    ? pendableFormatSpan
                    : (0, roosterjs_editor_dom_1$1o.findClosestElementAncestor)(node, contentDiv, ORIGINAL_STYLE_COLOR_SELECTOR));
            var ogBackgroundColorNode = isDarkMode &&
                (override[3]
                    ? pendableFormatSpan
                    : (0, roosterjs_editor_dom_1$1o.findClosestElementAncestor)(node, contentDiv, ORIGINAL_STYLE_BACK_COLOR_SELECTOR));
            return {
                fontName: override[0] || styles[0],
                fontSize: override[1] || styles[1],
                textColor: override[2] || styles[2],
                backgroundColor: override[3] || styles[3],
                textColors: ogTextColorNode
                    ? {
                        darkModeColor: override[2] || styles[2],
                        lightModeColor: ogTextColorNode.dataset["ogsc" /* OriginalStyleColor */] ||
                            ogTextColorNode.dataset["ogac" /* OriginalAttributeColor */] ||
                            styles[2],
                    }
                    : undefined,
                backgroundColors: ogBackgroundColorNode
                    ? {
                        darkModeColor: override[3] || styles[3],
                        lightModeColor: ogBackgroundColorNode.dataset["ogsb" /* OriginalStyleBackgroundColor */] ||
                            ogBackgroundColorNode.dataset["ogab" /* OriginalAttributeBackgroundColor */] ||
                            styles[3],
                    }
                    : undefined,
                lineHeight: styles[4],
                textAlign: styles[7],
                direction: styles[8],
            };
        }
    };
    getStyleBasedFormatState$1.getStyleBasedFormatState = getStyleBasedFormatState;

    var hasFocus$1 = {};

    Object.defineProperty(hasFocus$1, "__esModule", { value: true });
    hasFocus$1.hasFocus = void 0;
    var roosterjs_editor_dom_1$1n = lib$3;
    /**
     * @internal
     * Check if the editor has focus now
     * @param core The EditorCore object
     * @returns True if the editor has focus, otherwise false
     */
    var hasFocus = function (core) {
        var activeElement = core.contentDiv.ownerDocument.activeElement;
        return !!(activeElement && (0, roosterjs_editor_dom_1$1n.contains)(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/));
    };
    hasFocus$1.hasFocus = hasFocus;

    var insertNode$1 = {};

    Object.defineProperty(insertNode$1, "__esModule", { value: true });
    insertNode$1.insertNode = void 0;
    var roosterjs_editor_dom_1$1m = lib$3;
    function getInitialRange(core, option) {
        // Selection start replaces based on the current selection.
        // Range inserts based on a provided range.
        // Both have the potential to use the current selection to restore cursor position
        // So in both cases we need to store the selection state.
        var range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);
        var rangeToRestore = null;
        if (option.position == 5 /* Range */) {
            rangeToRestore = range;
            range = option.range;
        }
        else if (range) {
            rangeToRestore = range.cloneRange();
        }
        return { range: range, rangeToRestore: rangeToRestore };
    }
    /**
     * @internal
     * Insert a DOM node into editor content
     * @param core The EditorCore object. No op if null.
     * @param option An insert option object to specify how to insert the node
     */
    var insertNode = function (core, node, option) {
        var _a;
        option = option || {
            position: 3 /* SelectionStart */,
            insertOnNewLine: false,
            updateCursor: true,
            replaceSelection: true,
            insertToRegionRoot: false,
        };
        var contentDiv = core.contentDiv;
        if (option.updateCursor) {
            core.api.focus(core);
        }
        if (option.position == 4 /* Outside */) {
            (_a = contentDiv.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(node, contentDiv.nextSibling);
            return true;
        }
        core.api.transformColor(core, node, true /*includeSelf*/, function () {
            var _a, _b;
            if (!option) {
                return;
            }
            switch (option.position) {
                case 0 /* Begin */:
                case 1 /* End */: {
                    var isBegin = option.position == 0 /* Begin */;
                    var block = (0, roosterjs_editor_dom_1$1m.getFirstLastBlockElement)(contentDiv, isBegin);
                    var insertedNode_1;
                    if (block) {
                        var refNode = isBegin ? block.getStartNode() : block.getEndNode();
                        if (option.insertOnNewLine ||
                            refNode.nodeType == 3 /* Text */ ||
                            (0, roosterjs_editor_dom_1$1m.isVoidHtmlElement)(refNode)) {
                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)
                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the
                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV
                            if ((0, roosterjs_editor_dom_1$1m.safeInstanceOf)(node, 'DocumentFragment')) {
                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode
                                // because insertBefore() returns an empty DocumentFragment
                                insertedNode_1 = (0, roosterjs_editor_dom_1$1m.toArray)(node.childNodes);
                                (_a = refNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(node, isBegin ? refNode : refNode.nextSibling);
                            }
                            else {
                                insertedNode_1 = (_b = refNode.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(node, isBegin ? refNode : refNode.nextSibling);
                            }
                        }
                        else {
                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)
                            // i.e. <div>hello</div>, the content will be inserted before/after hello
                            insertedNode_1 = refNode.insertBefore(node, isBegin ? refNode.firstChild : null);
                        }
                    }
                    else {
                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv
                        insertedNode_1 = contentDiv.appendChild(node);
                    }
                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,
                    // add a DIV wrapping
                    if (insertedNode_1 && option.insertOnNewLine) {
                        var nodes = Array.isArray(insertedNode_1) ? insertedNode_1 : [insertedNode_1];
                        if (!(0, roosterjs_editor_dom_1$1m.isBlockElement)(nodes[0]) || !(0, roosterjs_editor_dom_1$1m.isBlockElement)(nodes[nodes.length - 1])) {
                            (0, roosterjs_editor_dom_1$1m.wrap)(nodes);
                        }
                    }
                    break;
                }
                case 2 /* DomEnd */:
                    // Use appendChild to insert the node at the end of the content div.
                    var insertedNode = contentDiv.appendChild(node);
                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,
                    // add a DIV wrapping
                    if (insertedNode && option.insertOnNewLine && !(0, roosterjs_editor_dom_1$1m.isBlockElement)(insertedNode)) {
                        (0, roosterjs_editor_dom_1$1m.wrap)(insertedNode);
                    }
                    break;
                case 5 /* Range */:
                case 3 /* SelectionStart */:
                    var _c = getInitialRange(core, option), range = _c.range, rangeToRestore = _c.rangeToRestore;
                    if (!range) {
                        return;
                    }
                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first
                    if (option.replaceSelection && !range.collapsed) {
                        range.deleteContents();
                    }
                    var pos = roosterjs_editor_dom_1$1m.Position.getStart(range);
                    var blockElement = void 0;
                    if (option.insertOnNewLine && option.insertToRegionRoot) {
                        pos = adjustInsertPositionRegionRoot(core, range, pos);
                    }
                    else if (option.insertOnNewLine &&
                        (blockElement = (0, roosterjs_editor_dom_1$1m.getBlockElementAtNode)(contentDiv, pos.normalize().node))) {
                        pos = adjustInsertPositionNewLine(blockElement, core, pos);
                    }
                    else {
                        pos = (0, roosterjs_editor_dom_1$1m.adjustInsertPosition)(contentDiv, node, pos, range);
                    }
                    var nodeForCursor = node.nodeType == 11 /* DocumentFragment */ ? node.lastChild : node;
                    range = (0, roosterjs_editor_dom_1$1m.createRange)(pos);
                    range.insertNode(node);
                    if (option.updateCursor && nodeForCursor) {
                        rangeToRestore = (0, roosterjs_editor_dom_1$1m.createRange)(new roosterjs_editor_dom_1$1m.Position(nodeForCursor, -3 /* After */).normalize());
                    }
                    if (rangeToRestore) {
                        core.api.selectRange(core, rangeToRestore);
                    }
                    break;
            }
        }, 0 /* LightToDark */);
        return true;
    };
    insertNode$1.insertNode = insertNode;
    function adjustInsertPositionRegionRoot(core, range, position) {
        var region = (0, roosterjs_editor_dom_1$1m.getRegionsFromRange)(core.contentDiv, range, 0 /* Table */)[0];
        var node = position.node;
        if (region) {
            if (node.nodeType == 3 /* Text */ && !position.isAtEnd) {
                node = (0, roosterjs_editor_dom_1$1m.splitTextNode)(node, position.offset, true /*returnFirstPart*/);
            }
            if (node != region.rootNode) {
                while (node && node.parentNode != region.rootNode) {
                    (0, roosterjs_editor_dom_1$1m.splitParentNode)(node, false /*splitBefore*/);
                    node = node.parentNode;
                }
            }
            if (node) {
                position = new roosterjs_editor_dom_1$1m.Position(node, -3 /* After */);
            }
        }
        return position;
    }
    function adjustInsertPositionNewLine(blockElement, core, pos) {
        var tempPos = new roosterjs_editor_dom_1$1m.Position(blockElement.getEndNode(), -3 /* After */);
        if ((0, roosterjs_editor_dom_1$1m.safeInstanceOf)(tempPos.node, 'HTMLTableRowElement')) {
            var div = core.contentDiv.ownerDocument.createElement('div');
            var range = (0, roosterjs_editor_dom_1$1m.createRange)(pos);
            range.insertNode(div);
            tempPos = new roosterjs_editor_dom_1$1m.Position(div, 0 /* Begin */);
        }
        return tempPos;
    }

    var restoreUndoSnapshot$1 = {};

    Object.defineProperty(restoreUndoSnapshot$1, "__esModule", { value: true });
    restoreUndoSnapshot$1.restoreUndoSnapshot = void 0;
    /**
     * @internal
     * Restore an undo snapshot into editor
     * @param core The editor core object
     * @param step Steps to move, can be 0, positive or negative
     */
    var restoreUndoSnapshot = function (core, step) {
        var _a;
        if (core.undo.hasNewContent && step < 0) {
            core.api.addUndoSnapshot(core, null /*callback*/, null /*changeSource*/, false /*canUndoByBackspace*/);
        }
        var snapshot = core.undo.snapshotsService.move(step);
        if (snapshot && snapshot.html != null) {
            try {
                core.undo.isRestoring = true;
                core.api.setContent(core, snapshot.html, true /*triggerContentChangedEvent*/, (_a = snapshot.metadata) !== null && _a !== void 0 ? _a : undefined);
                var darkColorHandler_1 = core.darkColorHandler;
                var isDarkModel_1 = core.lifecycle.isDarkMode;
                if (darkColorHandler_1) {
                    snapshot.knownColors.forEach(function (color) {
                        darkColorHandler_1.registerColor(color.lightModeColor, isDarkModel_1, color.darkModeColor);
                    });
                }
            }
            finally {
                core.undo.isRestoring = false;
            }
        }
    };
    restoreUndoSnapshot$1.restoreUndoSnapshot = restoreUndoSnapshot;

    var selectImage$1 = {};

    var addUniqueId$1 = {};

    Object.defineProperty(addUniqueId$1, "__esModule", { value: true });
    /**
     * Add an unique id to element and ensure that is unique
     * @param el The HTMLElement that will receive the id
     * @param idPrefix The prefix that will antecede the id (Ex: tableSelected01)
     */
    function addUniqueId(el, idPrefix) {
        var doc = el.ownerDocument;
        if (!el.id) {
            applyId(el, idPrefix, doc);
        }
        else {
            var elements = doc.querySelectorAll("#" + el.id);
            if (elements.length > 1) {
                el.removeAttribute('id');
                applyId(el, idPrefix, doc);
            }
        }
    }
    addUniqueId$1.default = addUniqueId;
    function applyId(el, idPrefix, doc) {
        var cont = 0;
        var getElement = function () { return doc.getElementById(idPrefix + cont); };
        //Ensure that there are no elements with the same ID
        var element = getElement();
        while (element) {
            cont++;
            element = getElement();
        }
        el.id = idPrefix + cont;
    }

    Object.defineProperty(selectImage$1, "__esModule", { value: true });
    selectImage$1.selectImage = void 0;
    var addUniqueId_1$1 = addUniqueId$1;
    var roosterjs_editor_dom_1$1l = lib$3;
    var IMAGE_ID = 'imageSelected';
    var CONTENT_DIV_ID$1 = 'contentDiv_';
    var STYLE_ID$1 = 'imageStyle';
    var DEFAULT_SELECTION_BORDER_COLOR = '#DB626C';
    /**
     * @internal
     * Select a image and save data of the selected range
     * @param image Image to select
     * @returns Selected image information
     */
    var selectImage = function (core, image) {
        unselect$1(core);
        var selection = null;
        if (image) {
            var range = (0, roosterjs_editor_dom_1$1l.createRange)(image);
            (0, addUniqueId_1$1.default)(image, IMAGE_ID);
            (0, addUniqueId_1$1.default)(core.contentDiv, CONTENT_DIV_ID$1);
            core.api.selectRange(core, (0, roosterjs_editor_dom_1$1l.createRange)(new roosterjs_editor_dom_1$1l.Position(image, -3 /* After */)));
            select$1(core, image);
            selection = {
                type: 2 /* ImageSelection */,
                ranges: [range],
                image: image,
                areAllCollapsed: range.collapsed,
            };
        }
        return selection;
    };
    selectImage$1.selectImage = selectImage;
    var select$1 = function (core, image) {
        (0, roosterjs_editor_dom_1$1l.removeImportantStyleRule)(image, ['border', 'margin']);
        var borderCSS = buildBorderCSS(core, image.id);
        (0, roosterjs_editor_dom_1$1l.setGlobalCssStyles)(core.contentDiv.ownerDocument, borderCSS, STYLE_ID$1 + core.contentDiv.id);
    };
    var buildBorderCSS = function (core, imageId) {
        var divId = core.contentDiv.id;
        var color = core.imageSelectionBorderColor || DEFAULT_SELECTION_BORDER_COLOR;
        return "#" + divId + " #" + imageId + " {outline-style: auto!important;outline-color: " + color + "!important;caret-color: transparent!important;}";
    };
    var unselect$1 = function (core) {
        var doc = core.contentDiv.ownerDocument;
        (0, roosterjs_editor_dom_1$1l.removeGlobalCssStyle)(doc, STYLE_ID$1 + core.contentDiv.id);
    };

    var selectRange$1 = {};

    Object.defineProperty(selectRange$1, "__esModule", { value: true });
    selectRange$1.selectRange = void 0;
    var hasFocus_1$1 = hasFocus$1;
    var roosterjs_editor_dom_1$1k = lib$3;
    /**
     * @internal
     * Change the editor selection to the given range
     * @param core The EditorCore object
     * @param range The range to select
     * @param skipSameRange When set to true, do nothing if the given range is the same with current selection
     * in editor, otherwise it will always remove current selection range and set to the given one.
     * This parameter is always treat as true in Edge to avoid some weird runtime exception.
     */
    var selectRange = function (core, range, skipSameRange) {
        if (!core.lifecycle.shadowEditSelectionPath && (0, roosterjs_editor_dom_1$1k.contains)(core.contentDiv, range)) {
            (0, roosterjs_editor_dom_1$1k.addRangeToSelection)(range, skipSameRange);
            if (!(0, hasFocus_1$1.hasFocus)(core)) {
                core.domEvent.selectionRange = range;
            }
            if (range.collapsed) {
                // If selected, and current selection is collapsed,
                // need to restore pending format state if exists.
                restorePendingFormatState(core);
            }
            return true;
        }
        else {
            return false;
        }
    };
    selectRange$1.selectRange = selectRange;
    /**
     * Restore cached pending format state (if exist) to current selection
     */
    function restorePendingFormatState(core) {
        var contentDiv = core.contentDiv, pendingFormatState = core.pendingFormatState, getSelectionRange = core.api.getSelectionRange;
        if (pendingFormatState.pendableFormatState) {
            var document_1 = contentDiv.ownerDocument;
            var formatState_1 = (0, roosterjs_editor_dom_1$1k.getPendableFormatState)(document_1);
            (0, roosterjs_editor_dom_1$1k.getObjectKeys)(roosterjs_editor_dom_1$1k.PendableFormatCommandMap).forEach(function (key) {
                var _a;
                if (!!((_a = pendingFormatState.pendableFormatState) === null || _a === void 0 ? void 0 : _a[key]) != formatState_1[key]) {
                    document_1.execCommand(roosterjs_editor_dom_1$1k.PendableFormatCommandMap[key], false /* showUI */, undefined /* value */);
                }
            });
            var range = getSelectionRange(core, true /*tryGetFromCache*/);
            var position = range && roosterjs_editor_dom_1$1k.Position.getStart(range);
            if (position) {
                pendingFormatState.pendableFormatPosition = position;
            }
        }
    }

    var selectTable$1 = {};

    Object.defineProperty(selectTable$1, "__esModule", { value: true });
    selectTable$1.selectTable = void 0;
    var addUniqueId_1 = addUniqueId$1;
    var roosterjs_editor_dom_1$1j = lib$3;
    var TABLE_ID = 'tableSelected';
    var CONTENT_DIV_ID = 'contentDiv_';
    var STYLE_ID = 'tableStyle';
    /**
     * @internal
     * Select a table and save data of the selected range
     * @param core The EditorCore object
     * @param table table to select
     * @param coordinates first and last cell of the selection, if this parameter is null, instead of
     * selecting, will unselect the table.
     * @returns true if successful
     */
    var selectTable = function (core, table, coordinates) {
        var _a;
        unselect(core);
        if (areValidCoordinates(coordinates) && table) {
            (0, addUniqueId_1.default)(table, TABLE_ID);
            (0, addUniqueId_1.default)(core.contentDiv, CONTENT_DIV_ID);
            var ranges = select(core, table, coordinates);
            if (!isMergedCell(table, coordinates)) {
                var cellToSelect = (_a = table.rows
                    .item(coordinates.firstCell.y)) === null || _a === void 0 ? void 0 : _a.cells.item(coordinates.firstCell.x);
                if (cellToSelect) {
                    core.api.selectRange(core, (0, roosterjs_editor_dom_1$1j.createRange)(new roosterjs_editor_dom_1$1j.Position(cellToSelect, 0 /* Begin */)));
                }
            }
            return {
                type: 1 /* TableSelection */,
                ranges: ranges,
                table: table,
                areAllCollapsed: ranges.filter(function (range) { return range === null || range === void 0 ? void 0 : range.collapsed; }).length == ranges.length,
                coordinates: coordinates,
            };
        }
        return null;
    };
    selectTable$1.selectTable = selectTable;
    function buildCss(table, coordinates, contentDivSelector) {
        var _a;
        var tr1 = coordinates.firstCell.y;
        var td1 = coordinates.firstCell.x;
        var tr2 = coordinates.lastCell.y;
        var td2 = coordinates.lastCell.x;
        var ranges = [];
        var firstSelected = null;
        var lastSelected = null;
        var selectors = [];
        var vTable = new roosterjs_editor_dom_1$1j.VTable(table);
        // Get whether table has thead, tbody or tfoot.
        var tableChildren = (0, roosterjs_editor_dom_1$1j.toArray)(table.childNodes).filter(function (node) { return ['THEAD', 'TBODY', 'TFOOT'].indexOf((0, roosterjs_editor_dom_1$1j.getTagOfNode)(node)) > -1; });
        // Set the start and end of each of the table children, so we can build the selector according the element between the table and the row.
        var cont = 0;
        var indexes = tableChildren.map(function (node) {
            var result = {
                el: (0, roosterjs_editor_dom_1$1j.getTagOfNode)(node),
                start: cont,
                end: node.childNodes.length + cont,
            };
            cont = result.end;
            return result;
        });
        (_a = vTable.cells) === null || _a === void 0 ? void 0 : _a.forEach(function (row, rowIndex) {
            var tdCount = 0;
            firstSelected = null;
            lastSelected = null;
            //Get current TBODY/THEAD/TFOOT
            var midElement = indexes.filter(function (ind) { return ind.start <= rowIndex && ind.end > rowIndex; })[0];
            var middleElSelector = midElement ? '>' + midElement.el + '>' : '>';
            var currentRow = midElement && rowIndex + 1 >= midElement.start
                ? rowIndex + 1 - midElement.start
                : rowIndex + 1;
            for (var cellIndex = 0; cellIndex < row.length; cellIndex++) {
                var cell = row[cellIndex].td;
                if (cell) {
                    var tag = (0, roosterjs_editor_dom_1$1j.getTagOfNode)(cell);
                    tdCount++;
                    if (rowIndex >= tr1 && rowIndex <= tr2 && cellIndex >= td1 && cellIndex <= td2) {
                        removeImportant(cell);
                        var selector = generateCssFromCell(contentDivSelector, table.id, middleElSelector, currentRow, tag, tdCount);
                        var elementsSelector = selector + ' *';
                        selectors.push(selector);
                        selectors.push(elementsSelector);
                        firstSelected = firstSelected || table.querySelector(selector);
                        lastSelected = table.querySelector(selector);
                    }
                }
            }
            if (firstSelected && lastSelected) {
                var rowRange = new Range();
                rowRange.setStartBefore(firstSelected);
                rowRange.setEndAfter(lastSelected);
                ranges.push(rowRange);
            }
        });
        var css = selectors.join(',') + " {background-color: rgba(198,198,198,0.7) !important; caret-color: transparent}";
        return { css: css, ranges: ranges };
    }
    function select(core, table, coordinates) {
        var contentDivSelector = '#' + core.contentDiv.id;
        var _a = buildCss(table, coordinates, contentDivSelector), css = _a.css, ranges = _a.ranges;
        (0, roosterjs_editor_dom_1$1j.setGlobalCssStyles)(core.contentDiv.ownerDocument, css, STYLE_ID + core.contentDiv.id);
        return ranges;
    }
    var unselect = function (core) {
        var doc = core.contentDiv.ownerDocument;
        (0, roosterjs_editor_dom_1$1j.removeGlobalCssStyle)(doc, STYLE_ID + core.contentDiv.id);
    };
    function generateCssFromCell(contentDivSelector, tableId, middleElSelector, rowIndex, cellTag, index) {
        return (contentDivSelector +
            ' #' +
            tableId +
            middleElSelector +
            ' tr:nth-child(' +
            rowIndex +
            ')>' +
            cellTag +
            ':nth-child(' +
            index +
            ')');
    }
    function removeImportant(cell) {
        if (cell) {
            (0, roosterjs_editor_dom_1$1j.removeImportantStyleRule)(cell, ['background-color', 'background']);
        }
    }
    function areValidCoordinates(input) {
        if (input) {
            var _a = input || {}, firstCell = _a.firstCell, lastCell = _a.lastCell;
            if (firstCell && lastCell) {
                var handler = function (coordinate) {
                    return isValidCoordinate(coordinate.x) && isValidCoordinate(coordinate.y);
                };
                return handler(firstCell) && handler(lastCell);
            }
        }
        return false;
    }
    function isValidCoordinate(input) {
        return (!!input || input == 0) && input > -1;
    }
    function isMergedCell(table, coordinates) {
        var _a;
        var firstCell = coordinates.firstCell;
        return !(table.rows.item(firstCell.y) && ((_a = table.rows.item(firstCell.y)) === null || _a === void 0 ? void 0 : _a.cells.item(firstCell.x)));
    }

    var setContent$1 = {};

    Object.defineProperty(setContent$1, "__esModule", { value: true });
    setContent$1.setContent = void 0;
    var roosterjs_editor_dom_1$1i = lib$3;
    var roosterjs_editor_dom_2$1 = lib$3;
    /**
     * @internal
     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
     * if triggerContentChangedEvent is set to true
     * @param core The EditorCore object
     * @param content HTML content to set in
     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true
     */
    var setContent = function (core, content, triggerContentChangedEvent, metadata) {
        var contentChanged = false;
        if (core.contentDiv.innerHTML != content) {
            core.api.triggerEvent(core, {
                eventType: 20 /* BeforeSetContent */,
                newContent: content,
            }, true /*broadcast*/);
            var metadataFromContent = (0, roosterjs_editor_dom_2$1.setHtmlWithMetadata)(core.contentDiv, content, core.trustedHTMLHandler);
            metadata = metadata || metadataFromContent;
            selectContentMetadata(core, metadata);
            contentChanged = true;
        }
        var isDarkMode = core.lifecycle.isDarkMode;
        if ((!metadata && isDarkMode) || (metadata && !!metadata.isDarkMode != !!isDarkMode)) {
            core.api.transformColor(core, core.contentDiv, false /*includeSelf*/, null /*callback*/, isDarkMode ? 0 /* LightToDark */ : 1 /* DarkToLight */, true /*forceTransform*/, metadata === null || metadata === void 0 ? void 0 : metadata.isDarkMode);
            contentChanged = true;
        }
        if (triggerContentChangedEvent && contentChanged) {
            core.api.triggerEvent(core, {
                eventType: 7 /* ContentChanged */,
                source: "SetContent" /* SetContent */,
            }, false /*broadcast*/);
        }
    };
    setContent$1.setContent = setContent;
    function selectContentMetadata(core, metadata) {
        if (!core.lifecycle.shadowEditSelectionPath && metadata) {
            core.domEvent.tableSelectionRange = null;
            core.domEvent.imageSelectionRange = null;
            core.domEvent.selectionRange = null;
            switch (metadata.type) {
                case 0 /* Normal */:
                    core.api.selectTable(core, null);
                    core.api.selectImage(core, null);
                    var range = (0, roosterjs_editor_dom_1$1i.createRange)(core.contentDiv, metadata.start, metadata.end);
                    core.api.selectRange(core, range);
                    break;
                case 1 /* TableSelection */:
                    var table = (0, roosterjs_editor_dom_1$1i.queryElements)(core.contentDiv, '#' + metadata.tableId)[0];
                    if (table) {
                        core.domEvent.tableSelectionRange = core.api.selectTable(core, table, metadata);
                    }
                    break;
                case 2 /* ImageSelection */:
                    var image = (0, roosterjs_editor_dom_1$1i.queryElements)(core.contentDiv, '#' + metadata.imageId)[0];
                    if (image) {
                        core.domEvent.imageSelectionRange = core.api.selectImage(core, image);
                    }
                    break;
            }
        }
    }

    var switchShadowEdit$1 = {};

    Object.defineProperty(switchShadowEdit$1, "__esModule", { value: true });
    switchShadowEdit$1.switchShadowEdit = void 0;
    var roosterjs_editor_dom_1$1h = lib$3;
    /**
     * @internal
     */
    var switchShadowEdit = function (core, isOn) {
        var lifecycle = core.lifecycle, contentDiv = core.contentDiv;
        var shadowEditEntities = lifecycle.shadowEditEntities, shadowEditFragment = lifecycle.shadowEditFragment, shadowEditSelectionPath = lifecycle.shadowEditSelectionPath, shadowEditTableSelectionPath = lifecycle.shadowEditTableSelectionPath, shadowEditImageSelectionPath = lifecycle.shadowEditImageSelectionPath;
        var wasInShadowEdit = !!shadowEditFragment;
        var getShadowEditSelectionPath = function (selectionType, shadowEditSelection) {
            return (((shadowEditSelection === null || shadowEditSelection === void 0 ? void 0 : shadowEditSelection.type) == selectionType &&
                shadowEditSelection.ranges
                    .map(function (range) { return (0, roosterjs_editor_dom_1$1h.getSelectionPath)(contentDiv, range); })
                    .map(function (w) { return w; })) ||
                null);
        };
        if (isOn) {
            if (!wasInShadowEdit) {
                var selection = core.api.getSelectionRangeEx(core);
                var range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);
                shadowEditSelectionPath = range && (0, roosterjs_editor_dom_1$1h.getSelectionPath)(contentDiv, range);
                shadowEditTableSelectionPath = getShadowEditSelectionPath(1 /* TableSelection */, selection);
                shadowEditImageSelectionPath = getShadowEditSelectionPath(2 /* ImageSelection */, selection);
                shadowEditEntities = {};
                shadowEditFragment = (0, roosterjs_editor_dom_1$1h.moveContentWithEntityPlaceholders)(contentDiv, shadowEditEntities);
                core.api.triggerEvent(core, {
                    eventType: 17 /* EnteredShadowEdit */,
                    fragment: shadowEditFragment,
                    selectionPath: shadowEditSelectionPath,
                }, false /*broadcast*/);
                lifecycle.shadowEditFragment = shadowEditFragment;
                lifecycle.shadowEditSelectionPath = shadowEditSelectionPath;
                lifecycle.shadowEditTableSelectionPath = shadowEditTableSelectionPath;
                lifecycle.shadowEditImageSelectionPath = shadowEditImageSelectionPath;
                lifecycle.shadowEditEntities = shadowEditEntities;
            }
            if (lifecycle.shadowEditFragment) {
                (0, roosterjs_editor_dom_1$1h.restoreContentWithEntityPlaceholder)(lifecycle.shadowEditFragment, contentDiv, lifecycle.shadowEditEntities, true /*insertClonedNode*/);
            }
        }
        else {
            lifecycle.shadowEditFragment = null;
            lifecycle.shadowEditSelectionPath = null;
            lifecycle.shadowEditEntities = null;
            if (wasInShadowEdit) {
                core.api.triggerEvent(core, {
                    eventType: 18 /* LeavingShadowEdit */,
                }, false /*broadcast*/);
                if (shadowEditFragment) {
                    (0, roosterjs_editor_dom_1$1h.restoreContentWithEntityPlaceholder)(shadowEditFragment, contentDiv, shadowEditEntities);
                }
                core.api.focus(core);
                if (shadowEditSelectionPath) {
                    core.api.selectRange(core, (0, roosterjs_editor_dom_1$1h.createRange)(contentDiv, shadowEditSelectionPath.start, shadowEditSelectionPath.end));
                }
                if (core.domEvent.imageSelectionRange) {
                    var image = core.domEvent.imageSelectionRange.image;
                    var imageElement = core.contentDiv.querySelector('#' + image.id);
                    if (imageElement) {
                        core.api.selectImage(core, image);
                    }
                }
                if (core.domEvent.tableSelectionRange) {
                    var _a = core.domEvent.tableSelectionRange, table = _a.table, coordinates = _a.coordinates;
                    var tableId = table.id;
                    var tableElement = core.contentDiv.querySelector('#' + tableId);
                    if (table) {
                        core.domEvent.tableSelectionRange = core.api.selectTable(core, tableElement, coordinates);
                    }
                }
            }
        }
    };
    switchShadowEdit$1.switchShadowEdit = switchShadowEdit;

    var transformColor$1 = {};

    var _a$2, _b$1;
    Object.defineProperty(transformColor$1, "__esModule", { value: true });
    transformColor$1.transformColor = void 0;
    var roosterjs_editor_dom_1$1g = lib$3;
    var ColorAttributeEnum;
    (function (ColorAttributeEnum) {
        ColorAttributeEnum[ColorAttributeEnum["CssColor"] = 0] = "CssColor";
        ColorAttributeEnum[ColorAttributeEnum["HtmlColor"] = 1] = "HtmlColor";
        ColorAttributeEnum[ColorAttributeEnum["CssDataSet"] = 2] = "CssDataSet";
        ColorAttributeEnum[ColorAttributeEnum["HtmlDataSet"] = 3] = "HtmlDataSet";
    })(ColorAttributeEnum || (ColorAttributeEnum = {}));
    var ColorAttributeName = [
        (_a$2 = {},
            _a$2[0 /* CssColor */] = 'color',
            _a$2[1 /* HtmlColor */] = 'color',
            _a$2[2 /* CssDataSet */] = "ogsc" /* OriginalStyleColor */,
            _a$2[3 /* HtmlDataSet */] = "ogac" /* OriginalAttributeColor */,
            _a$2),
        (_b$1 = {},
            _b$1[0 /* CssColor */] = 'background-color',
            _b$1[1 /* HtmlColor */] = 'bgcolor',
            _b$1[2 /* CssDataSet */] = "ogsb" /* OriginalStyleBackgroundColor */,
            _b$1[3 /* HtmlDataSet */] = "ogab" /* OriginalAttributeBackgroundColor */,
            _b$1),
    ];
    /**
     * @internal
     * Edit and transform color of elements between light mode and dark mode
     * @param core The EditorCore object
     * @param rootNode The root HTML elements to transform
     * @param includeSelf True to transform the root node as well, otherwise false
     * @param callback The callback function to invoke before do color transformation
     * @param direction To specify the transform direction, light to dark, or dark to light
     * @param forceTransform By default this function will only work when editor core is in dark mode.
     * Pass true to this value to force do color transformation even editor core is in light mode
     */
    var transformColor = function (core, rootNode, includeSelf, callback, direction, forceTransform, fromDarkMode) {
        var darkColorHandler = core.darkColorHandler;
        var elements = rootNode && (forceTransform || core.lifecycle.isDarkMode)
            ? getAll(rootNode, includeSelf)
            : [];
        callback === null || callback === void 0 ? void 0 : callback();
        if (darkColorHandler) {
            transformV2(elements, darkColorHandler, !!fromDarkMode, direction == 0 /* LightToDark */);
        }
        else {
            if (direction == 1 /* DarkToLight */) {
                transformToLightMode(elements);
            }
            else if (core.lifecycle.onExternalContentTransform) {
                elements.forEach(function (element) { return core.lifecycle.onExternalContentTransform(element); });
            }
            else {
                transformToDarkMode(elements, core.lifecycle.getDarkColor);
            }
        }
    };
    transformColor$1.transformColor = transformColor;
    function transformV2(elements, darkColorHandler, fromDark, toDark) {
        elements.forEach(function (element) {
            ColorAttributeName.forEach(function (names, i) {
                var color = darkColorHandler.parseColorValue(element.style.getPropertyValue(names[0 /* CssColor */]) ||
                    element.getAttribute(names[1 /* HtmlColor */]), fromDark).lightModeColor;
                element.style.setProperty(names[0 /* CssColor */], null);
                element.removeAttribute(names[1 /* HtmlColor */]);
                if (color && color != 'inherit') {
                    (0, roosterjs_editor_dom_1$1g.setColor)(element, color, i != 0, toDark, false /*shouldAdaptFontColor*/, darkColorHandler);
                }
            });
        });
    }
    function transformToLightMode(elements) {
        elements.forEach(function (element) {
            ColorAttributeName.forEach(function (names) {
                // Reset color styles based on the content of the ogsc/ogsb data element.
                // If those data properties are empty or do not exist, set them anyway to clear the content.
                element.style.setProperty(names[0 /* CssColor */], getValueOrDefault(element.dataset[names[2 /* CssDataSet */]], ''));
                delete element.dataset[names[2 /* CssDataSet */]];
                // Some elements might have set attribute colors. We need to reset these as well.
                var value = getValueOrDefault(element.dataset[names[3 /* HtmlDataSet */]], null);
                if (value) {
                    element.setAttribute(names[1 /* HtmlColor */], value);
                }
                else {
                    element.removeAttribute(names[1 /* HtmlColor */]);
                }
                delete element.dataset[names[3 /* HtmlDataSet */]];
            });
        });
    }
    function transformToDarkMode(elements, getDarkColor) {
        ColorAttributeName.forEach(function (names) {
            elements
                .map(function (element) {
                var styleColor = element.style.getPropertyValue(names[0 /* CssColor */]);
                var attrColor = element.getAttribute(names[1 /* HtmlColor */]);
                var existingDataSetCssValue = element.dataset[names[2 /* CssDataSet */]];
                var existingDataSetHtmlValue = element.dataset[names[3 /* HtmlDataSet */]];
                var needProcess = (!existingDataSetCssValue || existingDataSetCssValue == styleColor) &&
                    (!existingDataSetHtmlValue || existingDataSetHtmlValue == attrColor) &&
                    (styleColor || attrColor) &&
                    styleColor != 'inherit'; // For inherit style, no need to change it and let it keep inherit from parent element
                return needProcess
                    ? {
                        element: element,
                        styleColor: styleColor,
                        attrColor: attrColor,
                        newColor: styleColor || attrColor
                            ? getDarkColor((styleColor || attrColor))
                            : null,
                    }
                    : null;
            })
                .filter(function (x) { return !!x; })
                .forEach(function (entry) {
                if (!entry) {
                    return;
                }
                var element = entry.element, styleColor = entry.styleColor, attrColor = entry.attrColor, newColor = entry.newColor;
                element.style.setProperty(names[0 /* CssColor */], newColor, 'important');
                element.dataset[names[2 /* CssDataSet */]] = styleColor || '';
                if (attrColor && newColor) {
                    element.setAttribute(names[1 /* HtmlColor */], newColor);
                    element.dataset[names[3 /* HtmlDataSet */]] = attrColor;
                }
            });
        });
    }
    function getValueOrDefault(value, defaultValue) {
        return value && value != 'undefined' && value != 'null' ? value : defaultValue;
    }
    function getAll(rootNode, includeSelf) {
        var result = [];
        if ((0, roosterjs_editor_dom_1$1g.safeInstanceOf)(rootNode, 'HTMLElement')) {
            if (includeSelf) {
                result.push(rootNode);
            }
            var allChildren = rootNode.getElementsByTagName('*');
            (0, roosterjs_editor_dom_1$1g.arrayPush)(result, (0, roosterjs_editor_dom_1$1g.toArray)(allChildren));
        }
        else if ((0, roosterjs_editor_dom_1$1g.safeInstanceOf)(rootNode, 'DocumentFragment')) {
            var allChildren = rootNode.querySelectorAll('*');
            (0, roosterjs_editor_dom_1$1g.arrayPush)(result, (0, roosterjs_editor_dom_1$1g.toArray)(allChildren));
        }
        return result.filter(isHTMLElement);
    }
    // This is not a strict check, we just need to make sure this element has style so that we can set style to it
    // We don't use safeInstanceOf() here since this function will be called very frequently when extract html content
    // in dark mode, so we need to make sure this check is fast enough
    function isHTMLElement(element) {
        var htmlElement = element;
        return !!htmlElement.style && !!htmlElement.dataset;
    }

    var triggerEvent$1 = {};

    Object.defineProperty(triggerEvent$1, "__esModule", { value: true });
    triggerEvent$1.triggerEvent = void 0;
    var allowedEventsInShadowEdit = [
        11 /* EditorReady */,
        12 /* BeforeDispose */,
        8 /* ExtractContentWithDom */,
        21 /* ZoomChanged */,
    ];
    /**
     * @internal
     * Trigger a plugin event
     * @param core The EditorCore object
     * @param pluginEvent The event object to trigger
     * @param broadcast Set to true to skip the shouldHandleEventExclusively check
     */
    var triggerEvent = function (core, pluginEvent, broadcast) {
        if ((!core.lifecycle.shadowEditFragment ||
            allowedEventsInShadowEdit.indexOf(pluginEvent.eventType) >= 0) &&
            (broadcast || !core.plugins.some(function (plugin) { return handledExclusively(pluginEvent, plugin); }))) {
            core.plugins.forEach(function (plugin) {
                if (plugin.onPluginEvent) {
                    plugin.onPluginEvent(pluginEvent);
                }
            });
        }
    };
    triggerEvent$1.triggerEvent = triggerEvent;
    function handledExclusively(event, plugin) {
        var _a;
        if (plugin.onPluginEvent && ((_a = plugin.willHandleEventExclusively) === null || _a === void 0 ? void 0 : _a.call(plugin, event))) {
            plugin.onPluginEvent(event);
            return true;
        }
        return false;
    }

    Object.defineProperty(coreApiMap, "__esModule", { value: true });
    coreApiMap.coreApiMap = void 0;
    var addUndoSnapshot_1 = addUndoSnapshot$1;
    var attachDomEvent_1 = attachDomEvent$1;
    var createPasteFragment_1 = createPasteFragment$1;
    var ensureTypeInContainer_1 = ensureTypeInContainer$1;
    var focus_1 = focus$1;
    var getContent_1 = getContent$1;
    var getPendableFormatState_1 = getPendableFormatState$1;
    var getSelectionRange_1 = getSelectionRange$1;
    var getSelectionRangeEx_1 = getSelectionRangeEx$1;
    var getStyleBasedFormatState_1 = getStyleBasedFormatState$1;
    var hasFocus_1 = hasFocus$1;
    var insertNode_1 = insertNode$1;
    var restoreUndoSnapshot_1 = restoreUndoSnapshot$1;
    var selectImage_1 = selectImage$1;
    var selectRange_1 = selectRange$1;
    var selectTable_1 = selectTable$1;
    var setContent_1 = setContent$1;
    var switchShadowEdit_1 = switchShadowEdit$1;
    var transformColor_1 = transformColor$1;
    var triggerEvent_1 = triggerEvent$1;
    /**
     * @internal
     */
    coreApiMap.coreApiMap = {
        attachDomEvent: attachDomEvent_1.attachDomEvent,
        addUndoSnapshot: addUndoSnapshot_1.addUndoSnapshot,
        createPasteFragment: createPasteFragment_1.createPasteFragment,
        ensureTypeInContainer: ensureTypeInContainer_1.ensureTypeInContainer,
        focus: focus_1.focus,
        getContent: getContent_1.getContent,
        getSelectionRange: getSelectionRange_1.getSelectionRange,
        getSelectionRangeEx: getSelectionRangeEx_1.getSelectionRangeEx,
        getStyleBasedFormatState: getStyleBasedFormatState_1.getStyleBasedFormatState,
        getPendableFormatState: getPendableFormatState_1.getPendableFormatState,
        hasFocus: hasFocus_1.hasFocus,
        insertNode: insertNode_1.insertNode,
        restoreUndoSnapshot: restoreUndoSnapshot_1.restoreUndoSnapshot,
        selectRange: selectRange_1.selectRange,
        setContent: setContent_1.setContent,
        switchShadowEdit: switchShadowEdit_1.switchShadowEdit,
        transformColor: transformColor_1.transformColor,
        triggerEvent: triggerEvent_1.triggerEvent,
        selectTable: selectTable_1.selectTable,
        selectImage: selectImage_1.selectImage,
    };

    var __assign$e = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$e = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$e.apply(this, arguments);
    };
    Object.defineProperty(Editor$1, "__esModule", { value: true });
    var createCorePlugins_1 = createCorePlugins$1;
    var DarkColorHandlerImpl_1 = DarkColorHandlerImpl$1;
    var coreApiMap_1 = coreApiMap;
    var roosterjs_editor_dom_1$1f = lib$3;
    /**
     * RoosterJs core editor class
     */
    var Editor = /** @class */ (function () {
        //#region Lifecycle
        /**
         * Creates an instance of Editor
         * @param contentDiv The DIV HTML element which will be the container element of editor
         * @param options An optional options object to customize the editor
         */
        function Editor(contentDiv, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var _a;
            this.core = null;
            // 1. Make sure all parameters are valid
            if ((0, roosterjs_editor_dom_1$1f.getTagOfNode)(contentDiv) != 'DIV') {
                throw new Error('contentDiv must be an HTML DIV element');
            }
            // 2. Store options values to local variables
            var corePlugins = (0, createCorePlugins_1.default)(contentDiv, options);
            var plugins = [];
            (0, roosterjs_editor_dom_1$1f.getObjectKeys)(corePlugins).forEach(function (name) {
                if (name == '_placeholder') {
                    if (options.plugins) {
                        (0, roosterjs_editor_dom_1$1f.arrayPush)(plugins, options.plugins);
                    }
                }
                else {
                    plugins.push(corePlugins[name]);
                }
            });
            var zoomScale = ((_a = options.zoomScale) !== null && _a !== void 0 ? _a : -1) > 0 ? options.zoomScale : 1;
            this.core = __assign$e(__assign$e({ contentDiv: contentDiv, api: __assign$e(__assign$e({}, coreApiMap_1.coreApiMap), (options.coreApiOverride || {})), originalApi: coreApiMap_1.coreApiMap, plugins: plugins.filter(function (x) { return !!x; }) }, (0, createCorePlugins_1.getPluginState)(corePlugins)), { trustedHTMLHandler: options.trustedHTMLHandler || (function (html) { return html; }), zoomScale: zoomScale, sizeTransformer: options.sizeTransformer || (function (size) { return size / zoomScale; }), getVisibleViewport: options.getVisibleViewport ||
                    (function () {
                        var scrollContainer = _this.getScrollContainer();
                        return (0, roosterjs_editor_dom_1$1f.getIntersectedRect)(scrollContainer == contentDiv
                            ? [scrollContainer]
                            : [scrollContainer, contentDiv]);
                    }), imageSelectionBorderColor: options.imageSelectionBorderColor });
            if (this.isFeatureEnabled("VariableBasedDarkColor" /* VariableBasedDarkColor */)) {
                this.core.darkColorHandler = new DarkColorHandlerImpl_1.default(contentDiv, this.core.lifecycle.getDarkColor);
            }
            // 3. Initialize plugins
            this.core.plugins.forEach(function (plugin) { return plugin.initialize(_this); });
            // 4. Ensure user will type in a container node, not the editor content DIV
            this.ensureTypeInContainer(new roosterjs_editor_dom_1$1f.Position(this.core.contentDiv, 0 /* Begin */).normalize());
        }
        /**
         * Dispose this editor, dispose all plugins and custom data
         */
        Editor.prototype.dispose = function () {
            var _a;
            var core = this.getCore();
            for (var i = core.plugins.length - 1; i >= 0; i--) {
                core.plugins[i].dispose();
            }
            (_a = core.darkColorHandler) === null || _a === void 0 ? void 0 : _a.reset();
            this.core = null;
        };
        /**
         * Get whether this editor is disposed
         * @returns True if editor is disposed, otherwise false
         */
        Editor.prototype.isDisposed = function () {
            return !this.core;
        };
        //#endregion
        //#region Node API
        /**
         * Insert node into editor
         * @param node The node to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         * @returns true if node is inserted. Otherwise false
         */
        Editor.prototype.insertNode = function (node, option) {
            var core = this.getCore();
            return node ? core.api.insertNode(core, node, option !== null && option !== void 0 ? option : null) : false;
        };
        /**
         * Delete a node from editor content
         * @param node The node to delete
         * @returns true if node is deleted. Otherwise false
         */
        Editor.prototype.deleteNode = function (node) {
            // Only remove the node when it falls within editor
            if (node && this.contains(node) && node.parentNode) {
                node.parentNode.removeChild(node);
                return true;
            }
            return false;
        };
        /**
         * Replace a node in editor content with another node
         * @param existingNode The existing node to be replaced
         * @param toNode node to replace to
         * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false
         * @returns true if node is replaced. Otherwise false
         */
        Editor.prototype.replaceNode = function (existingNode, toNode, transformColorForDarkMode) {
            var core = this.getCore();
            // Only replace the node when it falls within editor
            if (this.contains(existingNode) && toNode) {
                core.api.transformColor(core, transformColorForDarkMode ? toNode : null, true /*includeSelf*/, function () { var _a; return (_a = existingNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(toNode, existingNode); }, 0 /* LightToDark */);
                return true;
            }
            return false;
        };
        /**
         * Get BlockElement at given node
         * @param node The node to create InlineElement
         * @returns The BlockElement result
         */
        Editor.prototype.getBlockElementAtNode = function (node) {
            return (0, roosterjs_editor_dom_1$1f.getBlockElementAtNode)(this.getCore().contentDiv, node);
        };
        Editor.prototype.contains = function (arg) {
            if (!arg) {
                return false;
            }
            return (0, roosterjs_editor_dom_1$1f.contains)(this.getCore().contentDiv, arg);
        };
        Editor.prototype.queryElements = function (selector, scopeOrCallback, callback) {
            if (scopeOrCallback === void 0) { scopeOrCallback = 0 /* Body */; }
            var core = this.getCore();
            var result = [];
            var scope = scopeOrCallback instanceof Function ? 0 /* Body */ : scopeOrCallback;
            callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;
            var selectionEx = scope == 0 /* Body */ ? null : this.getSelectionRangeEx();
            if (selectionEx) {
                selectionEx.ranges.forEach(function (range) {
                    result.push.apply(result, (0, roosterjs_editor_dom_1$1f.queryElements)(core.contentDiv, selector, callback, scope, range));
                });
            }
            else {
                return (0, roosterjs_editor_dom_1$1f.queryElements)(core.contentDiv, selector, callback, scope, undefined /* range */);
            }
            return result;
        };
        /**
         * Collapse nodes within the given start and end nodes to their common ancestor node,
         * split parent nodes if necessary
         * @param start The start node
         * @param end The end node
         * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent
         * and the returned nodes will be all nodes from start through end after splitting
         * False to disallow split parent
         * @returns When canSplitParent is true, returns all node from start through end after splitting,
         * otherwise just return start and end
         */
        Editor.prototype.collapseNodes = function (start, end, canSplitParent) {
            return (0, roosterjs_editor_dom_1$1f.collapseNodes)(this.getCore().contentDiv, start, end, canSplitParent);
        };
        //#endregion
        //#region Content API
        /**
         * Check whether the editor contains any visible content
         * @param trim Whether trim the content string before check. Default is false
         * @returns True if there's no visible content, otherwise false
         */
        Editor.prototype.isEmpty = function (trim) {
            return (0, roosterjs_editor_dom_1$1f.isNodeEmpty)(this.getCore().contentDiv, trim);
        };
        /**
         * Get current editor content as HTML string
         * @param mode specify what kind of HTML content to retrieve
         * @returns HTML string representing current editor content
         */
        Editor.prototype.getContent = function (mode) {
            if (mode === void 0) { mode = 0 /* CleanHTML */; }
            var core = this.getCore();
            return core.api.getContent(core, mode);
        };
        /**
         * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
         * @param content HTML content to set in
         * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true
         */
        Editor.prototype.setContent = function (content, triggerContentChangedEvent) {
            if (triggerContentChangedEvent === void 0) { triggerContentChangedEvent = true; }
            var core = this.getCore();
            core.api.setContent(core, content, triggerContentChangedEvent);
        };
        /**
         * Insert HTML content into editor
         * @param HTML content to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         */
        Editor.prototype.insertContent = function (content, option) {
            var _a;
            if (content) {
                var doc = this.getDocument();
                var body = (_a = new DOMParser().parseFromString(this.getCore().trustedHTMLHandler(content), 'text/html')) === null || _a === void 0 ? void 0 : _a.body;
                var allNodes = (body === null || body === void 0 ? void 0 : body.childNodes) ? (0, roosterjs_editor_dom_1$1f.toArray)(body.childNodes) : [];
                // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with
                // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped
                // separately to show up on its own line
                if (option && option.insertOnNewLine && allNodes.length > 1) {
                    allNodes = [(0, roosterjs_editor_dom_1$1f.wrap)(allNodes)];
                }
                var fragment_1 = doc.createDocumentFragment();
                allNodes.forEach(function (node) { return fragment_1.appendChild(node); });
                this.insertNode(fragment_1, option);
            }
        };
        /**
         * Delete selected content
         */
        Editor.prototype.deleteSelectedContent = function () {
            var range = this.getSelectionRange();
            if (range && !range.collapsed) {
                return (0, roosterjs_editor_dom_1$1f.deleteSelectedContent)(this.getCore().contentDiv, range);
            }
            return null;
        };
        /**
         * Paste into editor using a clipboardData object
         * @param clipboardData Clipboard data retrieved from clipboard
         * @param pasteAsText Force pasting as plain text. Default value is false
         * @param applyCurrentStyle True if apply format of current selection to the pasted content,
         * false to keep original format.  Default value is false. When pasteAsText is true, this parameter is ignored
         */
        Editor.prototype.paste = function (clipboardData, pasteAsText, applyCurrentFormat) {
            var _this = this;
            if (pasteAsText === void 0) { pasteAsText = false; }
            if (applyCurrentFormat === void 0) { applyCurrentFormat = false; }
            var core = this.getCore();
            if (!clipboardData) {
                return;
            }
            if (clipboardData.snapshotBeforePaste) {
                // Restore original content before paste a new one
                this.setContent(clipboardData.snapshotBeforePaste);
            }
            else {
                clipboardData.snapshotBeforePaste = this.getContent(2 /* RawHTMLWithSelection */);
            }
            var range = this.getSelectionRange();
            var pos = range && roosterjs_editor_dom_1$1f.Position.getStart(range);
            var fragment = core.api.createPasteFragment(core, clipboardData, pos, pasteAsText, applyCurrentFormat);
            if (fragment) {
                this.addUndoSnapshot(function () {
                    _this.insertNode(fragment);
                    return clipboardData;
                }, "Paste" /* Paste */);
            }
        };
        //#endregion
        //#region Focus and Selection
        /**
         * Get current selection range from Editor.
         * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
         * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.
         * Default value is true
         * @returns current selection range, or null if editor never got focus before
         */
        Editor.prototype.getSelectionRange = function (tryGetFromCache) {
            if (tryGetFromCache === void 0) { tryGetFromCache = true; }
            var core = this.getCore();
            return core.api.getSelectionRange(core, tryGetFromCache);
        };
        /**
         * Get current selection range from Editor.
         * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
         * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.
         * Default value is true
         * @returns current selection range, or null if editor never got focus before
         */
        Editor.prototype.getSelectionRangeEx = function () {
            var core = this.getCore();
            return core.api.getSelectionRangeEx(core);
        };
        /**
         * Get current selection in a serializable format
         * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
         * @returns current selection path, or null if editor never got focus before
         */
        Editor.prototype.getSelectionPath = function () {
            var range = this.getSelectionRange();
            return range && (0, roosterjs_editor_dom_1$1f.getSelectionPath)(this.getCore().contentDiv, range);
        };
        /**
         * Check if focus is in editor now
         * @returns true if focus is in editor, otherwise false
         */
        Editor.prototype.hasFocus = function () {
            var core = this.getCore();
            return core.api.hasFocus(core);
        };
        /**
         * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.
         */
        Editor.prototype.focus = function () {
            var core = this.getCore();
            core.api.focus(core);
        };
        Editor.prototype.select = function (arg1, arg2, arg3, arg4) {
            var core = this.getCore();
            var rangeEx = null;
            if (isSelectionRangeEx(arg1)) {
                rangeEx = arg1;
            }
            else if ((0, roosterjs_editor_dom_1$1f.safeInstanceOf)(arg1, 'HTMLTableElement') && isTableSelection(arg2)) {
                rangeEx = {
                    type: 1 /* TableSelection */,
                    ranges: [],
                    areAllCollapsed: false,
                    table: arg1,
                    coordinates: arg2,
                };
            }
            else if ((0, roosterjs_editor_dom_1$1f.safeInstanceOf)(arg1, 'HTMLImageElement') && typeof arg2 == 'undefined') {
                rangeEx = {
                    type: 2 /* ImageSelection */,
                    ranges: [],
                    areAllCollapsed: false,
                    image: arg1,
                };
            }
            else {
                var range = !arg1
                    ? null
                    : (0, roosterjs_editor_dom_1$1f.safeInstanceOf)(arg1, 'Range')
                        ? arg1
                        : isSelectionPath(arg1)
                            ? (0, roosterjs_editor_dom_1$1f.createRange)(core.contentDiv, arg1.start, arg1.end)
                            : isNodePosition(arg1) || (0, roosterjs_editor_dom_1$1f.safeInstanceOf)(arg1, 'Node')
                                ? (0, roosterjs_editor_dom_1$1f.createRange)(arg1, arg2, arg3, arg4)
                                : null;
                rangeEx = range
                    ? {
                        type: 0 /* Normal */,
                        ranges: [range],
                        areAllCollapsed: range.collapsed,
                    }
                    : null;
            }
            if (rangeEx) {
                switch (rangeEx.type) {
                    case 1 /* TableSelection */:
                        if (this.contains(rangeEx.table)) {
                            core.domEvent.imageSelectionRange = core.api.selectImage(core, null);
                            core.domEvent.tableSelectionRange = core.api.selectTable(core, rangeEx.table, rangeEx.coordinates);
                            rangeEx = core.domEvent.tableSelectionRange;
                        }
                        break;
                    case 2 /* ImageSelection */:
                        if (this.contains(rangeEx.image)) {
                            core.domEvent.tableSelectionRange = core.api.selectTable(core, null);
                            core.domEvent.imageSelectionRange = core.api.selectImage(core, rangeEx.image);
                            rangeEx = core.domEvent.imageSelectionRange;
                        }
                        break;
                    case 0 /* Normal */:
                        core.domEvent.tableSelectionRange = core.api.selectTable(core, null);
                        core.domEvent.imageSelectionRange = core.api.selectImage(core, null);
                        if (this.contains(rangeEx.ranges[0])) {
                            core.api.selectRange(core, rangeEx.ranges[0]);
                        }
                        else {
                            rangeEx = null;
                        }
                        break;
                }
                this.triggerPluginEvent(22 /* SelectionChanged */, {
                    selectionRangeEx: rangeEx,
                }, true /** broadcast **/);
            }
            else {
                core.domEvent.tableSelectionRange = core.api.selectTable(core, null);
                core.domEvent.imageSelectionRange = core.api.selectImage(core, null);
            }
            return !!rangeEx;
        };
        /**
         * Get current focused position. Return null if editor doesn't have focus at this time.
         */
        Editor.prototype.getFocusedPosition = function () {
            var _a;
            var sel = (_a = this.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
            if ((sel === null || sel === void 0 ? void 0 : sel.focusNode) && this.contains(sel.focusNode)) {
                return new roosterjs_editor_dom_1$1f.Position(sel.focusNode, sel.focusOffset);
            }
            var range = this.getSelectionRange();
            if (range) {
                return roosterjs_editor_dom_1$1f.Position.getStart(range);
            }
            return null;
        };
        /**
         * Get an HTML element from current cursor position.
         * When expectedTags is not specified, return value is the current node (if it is HTML element)
         * or its parent node (if current node is a Text node).
         * When expectedTags is specified, return value is the first ancestor of current node which has
         * one of the expected tags.
         * If no element found within editor by the given tag, return null.
         * @param selector Optional, an HTML selector to find HTML element with.
         * @param startFrom Start search from this node. If not specified, start from current focused position
         * @param event Optional, if specified, editor will try to get cached result from the event object first.
         * If it is not cached before, query from DOM and cache the result into the event object
         */
        Editor.prototype.getElementAtCursor = function (selector, startFrom, event) {
            var _this = this;
            var _a;
            event = startFrom ? undefined : event; // Only use cache when startFrom is not specified, for different start position can have different result
            return ((_a = (0, roosterjs_editor_dom_1$1f.cacheGetEventData)(event !== null && event !== void 0 ? event : null, 'GET_ELEMENT_AT_CURSOR_' + selector, function () {
                if (!startFrom) {
                    var position = _this.getFocusedPosition();
                    startFrom = position === null || position === void 0 ? void 0 : position.node;
                }
                return (startFrom &&
                    (0, roosterjs_editor_dom_1$1f.findClosestElementAncestor)(startFrom, _this.getCore().contentDiv, selector));
            })) !== null && _a !== void 0 ? _a : null);
        };
        /**
         * Check if this position is at beginning of the editor.
         * This will return true if all nodes between the beginning of target node and the position are empty.
         * @param position The position to check
         * @returns True if position is at beginning of the editor, otherwise false
         */
        Editor.prototype.isPositionAtBeginning = function (position) {
            return (0, roosterjs_editor_dom_1$1f.isPositionAtBeginningOf)(position, this.getCore().contentDiv);
        };
        /**
         * Get impacted regions from selection
         */
        Editor.prototype.getSelectedRegions = function (type) {
            if (type === void 0) { type = 0 /* Table */; }
            var selection = this.getSelectionRangeEx();
            var result = [];
            var contentDiv = this.getCore().contentDiv;
            selection.ranges.forEach(function (range) {
                result.push.apply(result, (range ? (0, roosterjs_editor_dom_1$1f.getRegionsFromRange)(contentDiv, range, type) : []));
            });
            return result.filter(function (value, index, self) {
                return self.indexOf(value) === index;
            });
        };
        //#endregion
        //#region EVENT API
        Editor.prototype.addDomEventHandler = function (nameOrMap, handler) {
            var _a;
            var eventsToMap = typeof nameOrMap == 'string' ? (_a = {}, _a[nameOrMap] = handler, _a) : nameOrMap;
            var core = this.getCore();
            return core.api.attachDomEvent(core, eventsToMap);
        };
        /**
         * Trigger an event to be dispatched to all plugins
         * @param eventType Type of the event
         * @param data data of the event with given type, this is the rest part of PluginEvent with the given type
         * @param broadcast indicates if the event needs to be dispatched to all plugins
         * True means to all, false means to allow exclusive handling from one plugin unless no one wants that
         * @returns the event object which is really passed into plugins. Some plugin may modify the event object so
         * the result of this function provides a chance to read the modified result
         */
        Editor.prototype.triggerPluginEvent = function (eventType, data, broadcast) {
            if (broadcast === void 0) { broadcast = false; }
            var core = this.getCore();
            var event = __assign$e({ eventType: eventType }, data);
            core.api.triggerEvent(core, event, broadcast);
            return event;
        };
        /**
         * Trigger a ContentChangedEvent
         * @param source Source of this event, by default is 'SetContent'
         * @param data additional data for this event
         */
        Editor.prototype.triggerContentChangedEvent = function (source, data) {
            if (source === void 0) { source = "SetContent" /* SetContent */; }
            this.triggerPluginEvent(7 /* ContentChanged */, {
                source: source,
                data: data,
            });
        };
        //#endregion
        //#region Undo API
        /**
         * Undo last edit operation
         */
        Editor.prototype.undo = function () {
            this.focus();
            var core = this.getCore();
            core.api.restoreUndoSnapshot(core, -1 /*step*/);
        };
        /**
         * Redo next edit operation
         */
        Editor.prototype.redo = function () {
            this.focus();
            var core = this.getCore();
            core.api.restoreUndoSnapshot(core, 1 /*step*/);
        };
        /**
         * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger
         * ContentChangedEvent with given change source.
         * If this function is called nested, undo snapshot will only be added in the outside one
         * @param callback The callback function to perform formatting, returns a data object which will be used as
         * the data field in ContentChangedEvent if changeSource is not null.
         * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,
         * a ContentChangedEvent will be fired with change source equal to this value
         * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).
         */
        Editor.prototype.addUndoSnapshot = function (callback, changeSource, canUndoByBackspace, additionalData) {
            var core = this.getCore();
            core.api.addUndoSnapshot(core, callback !== null && callback !== void 0 ? callback : null, changeSource !== null && changeSource !== void 0 ? changeSource : null, canUndoByBackspace !== null && canUndoByBackspace !== void 0 ? canUndoByBackspace : false, additionalData);
        };
        /**
         * Whether there is an available undo/redo snapshot
         */
        Editor.prototype.getUndoState = function () {
            var _a = this.getCore().undo, hasNewContent = _a.hasNewContent, snapshotsService = _a.snapshotsService;
            return {
                canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),
                canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),
            };
        };
        //#endregion
        //#region Misc
        /**
         * Get document which contains this editor
         * @returns The HTML document which contains this editor
         */
        Editor.prototype.getDocument = function () {
            return this.getCore().contentDiv.ownerDocument;
        };
        /**
         * Get the scroll container of the editor
         */
        Editor.prototype.getScrollContainer = function () {
            return this.getCore().domEvent.scrollContainer;
        };
        /**
         * Get custom data related to this editor
         * @param key Key of the custom data
         * @param getter Getter function. If custom data for the given key doesn't exist,
         * call this function to get one and store it if it is specified. Otherwise return undefined
         * @param disposer An optional disposer function to dispose this custom data when
         * dispose editor.
         */
        Editor.prototype.getCustomData = function (key, getter, disposer) {
            var core = this.getCore();
            return (core.lifecycle.customData[key] = core.lifecycle.customData[key] || {
                value: getter ? getter() : undefined,
                disposer: disposer,
            }).value;
        };
        /**
         * Check if editor is in IME input sequence
         * @returns True if editor is in IME input sequence, otherwise false
         */
        Editor.prototype.isInIME = function () {
            return this.getCore().domEvent.isInIME;
        };
        /**
         * Get default format of this editor
         * @returns Default format object of this editor
         */
        Editor.prototype.getDefaultFormat = function () {
            var _a;
            return (_a = this.getCore().lifecycle.defaultFormat) !== null && _a !== void 0 ? _a : {};
        };
        /**
         * Get a content traverser for the whole editor
         * @param startNode The node to start from. If not passed, it will start from the beginning of the body
         */
        Editor.prototype.getBodyTraverser = function (startNode) {
            return roosterjs_editor_dom_1$1f.ContentTraverser.createBodyTraverser(this.getCore().contentDiv, startNode);
        };
        /**
         * Get a content traverser for current selection
         * @returns A content traverser, or null if editor never got focus before
         */
        Editor.prototype.getSelectionTraverser = function (range) {
            var _a;
            range = (_a = range !== null && range !== void 0 ? range : this.getSelectionRange()) !== null && _a !== void 0 ? _a : undefined;
            return range
                ? roosterjs_editor_dom_1$1f.ContentTraverser.createSelectionTraverser(this.getCore().contentDiv, range)
                : null;
        };
        /**
         * Get a content traverser for current block element start from specified position
         * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart
         * @returns A content traverser, or null if editor never got focus before
         */
        Editor.prototype.getBlockTraverser = function (startFrom) {
            if (startFrom === void 0) { startFrom = 3 /* SelectionStart */; }
            var range = this.getSelectionRange();
            return range
                ? roosterjs_editor_dom_1$1f.ContentTraverser.createBlockTraverser(this.getCore().contentDiv, range, startFrom)
                : null;
        };
        /**
         * Get a text traverser of current selection
         * @param event Optional, if specified, editor will try to get cached result from the event object first.
         * If it is not cached before, query from DOM and cache the result into the event object
         * @returns A content traverser, or null if editor never got focus before
         */
        Editor.prototype.getContentSearcherOfCursor = function (event) {
            var _this = this;
            return (0, roosterjs_editor_dom_1$1f.cacheGetEventData)(event !== null && event !== void 0 ? event : null, 'ContentSearcher', function () {
                var range = _this.getSelectionRange();
                return (range &&
                    new roosterjs_editor_dom_1$1f.PositionContentSearcher(_this.getCore().contentDiv, roosterjs_editor_dom_1$1f.Position.getStart(range)));
            });
        };
        /**
         * Run a callback function asynchronously
         * @param callback The callback function to run
         * @returns a function to cancel this async run
         */
        Editor.prototype.runAsync = function (callback) {
            var _this = this;
            var win = this.getCore().contentDiv.ownerDocument.defaultView || window;
            var handle = win.requestAnimationFrame(function () {
                if (!_this.isDisposed() && callback) {
                    callback(_this);
                }
            });
            return function () {
                win.cancelAnimationFrame(handle);
            };
        };
        /**
         * Set DOM attribute of editor content DIV
         * @param name Name of the attribute
         * @param value Value of the attribute
         */
        Editor.prototype.setEditorDomAttribute = function (name, value) {
            if (value === null) {
                this.getCore().contentDiv.removeAttribute(name);
            }
            else {
                this.getCore().contentDiv.setAttribute(name, value);
            }
        };
        /**
         * Get DOM attribute of editor content DIV, null if there is no such attribute.
         * @param name Name of the attribute
         */
        Editor.prototype.getEditorDomAttribute = function (name) {
            return this.getCore().contentDiv.getAttribute(name);
        };
        /**
         * @deprecated Use getVisibleViewport() instead.
         *
         * Get current relative distance from top-left corner of the given element to top-left corner of editor content DIV.
         * @param element The element to calculate from. If the given element is not in editor, return value will be null
         * @param addScroll When pass true, The return value will also add scrollLeft and scrollTop if any. So the value
         * may be different than what user is seeing from the view. When pass false, scroll position will be ignored.
         * @returns An [x, y] array which contains the left and top distances, or null if the given element is not in editor.
         */
        Editor.prototype.getRelativeDistanceToEditor = function (element, addScroll) {
            if (this.contains(element)) {
                var contentDiv = this.getCore().contentDiv;
                var editorRect = contentDiv.getBoundingClientRect();
                var elementRect = element.getBoundingClientRect();
                if (editorRect && elementRect) {
                    var x = elementRect.left - (editorRect === null || editorRect === void 0 ? void 0 : editorRect.left);
                    var y = elementRect.top - (editorRect === null || editorRect === void 0 ? void 0 : editorRect.top);
                    if (addScroll) {
                        x += contentDiv.scrollLeft;
                        y += contentDiv.scrollTop;
                    }
                    return [x, y];
                }
            }
            return null;
        };
        /**
         * Add a Content Edit feature.
         * @param feature The feature to add
         */
        Editor.prototype.addContentEditFeature = function (feature) {
            var core = this.getCore();
            feature === null || feature === void 0 ? void 0 : feature.keys.forEach(function (key) {
                var array = core.edit.features[key] || [];
                array.push(feature);
                core.edit.features[key] = array;
            });
        };
        /**
         * Remove a Content Edit feature.
         * @param feature The feature to remove
         */
        Editor.prototype.removeContentEditFeature = function (feature) {
            var core = this.getCore();
            feature === null || feature === void 0 ? void 0 : feature.keys.forEach(function (key) {
                var _a;
                var featureSet = core.edit.features[key];
                var index = (_a = featureSet === null || featureSet === void 0 ? void 0 : featureSet.indexOf(feature)) !== null && _a !== void 0 ? _a : -1;
                if (index >= 0) {
                    core.edit.features[key].splice(index, 1);
                    if (core.edit.features[key].length < 1) {
                        delete core.edit.features[key];
                    }
                }
            });
        };
        /**
         * Get style based format state from current selection, including font name/size and colors
         */
        Editor.prototype.getStyleBasedFormatState = function (node) {
            var _a;
            if (!node) {
                var range = this.getSelectionRange();
                node = (_a = (range && roosterjs_editor_dom_1$1f.Position.getStart(range).normalize().node)) !== null && _a !== void 0 ? _a : undefined;
            }
            var core = this.getCore();
            return core.api.getStyleBasedFormatState(core, node !== null && node !== void 0 ? node : null);
        };
        /**
         * Get the pendable format such as underline and bold
         * @param forceGetStateFromDOM If set to true, will force get the format state from DOM tree.
         * @returns The pending format state
         */
        Editor.prototype.getPendableFormatState = function (forceGetStateFromDOM) {
            if (forceGetStateFromDOM === void 0) { forceGetStateFromDOM = false; }
            var core = this.getCore();
            return core.api.getPendableFormatState(core, forceGetStateFromDOM);
        };
        /**
         * Ensure user will type into a container element rather than into the editor content DIV directly
         * @param position The position that user is about to type to
         * @param keyboardEvent Optional keyboard event object
         */
        Editor.prototype.ensureTypeInContainer = function (position, keyboardEvent) {
            var core = this.getCore();
            core.api.ensureTypeInContainer(core, position, keyboardEvent, this.isFeatureEnabled("DefaultFormatInSpan" /* DefaultFormatInSpan */));
        };
        //#endregion
        //#region Dark mode APIs
        /**
         * Set the dark mode state and transforms the content to match the new state.
         * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.
         */
        Editor.prototype.setDarkModeState = function (nextDarkMode) {
            var isDarkMode = this.isDarkMode();
            if (isDarkMode == !!nextDarkMode) {
                return;
            }
            var core = this.getCore();
            core.api.transformColor(core, core.contentDiv, false /*includeSelf*/, null /*callback*/, nextDarkMode
                ? 0 /* LightToDark */
                : 1 /* DarkToLight */, true /*forceTransform*/, isDarkMode);
            this.triggerContentChangedEvent(nextDarkMode ? "SwitchToDarkMode" /* SwitchToDarkMode */ : "SwitchToLightMode" /* SwitchToLightMode */);
        };
        /**
         * Check if the editor is in dark mode
         * @returns True if the editor is in dark mode, otherwise false
         */
        Editor.prototype.isDarkMode = function () {
            return this.getCore().lifecycle.isDarkMode;
        };
        /**
         * Transform the given node and all its child nodes to dark mode color if editor is in dark mode
         * @param node The node to transform
         */
        Editor.prototype.transformToDarkColor = function (node) {
            var core = this.getCore();
            core.api.transformColor(core, node, true /*includeSelf*/, null /*callback*/, 0 /* LightToDark */);
        };
        /**
         * Get a darkColorHandler object for this editor. It will return null if experimental feature "VariableBasedDarkColor" is not enabled
         */
        Editor.prototype.getDarkColorHandler = function () {
            return this.getCore().darkColorHandler || null;
        };
        /**
         * Make the editor in "Shadow Edit" mode.
         * In Shadow Edit mode, all format change will finally be ignored.
         * This can be used for building a live preview feature for format button, to allow user
         * see format result without really apply it.
         * This function can be called repeated. If editor is already in shadow edit mode, we can still
         * use this function to do more shadow edit operation.
         */
        Editor.prototype.startShadowEdit = function () {
            var core = this.getCore();
            core.api.switchShadowEdit(core, true /*isOn*/);
        };
        /**
         * Leave "Shadow Edit" mode, all changes made during shadow edit will be discarded
         */
        Editor.prototype.stopShadowEdit = function () {
            var core = this.getCore();
            core.api.switchShadowEdit(core, false /*isOn*/);
        };
        /**
         * Check if editor is in Shadow Edit mode
         */
        Editor.prototype.isInShadowEdit = function () {
            return !!this.getCore().lifecycle.shadowEditFragment;
        };
        /**
         * Check if the given experimental feature is enabled
         * @param feature The feature to check
         */
        Editor.prototype.isFeatureEnabled = function (feature) {
            return this.getCore().lifecycle.experimentalFeatures.indexOf(feature) >= 0;
        };
        /**
         * Get a function to convert HTML string to trusted HTML string.
         * By default it will just return the input HTML directly. To override this behavior,
         * pass your own trusted HTML handler to EditorOptions.trustedHTMLHandler
         * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types
         */
        Editor.prototype.getTrustedHTMLHandler = function () {
            return this.getCore().trustedHTMLHandler;
        };
        /**
         * @deprecated Use getZoomScale() instead
         */
        Editor.prototype.getSizeTransformer = function () {
            return this.getCore().sizeTransformer;
        };
        /**
         * Get current zoom scale, default value is 1
         * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale
         * to let editor behave correctly especially for those mouse drag/drop behaviors
         * @returns current zoom scale number
         */
        Editor.prototype.getZoomScale = function () {
            return this.getCore().zoomScale;
        };
        /**
         * Set current zoom scale, default value is 1
         * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale
         * to let editor behave correctly especially for those mouse drag/drop behaviors
         * @param scale The new scale number to set. It should be positive number and no greater than 10, otherwise it will be ignored.
         */
        Editor.prototype.setZoomScale = function (scale) {
            var core = this.getCore();
            if (scale > 0 && scale <= 10) {
                var oldValue = core.zoomScale;
                core.zoomScale = scale;
                if (oldValue != scale) {
                    this.triggerPluginEvent(21 /* ZoomChanged */, {
                        oldZoomScale: oldValue,
                        newZoomScale: scale,
                    }, true /*broadcast*/);
                }
            }
        };
        /**
         * Retrieves the rect of the visible viewport of the editor.
         */
        Editor.prototype.getVisibleViewport = function () {
            return this.getCore().getVisibleViewport();
        };
        /**
         * @returns the current EditorCore object
         * @throws a standard Error if there's no core object
         */
        Editor.prototype.getCore = function () {
            if (!this.core) {
                throw new Error('Editor is already disposed');
            }
            return this.core;
        };
        return Editor;
    }());
    Editor$1.default = Editor;
    function isSelectionRangeEx(obj) {
        var rangeEx = obj;
        return (rangeEx &&
            typeof rangeEx == 'object' &&
            typeof rangeEx.type == 'number' &&
            Array.isArray(rangeEx.ranges));
    }
    function isTableSelection(obj) {
        var selection = obj;
        return (selection &&
            typeof selection == 'object' &&
            typeof selection.firstCell == 'object' &&
            typeof selection.lastCell == 'object');
    }
    function isSelectionPath(obj) {
        var path = obj;
        return path && typeof path == 'object' && Array.isArray(path.start) && Array.isArray(path.end);
    }
    function isNodePosition(obj) {
        var pos = obj;
        return (pos &&
            typeof pos == 'object' &&
            typeof pos.node == 'object' &&
            typeof pos.offset == 'number');
    }

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Editor = void 0;
    // Classes
    var Editor_1 = Editor$1;
    Object.defineProperty(exports, "Editor", { enumerable: true, get: function () { return Editor_1.default; } });

    }(lib$2));

    var __assign$d = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$d = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$d.apply(this, arguments);
    };
    Object.defineProperty(Rooster$1, "__esModule", { value: true });
    var React$e = react.exports;
    var index_1$3 = common;
    var Utilities_1$4 = require$$2$2;
    var roosterjs_editor_core_1 = lib$2;
    var Theme_1$1 = require$$12;
    /**
     * Main component of react wrapper for roosterjs
     * @param props Properties of this component
     * @returns The react component
     */
    function Rooster(props) {
        var editorDiv = React$e.useRef(null);
        var editor = React$e.useRef(null);
        var theme = (0, Theme_1$1.useTheme)();
        var focusOnInit = props.focusOnInit, editorCreator = props.editorCreator, zoomScale = props.zoomScale, inDarkMode = props.inDarkMode, plugins = props.plugins;
        React$e.useEffect(function () {
            if (plugins && editorDiv.current) {
                var uiUtilities_1 = (0, index_1$3.createUIUtilities)(editorDiv.current, theme);
                plugins.forEach(function (plugin) {
                    if (isReactEditorPlugin(plugin)) {
                        plugin.setUIUtilities(uiUtilities_1);
                    }
                });
            }
        }, [theme, editorCreator]);
        React$e.useEffect(function () {
            var _a;
            if (editorDiv.current) {
                editor.current = (editorCreator || defaultEditorCreator)(editorDiv.current, props);
            }
            if (focusOnInit) {
                (_a = editor.current) === null || _a === void 0 ? void 0 : _a.focus();
            }
            return function () {
                if (editor.current) {
                    editor.current.dispose();
                    editor.current = null;
                }
            };
        }, [editorCreator]);
        React$e.useEffect(function () {
            var _a;
            (_a = editor.current) === null || _a === void 0 ? void 0 : _a.setDarkModeState(!!inDarkMode);
        }, [inDarkMode]);
        React$e.useEffect(function () {
            var _a;
            if (zoomScale) {
                (_a = editor.current) === null || _a === void 0 ? void 0 : _a.setZoomScale(zoomScale);
            }
        }, [zoomScale]);
        var divProps = (0, Utilities_1$4.getNativeProps)(props, Utilities_1$4.divProperties);
        return React$e.createElement("div", __assign$d({ ref: editorDiv, tabIndex: 0 }, (divProps || {})));
    }
    Rooster$1.default = Rooster;
    function defaultEditorCreator(div, options) {
        return new roosterjs_editor_core_1.Editor(div, options);
    }
    function isReactEditorPlugin(plugin) {
        var _a;
        return !!((_a = plugin) === null || _a === void 0 ? void 0 : _a.setUIUtilities);
    }

    var createUpdateContentPlugin$1 = {};

    Object.defineProperty(createUpdateContentPlugin$1, "__esModule", { value: true });
    var UpdateMode_1 = UpdateMode;
    /**
     * A plugin to help get HTML content from editor
     */
    var UpdateContentPluginImpl = /** @class */ (function () {
        /**
         * Create a new instance of UpdateContentPlugin class
         * @param updateMode Mode of automatic update. It can be a combination of multiple UpdateMode values
         * @param onUpdate A callback to be invoked when update happens
         */
        function UpdateContentPluginImpl(updateMode, onUpdate) {
            var _this = this;
            this.updateMode = updateMode;
            this.onUpdate = onUpdate;
            this.editor = null;
            this.disposer = null;
            this.onBlur = function () {
                _this.update(UpdateMode_1.UpdateMode.OnBlur);
            };
        }
        /**
         * Get a friendly name of this plugin
         */
        UpdateContentPluginImpl.prototype.getName = function () {
            return 'UpdateContent';
        };
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        UpdateContentPluginImpl.prototype.initialize = function (editor) {
            this.editor = editor;
            this.disposer = this.editor.addDomEventHandler('blur', this.onBlur);
        };
        /**
         * Dispose this plugin
         */
        UpdateContentPluginImpl.prototype.dispose = function () {
            var _a;
            (_a = this.disposer) === null || _a === void 0 ? void 0 : _a.call(this);
            this.disposer = null;
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        UpdateContentPluginImpl.prototype.onPluginEvent = function (event) {
            switch (event.eventType) {
                case 11 /* EditorReady */:
                    this.update(UpdateMode_1.UpdateMode.OnInitialize);
                    break;
                case 12 /* BeforeDispose */:
                    this.update(UpdateMode_1.UpdateMode.OnDispose);
                    break;
                case 7 /* ContentChanged */:
                    this.update(UpdateMode_1.UpdateMode.OnContentChangedEvent);
                    break;
                case 3 /* Input */:
                    this.update(UpdateMode_1.UpdateMode.OnUserInput);
                    break;
            }
        };
        /**
         * Trigger a force update. onUpdate callback will be invoked with HTML content of editor
         */
        UpdateContentPluginImpl.prototype.forceUpdate = function () {
            this.update(UpdateMode_1.UpdateMode.Force);
        };
        UpdateContentPluginImpl.prototype.update = function (mode) {
            if (this.editor &&
                (mode == UpdateMode_1.UpdateMode.Force || ((this.updateMode || 0) & mode) == mode) &&
                this.onUpdate) {
                var content = this.editor.getContent();
                this.onUpdate(content, mode);
            }
        };
        return UpdateContentPluginImpl;
    }());
    /**
     * Create a new instance of UpdateContentPlugin class
     * @param updateMode Mode of automatic update. It can be a combination of multiple UpdateMode values
     * @param onUpdate A callback to be invoked when update happens
     */
    function createUpdateContentPlugin(updateMode, onUpdate) {
        return new UpdateContentPluginImpl(updateMode, onUpdate);
    }
    createUpdateContentPlugin$1.default = createUpdateContentPlugin;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUpdateContentPlugin = exports.Rooster = exports.UpdateMode = void 0;
    var UpdateMode_1 = UpdateMode;
    Object.defineProperty(exports, "UpdateMode", { enumerable: true, get: function () { return UpdateMode_1.UpdateMode; } });
    var Rooster_1 = Rooster$1;
    Object.defineProperty(exports, "Rooster", { enumerable: true, get: function () { return Rooster_1.default; } });
    var createUpdateContentPlugin_1 = createUpdateContentPlugin$1;
    Object.defineProperty(exports, "createUpdateContentPlugin", { enumerable: true, get: function () { return createUpdateContentPlugin_1.default; } });

    }(rooster));

    var ribbon = {};

    var KnownRibbonButton = {};

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KnownRibbonButtonKey = void 0;
    (function (KnownRibbonButtonKey) {
        /**
         * "Bold" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Bold"] = 0] = "Bold";
        /**
         * "Italic" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Italic"] = 1] = "Italic";
        /**
         * "Underline" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Underline"] = 2] = "Underline";
        /**
         * "Font" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Font"] = 3] = "Font";
        /**
         * "FontSize" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["FontSize"] = 4] = "FontSize";
        /**
         * "IncreaseFontSize" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["IncreaseFontSize"] = 5] = "IncreaseFontSize";
        /**
         * "DecreaseFontSize" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["DecreaseFontSize"] = 6] = "DecreaseFontSize";
        /**
         * "TextColor" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["TextColor"] = 7] = "TextColor";
        /**
         * "BackgroundColor" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["BackgroundColor"] = 8] = "BackgroundColor";
        /**
         * "BulletedList" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["BulletedList"] = 9] = "BulletedList";
        /**
         * "NumberedList" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["NumberedList"] = 10] = "NumberedList";
        /**
         * "DecreaseIndent" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["DecreaseIndent"] = 11] = "DecreaseIndent";
        /**
         * "IncreaseIndent" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["IncreaseIndent"] = 12] = "IncreaseIndent";
        /**
         * "Quote" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Quote"] = 13] = "Quote";
        /**
         * "AlignLeft" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["AlignLeft"] = 14] = "AlignLeft";
        /**
         * "AlignCenter" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["AlignCenter"] = 15] = "AlignCenter";
        /**
         * "AlignRight" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["AlignRight"] = 16] = "AlignRight";
        /**
         * "InsertLink" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["InsertLink"] = 17] = "InsertLink";
        /**
         * "RemoveLink" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["RemoveLink"] = 18] = "RemoveLink";
        /**
         * "InsertTable" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["InsertTable"] = 19] = "InsertTable";
        /**
         * "InsertImage" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["InsertImage"] = 20] = "InsertImage";
        /**
         * "Superscript" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Superscript"] = 21] = "Superscript";
        /**
         * "Subscript" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Subscript"] = 22] = "Subscript";
        /**
         * "Strikethrough" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Strikethrough"] = 23] = "Strikethrough";
        /**
         * "Header" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Header"] = 24] = "Header";
        /**
         * "Code" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Code"] = 25] = "Code";
        /**
         * "Ltr" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Ltr"] = 26] = "Ltr";
        /**
         * "Rtl" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Rtl"] = 27] = "Rtl";
        /**
         * "Undo" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Undo"] = 28] = "Undo";
        /**
         * "Redo" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["Redo"] = 29] = "Redo";
        /**
         * "ClearFormat" button on the format ribbon
         */
        KnownRibbonButtonKey[KnownRibbonButtonKey["ClearFormat"] = 30] = "ClearFormat";
    })(exports.KnownRibbonButtonKey || (exports.KnownRibbonButtonKey = {}));

    }(KnownRibbonButton));

    var Ribbon$1 = {};

    var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(CommandBar);

    var require$$7 = /*@__PURE__*/getAugmentedNamespace(FocusZone);

    var require$$10 = /*@__PURE__*/getAugmentedNamespace(Styling);

    var moreCommands = {};

    Object.defineProperty(moreCommands, "__esModule", { value: true });
    moreCommands.moreCommands = void 0;
    /**
     * @internal
     * "More commands" (overflow) button on the format ribbon
     */
    moreCommands.moreCommands = {
        key: 'buttonNameMoreCommands',
        unlocalizedText: 'More commands',
        iconName: 'MoreCommands',
        onClick: function (editor) {
            return true;
        },
    };

    var __assign$c = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$c = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$c.apply(this, arguments);
    };
    Object.defineProperty(Ribbon$1, "__esModule", { value: true });
    var React$d = react.exports;
    var getLocalizedString_1$1 = getLocalizedString$1;
    var CommandBar_1 = require$$2$1;
    var FocusZone_1$2 = require$$7;
    var roosterjs_editor_dom_1$1e = lib$3;
    var Styling_1$5 = require$$10;
    var moreCommands_1 = moreCommands;
    var ribbonClassName = (0, Styling_1$5.mergeStyles)({
        '& .ms-CommandBar': {
            padding: '0px',
        },
    });
    var rtlIcon = (0, Styling_1$5.mergeStyles)({
        transform: 'scaleX(-1)',
    });
    /**
     * The format ribbon component of roosterjs-react
     * @param props Properties of format ribbon component
     * @returns The format ribbon component
     */
    function Ribbon(props) {
        var plugin = props.plugin, buttons = props.buttons, strings = props.strings, dir = props.dir;
        var _a = React$d.useState(null), formatState = _a[0], setFormatState = _a[1];
        var isRtl = dir == 'rtl';
        var onClick = React$d.useCallback(function (_, item) {
            if (item) {
                plugin === null || plugin === void 0 ? void 0 : plugin.onButtonClick(item.data, item.key, strings);
            }
        }, [plugin, strings]);
        var onHover = React$d.useCallback(function (button, key) {
            plugin.startLivePreview(button, key, strings);
        }, [plugin, strings]);
        var onDismiss = React$d.useCallback(function () {
            plugin.stopLivePreview();
        }, [plugin]);
        var flipIcon = React$d.useCallback(function (props, defaultRender) {
            if (!defaultRender) {
                return null;
            }
            return React$d.createElement("span", { className: rtlIcon }, defaultRender(props));
        }, []);
        var commandBarItems = React$d.useMemo(function () {
            return buttons.map(function (button) {
                var _a, _b, _c, _d;
                var selectedItem = formatState && ((_b = (_a = button.dropDownMenu) === null || _a === void 0 ? void 0 : _a.getSelectedItemKey) === null || _b === void 0 ? void 0 : _b.call(_a, formatState));
                var dropDownMenu = button.dropDownMenu;
                var result = __assign$c({ key: button.key, data: button, iconProps: {
                        iconName: button.iconName,
                    }, onRenderIcon: isRtl && button.flipWhenRtl ? flipIcon : undefined, iconOnly: true, text: (0, getLocalizedString_1$1.default)(strings, button.key, button.unlocalizedText), ariaLabel: (0, getLocalizedString_1$1.default)(strings, button.key, button.unlocalizedText), canCheck: true, checked: (formatState && ((_c = button.isChecked) === null || _c === void 0 ? void 0 : _c.call(button, formatState))) || false, disabled: (formatState && ((_d = button.isDisabled) === null || _d === void 0 ? void 0 : _d.call(button, formatState))) || false }, (button.commandBarProperties || {}));
                var contextMenuItemRenderer = function (props, defaultRenderer) {
                    return props && defaultRenderer ? (React$d.createElement("div", { onMouseOver: function (e) { return onHover(button, props.key); } }, defaultRenderer(props))) : null;
                };
                if (dropDownMenu) {
                    result.subMenuProps = __assign$c({ shouldFocusOnMount: true, focusZoneProps: { direction: FocusZone_1$2.FocusZoneDirection.bidirectional }, onDismiss: onDismiss, onItemClick: onClick, onRenderContextualMenuItem: dropDownMenu.allowLivePreview
                            ? contextMenuItemRenderer
                            : undefined, items: (0, roosterjs_editor_dom_1$1e.getObjectKeys)(dropDownMenu.items).map(function (key) { return ({
                            key: key,
                            text: (0, getLocalizedString_1$1.default)(strings, key, dropDownMenu.items[key]),
                            data: button,
                            canCheck: !!dropDownMenu.getSelectedItemKey,
                            checked: selectedItem == key || false,
                            className: dropDownMenu.itemClassName,
                            onRender: dropDownMenu.itemRender
                                ? function (item) { return dropDownMenu.itemRender(item, onClick); }
                                : undefined,
                        }); }) }, (dropDownMenu.commandBarSubMenuProperties || {}));
                }
                else {
                    result.onClick = onClick;
                }
                return result;
            });
        }, [buttons, formatState, isRtl, strings, onClick, onDismiss, onHover]);
        React$d.useEffect(function () {
            var disposer = plugin === null || plugin === void 0 ? void 0 : plugin.registerFormatChangedCallback(setFormatState);
            return function () {
                disposer === null || disposer === void 0 ? void 0 : disposer();
            };
        }, [plugin]);
        var moreCommandsBtn = moreCommands_1.moreCommands;
        return (React$d.createElement(CommandBar_1.CommandBar, __assign$c({ items: commandBarItems }, props, { className: ribbonClassName + ' ' + ((props === null || props === void 0 ? void 0 : props.className) || ''), overflowButtonProps: {
                ariaLabel: (0, getLocalizedString_1$1.default)(strings, moreCommandsBtn.key, moreCommandsBtn.unlocalizedText),
            } })));
    }
    Ribbon$1.default = Ribbon;

    var getButtons = {};

    var alignCenter = {};

    var lib$1 = {};

    var changeFontSize = {};

    var applyInlineStyle$1 = {};

    var formatUndoSnapshot$1 = {};

    Object.defineProperty(formatUndoSnapshot$1, "__esModule", { value: true });
    /**
     * @internal
     * Execute add undo snapshot for the Format APIs
     * @param editor The editor instance
     * @param command Optional, The callback function to perform formatting, returns a data object which will be used as the data field in ContentChangedEvent if changeSource is not null.
     * @param apiName Optional, name of the API that was is going to be executed.
     * Default value is false.
     */
    function formatUndoSnapshot(editor, callback, apiName) {
        editor.addUndoSnapshot(callback, "Format" /* Format */, undefined /* canUndoByBackspace */, apiName && apiName != ''
            ? {
                formatApiName: apiName,
            }
            : undefined);
    }
    formatUndoSnapshot$1.default = formatUndoSnapshot;

    Object.defineProperty(applyInlineStyle$1, "__esModule", { value: true });
    var formatUndoSnapshot_1$f = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$1d = lib$3;
    /**
     * @internal
     * Apply inline style to current selection
     * @param editor The editor instance
     * @param callback The callback function to apply style
     */
    function applyInlineStyle(editor, callback, apiName) {
        editor.focus();
        var selection = editor.getSelectionRangeEx();
        var safeCallback = function (element, isInnerNode) {
            return element.isContentEditable && callback(element, isInnerNode);
        };
        if (selection && selection.areAllCollapsed) {
            var range = selection.ranges[0];
            var node = range.startContainer;
            var isEmptySpan = (0, roosterjs_editor_dom_1$1d.getTagOfNode)(node) == 'SPAN' &&
                (!node.firstChild ||
                    ((0, roosterjs_editor_dom_1$1d.getTagOfNode)(node.firstChild) == 'BR' && !node.firstChild.nextSibling));
            if (isEmptySpan) {
                editor.addUndoSnapshot();
                safeCallback(node);
            }
            else {
                editor.triggerPluginEvent(13 /* PendingFormatStateChanged */, {
                    formatState: {},
                    // Here we use callback instead of safeCallback because we know it's contentEditable.
                    // In addition, for elements that are not added to the DOM tree, isContentEditable always returns false on Safari.
                    formatCallback: callback,
                });
                editor.triggerContentChangedEvent("Format" /* Format */);
            }
        }
        else {
            // This is start and end node that get the style. The start and end needs to be recorded so that selection
            // can be re-applied post-applying style
            (0, formatUndoSnapshot_1$f.default)(editor, function () {
                var firstNode;
                var lastNode;
                selection.ranges.forEach(function (range) {
                    var contentTraverser = editor.getSelectionTraverser(range);
                    if (!contentTraverser) {
                        return;
                    }
                    var inlineElement = contentTraverser && contentTraverser.currentInlineElement;
                    while (inlineElement) {
                        var nextInlineElement = contentTraverser.getNextInlineElement();
                        inlineElement.applyStyle(function (element, isInnerNode) {
                            safeCallback(element, isInnerNode);
                            firstNode = firstNode || element;
                            lastNode = element;
                        });
                        inlineElement = nextInlineElement;
                    }
                });
                if (firstNode && lastNode && selection.type == 0 /* Normal */) {
                    editor.select(firstNode, -2 /* Before */, lastNode, -3 /* After */);
                }
            }, apiName);
        }
    }
    applyInlineStyle$1.default = applyInlineStyle;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNewFontSize = exports.FONT_SIZES = void 0;
    var applyInlineStyle_1 = applyInlineStyle$1;
    var roosterjs_editor_dom_1 = lib$3;
    /**
     * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,
     * So that when increase/decrease font size, the font size can match the sequence of your font size picker
     */
    exports.FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
    var MIN_FONT_SIZE = 1;
    var MAX_FONT_SIZE = 1000;
    /**
     * Increase or decrease font size in selection
     * @param editor The editor instance
     * @param change Whether increase or decrease font size
     * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES
     */
    function changeFontSize(editor, change, fontSizes) {
        if (fontSizes === void 0) { fontSizes = exports.FONT_SIZES; }
        var changeBase = change == 0 /* Increase */ ? 1 : -1;
        (0, applyInlineStyle_1.default)(editor, function (element) {
            var pt = parseFloat((0, roosterjs_editor_dom_1.getComputedStyle)(element, 'font-size') || element.style.fontSize);
            element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';
            var lineHeight = (0, roosterjs_editor_dom_1.getComputedStyle)(element, 'line-height');
            if (lineHeight && lineHeight != 'normal') {
                element.style.lineHeight = 'normal';
            }
        }, 'changeFontSize');
    }
    exports.default = changeFontSize;
    /**
     * @internal
     * Get new font size after increase/decrease. This is exported for test only
     * @param pt Original font size, in Point
     * @param changeBase Changed value, 1 means increase, -1 means decrease
     * @param fontSizes Known font size array
     */
    function getNewFontSize(pt, changeBase, fontSizes) {
        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);
        var last = fontSizes[fontSizes.length - 1];
        if (pt <= fontSizes[0]) {
            pt = Math.max(pt + changeBase, MIN_FONT_SIZE);
        }
        else if (pt > last || (pt == last && changeBase == 1)) {
            pt = pt / 10;
            pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);
            pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);
        }
        else if (changeBase == 1) {
            for (var i = 0; i < fontSizes.length; i++) {
                if (pt < fontSizes[i]) {
                    pt = fontSizes[i];
                    break;
                }
            }
        }
        else {
            for (var i = fontSizes.length - 1; i >= 0; i--) {
                if (pt > fontSizes[i]) {
                    pt = fontSizes[i];
                    break;
                }
            }
        }
        return pt;
    }
    exports.getNewFontSize = getNewFontSize;

    }(changeFontSize));

    var clearBlockFormat$2 = {};

    var clearFormat$2 = {};

    var applyListItemWrap = {};

    Object.defineProperty(applyListItemWrap, "__esModule", { value: true });
    var applyInlineStyle_1$2 = applyInlineStyle$1;
    var roosterjs_editor_dom_1$1c = lib$3;
    /**
     * @internal
     * Set the List Item Style when all inner inline element have the same style
     * @param editor The editor instance
     * @param styleName Name of the style to apply to the list item
     * @param formatCallback callback to apply the style to each element
     */
    function applyListItemStyleWrap(editor, styleName, formatCallback, apiName) {
        var parentNodes = [];
        (0, applyInlineStyle_1$2.default)(editor, function (element, isInnerNode) {
            formatCallback(element, isInnerNode);
            var parent = editor.getElementAtCursor('LI', element);
            if (parent && parentNodes.indexOf(parent) === -1) {
                parentNodes.push(parent);
            }
        }, apiName);
        applyStyleToListItems(parentNodes, [styleName]);
    }
    applyListItemWrap.default = applyListItemStyleWrap;
    /**
     * @internal
     * Checks if the parent element is a List Item, if it is, apply the style elements to the list item
     * @param parentNodes parentNodes to apply the style
     * @param styles styles to apply to the List Item Element
     */
    function applyStyleToListItems(parentNodes, styles) {
        parentNodes.forEach(function (node) {
            if ((0, roosterjs_editor_dom_1$1c.safeInstanceOf)(node, 'HTMLLIElement')) {
                (0, roosterjs_editor_dom_1$1c.setListItemStyle)(node, styles);
            }
        });
    }

    var blockFormat$1 = {};

    var commitListChains$1 = {};

    Object.defineProperty(commitListChains$1, "__esModule", { value: true });
    commitListChains$1.experimentCommitListChains = void 0;
    var roosterjs_editor_dom_1$1b = lib$3;
    /**
     * Commit changes of all list changes when experiment features are allowed
     * @param editor The Editor object
     * @param chains List chains to commit
     */
    function commitListChains(editor, chains) {
        if ((chains === null || chains === void 0 ? void 0 : chains.length) > 0) {
            var range = editor.getSelectionRange();
            var start = range && roosterjs_editor_dom_1$1b.Position.getStart(range);
            var end = range && roosterjs_editor_dom_1$1b.Position.getEnd(range);
            var shouldReuseAllAncestorListElements_1 = editor.isFeatureEnabled("ReuseAllAncestorListElements" /* ReuseAllAncestorListElements */);
            chains.forEach(function (chain) { return chain.commit(shouldReuseAllAncestorListElements_1); });
            if (start && end) {
                editor.select(start, end);
            }
        }
    }
    commitListChains$1.default = commitListChains;
    /**
     * @deprecated
     * Same with commitListChains, keep this export just for backward compatibility
     */
    commitListChains$1.experimentCommitListChains = commitListChains;

    Object.defineProperty(blockFormat$1, "__esModule", { value: true });
    var commitListChains_1$1 = commitListChains$1;
    var formatUndoSnapshot_1$e = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$1a = lib$3;
    /**
     * Split selection into regions, and perform a block-wise formatting action for each region.
     */
    function blockFormat(editor, callback, beforeRunCallback, apiName) {
        editor.focus();
        var selection = editor.getSelectionRangeEx();
        (0, formatUndoSnapshot_1$e.default)(editor, function (start, end) {
            if (!beforeRunCallback || beforeRunCallback()) {
                var regions = editor.getSelectedRegions();
                if (regions.length > 0) {
                    var chains_1 = roosterjs_editor_dom_1$1a.VListChain.createListChains(regions, start === null || start === void 0 ? void 0 : start.node);
                    regions.forEach(function (region) { return callback(region, start, end, chains_1); });
                    (0, commitListChains_1$1.default)(editor, chains_1);
                }
            }
            if (selection.type == 0 /* Normal */ && start && end) {
                editor.select(start, end);
            }
            else {
                editor.select(selection);
            }
        }, apiName);
    }
    blockFormat$1.default = blockFormat;

    var execCommand$1 = {};

    Object.defineProperty(execCommand$1, "__esModule", { value: true });
    var formatUndoSnapshot_1$d = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$19 = lib$3;
    /**
     * @internal
     * Execute a document command
     * @param editor The editor instance
     * @param command The command to execute
     * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.
     * Default value is false.
     * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.
     * Default value is false.
     */
    function execCommand(editor, command, apiName) {
        editor.focus();
        var formatter = function () { return editor.getDocument().execCommand(command, false, undefined); };
        var selection = editor.getSelectionRangeEx();
        if (selection && selection.areAllCollapsed) {
            editor.addUndoSnapshot();
            var formatState = editor.getPendableFormatState(false /* forceGetStateFromDom */);
            formatter();
            var formatName = (0, roosterjs_editor_dom_1$19.getObjectKeys)(roosterjs_editor_dom_1$19.PendableFormatCommandMap).filter(function (x) { return roosterjs_editor_dom_1$19.PendableFormatCommandMap[x] == command; })[0];
            if (formatName) {
                formatState[formatName] = !formatState[formatName];
                editor.triggerPluginEvent(13 /* PendingFormatStateChanged */, {
                    formatState: formatState,
                });
            }
        }
        else {
            (0, formatUndoSnapshot_1$d.default)(editor, function () {
                var needToSwitchSelection = selection.type != 0 /* Normal */;
                selection.ranges.forEach(function (range) {
                    if (needToSwitchSelection) {
                        editor.select(range);
                    }
                    formatter();
                });
                if (needToSwitchSelection) {
                    editor.select(selection);
                }
            }, apiName);
        }
    }
    execCommand$1.default = execCommand;

    var setBackgroundColor$1 = {};

    Object.defineProperty(setBackgroundColor$1, "__esModule", { value: true });
    var applyInlineStyle_1$1 = applyInlineStyle$1;
    var roosterjs_editor_dom_1$18 = lib$3;
    /**
     * Set background color at current selection
     * @param editor The editor instance
     * @param color One of two options:
     * The color string, can be any of the predefined color names (e.g, 'red')
     * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take effect
     * Alternatively, you can pass a @typedef ModeIndependentColor. If in light mode, the lightModeColor property will be used.
     * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.
     **/
    function setBackgroundColor(editor, color) {
        (0, applyInlineStyle_1$1.default)(editor, function (element, isInnerNode) {
            (0, roosterjs_editor_dom_1$18.setColor)(element, isInnerNode ? '' : color, true /*isBackground*/, editor.isDarkMode(), false /*shouldAdaptFontColor*/, editor.getDarkColorHandler());
        }, 'setBackgroundColor');
    }
    setBackgroundColor$1.default = setBackgroundColor;

    var setFontName$1 = {};

    Object.defineProperty(setFontName$1, "__esModule", { value: true });
    var applyListItemWrap_1$3 = applyListItemWrap;
    /**
     * Set font name at selection
     * @param editor The editor instance
     * @param fontName The fontName string, should be a valid CSS font-family style.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setFontName(editor, fontName) {
        // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard
        // (http://www.w3schools.com/tags/tag_font.asp).
        (0, applyListItemWrap_1$3.default)(editor, 'font-family', function (element, isInnerNode) {
            element.style.fontFamily = isInnerNode ? '' : fontName;
        }, 'setFontName');
    }
    setFontName$1.default = setFontName;

    var setFontSize$1 = {};

    Object.defineProperty(setFontSize$1, "__esModule", { value: true });
    var applyListItemWrap_1$2 = applyListItemWrap;
    var roosterjs_editor_dom_1$17 = lib$3;
    /**
     * Set font size at selection
     * @param editor The editor instance
     * @param fontSize The fontSize string, should be a valid CSS font-size style.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setFontSize(editor, fontSize) {
        // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.
        // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp).
        (0, applyListItemWrap_1$2.default)(editor, 'font-size', function (element, isInnerNode) {
            element.style.fontSize = isInnerNode ? '' : fontSize;
            var lineHeight = (0, roosterjs_editor_dom_1$17.getComputedStyle)(element, 'line-height');
            if (lineHeight && lineHeight != 'normal') {
                element.style.lineHeight = 'normal';
            }
        }, 'setFontSize');
    }
    setFontSize$1.default = setFontSize;

    var setTextColor$1 = {};

    Object.defineProperty(setTextColor$1, "__esModule", { value: true });
    var applyListItemWrap_1$1 = applyListItemWrap;
    var roosterjs_editor_dom_1$16 = lib$3;
    /**
     * Set text color at selection
     * @param editor The editor instance
     * @param color One of two options:
     * The color string, can be any of the predefined color names (e.g, 'red')
     * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     * Alternatively, you can pass a @typedef ModeIndependentColor. If in light mode, the lightModeColor property will be used.
     * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.
     * @param shouldApplyInlineStyle Optional callback function to be invoked to verify if the current element should have the inline Style applied
     */
    function setTextColor(editor, color, shouldApplyInlineStyle) {
        (0, applyListItemWrap_1$1.default)(editor, 'color', function (element, isInnerNode) {
            if (!shouldApplyInlineStyle || shouldApplyInlineStyle(element)) {
                (0, roosterjs_editor_dom_1$16.setColor)(element, isInnerNode ? '' : color, false /*isBackground*/, editor.isDarkMode(), false /*shouldAdaptFontColor*/, editor.getDarkColorHandler());
            }
        }, 'setTextColor');
    }
    setTextColor$1.default = setTextColor;

    var toggleBold$1 = {};

    Object.defineProperty(toggleBold$1, "__esModule", { value: true });
    var execCommand_1$7 = execCommand$1;
    /**
     * Toggle bold at selection
     * If selection is collapsed, it will only affect the following input after caret
     * If selection contains only bold text, the bold style will be removed
     * If selection contains only normal text, bold style will be added to the whole selected text
     * If selection contains both bold and normal text, bold style will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleBold(editor) {
        (0, execCommand_1$7.default)(editor, "bold" /* Bold */, 'toggleBold');
    }
    toggleBold$1.default = toggleBold;

    var toggleItalic$1 = {};

    Object.defineProperty(toggleItalic$1, "__esModule", { value: true });
    var execCommand_1$6 = execCommand$1;
    /**
     * Toggle italic at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only italic text, the italic style will be removed
     * If selection contains only normal text, italic style will be added to the whole selected text
     * If selection contains both italic and normal text, italic style will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleItalic(editor) {
        (0, execCommand_1$6.default)(editor, "italic" /* Italic */, 'toggleItalic');
    }
    toggleItalic$1.default = toggleItalic;

    var toggleUnderline$1 = {};

    Object.defineProperty(toggleUnderline$1, "__esModule", { value: true });
    var execCommand_1$5 = execCommand$1;
    /**
     * Toggle underline at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only underlined text, the underline style will be removed
     * If selection contains only normal text, underline style will be added to the whole selected text
     * If selection contains both underlined and normal text, the underline style will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleUnderline(editor) {
        (0, execCommand_1$5.default)(editor, "underline" /* Underline */, 'toggleUnderline');
    }
    toggleUnderline$1.default = toggleUnderline;

    Object.defineProperty(clearFormat$2, "__esModule", { value: true });
    var applyListItemWrap_1 = applyListItemWrap;
    var blockFormat_1$4 = blockFormat$1;
    var execCommand_1$4 = execCommand$1;
    var formatUndoSnapshot_1$c = formatUndoSnapshot$1;
    var setBackgroundColor_1$1 = setBackgroundColor$1;
    var setFontName_1 = setFontName$1;
    var setFontSize_1 = setFontSize$1;
    var setTextColor_1 = setTextColor$1;
    var toggleBold_1 = toggleBold$1;
    var toggleItalic_1 = toggleItalic$1;
    var toggleUnderline_1 = toggleUnderline$1;
    var roosterjs_editor_dom_1$15 = lib$3;
    var STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];
    var TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(',');
    var ATTRIBUTES_TO_PRESERVE = ['href', 'src', 'cellpadding', 'cellspacing'];
    var TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];
    /**
     * @param editor The editor instance
     * @returns if the current selection is composed of two or more block elements
     */
    function isMultiBlockSelection(editor) {
        var transverser = editor.getSelectionTraverser();
        var blockElement = transverser.currentBlockElement;
        if (!blockElement) {
            return false;
        }
        var nextBlockElement = transverser.getNextBlockElement();
        //At least two blocks are selected
        return !!nextBlockElement;
    }
    function clearNodeFormat(node) {
        // 1. Recursively clear format of all its child nodes
        var areBlockElements = (0, roosterjs_editor_dom_1$15.toArray)(node.childNodes).map(clearNodeFormat);
        var areAllChildrenBlock = areBlockElements.every(function (b) { return b; });
        var returnBlockElement = (0, roosterjs_editor_dom_1$15.isBlockElement)(node);
        // 2. Unwrap the tag if necessary
        var tag = (0, roosterjs_editor_dom_1$15.getTagOfNode)(node);
        if (tag) {
            if (TAGS_TO_UNWRAP.indexOf(tag) >= 0 ||
                (areAllChildrenBlock &&
                    !(0, roosterjs_editor_dom_1$15.isVoidHtmlElement)(node) &&
                    TAGS_TO_STOP_UNWRAP.indexOf(tag) < 0)) {
                if (returnBlockElement && !areAllChildrenBlock) {
                    (0, roosterjs_editor_dom_1$15.wrap)(node);
                }
                (0, roosterjs_editor_dom_1$15.unwrap)(node);
            }
            else {
                // 3. Otherwise, remove all attributes
                clearAttribute(node);
            }
        }
        return returnBlockElement;
    }
    function clearAttribute(element) {
        var isTableCell = (0, roosterjs_editor_dom_1$15.safeInstanceOf)(element, 'HTMLTableCellElement');
        var isTable = (0, roosterjs_editor_dom_1$15.safeInstanceOf)(element, 'HTMLTableElement');
        for (var _i = 0, _a = (0, roosterjs_editor_dom_1$15.toArray)(element.attributes); _i < _a.length; _i++) {
            var attr = _a[_i];
            if (isTableCell && attr.name == 'style') {
                removeNonBorderStyles(element);
            }
            else if (isTable && attr.name == 'style') {
                removeNotTableDefaultStyles(element);
            }
            else if (ATTRIBUTES_TO_PRESERVE.indexOf(attr.name.toLowerCase()) < 0 &&
                attr.name.indexOf('data-') != 0) {
                element.removeAttribute(attr.name);
            }
        }
    }
    function updateStyles(element, callbackfn) {
        var styles = (0, roosterjs_editor_dom_1$15.getStyles)(element);
        var result = {};
        (0, roosterjs_editor_dom_1$15.getObjectKeys)(styles).forEach(function (style) { return callbackfn(style, styles, result); });
        (0, roosterjs_editor_dom_1$15.setStyles)(element, styles);
        return result;
    }
    function removeNonBorderStyles(element) {
        return updateStyles(element, function (name, styles, result) {
            if (name.indexOf('border') < 0) {
                result[name] = styles[name];
                delete styles[name];
            }
        });
    }
    function removeNotTableDefaultStyles(element) {
        return updateStyles(element, function (name, styles, result) {
            if (name != 'border-collapse') {
                result[name] = styles[name];
                delete styles[name];
            }
        });
    }
    /**
     * Verifies recursively if a node and its parents have any siblings with text content
     * Ignoring the children of contentDiv and returning true if any node is LI
     * @returns `true` if this node, and its parents (minus the children of the contentDiv) have no siblings with text content
     */
    function isNodeWholeBlock(node, editor) {
        var _a;
        var currentNode = node;
        var _loop_1 = function () {
            if (currentNode.nextSibling || currentNode.previousSibling) {
                if ((0, roosterjs_editor_dom_1$15.safeInstanceOf)(currentNode, 'HTMLLIElement')) {
                    return { value: true };
                }
                var isOnlySiblingWithContent_1 = true;
                (_a = currentNode.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes.forEach(function (node) {
                    if (node != currentNode && node.textContent.length) {
                        isOnlySiblingWithContent_1 = false;
                    }
                });
                return { value: isOnlySiblingWithContent_1 };
            }
            currentNode = currentNode.parentNode;
        };
        while (currentNode && editor.contains(currentNode.parentNode)) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return true;
    }
    /**
     * Clear the format of the selected text or list of blocks
     * If the current selection is compose of multiple block elements then remove the text and struture format for all the selected blocks
     * If the current selection is compose of a partial inline element then only the text format is removed from the current selection
     * @param editor The editor instance
     */
    function clearAutoDetectFormat(editor) {
        var isMultiBlock = isMultiBlockSelection(editor);
        if (!isMultiBlock) {
            var transverser = editor.getSelectionTraverser();
            var inlineElement = transverser.currentInlineElement;
            var isPartial = inlineElement instanceof roosterjs_editor_dom_1$15.PartialInlineElement ||
                (inlineElement instanceof roosterjs_editor_dom_1$15.NodeInlineElement &&
                    !isNodeWholeBlock(inlineElement.getContainerNode(), editor));
            if (isPartial) {
                clearFormat$1(editor);
                return;
            }
        }
        clearBlockFormat$1(editor);
    }
    /**
     * Clear all formats of selected blocks.
     * When selection is collapsed, only clear format of current block.
     * @param editor The editor instance
     */
    function clearBlockFormat$1(editor) {
        (0, formatUndoSnapshot_1$c.default)(editor, function () {
            (0, blockFormat_1$4.default)(editor, function (region) {
                var blocks = (0, roosterjs_editor_dom_1$15.getSelectedBlockElementsInRegion)(region, undefined /* createBlockIfEmpty */, editor.isFeatureEnabled("DefaultFormatInSpan" /* DefaultFormatInSpan */));
                var nodes = (0, roosterjs_editor_dom_1$15.collapseNodesInRegion)(region, blocks);
                if (editor.contains(region.rootNode)) {
                    // If there are styles on table cell, wrap all its children and move down all non-border styles.
                    // So that we can preserve styles for unselected blocks as well as border styles for table
                    var nonborderStyles = removeNonBorderStyles(region.rootNode);
                    if ((0, roosterjs_editor_dom_1$15.getObjectKeys)(nonborderStyles).length > 0) {
                        var wrapper = (0, roosterjs_editor_dom_1$15.wrap)((0, roosterjs_editor_dom_1$15.toArray)(region.rootNode.childNodes));
                        (0, roosterjs_editor_dom_1$15.setStyles)(wrapper, nonborderStyles);
                    }
                }
                while (nodes.length > 0 && (0, roosterjs_editor_dom_1$15.isNodeInRegion)(region, nodes[0].parentNode)) {
                    nodes = [(0, roosterjs_editor_dom_1$15.splitBalancedNodeRange)(nodes)];
                }
                nodes.forEach(clearNodeFormat);
            });
            setDefaultFormat(editor);
        }, 'clearBlockFormat');
    }
    function clearInlineFormat(editor) {
        editor.focus();
        editor.addUndoSnapshot(function () {
            (0, execCommand_1$4.default)(editor, "removeFormat" /* RemoveFormat */);
            editor.queryElements('[class]', 1 /* OnSelection */, function (node) {
                return node.removeAttribute('class');
            });
            setDefaultFormat(editor);
            return 'clearInlineFormat';
        }, "Format" /* Format */);
    }
    function setDefaultFontWeight(editor, fontWeight) {
        if (fontWeight === void 0) { fontWeight = '400'; }
        (0, applyListItemWrap_1.default)(editor, 'font-weight', function (element) { return (element.style.fontWeight = fontWeight); }, 'setDefaultFontWeight');
    }
    function setDefaultFormat(editor) {
        var defaultFormat = editor.getDefaultFormat();
        var isDefaultFormatEmpty = (0, roosterjs_editor_dom_1$15.getObjectKeys)(defaultFormat).length === 0;
        editor.queryElements('[style]', 2 /* InSelection */, function (node) {
            var tag = (0, roosterjs_editor_dom_1$15.getTagOfNode)(node);
            if (TAGS_TO_STOP_UNWRAP.indexOf(tag) == -1) {
                removeStyles(tag, node, isDefaultFormatEmpty);
            }
            else {
                node.childNodes.forEach(function (node) {
                    node.childNodes.forEach(function (cNode) {
                        var tag = (0, roosterjs_editor_dom_1$15.getTagOfNode)(cNode);
                        if ((0, roosterjs_editor_dom_1$15.safeInstanceOf)(cNode, 'HTMLElement')) {
                            removeStyles(tag, cNode, isDefaultFormatEmpty);
                        }
                    });
                });
            }
        });
        if (!isDefaultFormatEmpty) {
            if (defaultFormat.fontFamily) {
                (0, setFontName_1.default)(editor, defaultFormat.fontFamily);
            }
            if (defaultFormat.fontSize) {
                (0, setFontSize_1.default)(editor, defaultFormat.fontSize);
            }
            if (defaultFormat.textColor) {
                var setColorIgnoredElements_1 = editor.queryElements('a *, a', 1 /* OnSelection */);
                var shouldApplyInlineStyle = setColorIgnoredElements_1.length > 0
                    ? function (element) { return setColorIgnoredElements_1.indexOf(element) == -1; }
                    : null;
                if (defaultFormat.textColors) {
                    (0, setTextColor_1.default)(editor, defaultFormat.textColors, shouldApplyInlineStyle);
                }
                else {
                    (0, setTextColor_1.default)(editor, defaultFormat.textColor, shouldApplyInlineStyle);
                }
            }
            if (defaultFormat.backgroundColor) {
                if (defaultFormat.backgroundColors) {
                    (0, setBackgroundColor_1$1.default)(editor, defaultFormat.backgroundColors);
                }
                else {
                    (0, setBackgroundColor_1$1.default)(editor, defaultFormat.backgroundColor);
                }
            }
            if (defaultFormat.bold) {
                (0, toggleBold_1.default)(editor);
            }
            else {
                setDefaultFontWeight(editor);
            }
            if (defaultFormat.italic) {
                (0, toggleItalic_1.default)(editor);
            }
            if (defaultFormat.underline) {
                (0, toggleUnderline_1.default)(editor);
            }
        }
    }
    function removeStyles(tag, node, isDefaultFormatEmpty) {
        if (TAGS_TO_STOP_UNWRAP.indexOf(tag) == -1) {
            STYLES_TO_REMOVE.forEach(function (style) { return node.style.removeProperty(style); });
            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style
            // (note: because default format is empty, we're not adding style back in)
            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {
                node.removeAttribute('style');
            }
        }
    }
    /**
     * Clear the format in current selection, after cleaning, the format will be
     * changed to default format. The format that get cleaned include B/I/U/font name/
     * font size/text color/background color/align left/align right/align center/superscript/subscript
     * @param editor The editor instance
     * @param formatType type of format to apply
     */
    function clearFormat$1(editor, formatType) {
        if (formatType === void 0) { formatType = 0 /* Inline */; }
        switch (formatType) {
            case 0 /* Inline */:
                clearInlineFormat(editor);
                break;
            case 1 /* Block */:
                clearBlockFormat$1(editor);
                break;
            default:
                clearAutoDetectFormat(editor);
        }
    }
    clearFormat$2.default = clearFormat$1;

    Object.defineProperty(clearBlockFormat$2, "__esModule", { value: true });
    var clearFormat_1 = clearFormat$2;
    /**
     * @deprecated Use clearFormat instead and pass the ClearFormatMode.Block as parameter
     * @param editor The editor instance
     */
    function clearBlockFormat(editor) {
        (0, clearFormat_1.default)(editor, 1 /* Block */);
    }
    clearBlockFormat$2.default = clearBlockFormat;

    var createLink$1 = {};

    Object.defineProperty(createLink$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$14 = lib$3;
    // Regex matching Uri scheme
    var URI_REGEX = /^[a-zA-Z]+:/i;
    // Regex matching begin of email address
    var MAILTO_REGEX = /^[\w.%+-]+@/i;
    // Regex matching begin of ftp, i.e. ftp.microsoft.com
    var FTP_REGEX = /^ftp\./i;
    function applyLinkPrefix(url) {
        if (!url) {
            return url;
        }
        // Add link prefix per rule:
        // (a) if the url always starts with a URI scheme, leave it as it is
        // (b) if the url is an email address, xxx@... add mailto: prefix
        // (c) if the url starts with ftp., add ftp:// prefix
        // (d) rest, add http:// prefix
        var prefix = '';
        if (url.search(URI_REGEX) < 0) {
            if (url.search(MAILTO_REGEX) == 0) {
                prefix = 'mailto:';
            }
            else if (url.search(FTP_REGEX) == 0) {
                prefix = 'ftp://';
            }
            else {
                // fallback to http://
                prefix = 'http://';
            }
        }
        return prefix + url;
    }
    /**
     * Insert a hyperlink at cursor.
     * When there is a selection, hyperlink will be applied to the selection,
     * otherwise a hyperlink will be inserted to the cursor position.
     * @param editor Editor object
     * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.
     * When protocol is not specified, a best matched protocol will be predicted.
     * @param altText Optional alt text of the link, will be shown when hover on the link
     * @param displayText Optional display text for the link.
     * @param target Optional display target for the link ("_blank"|"_self"|"_parent"|"_top"|"{framename}")
     * If specified, the display text of link will be replaced with this text.
     * If not specified and there wasn't a link, the link url will be used as display text.
     */
    function createLink(editor, link, altText, displayText, target) {
        editor.focus();
        var url = (checkXss(link) || '').trim();
        if (url) {
            var linkData = (0, roosterjs_editor_dom_1$14.matchLink)(url);
            // matchLink can match most links, but not all, i.e. if you pass link a link as "abc", it won't match
            // we know in that case, users will want to insert a link like http://abc
            // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link
            // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix
            // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix
            var normalizedUrl_1 = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);
            var originalUrl_1 = linkData ? linkData.originalUrl : url;
            editor.addUndoSnapshot(function () {
                var selection = editor.getSelectionRangeEx();
                var anchor = null;
                if (selection.type === 0 /* Normal */) {
                    var range = selection.ranges[0];
                    if (range && range.collapsed) {
                        anchor = getAnchorNodeAtCursor(editor);
                        // If there is already a link, just change its href
                        if (anchor) {
                            anchor.href = normalizedUrl_1;
                            // Change text content if it is specified
                            updateAnchorDisplayText(anchor, displayText);
                        }
                        else {
                            anchor = editor.getDocument().createElement('A');
                            anchor.textContent = displayText || originalUrl_1;
                            anchor.href = normalizedUrl_1;
                            editor.insertNode(anchor);
                        }
                    }
                    else {
                        // the selection is not collapsed, use browser execCommand
                        editor
                            .getDocument()
                            .execCommand("createLink" /* CreateLink */, false, normalizedUrl_1);
                        var traverser = editor.getSelectionTraverser();
                        var currentInline = traverser.getNextInlineElement();
                        // list for removing unwanted lines
                        var deletionInlineList = [];
                        while (currentInline) {
                            deletionInlineList.push(currentInline.getContainerNode());
                            currentInline = traverser.getNextInlineElement();
                        }
                        deletionInlineList.forEach(function (node) { return editor.deleteNode(node); });
                        anchor = getAnchorNodeAtCursor(editor);
                        updateAnchorDisplayText(anchor, displayText);
                    }
                }
                else if (selection.type === 2 /* ImageSelection */) {
                    anchor = (0, roosterjs_editor_dom_1$14.wrap)(selection.image, 'A');
                    anchor.href = normalizedUrl_1;
                }
                if (altText && anchor) {
                    anchor.title = altText;
                }
                if (anchor) {
                    updateAnchorTarget(anchor, target);
                }
                return anchor;
            }, "CreateLink" /* CreateLink */);
        }
    }
    createLink$1.default = createLink;
    function getAnchorNodeAtCursor(editor) {
        return editor.queryElements('a[href]', 1 /* OnSelection */)[0];
    }
    function updateAnchorDisplayText(anchor, displayText) {
        if (displayText && anchor.textContent != displayText) {
            anchor.textContent = displayText;
        }
    }
    function updateAnchorTarget(anchor, target) {
        if (target) {
            anchor.target = target;
        }
        else if (!target && anchor.getAttribute('target')) {
            anchor.removeAttribute('target');
        }
    }
    function checkXss(link) {
        var sanitizer = new roosterjs_editor_dom_1$14.HtmlSanitizer();
        var a = document.createElement('a');
        a.href = link || '';
        sanitizer.sanitize(a);
        // We use getAttribute because some browsers will try to make the href property a valid link.
        // This has unintended side effects when the link lacks a protocol.
        return a.getAttribute('href');
    }

    var getFormatState$1 = {};

    var __assign$b = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$b = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$b.apply(this, arguments);
    };
    Object.defineProperty(getFormatState$1, "__esModule", { value: true });
    getFormatState$1.getElementBasedFormatState = void 0;
    var roosterjs_editor_dom_1$13 = lib$3;
    /**
     * Get element based Format State at cursor
     * @param editor The editor instance
     * @param event (Optional) The plugin event, it stores the event cached data for looking up.
     * In this function the event cache is used to get list state and header level. If not passed,
     * it will query the node within selection to get the info
     * @returns An ElementBasedFormatState object
     */
    function getElementBasedFormatState(editor, event) {
        var listTag = (0, roosterjs_editor_dom_1$13.getTagOfNode)(editor.getElementAtCursor('OL,UL', null /*startFrom*/, event));
        // Check if selection is multiline, spans more than one block
        var range = editor.getSelectionRange();
        var multiline = false;
        if (range && !range.collapsed) {
            var startingBlock = editor.getBlockElementAtNode(range.startContainer);
            var endingBlock = editor.getBlockElementAtNode(range.endContainer);
            multiline = endingBlock && startingBlock ? !endingBlock.equals(startingBlock) : false;
        }
        var headerTag = (0, roosterjs_editor_dom_1$13.getTagOfNode)(editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', null /*startFrom*/, event));
        var table = editor.queryElements('table', 1 /* OnSelection */)[0];
        var tableFormat = table ? (0, roosterjs_editor_dom_1$13.getTableFormatInfo)(table) : undefined;
        var hasHeader = (table === null || table === void 0 ? void 0 : table.rows[0])
            ? (0, roosterjs_editor_dom_1$13.toArray)(table.rows[0].cells).every(function (cell) { return (0, roosterjs_editor_dom_1$13.getTagOfNode)(cell) == 'TH'; })
            : undefined;
        return {
            isBullet: listTag == 'UL',
            isNumbering: listTag == 'OL',
            isMultilineSelection: multiline,
            headerLevel: (headerTag && parseInt(headerTag[1])) || 0,
            canUnlink: !!editor.queryElements('a[href]', 1 /* OnSelection */)[0],
            canAddImageAltText: !!editor.queryElements('img', 1 /* OnSelection */)[0],
            isBlockQuote: !!editor.queryElements('blockquote', 1 /* OnSelection */)[0],
            isCodeInline: !!editor.queryElements('code', 1 /* OnSelection */)[0],
            isCodeBlock: !!editor.queryElements('pre>code', 1 /* OnSelection */)[0],
            isInTable: !!table,
            tableFormat: tableFormat,
            tableHasHeader: hasHeader,
            canMergeTableCell: canMergeTableCell(editor),
        };
    }
    getFormatState$1.getElementBasedFormatState = getElementBasedFormatState;
    /**
     * Get format state at cursor
     * A format state is a collection of all format related states, e.g.,
     * bold, italic, underline, font name, font size, etc.
     * @param editor The editor instance
     * @param event (Optional) The plugin event, it stores the event cached data for looking up.
     * In this function the event cache is used to get list state and header level. If not passed,
     * it will query the node within selection to get the info
     * @returns The format state at cursor
     */
    function getFormatState(editor, event) {
        return __assign$b(__assign$b(__assign$b(__assign$b(__assign$b({}, editor.getPendableFormatState(false /* forceGetStateFromDom */)), getElementBasedFormatState(editor, event)), editor.getStyleBasedFormatState()), editor.getUndoState()), { isDarkMode: editor.isDarkMode(), zoomScale: editor.getZoomScale() });
    }
    getFormatState$1.default = getFormatState;
    /**
     * Checks whether the editor selection range is starting and ending at a table element.
     * @param editor Editor Instance
     * @returns
     */
    var canMergeTableCell = function (editor) {
        var selection = editor.getSelectionRangeEx();
        var isATable = selection && selection.type === 1 /* TableSelection */;
        if (isATable && selection.coordinates) {
            var _a = selection.coordinates, firstCell = _a.firstCell, lastCell = _a.lastCell;
            if (firstCell.x !== lastCell.x || firstCell.y !== lastCell.y) {
                return true;
            }
            return false;
        }
        return false;
    };

    var insertEntity$1 = {};

    Object.defineProperty(insertEntity$1, "__esModule", { value: true });
    var commitListChains_1 = commitListChains$1;
    var roosterjs_editor_dom_1$12 = lib$3;
    /**
     * Insert an entity into editor.
     * @param editor The editor to insert entity into.
     * @param type Type of the entity
     * @param contentNode Root element of the entity
     * @param isBlock Whether the entity will be shown as a block
     * @param isReadonly Whether the entity will be a readonly entity
     * @param position @optional The position to insert into. If not specified, current position will be used.
     * If isBlock is true, entity will be insert below this position
     * @param insertToRegionRoot @optional When pass true, insert the entity at the root level of current region.
     * Parent nodes will be split if need
     */
    function insertEntity(editor, type, contentNode, isBlock, isReadonly, position, insertToRegionRoot) {
        var wrapper = (0, roosterjs_editor_dom_1$12.wrap)(contentNode, isBlock ? 'DIV' : 'SPAN');
        // For inline & readonly entity, we need to set display to "inline-block" otherwise
        // there will be some weird behavior when move cursor around the entity node.
        // And we should only do this for readonly entity since "inline-block" has some side effect
        // in IE that there will be a resize border around the inline-block element. We made some
        // workaround for readonly entity for this issue but for editable entity, keep it as "inline"
        // will just work fine.
        if (!isBlock && isReadonly) {
            wrapper.style.display = 'inline-block';
        }
        (0, roosterjs_editor_dom_1$12.commitEntity)(wrapper, type, isReadonly);
        if (!editor.contains(wrapper)) {
            var currentRange = void 0;
            var contentPosition = void 0;
            if (typeof position == 'number') {
                contentPosition = position;
            }
            else if (position) {
                currentRange = editor.getSelectionRange();
                var node = position.normalize().node;
                var existingEntity = node && editor.getElementAtCursor((0, roosterjs_editor_dom_1$12.getEntitySelector)(), node);
                // Do not insert entity into another entity
                if (existingEntity) {
                    position = new roosterjs_editor_dom_1$12.Position(existingEntity, -3 /* After */);
                }
                editor.select(position);
                contentPosition = 3 /* SelectionStart */;
            }
            else {
                editor.focus();
                contentPosition = 3 /* SelectionStart */;
            }
            var regions = insertToRegionRoot && editor.getSelectedRegions();
            var chains = regions && roosterjs_editor_dom_1$12.VListChain.createListChains(regions);
            editor.insertNode(wrapper, {
                updateCursor: false,
                insertOnNewLine: isBlock,
                replaceSelection: true,
                position: contentPosition,
                insertToRegionRoot: insertToRegionRoot,
            });
            if (chains) {
                (0, commitListChains_1.default)(editor, chains);
            }
            if (contentPosition == 3 /* SelectionStart */) {
                if (currentRange) {
                    editor.select(currentRange);
                }
                else if (!isBlock) {
                    editor.select(wrapper, -3 /* After */);
                }
            }
        }
        if (isBlock) {
            // Insert an extra empty line for block entity to make sure
            // user can still put cursor below the entity.
            var br = editor.getDocument().createElement('BR');
            wrapper.parentNode.insertBefore(br, wrapper.nextSibling);
        }
        var entity = (0, roosterjs_editor_dom_1$12.getEntityFromElement)(wrapper);
        if (!isBlock &&
            isReadonly &&
            editor.isFeatureEnabled("InlineEntityReadOnlyDelimiters" /* InlineEntityReadOnlyDelimiters */)) {
            (0, roosterjs_editor_dom_1$12.addDelimiters)(entity.wrapper);
            if (entity.wrapper.nextElementSibling) {
                editor.select(new roosterjs_editor_dom_1$12.Position(entity.wrapper.nextElementSibling, -3 /* After */));
            }
        }
        editor.triggerContentChangedEvent("InsertEntity" /* InsertEntity */, entity);
        return entity;
    }
    insertEntity$1.default = insertEntity;

    var insertImage$2 = {};

    Object.defineProperty(insertImage$2, "__esModule", { value: true });
    var formatUndoSnapshot_1$b = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$11 = lib$3;
    /**
     * Insert an image to editor at current selection
     * @param editor The editor instance
     * @param imageFileOrSrc Either the image file blob or source string of the image.
     * @param attributes Optional image element attributes
     */
    function insertImage$1(editor, imageFileOrSrc, attributes) {
        if (typeof imageFileOrSrc == 'string') {
            insertImageWithSrc(editor, imageFileOrSrc, attributes);
        }
        else {
            (0, roosterjs_editor_dom_1$11.readFile)(imageFileOrSrc, function (dataUrl) {
                if (dataUrl && !editor.isDisposed()) {
                    insertImageWithSrc(editor, dataUrl, attributes);
                }
            });
        }
    }
    insertImage$2.default = insertImage$1;
    function insertImageWithSrc(editor, src, attributes) {
        (0, formatUndoSnapshot_1$b.default)(editor, function () {
            var image = editor.getDocument().createElement('img');
            image.src = src;
            if (attributes) {
                (0, roosterjs_editor_dom_1$11.getObjectKeys)(attributes).forEach(function (attribute) {
                    return image.setAttribute(attribute, attributes[attribute]);
                });
            }
            editor.insertNode(image);
        }, 'insertImage');
    }

    var insertTable$2 = {};

    Object.defineProperty(insertTable$2, "__esModule", { value: true });
    var formatUndoSnapshot_1$a = formatUndoSnapshot$1;
    var setBackgroundColor_1 = setBackgroundColor$1;
    var roosterjs_editor_dom_1$10 = lib$3;
    /**
     * Insert table into editor at current selection
     * @param editor The editor instance
     * @param columns Number of columns in table, it also controls the default table cell width:
     * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px
     * @param rows Number of rows in table
     * @param format (Optional) The table format. If not passed, the default format will be applied:
     * background color: #FFF; border color: #ABABAB
     */
    function insertTable$1(editor, columns, rows, format) {
        var document = editor.getDocument();
        var table = document.createElement('table');
        table.cellSpacing = '0';
        table.cellPadding = '1';
        for (var i = 0; i < rows; i++) {
            var tr = document.createElement('tr');
            table.appendChild(tr);
            for (var j = 0; j < columns; j++) {
                var td = document.createElement('td');
                tr.appendChild(td);
                td.appendChild(document.createElement('br'));
                td.style.width = getTableCellWidth(columns);
            }
        }
        editor.focus();
        (0, formatUndoSnapshot_1$a.default)(editor, function () {
            var element = editor.getElementAtCursor();
            if (element === null || element === void 0 ? void 0 : element.style.backgroundColor) {
                (0, setBackgroundColor_1.default)(editor, 'transparent');
            }
            var vtable = new roosterjs_editor_dom_1$10.VTable(table);
            vtable.applyFormat(format || {});
            vtable.writeBack();
            editor.insertNode(table);
            editor.runAsync(function (editor) {
                return editor.select(new roosterjs_editor_dom_1$10.Position(table, 0 /* Begin */).normalize());
            });
        }, 'insertTable');
    }
    insertTable$2.default = insertTable$1;
    function getTableCellWidth(columns) {
        if (columns <= 4) {
            return '120px';
        }
        else if (columns <= 6) {
            return '100px';
        }
        else {
            return '70px';
        }
    }

    var editTable$1 = {};

    Object.defineProperty(editTable$1, "__esModule", { value: true });
    var formatUndoSnapshot_1$9 = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$$ = lib$3;
    /**
     * Edit table with given operation. If there is no table at cursor then no op.
     * @param editor The editor instance
     * @param operation Table operation
     */
    function editTable(editor, operation) {
        var td = editor.getElementAtCursor('TD,TH');
        if (td) {
            (0, formatUndoSnapshot_1$9.default)(editor, function () {
                var vtable = new roosterjs_editor_dom_1$$.VTable(td);
                saveTableSelection(editor, vtable);
                vtable.edit(operation);
                vtable.writeBack();
                editor.transformToDarkColor(vtable.table);
                editor.focus();
                if (isUndefined(vtable.row) || isUndefined(vtable.col)) {
                    return;
                }
                var _a = calculateCellToSelect(operation, vtable.row, vtable.col), newCol = _a.newCol, newRow = _a.newRow;
                var newTd = vtable.getCell(newRow, newCol).td;
                if (newTd) {
                    editor.select(newTd, 0 /* Begin */);
                }
            }, 'editTable');
        }
    }
    editTable$1.default = editTable;
    function isUndefined(n) {
        return n == undefined;
    }
    function calculateCellToSelect(operation, currentRow, currentCol) {
        var newRow = currentRow;
        var newCol = currentCol;
        switch (operation) {
            case 0 /* InsertAbove */:
                newCol = 0;
                break;
            case 1 /* InsertBelow */:
                newRow += 1;
                newCol = 0;
                break;
            case 2 /* InsertLeft */:
                newRow = 0;
                break;
            case 3 /* InsertRight */:
                newRow = 0;
                newCol += 1;
                break;
        }
        return {
            newRow: newRow,
            newCol: newCol,
        };
    }
    function saveTableSelection(editor, vtable) {
        var _a;
        var selection = editor.getSelectionRangeEx();
        if (selection && selection.type === 1 /* TableSelection */) {
            vtable.selection = (_a = selection.coordinates) !== null && _a !== void 0 ? _a : null;
        }
    }

    var formatTable$1 = {};

    Object.defineProperty(formatTable$1, "__esModule", { value: true });
    var formatUndoSnapshot_1$8 = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$_ = lib$3;
    /**
     * Format table
     * @param editor The editor which contains the table to format
     * @param format A TableFormat object contains format information we want to apply to the table
     * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted
     */
    function formatTable(editor, format, table) {
        table = table || editor.getElementAtCursor('TABLE');
        if (table) {
            (0, formatUndoSnapshot_1$8.default)(editor, function (start, end) {
                if (!table) {
                    return;
                }
                var vtable = new roosterjs_editor_dom_1$_.VTable(table);
                vtable.applyFormat(format);
                vtable.writeBack();
                editor.transformToDarkColor(vtable.table);
                editor.focus();
                if (start && end) {
                    editor.select(start, end);
                }
            }, 'formatTable');
        }
    }
    formatTable$1.default = formatTable;

    var removeLink$2 = {};

    Object.defineProperty(removeLink$2, "__esModule", { value: true });
    var formatUndoSnapshot_1$7 = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$Z = lib$3;
    /**
     * Remove link at selection. If no links at selection, do nothing.
     * If selection contains multiple links, all of the link styles will be removed.
     * If only part of a link is selected, the whole link style will be removed.
     * @param editor The editor instance
     */
    function removeLink$1(editor) {
        editor.focus();
        (0, formatUndoSnapshot_1$7.default)(editor, function (start, end) {
            editor.queryElements('a[href]', 1 /* OnSelection */, roosterjs_editor_dom_1$Z.unwrap);
            editor.select(start, end);
        }, 'removeLink');
    }
    removeLink$2.default = removeLink$1;

    var replaceWithNode$1 = {};

    Object.defineProperty(replaceWithNode$1, "__esModule", { value: true });
    function replaceWithNode(editor, textOrRange, node, exactMatch, searcher) {
        // Make sure the text and node is valid
        if (!textOrRange || !node) {
            return false;
        }
        var range;
        if (typeof textOrRange == 'string') {
            searcher = searcher || editor.getContentSearcherOfCursor();
            range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);
        }
        else {
            range = textOrRange;
        }
        if (range) {
            var backupRange = editor.getSelectionRange();
            // If the range to replace is right before current cursor, it is actually an exact match
            if (backupRange.collapsed &&
                range.endContainer == backupRange.startContainer &&
                range.endOffset == backupRange.startOffset) {
                exactMatch = true;
            }
            editor.insertNode(node, {
                position: 5 /* Range */,
                updateCursor: exactMatch,
                replaceSelection: true,
                insertOnNewLine: false,
                range: range,
            });
            return true;
        }
        return false;
    }
    replaceWithNode$1.default = replaceWithNode;

    var rotateElement$1 = {};

    Object.defineProperty(rotateElement$1, "__esModule", { value: true });
    var formatUndoSnapshot_1$6 = formatUndoSnapshot$1;
    /**
     * Rotate an element visually
     * @param editor The editor instance
     * @param element The element that should be rotated
     * @param angle The degree at which to rotate the element from it's center
     */
    function rotateElement(editor, element, angle) {
        if (element) {
            (0, formatUndoSnapshot_1$6.default)(editor, function () {
                element.style.transform = "rotate(" + angle + "deg)";
            }, 'rotateElement');
        }
    }
    rotateElement$1.default = rotateElement;

    var setAlignment$1 = {};

    var normalizeBlockquote$1 = {};

    Object.defineProperty(normalizeBlockquote$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$Y = lib$3;
    /**
     * @internal
     * @param node start node to normalize
     * @param quotesHandled Optional parameter to prevent already modified quotes to be rechecked.
     * @returns
     */
    function normalizeBlockquote(node, quotesHandled) {
        if ((0, roosterjs_editor_dom_1$Y.safeInstanceOf)(node, 'HTMLElement')) {
            var alignment = node.style.textAlign;
            var quote = (0, roosterjs_editor_dom_1$Y.findClosestElementAncestor)(node, undefined /* root */, 'blockquote');
            if (!quote) {
                return;
            }
            var isNodeRTL = isRTL(node);
            if (quotesHandled) {
                if (quotesHandled.indexOf(quote) > -1) {
                    return;
                }
                quotesHandled.push(quote);
            }
            while (quote) {
                if (alignment == 'center') {
                    if (isNodeRTL) {
                        quote.style.removeProperty('marginInlineEnd');
                        quote.style.marginInlineStart = 'auto';
                    }
                    else {
                        quote.style.removeProperty('marginInlineStart');
                        quote.style.marginInlineEnd = 'auto';
                    }
                }
                else {
                    quote.style.removeProperty('marginInlineEnd');
                    quote.style.removeProperty('marginInlineStart');
                }
                quote = (0, roosterjs_editor_dom_1$Y.findClosestElementAncestor)(quote.parentElement, undefined /* root */, 'blockquote');
            }
        }
    }
    normalizeBlockquote$1.default = normalizeBlockquote;
    function isRTL(el) {
        return (0, roosterjs_editor_dom_1$Y.getComputedStyle)(el, 'direction') == 'rtl' || el.getAttribute('dir') == 'rtl';
    }

    Object.defineProperty(setAlignment$1, "__esModule", { value: true });
    var blockFormat_1$3 = blockFormat$1;
    var execCommand_1$3 = execCommand$1;
    var formatUndoSnapshot_1$5 = formatUndoSnapshot$1;
    var normalizeBlockquote_1$1 = normalizeBlockquote$1;
    var roosterjs_editor_dom_1$X = lib$3;
    /**
     * Set content alignment
     * @param editor The editor instance
     * @param alignment The alignment option:
     * Alignment.Center, Alignment.Left, Alignment.Right
     */
    function setAlignment(editor, alignment) {
        (0, formatUndoSnapshot_1$5.default)(editor, function () {
            var selection = editor.getSelectionRangeEx();
            var isATable = selection && selection.type === 1 /* TableSelection */;
            var elementAtCursor = editor.getElementAtCursor();
            if (isATable &&
                (0, roosterjs_editor_dom_1$X.isWholeTableSelected)(new roosterjs_editor_dom_1$X.VTable(selection.table), selection.coordinates)) {
                alignTable(selection, alignment);
            }
            else if (isList$1(elementAtCursor) &&
                editor.isFeatureEnabled("ListItemAlignment" /* ListItemAlignment */)) {
                alignList(editor, alignment);
            }
            else {
                alignText(editor, alignment);
            }
        }, 'setAlignment');
    }
    setAlignment$1.default = setAlignment;
    /**
     * Align text using the margins
     * @param editor
     * @param element
     * @param alignment
     * @param addUndoSnapshot
     * @returns
     */
    function alignTable(selection, alignment) {
        var table = selection.table;
        if (alignment == 1 /* Center */) {
            table.style.marginLeft = 'auto';
            table.style.marginRight = 'auto';
        }
        else if (alignment == 2 /* Right */) {
            table.style.marginLeft = 'auto';
            table.style.marginRight = '';
        }
        else {
            table.style.marginLeft = '';
            table.style.marginRight = 'auto';
        }
    }
    /**
     * Align text using the text-align
     * @param editor
     * @param alignment
     * @returns
     */
    function alignText(editor, alignment) {
        var align = 'left';
        var command = "justifyLeft" /* JustifyLeft */;
        if (alignment == 1 /* Center */) {
            command = "justifyCenter" /* JustifyCenter */;
            align = 'center';
        }
        else if (alignment == 2 /* Right */) {
            command = "justifyRight" /* JustifyRight */;
            align = 'right';
        }
        (0, execCommand_1$3.default)(editor, command);
        var elements = editor.queryElements('[align]', 1 /* OnSelection */, function (node) {
            node.style.textAlign = align;
            (0, normalizeBlockquote_1$1.default)(node);
        });
        if (elements.length == 0) {
            var node = editor.getElementAtCursor();
            (0, normalizeBlockquote_1$1.default)(node);
        }
    }
    function isList$1(element) {
        return (0, roosterjs_editor_dom_1$X.findClosestElementAncestor)(element, undefined /** root */, 'LI');
    }
    function alignList(editor, alignment) {
        (0, blockFormat_1$3.default)(editor, function (region, start, end) {
            var blocks = (0, roosterjs_editor_dom_1$X.getSelectedBlockElementsInRegion)(region, undefined /* createBlockIfEmpty */, editor.isFeatureEnabled("DefaultFormatInSpan" /* DefaultFormatInSpan */));
            var startNode = blocks[0].getStartNode();
            var vList = (0, roosterjs_editor_dom_1$X.createVListFromRegion)(region, true /*includeSiblingLists*/, startNode);
            vList.setAlignment(start, end, alignment);
        }, undefined /* beforeRunCallback */, 'alignList');
    }

    var setDirection$1 = {};

    var collapseSelectedBlocks$1 = {};

    Object.defineProperty(collapseSelectedBlocks$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$W = lib$3;
    /**
     * @internal
     * Collapse all selected blocks, return single HTML elements for each block
     * @param editor The editor instance
     * @param forEachCallback A callback function to invoke for each of the collapsed element
     */
    function collapseSelectedBlocks(editor, forEachCallback) {
        var traverser = editor.getSelectionTraverser();
        if (!traverser) {
            return;
        }
        var block = traverser.currentBlockElement;
        var blocks = [];
        while (block) {
            if (!isEmptyBlockUnderTR(block)) {
                blocks.push(block);
            }
            block = traverser.getNextBlockElement();
        }
        blocks.forEach(function (block) {
            var element = block.collapseToSingleElement();
            forEachCallback(element);
        });
    }
    collapseSelectedBlocks$1.default = collapseSelectedBlocks;
    function isEmptyBlockUnderTR(block) {
        var startNode = block.getStartNode();
        return (startNode == block.getEndNode() &&
            startNode.nodeType == 3 /* Text */ &&
            ['TR', 'TABLE'].indexOf((0, roosterjs_editor_dom_1$W.getTagOfNode)(startNode.parentNode)) >= 0);
    }

    Object.defineProperty(setDirection$1, "__esModule", { value: true });
    var collapseSelectedBlocks_1 = collapseSelectedBlocks$1;
    var formatUndoSnapshot_1$4 = formatUndoSnapshot$1;
    /**
     * Change direction for the blocks/paragraph at selection
     * @param editor The editor instance
     * @param direction The direction option:
     * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'
     */
    function setDirection(editor, direction) {
        editor.focus();
        (0, formatUndoSnapshot_1$4.default)(editor, function (start, end) {
            (0, collapseSelectedBlocks_1.default)(editor, function (element) {
                element.setAttribute('dir', direction == 0 /* LeftToRight */ ? 'ltr' : 'rtl');
                element.style.textAlign = direction == 0 /* LeftToRight */ ? 'left' : 'right';
            });
            editor.select(start, end);
        }, 'setDirection');
    }
    setDirection$1.default = setDirection;

    var setImageAltText$1 = {};

    Object.defineProperty(setImageAltText$1, "__esModule", { value: true });
    var formatUndoSnapshot_1$3 = formatUndoSnapshot$1;
    /**
     * Set image alt text for all selected images at selection. If no images is contained
     * in selection, do nothing.
     * The alt attribute provides alternative information for an image if a user for some reason
     * cannot view it (because of slow connection, an error in the src attribute, or if the user
     * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp
     * @param editor The editor instance
     * @param altText The image alt text
     */
    function setImageAltText(editor, altText) {
        editor.focus();
        (0, formatUndoSnapshot_1$3.default)(editor, function () {
            editor.queryElements('img', 1 /* OnSelection */, function (node) {
                return node.setAttribute('alt', altText);
            });
        }, 'setImageAltText');
    }
    setImageAltText$1.default = setImageAltText;

    var setIndentation$1 = {};

    Object.defineProperty(setIndentation$1, "__esModule", { value: true });
    var blockFormat_1$2 = blockFormat$1;
    var normalizeBlockquote_1 = normalizeBlockquote$1;
    var roosterjs_editor_dom_1$V = lib$3;
    /**
     * Set indentation at selection
     * If selection contains bullet/numbering list, increase/decrease indentation will
     * increase/decrease the list level by one.
     * @param editor The editor instance
     * @param indentation The indentation option:
     * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation
     */
    function setIndentation(editor, indentation) {
        var handler = indentation == 0 /* Increase */ ? indent : outdent;
        (0, blockFormat_1$2.default)(editor, function (region, start, end) {
            var blocks = (0, roosterjs_editor_dom_1$V.getSelectedBlockElementsInRegion)(region, true /*createBlockIfEmpty*/, editor.isFeatureEnabled("DefaultFormatInSpan" /* DefaultFormatInSpan */));
            var blockGroups = [[]];
            for (var i = 0; i < blocks.length; i++) {
                var startNode = blocks[i].getStartNode();
                var vList = (0, roosterjs_editor_dom_1$V.createVListFromRegion)(region, true /*includeSiblingLists*/, startNode);
                if (vList) {
                    while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {
                        i++;
                    }
                    var isTabKeyTextFeaturesEnabled = editor.isFeatureEnabled("TabKeyTextFeatures" /* TabKeyTextFeatures */);
                    if (isTabKeyTextFeaturesEnabled &&
                        isFirstItem(vList, startNode) &&
                        shouldHandleWithBlockquotes(indentation, editor, startNode)) {
                        var block = editor.getBlockElementAtNode(vList.rootList);
                        blockGroups.push([block]);
                    }
                    else {
                        indentation == 1 /* Decrease */
                            ? vList.setIndentation(start, end, indentation, false /* softOutdent */, isTabKeyTextFeaturesEnabled /* preventItemRemoval */)
                            : vList.setIndentation(start, end, indentation);
                        vList.writeBack(editor.isFeatureEnabled("ReuseAllAncestorListElements" /* ReuseAllAncestorListElements */));
                        blockGroups.push([]);
                    }
                }
                else {
                    blockGroups[blockGroups.length - 1].push(blocks[i]);
                }
            }
            blockGroups.forEach(function (group) { return handler(region, group); });
        }, function () {
            var selection = editor.getSelectionRangeEx();
            if (selection.type == 1 /* TableSelection */ &&
                (0, roosterjs_editor_dom_1$V.isWholeTableSelected)(new roosterjs_editor_dom_1$V.VTable(selection.table), selection.coordinates)) {
                if (indentation == 1 /* Decrease */) {
                    var quote = editor.getElementAtCursor('blockquote', selection.table);
                    (0, roosterjs_editor_dom_1$V.unwrap)(quote);
                }
                else if (indentation == 0 /* Increase */) {
                    (0, roosterjs_editor_dom_1$V.wrap)(selection.table, 2 /* BlockquoteWrapper */);
                }
                return false;
            }
            return true;
        }, 'setIndentation');
        function indent(region, blocks) {
            var nodes = (0, roosterjs_editor_dom_1$V.collapseNodesInRegion)(region, blocks);
            (0, roosterjs_editor_dom_1$V.wrap)(nodes, 2 /* BlockquoteWrapper */);
            var quotesHandled = [];
            nodes.forEach(function (node) { return (0, normalizeBlockquote_1.default)(node, quotesHandled); });
        }
    }
    setIndentation$1.default = setIndentation;
    function outdent(region, blocks) {
        blocks.forEach(function (blockElement) {
            var node = blockElement.collapseToSingleElement();
            var quote = (0, roosterjs_editor_dom_1$V.findClosestElementAncestor)(node, region.rootNode, 'blockquote');
            if (quote) {
                if (node == quote) {
                    node = (0, roosterjs_editor_dom_1$V.wrap)((0, roosterjs_editor_dom_1$V.toArray)(node.childNodes));
                }
                while (node && (0, roosterjs_editor_dom_1$V.isNodeInRegion)(region, node) && (0, roosterjs_editor_dom_1$V.getTagOfNode)(node) != 'BLOCKQUOTE') {
                    node = (0, roosterjs_editor_dom_1$V.splitBalancedNodeRange)(node);
                }
                if (node && (0, roosterjs_editor_dom_1$V.isNodeInRegion)(region, node)) {
                    (0, roosterjs_editor_dom_1$V.unwrap)(node);
                }
            }
        });
    }
    function isFirstItem(vList, startNode) {
        var _a;
        return (((_a = vList.items[0]) === null || _a === void 0 ? void 0 : _a.getNode()) == startNode &&
            vList.getListItemIndex(startNode) == (vList.getStart() || 1));
    }
    function shouldHandleWithBlockquotes(indentation, editor, startNode) {
        return (indentation == 0 /* Increase */ || editor.getElementAtCursor('blockquote', startNode));
    }

    var changeCapitalization$1 = {};

    Object.defineProperty(changeCapitalization$1, "__esModule", { value: true });
    var applyInlineStyle_1 = applyInlineStyle$1;
    var roosterjs_editor_dom_1$U = lib$3;
    /**
     * Change the capitalization of text in the selection
     * @param editor The editor instance
     * @param capitalization The case option
     * @param language Optional parameter for language string that should comply to "IETF BCP 47 Tags for
     * Identifying Languages". For example: 'en' or 'en-US' for English, 'tr' for Turkish.
     * Default is the host environments current locale.
     */
    function changeCapitalization(editor, capitalization, language) {
        (0, applyInlineStyle_1.default)(editor, function (element) {
            for (var node = (0, roosterjs_editor_dom_1$U.getFirstLeafNode)(element); node; node = (0, roosterjs_editor_dom_1$U.getNextLeafSibling)(element, node)) {
                if (node.nodeType == 3 /* Text */) {
                    try {
                        node.textContent = getCapitalizedText(node.textContent, language);
                    }
                    catch (_a) {
                        node.textContent = getCapitalizedText(node.textContent, undefined);
                    }
                }
            }
        }, 'changeCapitalization');
        function getCapitalizedText(originalText, language) {
            switch (capitalization) {
                case "lowercase" /* Lowercase */:
                    return originalText.toLocaleLowerCase(language);
                case "uppercase" /* Uppercase */:
                    return originalText.toLocaleUpperCase(language);
                case "capitalize" /* CapitalizeEachWord */:
                    var wordArray = originalText.toLocaleLowerCase(language).split(' ');
                    for (var i = 0; i < wordArray.length; i++) {
                        wordArray[i] =
                            wordArray[i].charAt(0).toLocaleUpperCase(language) + wordArray[i].slice(1);
                    }
                    return wordArray.join(' ');
                case "sentence" /* Sentence */:
                    // TODO: Add rules on punctuation for internationalization - TASK 104769
                    var punctuationMarks = '[\\.\\!\\?]';
                    // Find a match of a word character either:
                    // - At the beginning of a string with or without preceding whitespace, for
                    // example: '  hello world' and 'hello world' strings would both match 'h'.
                    // - Or preceded by a punctuation mark and at least one whitespace, for
                    // example 'yes. hello world' would match 'y' and 'h'.
                    var regex = new RegExp('^\\s*\\w|' + punctuationMarks + '\\s+\\w', 'g');
                    return originalText.toLocaleLowerCase(language).replace(regex, function (match) {
                        return match.toLocaleUpperCase(language);
                    });
            }
        }
    }
    changeCapitalization$1.default = changeCapitalization;

    var toggleBullet$1 = {};

    var toggleListType$1 = {};

    Object.defineProperty(toggleListType$1, "__esModule", { value: true });
    var blockFormat_1$1 = blockFormat$1;
    var roosterjs_editor_dom_1$T = lib$3;
    /**
     * Toggle List Type at selection
     * If ListType Provided is Ordered:
     *      If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one
     *      If selection contains bullet list, toggle numbering will convert the bullet list into number list
     *      If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     *       realization of browser execCommand API
     * If ListType Provided is Unordered:
     *      If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one
     *      If selection contains number list, toggle bullet will convert the number list into bullet list
     *      If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     *      browser execCommand API
     * @param editor The editor instance
     * @param listType The list type to toggle
     * @param startNumber (Optional) Start number of the list
     * @param includeSiblingLists Sets wether the operation should include Sibling Lists, by default true
     * @param orderedStyle (Optional) the style of an ordered. If not defined, the style will be set to decimal.
     * @param unorderedStyle (Optional) the style of an unordered list. If not defined, the style will be set to disc.
     * @param apiNameOverride (Optional) Set a new api name, if empty the api name will be 'toggleListType'.
     */
    function toggleListType(editor, listType, startNumber, includeSiblingLists, orderedStyle, unorderedStyle, apiNameOverride) {
        if (startNumber === void 0) { startNumber = 0; }
        if (includeSiblingLists === void 0) { includeSiblingLists = true; }
        (0, blockFormat_1$1.default)(editor, function (region, start, end, chains) {
            var _a, _b;
            var chain = startNumber > 0 && chains.filter(function (chain) { return chain.canAppendAtCursor(startNumber); })[0];
            var block = (_b = (0, roosterjs_editor_dom_1$T.getBlockElementAtNode)(region.rootNode, (_a = start === null || start === void 0 ? void 0 : start.node) !== null && _a !== void 0 ? _a : null)) === null || _b === void 0 ? void 0 : _b.collapseToSingleElement();
            if (!block) {
                return;
            }
            var vList = chain && end && (start === null || start === void 0 ? void 0 : start.equalTo(end))
                ? chain.createVListAtBlock(block, startNumber)
                : (0, roosterjs_editor_dom_1$T.createVListFromRegion)(region, startNumber === 1 ? false : includeSiblingLists);
            if (vList && start && end) {
                vList.changeListType(start, end, listType);
                if (editor.isFeatureEnabled("AutoFormatList" /* AutoFormatList */)) {
                    vList.setListStyleType(orderedStyle, unorderedStyle);
                }
                vList.writeBack(editor.isFeatureEnabled("ReuseAllAncestorListElements" /* ReuseAllAncestorListElements */));
            }
        }, undefined /* beforeRunCallback */, apiNameOverride || 'toggleListType');
    }
    toggleListType$1.default = toggleListType;

    Object.defineProperty(toggleBullet$1, "__esModule", { value: true });
    var toggleListType_1$1 = toggleListType$1;
    /**
     * Toggle bullet at selection
     * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one
     * If selection contains number list, toggle bullet will convert the number list into bullet list
     * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     * browser execCommand API
     * @param editor The editor instance
     * @param listStyle (Optional) the style of the bullet list. If not defined, the style will be set to disc.
     * @param apiNameOverride (Optional) Set a new api name, if empty the api name will be 'toggleListType'.
     */
    function toggleBullet(editor, listStyle, apiNameOverride) {
        (0, toggleListType_1$1.default)(editor, 2 /* Unordered */, undefined /* startNumber */, false /* includeSiblingLists */, undefined /** orderedStyle  */, listStyle, apiNameOverride);
    }
    toggleBullet$1.default = toggleBullet;

    var toggleNumbering$1 = {};

    Object.defineProperty(toggleNumbering$1, "__esModule", { value: true });
    var toggleListType_1 = toggleListType$1;
    /**
     * Toggle numbering at selection
     * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one
     * If selection contains bullet list, toggle numbering will convert the bullet list into number list
     * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     * realization of browser execCommand API
     * @param editor The editor instance
     * @param startNumber (Optional) Start number of the list
     * @param listStyle (Optional) The style of the numbering list. If not defined, the style will be set to decimal.
     * @param apiNameOverride (Optional) Set a new api name, if empty the api name will be 'toggleListType'.
     */
    function toggleNumbering(editor, startNumber, listStyle, apiNameOverride) {
        (0, toggleListType_1.default)(editor, 1 /* Ordered */, startNumber, undefined /* includeSiblingLists */, listStyle, undefined /* unorderedStyle */, apiNameOverride);
    }
    toggleNumbering$1.default = toggleNumbering;

    var setOrderedListNumbering$1 = {};

    Object.defineProperty(setOrderedListNumbering$1, "__esModule", { value: true });
    var formatUndoSnapshot_1$2 = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$S = lib$3;
    /**
     * Resets Ordered List Numbering back to the value of the parameter startNumber
     * @param editor The editor instance
     * @param separator The HTML element that indicates when to split the VList
     * @param startNumber The number of that the splitted list should start
     */
    function setOrderedListNumbering(editor, separator, startNumber) {
        if (startNumber === void 0) { startNumber = 1; }
        (0, formatUndoSnapshot_1$2.default)(editor, function () {
            editor.focus();
            var regions = editor.getSelectedRegions();
            if (regions[0]) {
                var vList = (0, roosterjs_editor_dom_1$S.createVListFromRegion)(regions[0], false /*includeSiblingLists*/, separator);
                if (vList) {
                    vList.split(separator, startNumber);
                    vList.writeBack(editor.isFeatureEnabled("ReuseAllAncestorListElements" /* ReuseAllAncestorListElements */));
                }
            }
        }, 'setOrderedListNumbering');
    }
    setOrderedListNumbering$1.default = setOrderedListNumbering;

    var toggleBlockQuote$1 = {};

    var blockWrap$1 = {};

    Object.defineProperty(blockWrap$1, "__esModule", { value: true });
    var blockFormat_1 = blockFormat$1;
    var roosterjs_editor_dom_1$R = lib$3;
    /**
     * @internal
     * Toggle a tag at selection, if selection already contains elements of such tag,
     * the elements will be untagged and other elements will take no effect
     * @param editor The editor instance
     * @param wrapFunction  The wrap function
     * @param beforeRunCallback A callback function to run before looping all regions. If it returns false,
     * the loop for regions will be skipped
     */
    function blockWrap(editor, wrapFunction, beforeRunCallback, apiName) {
        (0, blockFormat_1.default)(editor, function (region) {
            var blocks = (0, roosterjs_editor_dom_1$R.getSelectedBlockElementsInRegion)(region, true /*createBlockIfEmpty*/, editor.isFeatureEnabled("DefaultFormatInSpan" /* DefaultFormatInSpan */));
            var nodes = (0, roosterjs_editor_dom_1$R.collapseNodesInRegion)(region, blocks);
            if (nodes.length > 0) {
                if (nodes.length == 1) {
                    var NodeTag = (0, roosterjs_editor_dom_1$R.getTagOfNode)(nodes[0]);
                    if (NodeTag == 'BR') {
                        nodes = [(0, roosterjs_editor_dom_1$R.wrap)(nodes[0])];
                    }
                    else if (NodeTag == 'LI' || NodeTag == 'TD') {
                        nodes = (0, roosterjs_editor_dom_1$R.toArray)(nodes[0].childNodes);
                    }
                }
                while (nodes[0] &&
                    nodes[0].parentNode &&
                    (0, roosterjs_editor_dom_1$R.isNodeInRegion)(region, nodes[0].parentNode) &&
                    nodes.some(function (node) { return (0, roosterjs_editor_dom_1$R.getTagOfNode)(node) == 'LI'; })) {
                    var result = (0, roosterjs_editor_dom_1$R.splitBalancedNodeRange)(nodes);
                    nodes = result ? [result] : [];
                }
                wrapFunction(nodes);
            }
        }, beforeRunCallback, apiName);
    }
    blockWrap$1.default = blockWrap;

    Object.defineProperty(toggleBlockQuote$1, "__esModule", { value: true });
    var blockWrap_1$1 = blockWrap$1;
    var roosterjs_editor_dom_1$Q = lib$3;
    var BLOCKQUOTE_TAG = 'blockquote';
    var DEFAULT_STYLER = function (element) {
        element.style.borderLeft = '3px solid';
        element.style.borderColor = '#C8C8C8';
        element.style.paddingLeft = '10px';
        element.style.color = '#666666';
    };
    /**
     * Toggle blockquote at selection, if selection already contains any blockquote elements,
     * the blockquote elements will be unquote and other elements will take no effect
     * @param editor The editor instance
     * @param styler (Optional) The custom styler for setting the style for the blockquote element
     */
    function toggleBlockQuote(editor, styler) {
        (0, blockWrap_1$1.default)(editor, function (nodes) {
            var wrapper = (0, roosterjs_editor_dom_1$Q.wrap)(nodes, BLOCKQUOTE_TAG);
            (styler || DEFAULT_STYLER)(wrapper);
        }, function () { return editor.queryElements('blockquote', 1 /* OnSelection */, roosterjs_editor_dom_1$Q.unwrap).length == 0; }, 'toggleBlockQuote');
    }
    toggleBlockQuote$1.default = toggleBlockQuote;

    var toggleCodeBlock$1 = {};

    Object.defineProperty(toggleCodeBlock$1, "__esModule", { value: true });
    var blockWrap_1 = blockWrap$1;
    var roosterjs_editor_dom_1$P = lib$3;
    var PRE_TAG = 'pre';
    var CODE_TAG = 'code';
    var SELECTOR = PRE_TAG + ">" + CODE_TAG;
    /**
     * Toggle code block at selection, if selection already contains any code blocked elements,
     * the code block elements will be no longer be code blocked and other elements will take no affect
     * @param editor The editor instance
     * @param styler (Optional) The custom styler for setting the style for the code block element
     */
    function toggleCodeBlock(editor, styler) {
        (0, blockWrap_1.default)(editor, function (nodes) {
            var code = (0, roosterjs_editor_dom_1$P.wrap)(nodes, CODE_TAG);
            var pre = (0, roosterjs_editor_dom_1$P.wrap)(code, PRE_TAG);
            styler === null || styler === void 0 ? void 0 : styler(pre);
        }, function () {
            return editor.queryElements(SELECTOR, 1 /* OnSelection */, function (code) {
                if (!code.previousSibling && !code.nextSibling) {
                    var parent_1 = code.parentNode;
                    (0, roosterjs_editor_dom_1$P.unwrap)(code);
                    (0, roosterjs_editor_dom_1$P.unwrap)(parent_1);
                }
            }).length == 0;
        }, 'toggleCodeBlock');
    }
    toggleCodeBlock$1.default = toggleCodeBlock;

    var toggleStrikethrough$1 = {};

    Object.defineProperty(toggleStrikethrough$1, "__esModule", { value: true });
    var execCommand_1$2 = execCommand$1;
    /**
     * Toggle strikethrough at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only strikethrough text, the strikethrough style will be removed
     * If selection contains only normal text, strikethrough style will be added to the whole selected text
     * If selection contains both strikethrough and normal text, strikethrough style will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleStrikethrough(editor) {
        (0, execCommand_1$2.default)(editor, "strikeThrough" /* StrikeThrough */, 'toggleStrikethrough');
    }
    toggleStrikethrough$1.default = toggleStrikethrough;

    var toggleSubscript$1 = {};

    Object.defineProperty(toggleSubscript$1, "__esModule", { value: true });
    var execCommand_1$1 = execCommand$1;
    /**
     * Toggle subscript at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only subscript text, the subscript style will be removed
     * If selection contains only normal text, subscript style will be added to the whole selected text
     * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text
     * If selection contains any superscript text, the behavior is determined by corresponding realization of browser
     * execCommand API
     * @param editor The editor instance
     */
    function toggleSubscript(editor) {
        (0, execCommand_1$1.default)(editor, "subscript" /* Subscript */, 'toggleSubscript');
    }
    toggleSubscript$1.default = toggleSubscript;

    var toggleSuperscript$1 = {};

    Object.defineProperty(toggleSuperscript$1, "__esModule", { value: true });
    var execCommand_1 = execCommand$1;
    /**
     * Toggle superscript at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only superscript text, the superscript style will be removed
     * If selection contains only normal text, superscript style will be added to the whole selected text
     * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text
     * If selection contains any subscript text, the behavior is determined by corresponding realization of browser
     * execCommand API
     * @param editor The editor instance
     */
    function toggleSuperscript(editor) {
        (0, execCommand_1.default)(editor, "superscript" /* Superscript */, 'toggleSuperscript');
    }
    toggleSuperscript$1.default = toggleSuperscript;

    var toggleHeader$1 = {};

    Object.defineProperty(toggleHeader$1, "__esModule", { value: true });
    var formatUndoSnapshot_1$1 = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$O = lib$3;
    /**
     * Toggle header at selection
     * @param editor The editor instance
     * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to
     * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header
     * if passed in param is outside the range, will be rounded to nearest number in the range
     */
    function toggleHeader(editor, level) {
        level = Math.min(Math.max(Math.round(level), 0), 6);
        (0, formatUndoSnapshot_1$1.default)(editor, function () {
            editor.focus();
            var wrapped = false;
            editor.queryElements('H1,H2,H3,H4,H5,H6', 1 /* OnSelection */, function (header) {
                if (!wrapped) {
                    editor.getDocument().execCommand("formatBlock" /* FormatBlock */, false, '<DIV>');
                    wrapped = true;
                }
                var div = editor.getDocument().createElement('div');
                (0, roosterjs_editor_dom_1$O.moveChildNodes)(div, header);
                editor.replaceNode(header, div);
            });
            if (level > 0) {
                var traverser = editor.getSelectionTraverser();
                var blockElement = traverser ? traverser.currentBlockElement : null;
                var sanitizer = new roosterjs_editor_dom_1$O.HtmlSanitizer({
                    cssStyleCallbacks: {
                        'font-size': function () { return false; },
                    },
                });
                while (blockElement) {
                    var element = blockElement.collapseToSingleElement();
                    sanitizer.sanitize(element);
                    blockElement = traverser.getNextBlockElement();
                }
                editor.getDocument().execCommand("formatBlock" /* FormatBlock */, false, "<H" + level + ">");
            }
        }, 'toggleHeader');
    }
    toggleHeader$1.default = toggleHeader;

    var applyCellShading$1 = {};

    Object.defineProperty(applyCellShading$1, "__esModule", { value: true });
    var formatUndoSnapshot_1 = formatUndoSnapshot$1;
    var roosterjs_editor_dom_1$N = lib$3;
    /**
     * Set background color of cells.
     * @param editor The editor instance
     * @param color One of two options:
     **/
    function applyCellShading(editor, color) {
        editor.focus();
        (0, formatUndoSnapshot_1.default)(editor, function () {
            var regions = editor.getSelectedRegions();
            regions.forEach(function (region) {
                if ((0, roosterjs_editor_dom_1$N.safeInstanceOf)(region.rootNode, 'HTMLTableCellElement')) {
                    (0, roosterjs_editor_dom_1$N.setColor)(region.rootNode, color, true /* isBackgroundColor */, editor.isDarkMode(), true /** shouldAdaptFontColor */, editor.getDarkColorHandler());
                    (0, roosterjs_editor_dom_1$N.saveTableCellMetadata)(region.rootNode, { bgColorOverride: true });
                }
            });
        }, 'applyCellShading');
    }
    applyCellShading$1.default = applyCellShading;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.experimentCommitListChains = exports.commitListChains = exports.blockFormat = exports.toggleListType = exports.applyCellShading = exports.toggleHeader = exports.toggleUnderline = exports.toggleSuperscript = exports.toggleSubscript = exports.toggleStrikethrough = exports.toggleCodeBlock = exports.toggleBlockQuote = exports.setOrderedListNumbering = exports.toggleNumbering = exports.toggleItalic = exports.toggleBullet = exports.toggleBold = exports.changeCapitalization = exports.setIndentation = exports.setImageAltText = exports.setFontSize = exports.setFontName = exports.setDirection = exports.setTextColor = exports.setBackgroundColor = exports.setAlignment = exports.rotateElement = exports.replaceWithNode = exports.removeLink = exports.formatTable = exports.editTable = exports.insertTable = exports.insertImage = exports.insertEntity = exports.getElementBasedFormatState = exports.getFormatState = exports.createLink = exports.clearFormat = exports.clearBlockFormat = exports.FONT_SIZES = exports.changeFontSize = void 0;
    var changeFontSize_1 = changeFontSize;
    Object.defineProperty(exports, "changeFontSize", { enumerable: true, get: function () { return changeFontSize_1.default; } });
    Object.defineProperty(exports, "FONT_SIZES", { enumerable: true, get: function () { return changeFontSize_1.FONT_SIZES; } });
    var clearBlockFormat_1 = clearBlockFormat$2;
    Object.defineProperty(exports, "clearBlockFormat", { enumerable: true, get: function () { return clearBlockFormat_1.default; } });
    var clearFormat_1 = clearFormat$2;
    Object.defineProperty(exports, "clearFormat", { enumerable: true, get: function () { return clearFormat_1.default; } });
    var createLink_1 = createLink$1;
    Object.defineProperty(exports, "createLink", { enumerable: true, get: function () { return createLink_1.default; } });
    var getFormatState_1 = getFormatState$1;
    Object.defineProperty(exports, "getFormatState", { enumerable: true, get: function () { return getFormatState_1.default; } });
    Object.defineProperty(exports, "getElementBasedFormatState", { enumerable: true, get: function () { return getFormatState_1.getElementBasedFormatState; } });
    var insertEntity_1 = insertEntity$1;
    Object.defineProperty(exports, "insertEntity", { enumerable: true, get: function () { return insertEntity_1.default; } });
    var insertImage_1 = insertImage$2;
    Object.defineProperty(exports, "insertImage", { enumerable: true, get: function () { return insertImage_1.default; } });
    var insertTable_1 = insertTable$2;
    Object.defineProperty(exports, "insertTable", { enumerable: true, get: function () { return insertTable_1.default; } });
    var editTable_1 = editTable$1;
    Object.defineProperty(exports, "editTable", { enumerable: true, get: function () { return editTable_1.default; } });
    var formatTable_1 = formatTable$1;
    Object.defineProperty(exports, "formatTable", { enumerable: true, get: function () { return formatTable_1.default; } });
    var removeLink_1 = removeLink$2;
    Object.defineProperty(exports, "removeLink", { enumerable: true, get: function () { return removeLink_1.default; } });
    var replaceWithNode_1 = replaceWithNode$1;
    Object.defineProperty(exports, "replaceWithNode", { enumerable: true, get: function () { return replaceWithNode_1.default; } });
    var rotateElement_1 = rotateElement$1;
    Object.defineProperty(exports, "rotateElement", { enumerable: true, get: function () { return rotateElement_1.default; } });
    var setAlignment_1 = setAlignment$1;
    Object.defineProperty(exports, "setAlignment", { enumerable: true, get: function () { return setAlignment_1.default; } });
    var setBackgroundColor_1 = setBackgroundColor$1;
    Object.defineProperty(exports, "setBackgroundColor", { enumerable: true, get: function () { return setBackgroundColor_1.default; } });
    var setTextColor_1 = setTextColor$1;
    Object.defineProperty(exports, "setTextColor", { enumerable: true, get: function () { return setTextColor_1.default; } });
    var setDirection_1 = setDirection$1;
    Object.defineProperty(exports, "setDirection", { enumerable: true, get: function () { return setDirection_1.default; } });
    var setFontName_1 = setFontName$1;
    Object.defineProperty(exports, "setFontName", { enumerable: true, get: function () { return setFontName_1.default; } });
    var setFontSize_1 = setFontSize$1;
    Object.defineProperty(exports, "setFontSize", { enumerable: true, get: function () { return setFontSize_1.default; } });
    var setImageAltText_1 = setImageAltText$1;
    Object.defineProperty(exports, "setImageAltText", { enumerable: true, get: function () { return setImageAltText_1.default; } });
    var setIndentation_1 = setIndentation$1;
    Object.defineProperty(exports, "setIndentation", { enumerable: true, get: function () { return setIndentation_1.default; } });
    var changeCapitalization_1 = changeCapitalization$1;
    Object.defineProperty(exports, "changeCapitalization", { enumerable: true, get: function () { return changeCapitalization_1.default; } });
    var toggleBold_1 = toggleBold$1;
    Object.defineProperty(exports, "toggleBold", { enumerable: true, get: function () { return toggleBold_1.default; } });
    var toggleBullet_1 = toggleBullet$1;
    Object.defineProperty(exports, "toggleBullet", { enumerable: true, get: function () { return toggleBullet_1.default; } });
    var toggleItalic_1 = toggleItalic$1;
    Object.defineProperty(exports, "toggleItalic", { enumerable: true, get: function () { return toggleItalic_1.default; } });
    var toggleNumbering_1 = toggleNumbering$1;
    Object.defineProperty(exports, "toggleNumbering", { enumerable: true, get: function () { return toggleNumbering_1.default; } });
    var setOrderedListNumbering_1 = setOrderedListNumbering$1;
    Object.defineProperty(exports, "setOrderedListNumbering", { enumerable: true, get: function () { return setOrderedListNumbering_1.default; } });
    var toggleBlockQuote_1 = toggleBlockQuote$1;
    Object.defineProperty(exports, "toggleBlockQuote", { enumerable: true, get: function () { return toggleBlockQuote_1.default; } });
    var toggleCodeBlock_1 = toggleCodeBlock$1;
    Object.defineProperty(exports, "toggleCodeBlock", { enumerable: true, get: function () { return toggleCodeBlock_1.default; } });
    var toggleStrikethrough_1 = toggleStrikethrough$1;
    Object.defineProperty(exports, "toggleStrikethrough", { enumerable: true, get: function () { return toggleStrikethrough_1.default; } });
    var toggleSubscript_1 = toggleSubscript$1;
    Object.defineProperty(exports, "toggleSubscript", { enumerable: true, get: function () { return toggleSubscript_1.default; } });
    var toggleSuperscript_1 = toggleSuperscript$1;
    Object.defineProperty(exports, "toggleSuperscript", { enumerable: true, get: function () { return toggleSuperscript_1.default; } });
    var toggleUnderline_1 = toggleUnderline$1;
    Object.defineProperty(exports, "toggleUnderline", { enumerable: true, get: function () { return toggleUnderline_1.default; } });
    var toggleHeader_1 = toggleHeader$1;
    Object.defineProperty(exports, "toggleHeader", { enumerable: true, get: function () { return toggleHeader_1.default; } });
    var applyCellShading_1 = applyCellShading$1;
    Object.defineProperty(exports, "applyCellShading", { enumerable: true, get: function () { return applyCellShading_1.default; } });
    var toggleListType_1 = toggleListType$1;
    Object.defineProperty(exports, "toggleListType", { enumerable: true, get: function () { return toggleListType_1.default; } });
    var blockFormat_1 = blockFormat$1;
    Object.defineProperty(exports, "blockFormat", { enumerable: true, get: function () { return blockFormat_1.default; } });
    var commitListChains_1 = commitListChains$1;
    Object.defineProperty(exports, "commitListChains", { enumerable: true, get: function () { return commitListChains_1.default; } });
    Object.defineProperty(exports, "experimentCommitListChains", { enumerable: true, get: function () { return commitListChains_1.experimentCommitListChains; } });

    }(lib$1));

    Object.defineProperty(alignCenter, "__esModule", { value: true });
    alignCenter.alignCenter = void 0;
    var roosterjs_editor_api_1$G = lib$1;
    /**
     * @internal
     * "Align center" button on the format ribbon
     */
    alignCenter.alignCenter = {
        key: 'buttonNameAlignCenter',
        unlocalizedText: 'Align center',
        iconName: 'AlignCenter',
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$G.setAlignment)(editor, 1 /* Center */);
        },
    };

    var alignLeft = {};

    Object.defineProperty(alignLeft, "__esModule", { value: true });
    alignLeft.alignLeft = void 0;
    var roosterjs_editor_api_1$F = lib$1;
    /**
     * @internal
     * "Align left" button on the format ribbon
     */
    alignLeft.alignLeft = {
        key: 'buttonNameAlignLeft',
        unlocalizedText: 'Align left',
        iconName: 'AlignLeft',
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$F.setAlignment)(editor, 0 /* Left */);
        },
    };

    var alignRight = {};

    Object.defineProperty(alignRight, "__esModule", { value: true });
    alignRight.alignRight = void 0;
    var roosterjs_editor_api_1$E = lib$1;
    /**
     * @internal
     * "Align right" button on the format ribbon
     */
    alignRight.alignRight = {
        key: 'buttonNameAlignRight',
        unlocalizedText: 'Align right',
        iconName: 'AlignRight',
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$E.setAlignment)(editor, 2 /* Right */);
        },
    };

    var backgroundColor = {};

    var renderColorPicker$1 = {};

    Object.defineProperty(renderColorPicker$1, "__esModule", { value: true });
    renderColorPicker$1.renderColorPicker = void 0;
    var React$c = react.exports;
    var Styling_1$4 = require$$10;
    var classNames$3 = (0, Styling_1$4.mergeStyleSets)({
        colorSquare: {
            width: '20px',
            height: '20px',
            margin: '4px',
            borderStyle: 'solid',
            borderWidth: '2px',
            '&:hover': {
                borderColor: 'red',
            },
        },
        colorSquareBorder: {
            borderColor: 'transparent',
        },
        colorSquareBorderWhite: {
            borderColor: '#bebebe',
        },
    });
    /**
     * @internal
     */
    function renderColorPicker(item, colorDef, onClick) {
        var key = item.key;
        var buttonColor = colorDef[key].lightModeColor;
        return (React$c.createElement("button", { onClick: function (e) { return onClick(e, item); }, title: item.text },
            React$c.createElement("div", { className: classNames$3.colorSquare +
                    ' ' +
                    (key == 'textColorWhite' || key == 'backgroundColorWhite'
                        ? classNames$3.colorSquareBorderWhite
                        : classNames$3.colorSquareBorder), style: {
                    backgroundColor: buttonColor,
                } })));
    }
    renderColorPicker$1.renderColorPicker = renderColorPicker;

    var getClassNamesForColorPicker = {};

    Object.defineProperty(getClassNamesForColorPicker, "__esModule", { value: true });
    getClassNamesForColorPicker.getColorPickerItemClassName = getClassNamesForColorPicker.getColorPickerContainerClassName = void 0;
    var Styling_1$3 = require$$10;
    var classNames$2 = (0, Styling_1$3.mergeStyleSets)({
        colorPickerContainer: {
            width: '192px',
            padding: '8px',
            overflow: 'hidden',
            '& ul': {
                width: '192px',
                overflow: 'hidden',
            },
        },
        colorMenuItem: {
            display: 'inline-block',
            width: '32px',
            height: '32px',
            '& button': {
                padding: '0px',
                minWidth: '0px',
                background: 'transparent',
                border: 'none',
            },
        },
    });
    /**
     * @internal
     */
    function getColorPickerContainerClassName() {
        return classNames$2.colorPickerContainer;
    }
    getClassNamesForColorPicker.getColorPickerContainerClassName = getColorPickerContainerClassName;
    /**
     * @internal
     */
    function getColorPickerItemClassName() {
        return classNames$2.colorMenuItem;
    }
    getClassNamesForColorPicker.getColorPickerItemClassName = getColorPickerItemClassName;

    var backgroundColors = {};

    Object.defineProperty(backgroundColors, "__esModule", { value: true });
    backgroundColors.getBackgroundColorValue = backgroundColors.BackgroundColorDropDownItems = backgroundColors.BackgroundColors = void 0;
    /**
     * @internal
     */
    var BackgroundColors = {
        backgroundColorCyan: { lightModeColor: '#00ffff', darkModeColor: '#005357' },
        backgroundColorGreen: { lightModeColor: '#00ff00', darkModeColor: '#005e00' },
        backgroundColorYellow: { lightModeColor: '#ffff00', darkModeColor: '#383e00' },
        backgroundColorOrange: { lightModeColor: '#ff8000', darkModeColor: '#bf4c00' },
        backgroundColorRed: { lightModeColor: '#ff0000', darkModeColor: '#ff2711' },
        backgroundColorMagenta: { lightModeColor: '#ff00ff', darkModeColor: '#e700e8' },
        backgroundColorLightCyan: { lightModeColor: '#80ffff', darkModeColor: '#004c4f' },
        backgroundColorLightGreen: { lightModeColor: '#80ff80', darkModeColor: '#005400' },
        backgroundColorLightYellow: { lightModeColor: '#ffff80', darkModeColor: '#343c00' },
        backgroundColorLightOrange: { lightModeColor: '#ffc080', darkModeColor: '#77480b' },
        backgroundColorLightRed: { lightModeColor: '#ff8080', darkModeColor: '#bc454a' },
        backgroundColorLightMagenta: { lightModeColor: '#ff80ff', darkModeColor: '#aa2bad' },
        backgroundColorWhite: { lightModeColor: '#ffffff', darkModeColor: '#333333' },
        backgroundColorLightGray: { lightModeColor: '#cccccc', darkModeColor: '#535353' },
        backgroundColorGray: { lightModeColor: '#999999', darkModeColor: '#777777' },
        backgroundColorDarkGray: { lightModeColor: '#666666', darkModeColor: '#a0a0a0' },
        backgroundColorDarkerGray: { lightModeColor: '#333333', darkModeColor: '#cfcfcf' },
        backgroundColorBlack: { lightModeColor: '#000000', darkModeColor: '#ffffff' },
    };
    backgroundColors.BackgroundColors = BackgroundColors;
    /**
     * @internal
     * List of colors in drop down list
     */
    var BackgroundColorDropDownItems = {
        backgroundColorCyan: 'Cyan',
        backgroundColorGreen: 'Green',
        backgroundColorYellow: 'Yellow',
        backgroundColorOrange: 'Orange',
        backgroundColorRed: 'Red',
        backgroundColorMagenta: 'Magenta',
        backgroundColorLightCyan: 'Light cyan',
        backgroundColorLightGreen: 'Light green',
        backgroundColorLightYellow: 'Light yellow',
        backgroundColorLightOrange: 'Light orange',
        backgroundColorLightRed: 'Light red',
        backgroundColorLightMagenta: 'Light magenta',
        backgroundColorWhite: 'White',
        backgroundColorLightGray: 'Light gray',
        backgroundColorGray: 'Gray',
        backgroundColorDarkGray: 'Dark gray',
        backgroundColorDarkerGray: 'Darker gray',
        backgroundColorBlack: 'Black',
    };
    backgroundColors.BackgroundColorDropDownItems = BackgroundColorDropDownItems;
    /**
     * Get mode independent color value of background color from the given color key
     * @param key The key to get color from
     * @returns A model independent color value of the given key
     */
    function getBackgroundColorValue(key) {
        return BackgroundColors[key];
    }
    backgroundColors.getBackgroundColorValue = getBackgroundColorValue;

    Object.defineProperty(backgroundColor, "__esModule", { value: true });
    backgroundColor.backgroundColor = void 0;
    var renderColorPicker_1$2 = renderColorPicker$1;
    var roosterjs_editor_api_1$D = lib$1;
    var getClassNamesForColorPicker_1$2 = getClassNamesForColorPicker;
    var backgroundColors_1$1 = backgroundColors;
    var Key$1 = 'buttonNameBackgroundColor';
    /**
     * @internal
     * "Background color" button on the format ribbon
     */
    backgroundColor.backgroundColor = {
        dropDownMenu: {
            items: backgroundColors_1$1.BackgroundColorDropDownItems,
            itemClassName: (0, getClassNamesForColorPicker_1$2.getColorPickerItemClassName)(),
            allowLivePreview: true,
            itemRender: function (item, onClick) { return (0, renderColorPicker_1$2.renderColorPicker)(item, backgroundColors_1$1.BackgroundColors, onClick); },
            commandBarSubMenuProperties: {
                className: (0, getClassNamesForColorPicker_1$2.getColorPickerContainerClassName)(),
            },
        },
        key: Key$1,
        unlocalizedText: 'Background color',
        iconName: 'FabricTextHighlight',
        onClick: function (editor, key) {
            // This check will always be true, add it here just to satisfy compiler
            if (key != Key$1) {
                (0, roosterjs_editor_api_1$D.setBackgroundColor)(editor, (0, backgroundColors_1$1.getBackgroundColorValue)(key));
            }
        },
    };

    var bold = {};

    Object.defineProperty(bold, "__esModule", { value: true });
    bold.bold = void 0;
    var roosterjs_editor_api_1$C = lib$1;
    /**
     * @internal
     * "Bold" button on the format ribbon
     */
    bold.bold = {
        key: 'buttonNameBold',
        unlocalizedText: 'Bold',
        iconName: 'Bold',
        isChecked: function (formatState) { return !!formatState.isBold; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$C.toggleBold)(editor);
            return true;
        },
    };

    var bulletedList = {};

    Object.defineProperty(bulletedList, "__esModule", { value: true });
    bulletedList.bulletedList = void 0;
    var roosterjs_editor_api_1$B = lib$1;
    /**
     * @internal
     * "Bulleted list" button on the format ribbon
     */
    bulletedList.bulletedList = {
        key: 'buttonNameBulletedList',
        unlocalizedText: 'Bulleted list',
        iconName: 'BulletedList',
        isChecked: function (formatState) { return !!formatState.isBullet; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$B.toggleBullet)(editor);
            return true;
        },
    };

    var clearFormat = {};

    Object.defineProperty(clearFormat, "__esModule", { value: true });
    clearFormat.clearFormat = void 0;
    var roosterjs_editor_api_1$A = lib$1;
    /**
     * @internal
     * "Clear format" button on the format ribbon
     */
    clearFormat.clearFormat = {
        key: 'buttonNameClearFormat',
        unlocalizedText: 'Clear format',
        iconName: 'ClearFormatting',
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$A.clearFormat)(editor, 2 /* AutoDetect */);
        },
    };

    var code = {};

    Object.defineProperty(code, "__esModule", { value: true });
    code.code = void 0;
    var roosterjs_editor_api_1$z = lib$1;
    /**
     * @internal
     * "Code" button on the format ribbon
     */
    code.code = {
        key: 'buttonNameCode',
        unlocalizedText: 'Code',
        iconName: 'Code',
        isChecked: function (formatState) { return !!formatState.isCodeBlock; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$z.toggleCodeBlock)(editor);
        },
    };

    var decreaseFontSize = {};

    Object.defineProperty(decreaseFontSize, "__esModule", { value: true });
    decreaseFontSize.decreaseFontSize = void 0;
    var roosterjs_editor_api_1$y = lib$1;
    /**
     * @internal
     * "Decrease font size" button on the format ribbon
     */
    decreaseFontSize.decreaseFontSize = {
        key: 'buttonNameDecreaseFontSize',
        unlocalizedText: 'Decrease font size',
        iconName: 'FontDecrease',
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$y.changeFontSize)(editor, 1 /* Decrease */);
        },
    };

    var decreaseIndent = {};

    Object.defineProperty(decreaseIndent, "__esModule", { value: true });
    decreaseIndent.decreaseIndent = void 0;
    var roosterjs_editor_api_1$x = lib$1;
    /**
     * @internal
     * "Decrease indent" button on the format ribbon
     */
    decreaseIndent.decreaseIndent = {
        key: 'buttonNameDecreaseIndent',
        unlocalizedText: 'Decrease indent',
        iconName: 'DecreaseIndentLegacy',
        flipWhenRtl: true,
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$x.setIndentation)(editor, 1 /* Decrease */);
        },
    };

    var font = {};

    Object.defineProperty(font, "__esModule", { value: true });
    font.font = void 0;
    var roosterjs_editor_api_1$w = lib$1;
    var FontNames = [
        { name: 'Arial', family: 'Arial,Helvetica,sans-serif' },
        { name: 'Arial Black', family: "'Arial Black',Arial,sans-serif" },
        { name: 'Calibri', family: 'Calibri,Helvetica,sans-serif' },
        { name: 'Calibri Light', family: "'Calibri Light','Helvetica Light',sans-serif" },
        { name: 'Cambria', family: 'Cambria,Georgia,serif' },
        { name: 'Candara', family: 'Candara,Optima,sans-serif' },
        { name: 'Century Gothic', family: "'Century Gothic',sans-serif" },
        { name: 'Comic Sans MS', family: "'Comic Sans MS',Chalkboard,cursive" },
        { name: 'Consolas', family: 'Consolas,Courier,monospace' },
        { name: 'Constantia', family: "Constantia,'Hoefler Text',serif" },
        { name: 'Corbel', family: 'Corbel,Skia,sans-serif' },
        { name: 'Courier New', family: "'Courier New',monospace" },
        {
            name: 'Franklin Gothic Book',
            family: "'Franklin Gothic Book','Avenir Next Condensed',sans-serif",
        },
        {
            name: 'Franklin Gothic Demi',
            family: "'Franklin Gothic Demi','Avenir Next Condensed Demi Bold',sans-serif",
        },
        {
            name: 'Franklin Gothic Medium',
            family: "'Franklin Gothic Medium','Avenir Next Condensed Medium',sans-serif",
        },
        { name: 'Garamond', family: 'Garamond,Georgia,serif' },
        { name: 'Georgia', family: 'Georgia,serif' },
        { name: 'Impact', family: 'Impact,Charcoal,sans-serif' },
        { name: 'Lucida Console', family: "'Lucida Console',Monaco,monospace" },
        { name: 'Lucida Handwriting', family: "'Lucida Handwriting','Apple Chancery',cursive" },
        { name: 'Lucida Sans Unicode', family: "'Lucida Sans Unicode','Lucida Grande',sans-serif" },
        { name: 'Palatino Linotype', family: "'Palatino Linotype','Book Antiqua',Palatino,serif" },
        {
            name: 'Segoe UI',
            family: "'Segoe UI', 'Segoe UI Web (West European)', 'Helvetica Neue', sans-serif",
        },
        { name: 'Sitka Heading', family: "'Sitka Heading',Cochin,serif" },
        { name: 'Sitka Text', family: "'Sitka Text',Cochin,serif" },
        { name: 'Tahoma', family: 'Tahoma,Geneva,sans-serif' },
        { name: 'Times', family: "Times,'Times New Roman',serif" },
        { name: 'Times New Roman', family: "'Times New Roman',Times,serif" },
        { name: 'Trebuchet MS', family: "'Trebuchet MS',Trebuchet,sans-serif" },
        { name: 'TW Cen MT', family: "'TW Cen MT','Century Gothic',sans-serif" },
        { name: 'Verdana', family: 'Verdana,Geneva,sans-serif' },
        { name: '-', family: 'FontDivider0' },
        {
            name: 'Microsoft YaHei',
            family: "'Microsoft YaHei','',STHeiti,sans-serif",
            localizedName: '',
        },
        { name: 'SimHei', family: "SimHei,'',STHeiti,sans-serif", localizedName: '' },
        {
            name: 'NSimSun',
            family: "NSimSun,'',SimSun,'',SimSun-ExtB,'-ExtB',STSong,serif",
            localizedName: '',
        },
        { name: 'FangSong', family: "FangSong,'',STFangsong,serif", localizedName: '' },
        { name: 'SimLi', family: "SimLi,'','Baoli SC',serif", localizedName: '' },
        { name: 'KaiTi', family: "KaiTi,'',STKaiti,serif", localizedName: '' },
        { name: '-', family: 'FontDivider1' },
        {
            name: 'Microsoft JhengHei',
            family: "'Microsoft JhengHei','','Apple LiGothic',sans-serif",
            localizedName: '',
        },
        {
            name: 'PMingLiU',
            family: "PMingLiU,'',PMingLiU-ExtB,'-ExtB','Apple LiSung',serif",
            localizedName: '',
        },
        { name: 'DFKai-SB', family: "DFKai-SB,'','BiauKai',serif", localizedName: '' },
        { name: '-', family: 'FontDivider2' },
        {
            name: 'Meiryo',
            family: "Meiryo,'','Hiragino Sans',sans-serif",
            localizedName: '',
        },
        {
            name: 'MS PGothic',
            family: "'MS PGothic',' ','MS Gothic',' ','Hiragino Kaku Gothic ProN',sans-serif",
            localizedName: ' ',
        },
        {
            name: 'MS PMincho',
            family: "'MS PMincho',' ','MS Mincho',' ','Hiragino Mincho ProN',serif",
            localizedName: ' ',
        },
        {
            name: 'Yu Gothic',
            family: "'Yu Gothic','','YuGothic',sans-serif",
            localizedName: '',
        },
        { name: 'Yu Mincho', family: "'Yu Mincho','','YuMincho',serif", localizedName: '' },
        { name: '-', family: 'FontDivider3' },
        {
            name: 'Malgun Gothic',
            family: "'Malgun Gothic',' ',AppleGothic,sans-serif",
            localizedName: ' ',
        },
        { name: 'Gulim', family: "Gulim,'','Nanum Gothic',sans-serif", localizedName: '' },
        { name: 'Dotum', family: "Dotum,'',AppleGothic,sans-serif", localizedName: '' },
        { name: 'Batang', family: "Batang,'',AppleMyungjo,serif", localizedName: '' },
        { name: 'BatangChe', family: "BatangChe,'',AppleMyungjo,serif", localizedName: '' },
        { name: 'Gungsuh', family: "Gungsuh,'',GungSeo,serif", localizedName: '' },
        { name: '-', family: 'FontDivider4' },
        { name: 'Leelawadee UI', family: "'Leelawadee UI',Thonburi,sans-serif" },
        { name: 'Angsana New', family: "'Angsana New','Leelawadee UI',Sathu,serif" },
        { name: 'Cordia New', family: "'Cordia New','Leelawadee UI',Silom,sans-serif" },
        { name: 'DaunPenh', family: "DaunPenh,'Leelawadee UI','Khmer MN',sans-serif" },
        { name: '-', family: 'FontDivider5' },
        { name: 'Nirmala UI', family: "'Nirmala UI',sans-serif" },
        { name: 'Gautami', family: "Gautami,'Nirmala UI','Telugu MN',sans-serif" },
        { name: 'Iskoola Pota', family: "'Iskoola Pota','Nirmala UI','Sinhala MN',sans-serif" },
        { name: 'Kalinga', family: "Kalinga,'Nirmala UI','Oriya MN',sans-serif" },
        { name: 'Kartika', family: "Kartika,'Nirmala UI','Malayalam MN',sans-serif" },
        { name: 'Latha', family: "Latha,'Nirmala UI','Tamil MN',sans-serif" },
        { name: 'Mangal', family: "Mangal,'Nirmala UI','Devanagari Sangam MN',sans-serif" },
        { name: 'Raavi', family: "Raavi,'Nirmala UI','Gurmukhi MN',sans-serif" },
        { name: 'Shruti', family: "Shruti,'Nirmala UI','Gujarati Sangam MN',sans-serif" },
        { name: 'Tunga', family: "Tunga,'Nirmala UI','Kannada MN',sans-serif" },
        { name: 'Vrinda', family: "Vrinda,'Nirmala UI','Bangla MN',sans-serif" },
        { name: '-', family: 'FontDivider6' },
        { name: 'Nyala', family: 'Nyala,Kefa,sans-serif' },
        { name: 'Sylfaen', family: 'Sylfaen,Mshtakan,Menlo,serif' }, //other-armenian-georgian
    ];
    var DropDownItems = FontNames.reduce(function (items, font) {
        items[font.family] = font.localizedName || font.name;
        return items;
    }, {});
    var LowerCaseFontMap = FontNames.reduce(function (items, font) {
        items[font.name.toLowerCase()] = font.family;
        return items;
    }, {});
    var FirstFontRegex = /^['"]?([^'",]+)/i;
    /**
     * @internal
     * "Font" button on the format ribbon
     */
    font.font = {
        key: 'buttonNameFont',
        unlocalizedText: 'Font',
        iconName: 'Font',
        dropDownMenu: {
            items: DropDownItems,
            getSelectedItemKey: function (formatState) {
                var _a, _b;
                var matches = (_a = formatState.fontName) === null || _a === void 0 ? void 0 : _a.match(FirstFontRegex);
                var firstName = (_b = matches === null || matches === void 0 ? void 0 : matches[1]) === null || _b === void 0 ? void 0 : _b.toLowerCase();
                var selectedKey = (firstName && LowerCaseFontMap[firstName]) || '';
                return selectedKey;
            },
            allowLivePreview: true,
        },
        onClick: function (editor, font) {
            (0, roosterjs_editor_api_1$w.setFontName)(editor, font);
        },
    };

    var fontSize = {};

    Object.defineProperty(fontSize, "__esModule", { value: true });
    fontSize.fontSize = void 0;
    var roosterjs_editor_api_1$v = lib$1;
    /**
     * @internal
     * "Font Size" button on the format ribbon
     */
    fontSize.fontSize = {
        key: 'buttonNameFontSize',
        unlocalizedText: 'Font size',
        iconName: 'FontSize',
        dropDownMenu: {
            items: roosterjs_editor_api_1$v.FONT_SIZES.reduce(function (map, size) {
                map[size + 'pt'] = size.toString();
                return map;
            }, {}),
            getSelectedItemKey: function (formatState) { var _a; return (_a = formatState.fontSize) !== null && _a !== void 0 ? _a : null; },
            allowLivePreview: true,
        },
        onClick: function (editor, size) {
            (0, roosterjs_editor_api_1$v.setFontSize)(editor, size);
        },
    };

    var header = {};

    Object.defineProperty(header, "__esModule", { value: true });
    header.header = void 0;
    var roosterjs_editor_dom_1$M = lib$3;
    var roosterjs_editor_api_1$u = lib$1;
    var headers = {
        buttonNameHeader1: 'Header 1',
        buttonNameHeader2: 'Header 2',
        buttonNameHeader3: 'Header 3',
        buttonNameHeader4: 'Header 4',
        buttonNameHeader5: 'Header 5',
        buttonNameHeader6: 'Header 6',
        '-': '-',
        buttonNameNoHeader: 'No header',
    };
    /**
     * @internal
     * "Header" button on the format ribbon
     */
    header.header = {
        key: 'buttonNameHeader',
        unlocalizedText: 'Header',
        iconName: 'Header1',
        dropDownMenu: {
            items: headers,
            getSelectedItemKey: function (formatState) {
                var _a;
                return ((_a = formatState.headerLevel) !== null && _a !== void 0 ? _a : 0) > 0
                    ? 'header' + formatState.headerLevel
                    : 'noHeader';
            },
        },
        onClick: function (editor, key) {
            var index = (0, roosterjs_editor_dom_1$M.getObjectKeys)(headers).indexOf(key) + 1;
            if (index > 6) {
                (0, roosterjs_editor_api_1$u.toggleHeader)(editor, 0);
            }
            else if (index > 0) {
                (0, roosterjs_editor_api_1$u.toggleHeader)(editor, index);
            }
        },
    };

    var increaseFontSize = {};

    Object.defineProperty(increaseFontSize, "__esModule", { value: true });
    increaseFontSize.increaseFontSize = void 0;
    var roosterjs_editor_api_1$t = lib$1;
    /**
     * @internal
     * "Increase font size" button on the format ribbon
     */
    increaseFontSize.increaseFontSize = {
        key: 'buttonNameIncreaseFontSize',
        unlocalizedText: 'Increase font size',
        iconName: 'FontIncrease',
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$t.changeFontSize)(editor, 0 /* Increase */);
        },
    };

    var increaseIndent = {};

    Object.defineProperty(increaseIndent, "__esModule", { value: true });
    increaseIndent.increaseIndent = void 0;
    var roosterjs_editor_api_1$s = lib$1;
    /**
     * @internal
     * "Increase indent" button on the format ribbon
     */
    increaseIndent.increaseIndent = {
        key: 'buttonNameIncreaseIndent',
        unlocalizedText: 'Increase indent',
        iconName: 'IncreaseIndentLegacy',
        flipWhenRtl: true,
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$s.setIndentation)(editor, 0 /* Increase */);
        },
    };

    var insertImage = {};

    Object.defineProperty(insertImage, "__esModule", { value: true });
    insertImage.insertImage = void 0;
    var roosterjs_editor_dom_1$L = lib$3;
    var roosterjs_editor_api_1$r = lib$1;
    var FileInput = {
        tag: 'input',
        attributes: {
            type: 'file',
            accept: 'image/*',
            display: 'none',
        },
    };
    /**
     * @internal
     * "Insert image" button on the format ribbon
     */
    insertImage.insertImage = {
        key: 'buttonNameInsertImage',
        unlocalizedText: 'Insert image',
        iconName: 'Photo2',
        onClick: function (editor) {
            var document = editor.getDocument();
            var fileInput = (0, roosterjs_editor_dom_1$L.createElement)(FileInput, document);
            document.body.appendChild(fileInput);
            fileInput.addEventListener('change', function () {
                if (fileInput.files) {
                    for (var i = 0; i < fileInput.files.length; i++) {
                        (0, roosterjs_editor_api_1$r.insertImage)(editor, fileInput.files[i]);
                    }
                }
            });
            try {
                fileInput.click();
            }
            finally {
                document.body.removeChild(fileInput);
            }
        },
    };

    var insertLink = {};

    var showInputDialog$1 = {};

    var InputDialog$1 = {};

    var InputDialogItem$1 = {};

    var require$$9 = /*@__PURE__*/getAugmentedNamespace(TextField);

    Object.defineProperty(InputDialogItem$1, "__esModule", { value: true });
    var React$b = react.exports;
    var index_1$2 = common;
    var Styling_1$2 = require$$10;
    var TextField_1 = require$$9;
    var classNames$1 = (0, Styling_1$2.mergeStyleSets)({
        inputBox: {
            width: '100%',
            minWidth: '250px',
            height: '32px',
            margin: '5px 0 16px',
            borderRadius: '2px',
        },
    });
    /**
     * @internal
     */
    function InputDialogItem(props) {
        var itemName = props.itemName, strings = props.strings, items = props.items, currentValues = props.currentValues, onChanged = props.onChanged, onEnterKey = props.onEnterKey;
        var _a = items[itemName], labelKey = _a.labelKey, unlocalizedLabel = _a.unlocalizedLabel, autoFocus = _a.autoFocus;
        var value = currentValues[itemName];
        var onValueChange = React$b.useCallback(function (_, newValue) {
            onChanged(itemName, newValue);
        }, [itemName, onChanged]);
        var onKeyPress = React$b.useCallback(function (e) {
            if (e.which == 13 /* ENTER */) {
                onEnterKey();
            }
        }, [onEnterKey]);
        return (React$b.createElement("div", null,
            labelKey ? React$b.createElement("div", null, (0, index_1$2.getLocalizedString)(strings, labelKey, unlocalizedLabel)) : null,
            React$b.createElement("div", null,
                React$b.createElement(TextField_1.TextField, { role: "textbox", type: "text", className: classNames$1.inputBox, value: value, onChange: onValueChange, onKeyPress: onKeyPress, autoFocus: autoFocus }))));
    }
    InputDialogItem$1.default = InputDialogItem;

    var require$$6 = /*@__PURE__*/getAugmentedNamespace(Button);

    var require$$4 = /*@__PURE__*/getAugmentedNamespace(Dialog);

    var __assign$a = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$a = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$a.apply(this, arguments);
    };
    Object.defineProperty(InputDialog$1, "__esModule", { value: true });
    var React$a = react.exports;
    var InputDialogItem_1 = InputDialogItem$1;
    var index_1$1 = common;
    var Button_1$1 = require$$6;
    var Dialog_1 = require$$4;
    var roosterjs_editor_dom_1$K = lib$3;
    /**
     * @internal
     */
    function InputDialog(props) {
        var items = props.items, strings = props.strings, dialogTitleKey = props.dialogTitleKey, unlocalizedTitle = props.unlocalizedTitle, onOk = props.onOk, onCancel = props.onCancel, onChange = props.onChange;
        var dialogContentProps = React$a.useMemo(function () { return ({
            type: Dialog_1.DialogType.normal,
            title: (0, index_1$1.getLocalizedString)(strings, dialogTitleKey, unlocalizedTitle),
        }); }, [strings, dialogTitleKey, unlocalizedTitle]);
        var _a = React$a.useState((0, roosterjs_editor_dom_1$K.getObjectKeys)(items).reduce(function (result, key) {
            result[key] = items[key].initValue;
            return result;
        }, {})), currentValues = _a[0], setCurrentValues = _a[1];
        var onSubmit = React$a.useCallback(function () {
            onOk === null || onOk === void 0 ? void 0 : onOk(currentValues);
        }, [onOk, currentValues]);
        var onItemChanged = React$a.useCallback(function (itemName, newValue) {
            var _a;
            if (itemName in items) {
                var newValues = (onChange === null || onChange === void 0 ? void 0 : onChange(itemName, newValue, __assign$a({}, currentValues))) || __assign$a(__assign$a({}, currentValues), (_a = {}, _a[itemName] = newValue, _a));
                setCurrentValues(newValues);
            }
        }, [setCurrentValues, currentValues, items]);
        return (React$a.createElement(Dialog_1.Dialog, { dialogContentProps: dialogContentProps, hidden: false, onDismiss: onCancel },
            React$a.createElement("div", null, (0, roosterjs_editor_dom_1$K.getObjectKeys)(items).map(function (key) { return (React$a.createElement(InputDialogItem_1.default, { key: key, itemName: key, items: items, strings: strings, currentValues: currentValues, onEnterKey: onSubmit, onChanged: onItemChanged })); })),
            React$a.createElement(Dialog_1.DialogFooter, null,
                React$a.createElement(Button_1$1.PrimaryButton, { text: (0, index_1$1.getLocalizedString)(strings, 'buttonNameOK', 'OK'), onClick: onSubmit }),
                React$a.createElement(Button_1$1.DefaultButton, { text: (0, index_1$1.getLocalizedString)(strings, 'buttonNameCancel', 'Cancel'), onClick: onCancel }))));
    }
    InputDialog$1.default = InputDialog;

    var renderReactComponent$1 = {};

    Object.defineProperty(renderReactComponent$1, "__esModule", { value: true });
    renderReactComponent$1.renderReactComponent = void 0;
    /**
     * @internal
     */
    function renderReactComponent(uiUtilities, reactElement) {
        if (uiUtilities) {
            return uiUtilities.renderComponent(reactElement);
        }
        else {
            throw new Error('UIUtilities is required but not provided. Please call ReactEditorPlugin.setUIUtilities() to set a valid uiUtilities object');
        }
    }
    renderReactComponent$1.renderReactComponent = renderReactComponent;

    Object.defineProperty(showInputDialog$1, "__esModule", { value: true });
    var React$9 = react.exports;
    var InputDialog_1 = InputDialog$1;
    var renderReactComponent_1$3 = renderReactComponent$1;
    /**
     * @internal
     */
    function showInputDialog(uiUtilities, dialogTitleKey, unlocalizedTitle, items, strings, onChange) {
        return new Promise(function (resolve) {
            var disposer = null;
            var onOk = function (result) {
                disposer === null || disposer === void 0 ? void 0 : disposer();
                resolve(result);
            };
            var onCancel = function () {
                disposer === null || disposer === void 0 ? void 0 : disposer();
                resolve(null);
            };
            var component = (React$9.createElement(InputDialog_1.default, { dialogTitleKey: dialogTitleKey, unlocalizedTitle: unlocalizedTitle, items: items, strings: strings, onOk: onOk, onCancel: onCancel, onChange: onChange }));
            disposer = (0, renderReactComponent_1$3.renderReactComponent)(uiUtilities, component);
        });
    }
    showInputDialog$1.default = showInputDialog;

    Object.defineProperty(insertLink, "__esModule", { value: true });
    insertLink.insertLink = void 0;
    var showInputDialog_1$2 = showInputDialog$1;
    var roosterjs_editor_api_1$q = lib$1;
    /**
     * @internal
     * "Insert link" button on the format ribbon
     */
    insertLink.insertLink = {
        key: 'buttonNameInsertLink',
        unlocalizedText: 'Insert link',
        iconName: 'Link',
        isDisabled: function (formatState) { return !!formatState.isMultilineSelection; },
        onClick: function (editor, _, strings, uiUtilities) {
            var _a;
            var existingLink = editor.queryElements('a[href]', 1 /* OnSelection */)[0];
            var url = (existingLink === null || existingLink === void 0 ? void 0 : existingLink.href) || '';
            var displayText = (existingLink === null || existingLink === void 0 ? void 0 : existingLink.textContent) || ((_a = editor.getSelectionRange()) === null || _a === void 0 ? void 0 : _a.toString()) || '';
            var items = {
                url: {
                    autoFocus: true,
                    labelKey: 'insertLinkDialogUrl',
                    unlocalizedLabel: 'Web address (URL)',
                    initValue: url,
                },
                displayText: {
                    labelKey: 'insertLinkDialogDisplayAs',
                    unlocalizedLabel: 'Display as',
                    initValue: displayText,
                },
            };
            (0, showInputDialog_1$2.default)(uiUtilities, 'insertLinkTitle', 'Insert link', items, strings, function (itemName, newValue, values) {
                if (itemName == 'url' && values.displayText == values.url) {
                    values.displayText = newValue;
                    values.url = newValue;
                    return values;
                }
                else {
                    return null;
                }
            }).then(function (result) {
                editor.focus();
                if (result &&
                    result.displayText &&
                    result.url &&
                    (result.displayText != displayText || result.url != url)) {
                    (0, roosterjs_editor_api_1$q.createLink)(editor, result.url, result.url, result.displayText);
                }
            });
        },
    };

    var insertTable = {};

    var __assign$9 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$9 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$9.apply(this, arguments);
    };
    Object.defineProperty(insertTable, "__esModule", { value: true });
    insertTable.insertTable = void 0;
    var React$8 = react.exports;
    var FocusZone_1$1 = require$$7;
    var roosterjs_editor_api_1$p = lib$1;
    var Styling_1$1 = require$$10;
    var roosterjs_editor_dom_1$J = lib$3;
    var MaxRows = 10;
    var MaxCols = 10;
    var classNames = (0, Styling_1$1.mergeStyleSets)({
        tableButton: {
            width: '15px',
            height: '15px',
            margin: '1px 1px 0 0',
            border: 'solid 1px #a19f9d',
            display: 'inline-block',
            cursor: 'pointer',
            backgroundColor: 'transparent',
        },
        hovered: {
            border: 'solid 1px #DB626C',
        },
        tablePane: {
            width: '160px',
            minWidth: 'auto',
            padding: '4px',
            boxSizing: 'content-box',
        },
        tablePaneInner: {
            lineHeight: '12px',
        },
        title: {
            margin: '5px 0',
        },
    });
    /**
     * @internal
     * "Insert table" button on the format ribbon
     */
    insertTable.insertTable = {
        key: 'buttonNameInsertTable',
        unlocalizedText: 'Insert table',
        iconName: 'Table',
        onClick: function (editor, key) {
            var _a = parseKey(key), row = _a.row, col = _a.col;
            (0, roosterjs_editor_api_1$p.insertTable)(editor, col, row);
        },
        dropDownMenu: {
            items: {
                insertTablePane: '{0} x {1} table',
            },
            itemRender: function (item, onClick) {
                return React$8.createElement(InsertTablePane, { item: item, onClick: onClick });
            },
            commandBarSubMenuProperties: {
                className: classNames.tablePane,
            },
        },
    };
    function InsertTablePane(props) {
        var _a;
        var item = props.item, onClick = props.onClick;
        var _b = React$8.useState(1), col = _b[0], setCol = _b[1];
        var _c = React$8.useState(1), row = _c[0], setRow = _c[1];
        var updateSize = React$8.useCallback(function (t) {
            var _a, _b;
            if ((0, roosterjs_editor_dom_1$J.safeInstanceOf)(t, 'HTMLElement')) {
                var col_1 = parseInt((_a = t.dataset.col) !== null && _a !== void 0 ? _a : '-1');
                var row_1 = parseInt((_b = t.dataset.row) !== null && _b !== void 0 ? _b : '-1');
                if (col_1 > 0 && col_1 <= MaxCols && row_1 > 0 && row_1 <= MaxRows) {
                    setCol(col_1);
                    setRow(row_1);
                }
            }
        }, [setCol, setRow]);
        var onMouseEnter = React$8.useCallback(function (e) {
            updateSize(e.target);
        }, [updateSize]);
        var onClickButton = React$8.useCallback(function (e) {
            onClick(e, __assign$9(__assign$9({}, item), { key: createKey(row, col) }));
        }, [row, col, onClick]);
        var ariaLabels = React$8.useMemo(function () {
            var _a;
            var result = [];
            for (var i = 1; i <= MaxCols; i++) {
                var col_2 = [];
                for (var j = 1; j <= MaxRows; j++) {
                    col_2[j] = formatText((_a = item.text) !== null && _a !== void 0 ? _a : '', i, j);
                }
                result[i] = col_2;
            }
            return result;
        }, [item.text]);
        var items = React$8.useMemo(function () {
            var items = [];
            for (var i = 1; i <= MaxRows; i++) {
                for (var j = 1; j <= MaxCols; j++) {
                    var key = "cell_" + i + "_" + j;
                    var isSelected = j <= col && i <= row;
                    items.push(React$8.createElement("button", { className: classNames.tableButton + ' ' + (isSelected ? classNames.hovered : ''), onClick: onClickButton, key: key, id: key, "data-col": j, "data-row": i, "data-is-focusable": true, onMouseEnter: onMouseEnter, "aria-label": ariaLabels[i][j] }));
                }
            }
            return items;
        }, [col, row]);
        var text = formatText((_a = item.text) !== null && _a !== void 0 ? _a : '', row, col);
        return (React$8.createElement("div", { className: classNames.tablePaneInner },
            React$8.createElement("div", { className: classNames.title }, text),
            React$8.createElement(FocusZone_1$1.FocusZone, { defaultActiveElement: "cell_1_1", direction: FocusZone_1$1.FocusZoneDirection.bidirectional, onActiveElementChanged: updateSize }, items)));
    }
    function formatText(text, row, col) {
        return text.replace('{0}', col.toString()).replace('{1}', row.toString());
    }
    function createKey(row, col) {
        return row + "," + col;
    }
    function parseKey(key) {
        var _a = key.split(','), row = _a[0], col = _a[1];
        return {
            row: parseInt(row),
            col: parseInt(col),
        };
    }

    var italic = {};

    Object.defineProperty(italic, "__esModule", { value: true });
    italic.italic = void 0;
    var roosterjs_editor_api_1$o = lib$1;
    /**
     * @internal
     * "Italic" button on the format ribbon
     */
    italic.italic = {
        key: 'buttonNameItalic',
        unlocalizedText: 'Italic',
        iconName: 'Italic',
        isChecked: function (formatState) { return !!formatState.isItalic; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$o.toggleItalic)(editor);
            return true;
        },
    };

    var ltr = {};

    Object.defineProperty(ltr, "__esModule", { value: true });
    ltr.ltr = void 0;
    var roosterjs_editor_api_1$n = lib$1;
    /**
     * @internal
     * "Left to right" button on the format ribbon
     */
    ltr.ltr = {
        key: 'buttonNameLtr',
        unlocalizedText: 'Left to right',
        iconName: 'BidiLtr',
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$n.setDirection)(editor, 0 /* LeftToRight */);
        },
    };

    var numberedList = {};

    Object.defineProperty(numberedList, "__esModule", { value: true });
    numberedList.numberedList = void 0;
    var roosterjs_editor_api_1$m = lib$1;
    /**
     * @internal
     * "Numbered list" button on the format ribbon
     */
    numberedList.numberedList = {
        key: 'buttonNameNumberedList',
        unlocalizedText: 'Numbered list',
        iconName: 'NumberedList',
        isChecked: function (formatState) { return !!formatState.isNumbering; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$m.toggleNumbering)(editor);
            return true;
        },
    };

    var quote = {};

    Object.defineProperty(quote, "__esModule", { value: true });
    quote.quote = void 0;
    var roosterjs_editor_api_1$l = lib$1;
    /**
     * @internal
     * "Quote" button on the format ribbon
     */
    quote.quote = {
        key: 'buttonNameQuote',
        unlocalizedText: 'Quote',
        iconName: 'RightDoubleQuote',
        isChecked: function (formatState) { return !!formatState.isBlockQuote; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$l.toggleBlockQuote)(editor);
            return true;
        },
    };

    var redo = {};

    Object.defineProperty(redo, "__esModule", { value: true });
    redo.redo = void 0;
    /**
     * @internal
     * "Redo" button on the format ribbon
     */
    redo.redo = {
        key: 'buttonNameRedo',
        unlocalizedText: 'Redo',
        iconName: 'Redo',
        isDisabled: function (formatState) { return !formatState.canRedo; },
        onClick: function (editor) {
            editor.redo();
            return true;
        },
    };

    var removeLink = {};

    Object.defineProperty(removeLink, "__esModule", { value: true });
    removeLink.removeLink = void 0;
    var roosterjs_editor_api_1$k = lib$1;
    /**
     * @internal
     * "Remove link" button on the format ribbon
     */
    removeLink.removeLink = {
        key: 'buttonNameRemoveLink',
        unlocalizedText: 'Remove link',
        iconName: 'RemoveLink',
        isDisabled: function (formatState) { return !formatState.canUnlink; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$k.removeLink)(editor);
        },
    };

    var rtl = {};

    Object.defineProperty(rtl, "__esModule", { value: true });
    rtl.rtl = void 0;
    var roosterjs_editor_api_1$j = lib$1;
    /**
     * @internal
     * "Right to left" button on the format ribbon
     */
    rtl.rtl = {
        key: 'buttonNameRtl',
        unlocalizedText: 'Right to left',
        iconName: 'BidiRtl',
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$j.setDirection)(editor, 1 /* RightToLeft */);
        },
    };

    var strikethrough = {};

    Object.defineProperty(strikethrough, "__esModule", { value: true });
    strikethrough.strikethrough = void 0;
    var roosterjs_editor_api_1$i = lib$1;
    /**
     * @internal
     * "Strikethrough" button on the format ribbon
     */
    strikethrough.strikethrough = {
        key: 'buttonNameStrikethrough',
        unlocalizedText: 'Strikethrough',
        iconName: 'Strikethrough',
        isChecked: function (formatState) { return !!formatState.isStrikeThrough; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$i.toggleStrikethrough)(editor);
            return true;
        },
    };

    var subscript = {};

    Object.defineProperty(subscript, "__esModule", { value: true });
    subscript.subscript = void 0;
    var roosterjs_editor_api_1$h = lib$1;
    /**
     * @internal
     * "Subscript" button on the format ribbon
     */
    subscript.subscript = {
        key: 'buttonNameSubscript',
        unlocalizedText: 'Subscript',
        iconName: 'Subscript',
        isChecked: function (formatState) { return !!formatState.isSubscript; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$h.toggleSubscript)(editor);
            return true;
        },
    };

    var superscript = {};

    Object.defineProperty(superscript, "__esModule", { value: true });
    superscript.superscript = void 0;
    var roosterjs_editor_api_1$g = lib$1;
    /**
     * @internal
     * "Superscript" button on the format ribbon
     */
    superscript.superscript = {
        key: 'buttonNameSuperscript',
        unlocalizedText: 'Superscript',
        iconName: 'Superscript',
        isChecked: function (formatState) { return !!formatState.isSuperscript; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$g.toggleSuperscript)(editor);
            return true;
        },
    };

    var textColor = {};

    var textColors = {};

    Object.defineProperty(textColors, "__esModule", { value: true });
    textColors.getTextColorValue = textColors.TextColorDropDownItems = textColors.TextColors = void 0;
    /**
     * @internal
     */
    var TextColors = {
        textColorLightBlue: { lightModeColor: '#51a7f9', darkModeColor: '#0075c2' },
        textColorLightGreen: { lightModeColor: '#6fc040', darkModeColor: '#207a00' },
        textColorLightYellow: { lightModeColor: '#f5d427', darkModeColor: '#5d4d00' },
        textColorLightOrange: { lightModeColor: '#f3901d', darkModeColor: '#ab5500' },
        textColorLightRed: { lightModeColor: '#ed5c57', darkModeColor: '#df504d' },
        textColorLightPurple: { lightModeColor: '#b36ae2', darkModeColor: '#ab63da' },
        textColorBlue: { lightModeColor: '#0c64c0', darkModeColor: '#6da0ff' },
        textColorGreen: { lightModeColor: '#0c882a', darkModeColor: '#3da848' },
        textColorYellow: { lightModeColor: '#dcbe22', darkModeColor: '#6d5c00' },
        textColorOrange: { lightModeColor: '#de6a19', darkModeColor: '#d3610c' },
        textColorRed: { lightModeColor: '#c82613', darkModeColor: '#ff6847' },
        textColorPurple: { lightModeColor: '#763e9b', darkModeColor: '#d394f9' },
        textColorDarkBlue: { lightModeColor: '#174e86', darkModeColor: '#93b8f9' },
        textColorDarkGreen: { lightModeColor: '#0f5c1a', darkModeColor: '#7fc57b' },
        textColorDarkYellow: { lightModeColor: '#c3971d', darkModeColor: '#946f00' },
        textColorDarkOrange: { lightModeColor: '#be5b17', darkModeColor: '#de7633' },
        textColorDarkRed: { lightModeColor: '#861106', darkModeColor: '#ff9b7c' },
        textColorDarkPurple: { lightModeColor: '#5e327c', darkModeColor: '#dea9fd' },
        textColorDarkerBlue: { lightModeColor: '#002451', darkModeColor: '#cedbff' },
        textColorDarkerGreen: { lightModeColor: '#06400c', darkModeColor: '#a3da9b' },
        textColorDarkerYellow: { lightModeColor: '#a37519', darkModeColor: '#b5852a' },
        textColorDarkerOrange: { lightModeColor: '#934511', darkModeColor: '#ef935c' },
        textColorDarkerRed: { lightModeColor: '#570606', darkModeColor: '#ffc0b1' },
        textColorDarkerPurple: { lightModeColor: '#3b204d', darkModeColor: '#eecaff' },
        textColorWhite: { lightModeColor: '#ffffff', darkModeColor: '#333333' },
        textColorLightGray: { lightModeColor: '#cccccc', darkModeColor: '#535353' },
        textColorGray: { lightModeColor: '#999999', darkModeColor: '#777777' },
        textColorDarkGray: { lightModeColor: '#666666', darkModeColor: '#a0a0a0' },
        textColorDarkerGray: { lightModeColor: '#333333', darkModeColor: '#cfcfcf' },
        textColorBlack: { lightModeColor: '#000000', darkModeColor: '#ffffff' },
    };
    textColors.TextColors = TextColors;
    /**
     * @internal
     */
    var TextColorDropDownItems = {
        textColorLightBlue: 'Light blue',
        textColorLightGreen: 'Light green',
        textColorLightYellow: 'Light yellow',
        textColorLightOrange: 'Light orange',
        textColorLightRed: 'Light red',
        textColorLightPurple: 'Light purple',
        textColorBlue: 'Blue',
        textColorGreen: 'Green',
        textColorYellow: 'Yellow',
        textColorOrange: 'Orange',
        textColorRed: 'Red',
        textColorPurple: 'Purple',
        textColorDarkBlue: 'Dark blue',
        textColorDarkGreen: 'Dark green',
        textColorDarkYellow: 'Dark yellow',
        textColorDarkOrange: 'Dark orange',
        textColorDarkRed: 'Dark red',
        textColorDarkPurple: 'Dark purple',
        textColorDarkerBlue: 'Darker blue',
        textColorDarkerGreen: 'Darker green',
        textColorDarkerYellow: 'Darker yellow',
        textColorDarkerOrange: 'Darker orange',
        textColorDarkerRed: 'Darker red',
        textColorDarkerPurple: 'Darker purple',
        textColorWhite: 'White',
        textColorLightGray: 'Light gray',
        textColorGray: 'Gray',
        textColorDarkGray: 'Dark gray',
        textColorDarkerGray: 'Darker gray',
        textColorBlack: 'Black',
    };
    textColors.TextColorDropDownItems = TextColorDropDownItems;
    /**
     * Get mode independent color value of text color from the given color key
     * @param key The key to get color from
     * @returns A model independent color value of the given key
     */
    function getTextColorValue(key) {
        return TextColors[key];
    }
    textColors.getTextColorValue = getTextColorValue;

    Object.defineProperty(textColor, "__esModule", { value: true });
    textColor.textColor = void 0;
    var renderColorPicker_1$1 = renderColorPicker$1;
    var roosterjs_editor_api_1$f = lib$1;
    var textColors_1 = textColors;
    var getClassNamesForColorPicker_1$1 = getClassNamesForColorPicker;
    var Key = 'buttonNameTextColor';
    /**
     * @internal
     * "Text color" button on the format ribbon
     */
    textColor.textColor = {
        dropDownMenu: {
            items: textColors_1.TextColorDropDownItems,
            itemClassName: (0, getClassNamesForColorPicker_1$1.getColorPickerItemClassName)(),
            allowLivePreview: true,
            itemRender: function (item, onClick) { return (0, renderColorPicker_1$1.renderColorPicker)(item, textColors_1.TextColors, onClick); },
            commandBarSubMenuProperties: {
                className: (0, getClassNamesForColorPicker_1$1.getColorPickerContainerClassName)(),
            },
        },
        key: Key,
        unlocalizedText: 'Text color',
        iconName: 'FontColor',
        onClick: function (editor, key) {
            // This check will always be true, add it here just to satisfy compiler
            if (key != Key) {
                (0, roosterjs_editor_api_1$f.setTextColor)(editor, (0, textColors_1.getTextColorValue)(key));
            }
        },
    };

    var underline = {};

    Object.defineProperty(underline, "__esModule", { value: true });
    underline.underline = void 0;
    var roosterjs_editor_api_1$e = lib$1;
    /**
     * @internal
     * "Underline" button on the format ribbon
     */
    underline.underline = {
        key: 'buttonNameUnderline',
        unlocalizedText: 'Underline',
        iconName: 'Underline',
        isChecked: function (formatState) { return !!formatState.isUnderline; },
        onClick: function (editor) {
            (0, roosterjs_editor_api_1$e.toggleUnderline)(editor);
            return true;
        },
    };

    var undo = {};

    Object.defineProperty(undo, "__esModule", { value: true });
    undo.undo = void 0;
    /**
     * @internal
     * "Undo" button on the format ribbon
     */
    undo.undo = {
        key: 'buttonNameUndo',
        unlocalizedText: 'Undo',
        iconName: 'undo',
        isDisabled: function (formatState) { return !formatState.canUndo; },
        onClick: function (editor) {
            editor.undo();
            return true;
        },
    };

    (function (exports) {
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AllButtonKeys = void 0;
    var alignCenter_1 = alignCenter;
    var alignLeft_1 = alignLeft;
    var alignRight_1 = alignRight;
    var backgroundColor_1 = backgroundColor;
    var bold_1 = bold;
    var bulletedList_1 = bulletedList;
    var clearFormat_1 = clearFormat;
    var code_1 = code;
    var decreaseFontSize_1 = decreaseFontSize;
    var decreaseIndent_1 = decreaseIndent;
    var font_1 = font;
    var fontSize_1 = fontSize;
    var header_1 = header;
    var increaseFontSize_1 = increaseFontSize;
    var increaseIndent_1 = increaseIndent;
    var insertImage_1 = insertImage;
    var insertLink_1 = insertLink;
    var insertTable_1 = insertTable;
    var italic_1 = italic;
    var KnownRibbonButton_1 = KnownRibbonButton;
    var ltr_1 = ltr;
    var numberedList_1 = numberedList;
    var quote_1 = quote;
    var redo_1 = redo;
    var removeLink_1 = removeLink;
    var rtl_1 = rtl;
    var strikethrough_1 = strikethrough;
    var subscript_1 = subscript;
    var superscript_1 = superscript;
    var textColor_1 = textColor;
    var underline_1 = underline;
    var undo_1 = undo;
    var KnownRibbonButtons = (_a = {},
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Bold] = bold_1.bold,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Italic] = italic_1.italic,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Underline] = underline_1.underline,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Font] = font_1.font,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.FontSize] = fontSize_1.fontSize,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.IncreaseFontSize] = increaseFontSize_1.increaseFontSize,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.DecreaseFontSize] = decreaseFontSize_1.decreaseFontSize,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.TextColor] = textColor_1.textColor,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.BackgroundColor] = backgroundColor_1.backgroundColor,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.BulletedList] = bulletedList_1.bulletedList,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.NumberedList] = numberedList_1.numberedList,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.DecreaseIndent] = decreaseIndent_1.decreaseIndent,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.IncreaseIndent] = increaseIndent_1.increaseIndent,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Quote] = quote_1.quote,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.AlignLeft] = alignLeft_1.alignLeft,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.AlignCenter] = alignCenter_1.alignCenter,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.AlignRight] = alignRight_1.alignRight,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.InsertLink] = insertLink_1.insertLink,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.RemoveLink] = removeLink_1.removeLink,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.InsertTable] = insertTable_1.insertTable,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.InsertImage] = insertImage_1.insertImage,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Superscript] = superscript_1.superscript,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Subscript] = subscript_1.subscript,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Strikethrough] = strikethrough_1.strikethrough,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Header] = header_1.header,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Code] = code_1.code,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Ltr] = ltr_1.ltr,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Rtl] = rtl_1.rtl,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Undo] = undo_1.undo,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.Redo] = redo_1.redo,
        _a[KnownRibbonButton_1.KnownRibbonButtonKey.ClearFormat] = clearFormat_1.clearFormat,
        _a);
    /**
     * An array of keys of all known ribbon buttons
     */
    exports.AllButtonKeys = [
        KnownRibbonButton_1.KnownRibbonButtonKey.Bold,
        KnownRibbonButton_1.KnownRibbonButtonKey.Italic,
        KnownRibbonButton_1.KnownRibbonButtonKey.Underline,
        KnownRibbonButton_1.KnownRibbonButtonKey.Font,
        KnownRibbonButton_1.KnownRibbonButtonKey.FontSize,
        KnownRibbonButton_1.KnownRibbonButtonKey.IncreaseFontSize,
        KnownRibbonButton_1.KnownRibbonButtonKey.DecreaseFontSize,
        KnownRibbonButton_1.KnownRibbonButtonKey.TextColor,
        KnownRibbonButton_1.KnownRibbonButtonKey.BackgroundColor,
        KnownRibbonButton_1.KnownRibbonButtonKey.BulletedList,
        KnownRibbonButton_1.KnownRibbonButtonKey.NumberedList,
        KnownRibbonButton_1.KnownRibbonButtonKey.DecreaseIndent,
        KnownRibbonButton_1.KnownRibbonButtonKey.IncreaseIndent,
        KnownRibbonButton_1.KnownRibbonButtonKey.Quote,
        KnownRibbonButton_1.KnownRibbonButtonKey.AlignLeft,
        KnownRibbonButton_1.KnownRibbonButtonKey.AlignCenter,
        KnownRibbonButton_1.KnownRibbonButtonKey.AlignRight,
        KnownRibbonButton_1.KnownRibbonButtonKey.InsertLink,
        KnownRibbonButton_1.KnownRibbonButtonKey.RemoveLink,
        KnownRibbonButton_1.KnownRibbonButtonKey.InsertTable,
        KnownRibbonButton_1.KnownRibbonButtonKey.InsertImage,
        KnownRibbonButton_1.KnownRibbonButtonKey.Superscript,
        KnownRibbonButton_1.KnownRibbonButtonKey.Subscript,
        KnownRibbonButton_1.KnownRibbonButtonKey.Strikethrough,
        KnownRibbonButton_1.KnownRibbonButtonKey.Header,
        KnownRibbonButton_1.KnownRibbonButtonKey.Code,
        KnownRibbonButton_1.KnownRibbonButtonKey.Ltr,
        KnownRibbonButton_1.KnownRibbonButtonKey.Rtl,
        KnownRibbonButton_1.KnownRibbonButtonKey.Undo,
        KnownRibbonButton_1.KnownRibbonButtonKey.Redo,
        KnownRibbonButton_1.KnownRibbonButtonKey.ClearFormat,
    ];
    /**
     * A shortcut to get all format buttons provided by roosterjs-react
     * @param keyOrButtons An array of buttons or known button key. Default value is all known buttons provided by roosterjs-react
     * @returns An array of all buttons
     */
    function getButtons(keyOrButtons) {
        if (keyOrButtons === void 0) { keyOrButtons = exports.AllButtonKeys; }
        return keyOrButtons.map(function (keyOrButton) {
            return typeof keyOrButton == 'number' ? KnownRibbonButtons[keyOrButton] : keyOrButton;
        });
    }
    exports.default = getButtons;

    }(getButtons));

    var createRibbonPlugin$1 = {};

    Object.defineProperty(createRibbonPlugin$1, "__esModule", { value: true });
    var roosterjs_editor_api_1$d = lib$1;
    var roosterjs_editor_dom_1$I = lib$3;
    /**
     * A plugin to connect format ribbon component and the editor
     */
    var RibbonPluginImpl = /** @class */ (function () {
        /**
         * Construct a new instance of RibbonPlugin object
         * @param delayUpdateTime The time to wait before refresh the button when user do some editing operation in editor
         */
        function RibbonPluginImpl(delayUpdateTime) {
            if (delayUpdateTime === void 0) { delayUpdateTime = 200; }
            this.delayUpdateTime = delayUpdateTime;
            this.editor = null;
            this.onFormatChanged = null;
            this.timer = 0;
            this.formatState = null;
            this.uiUtilities = null;
        }
        /**
         * Get a friendly name of this plugin
         */
        RibbonPluginImpl.prototype.getName = function () {
            return 'Ribbon';
        };
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        RibbonPluginImpl.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        RibbonPluginImpl.prototype.dispose = function () {
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        RibbonPluginImpl.prototype.onPluginEvent = function (event) {
            switch (event.eventType) {
                case 11 /* EditorReady */:
                case 7 /* ContentChanged */:
                case 21 /* ZoomChanged */:
                    this.updateFormat();
                    break;
                case 0 /* KeyDown */:
                case 6 /* MouseUp */:
                    this.delayUpdate();
                    break;
            }
        };
        /**
         * Set the UI utilities objects to this plugin to help render additional UI elements
         * @param uiUtilities The UI utilities object to set
         */
        RibbonPluginImpl.prototype.setUIUtilities = function (uiUtilities) {
            this.uiUtilities = uiUtilities;
        };
        /**
         * Register a callback to be invoked when format state of editor is changed, returns a disposer function.
         */
        RibbonPluginImpl.prototype.registerFormatChangedCallback = function (callback) {
            var _this = this;
            this.onFormatChanged = callback;
            return function () {
                _this.onFormatChanged = null;
            };
        };
        /**
         * When user clicks on a button, call this method to let the plugin to handle this click event
         * @param button The button that is clicked
         * @param key Key of child menu item that is clicked if any
         * @param strings The localized string map for this button
         */
        RibbonPluginImpl.prototype.onButtonClick = function (button, key, strings) {
            var _a;
            if (this.editor && this.uiUtilities) {
                this.editor.stopShadowEdit();
                button.onClick(this.editor, key, strings, this.uiUtilities);
                if (button.isChecked || button.isDisabled || ((_a = button.dropDownMenu) === null || _a === void 0 ? void 0 : _a.getSelectedItemKey)) {
                    this.updateFormat();
                }
            }
        };
        /**
         * Enter live preview state (shadow edit) of editor if there is a non-collapsed selection
         * @param button The button that triggered this action
         * @param key Key of the hovered button sub item
         * @param strings The localized string map for this button
         */
        RibbonPluginImpl.prototype.startLivePreview = function (button, key, strings) {
            if (this.editor && this.uiUtilities) {
                var isInShadowEdit = this.editor.isInShadowEdit();
                // If editor is already in shadow edit, no need to check again.
                // And the check result may be incorrect because the content is changed from last shadow edit and the cached selection path won't apply
                var range = !isInShadowEdit && this.editor.getSelectionRangeEx();
                if (isInShadowEdit || (range && !range.areAllCollapsed)) {
                    this.editor.startShadowEdit();
                    button.onClick(this.editor, key, strings, this.uiUtilities);
                }
            }
        };
        /**
         * Leave live preview state (shadow edit) of editor
         */
        RibbonPluginImpl.prototype.stopLivePreview = function () {
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.stopShadowEdit();
        };
        RibbonPluginImpl.prototype.delayUpdate = function () {
            var _this = this;
            var _a;
            var window = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getDocument().defaultView;
            if (!window) {
                return;
            }
            if (this.timer) {
                window.clearTimeout(this.timer);
            }
            this.timer = window.setTimeout(function () {
                var _a;
                _this.timer = 0;
                (_a = _this.updateFormat) === null || _a === void 0 ? void 0 : _a.call(_this);
            }, this.delayUpdateTime);
        };
        RibbonPluginImpl.prototype.updateFormat = function () {
            var _this = this;
            if (this.editor && this.onFormatChanged) {
                var newFormatState_1 = (0, roosterjs_editor_api_1$d.getFormatState)(this.editor);
                if (!this.formatState ||
                    (0, roosterjs_editor_dom_1$I.getObjectKeys)(newFormatState_1).some(function (key) { var _a; return newFormatState_1[key] != ((_a = _this.formatState) === null || _a === void 0 ? void 0 : _a[key]); })) {
                    this.formatState = newFormatState_1;
                    this.onFormatChanged(newFormatState_1);
                }
            }
        };
        return RibbonPluginImpl;
    }());
    /**
     * Create a new instance of RibbonPlugin object
     * @param delayUpdateTime The time to wait before refresh the button when user do some editing operation in editor
     */
    function createRibbonPlugin(delayUpdateTime) {
        return new RibbonPluginImpl(delayUpdateTime);
    }
    createRibbonPlugin$1.default = createRibbonPlugin;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRibbonPlugin = exports.AllButtonKeys = exports.getButtons = exports.Ribbon = exports.KnownRibbonButtonKey = void 0;
    var KnownRibbonButton_1 = KnownRibbonButton;
    Object.defineProperty(exports, "KnownRibbonButtonKey", { enumerable: true, get: function () { return KnownRibbonButton_1.KnownRibbonButtonKey; } });
    var Ribbon_1 = Ribbon$1;
    Object.defineProperty(exports, "Ribbon", { enumerable: true, get: function () { return Ribbon_1.default; } });
    var getButtons_1 = getButtons;
    Object.defineProperty(exports, "getButtons", { enumerable: true, get: function () { return getButtons_1.default; } });
    Object.defineProperty(exports, "AllButtonKeys", { enumerable: true, get: function () { return getButtons_1.AllButtonKeys; } });
    var createRibbonPlugin_1 = createRibbonPlugin$1;
    Object.defineProperty(exports, "createRibbonPlugin", { enumerable: true, get: function () { return createRibbonPlugin_1.default; } });

    }(ribbon));

    var contextMenu = {};

    var createContextMenuPlugin$1 = {};

    var lib = {};

    var ContentEdit$3 = {};

    var ContentEdit$2 = {};

    var ContentEdit$1 = {};

    var getAllFeatures$1 = {};

    var autoLinkFeatures = {};

    Object.defineProperty(autoLinkFeatures, "__esModule", { value: true });
    autoLinkFeatures.AutoLinkFeatures = void 0;
    var roosterjs_editor_api_1$c = lib$1;
    var roosterjs_editor_dom_1$H = lib$3;
    /**
     * When user type, they may end a link with a punctuation, i.e. www.bing.com;
     * we need to trim off the trailing punctuation before turning it to link match
     */
    var TRAILING_PUNCTUATION_REGEX = /[.+=\s:;"',>]+$/i;
    var MINIMUM_LENGTH = 5;
    /**
     * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted
     * in hyperlink format into a real hyperlink
     */
    var AutoLink = {
        keys: [13 /* ENTER */, 32 /* SPACE */, 257 /* CONTENTCHANGED */],
        shouldHandleEvent: cacheGetLinkData,
        handleEvent: autoLink,
    };
    /**
     * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text
     * if user presses BACKSPACE right after a hyperlink
     */
    var UnlinkWhenBackspaceAfterLink = {
        keys: [8 /* BACKSPACE */],
        shouldHandleEvent: hasLinkBeforeCursor,
        handleEvent: function (event, editor) {
            event.rawEvent.preventDefault();
            (0, roosterjs_editor_api_1$c.removeLink)(editor);
        },
        defaultDisabled: true,
    };
    function cacheGetLinkData(event, editor) {
        return event.eventType == 0 /* KeyDown */ ||
            (event.eventType == 7 /* ContentChanged */ && event.source == "Paste" /* Paste */)
            ? (0, roosterjs_editor_dom_1$H.cacheGetEventData)(event, 'LINK_DATA', function () {
                // First try to match link from the whole paste string from the plain text in clipboard.
                // This helps when we paste a link next to some existing character, and the text we got
                // from clipboard will only contain what we pasted, any existing characters will not
                // be included.
                var clipboardData = event.eventType == 7 /* ContentChanged */ &&
                    event.source == "Paste" /* Paste */ &&
                    event.data;
                var link = (0, roosterjs_editor_dom_1$H.matchLink)((clipboardData.text || '').trim());
                var searcher = editor.getContentSearcherOfCursor(event);
                // In case the matched link is already inside a <A> tag, we do a range search.
                // getRangeFromText will return null if the given text is already in a LinkInlineElement
                if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {
                    return link;
                }
                var word = searcher && searcher.getWordBefore();
                if (word && word.length > MINIMUM_LENGTH) {
                    // Check for trailing punctuation
                    var trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);
                    var trailingPunctuation = (trailingPunctuations || [])[0] || '';
                    var candidate_1 = word.substring(0, word.length - trailingPunctuation.length);
                    // Do special handling for ')', '}', ']'
                    ['()', '{}', '[]'].forEach(function (str) {
                        if (candidate_1[candidate_1.length - 1] == str[1] &&
                            candidate_1.indexOf(str[0]) < 0) {
                            candidate_1 = candidate_1.substr(0, candidate_1.length - 1);
                        }
                    });
                    // Match and replace in editor
                    return (0, roosterjs_editor_dom_1$H.matchLink)(candidate_1);
                }
                return null;
            })
            : null;
    }
    function hasLinkBeforeCursor(event, editor) {
        var contentSearcher = editor.getContentSearcherOfCursor(event);
        var inline = contentSearcher.getInlineElementBefore();
        return inline instanceof roosterjs_editor_dom_1$H.LinkInlineElement;
    }
    function autoLink(event, editor) {
        var anchor = editor.getDocument().createElement('a');
        var linkData = cacheGetLinkData(event, editor);
        // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line
        // and at that time a new searcher won't be able to find the link text to replace
        var searcher = editor.getContentSearcherOfCursor();
        anchor.textContent = linkData.originalUrl;
        anchor.href = linkData.normalizedUrl;
        editor.runAsync(function (editor) {
            editor.addUndoSnapshot(function () {
                (0, roosterjs_editor_api_1$c.replaceWithNode)(editor, linkData.originalUrl, anchor, false /* exactMatch */, searcher);
                // The content at cursor has changed. Should also clear the cursor data cache
                (0, roosterjs_editor_dom_1$H.clearEventDataCache)(event);
                return anchor;
            }, "AutoLink" /* AutoLink */, true /*canUndoByBackspace*/);
        });
    }
    /**
     * @internal
     */
    autoLinkFeatures.AutoLinkFeatures = {
        autoLink: AutoLink,
        unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,
    };

    var cursorFeatures = {};

    Object.defineProperty(cursorFeatures, "__esModule", { value: true });
    cursorFeatures.CursorFeatures = void 0;
    var roosterjs_editor_dom_1$G = lib$3;
    var NoCycleCursorMove = {
        keys: [37 /* LEFT */, 39 /* RIGHT */],
        allowFunctionKeys: true,
        shouldHandleEvent: function (event, editor, ctrlOrMeta) {
            var range;
            var position;
            if (!ctrlOrMeta ||
                !(range = editor.getSelectionRange()) ||
                !range.collapsed ||
                !(position = roosterjs_editor_dom_1$G.Position.getStart(range)) ||
                !editor.isPositionAtBeginning(position)) {
                return false;
            }
            var rtl = (0, roosterjs_editor_dom_1$G.getComputedStyle)(position.element, 'direction') == 'rtl';
            var rawEvent = event.rawEvent;
            return (!rtl && rawEvent.which == 37 /* LEFT */) || (rtl && rawEvent.which == 39 /* RIGHT */);
        },
        handleEvent: function (event) {
            event.rawEvent.preventDefault();
        },
        defaultDisabled: !roosterjs_editor_dom_1$G.Browser.isChrome,
    };
    /**
     * @internal
     */
    cursorFeatures.CursorFeatures = {
        noCycleCursorMove: NoCycleCursorMove,
    };

    var entityFeatures = {};

    Object.defineProperty(entityFeatures, "__esModule", { value: true });
    entityFeatures.EntityFeatures = void 0;
    var roosterjs_editor_dom_1$F = lib$3;
    var roosterjs_editor_dom_2 = lib$3;
    /**
     * A content edit feature to trigger EntityOperation event with operation "Click" when user
     * clicks on a readonly entity.
     */
    var ClickOnEntityFeature = {
        keys: [13 /* ENTER */],
        shouldHandleEvent: function (event, editor) { return cacheGetReadonlyEntityElement(event, editor); },
        handleEvent: function (event, editor) {
            cacheGetReadonlyEntityElement(event, editor, 1 /* Click */);
        },
    };
    /**
     * A content edit feature to trigger EntityOperation event with operation "Escape" when user
     * presses ESC on a readonly entity.
     */
    var EscapeFromEntityFeature = {
        keys: [27 /* ESCAPE */],
        shouldHandleEvent: function (event, editor) { return cacheGetReadonlyEntityElement(event, editor); },
        handleEvent: function (event, editor) {
            cacheGetReadonlyEntityElement(event, editor, 3 /* Escape */);
        },
    };
    function cacheGetReadonlyEntityElement(event, editor, operation) {
        var element = (0, roosterjs_editor_dom_2.cacheGetEventData)(event, 'READONLY_ENTITY_ELEMENT', function () {
            var node = event.rawEvent.target;
            var entityElement = node && editor.getElementAtCursor((0, roosterjs_editor_dom_2.getEntitySelector)(), node);
            return entityElement && !entityElement.isContentEditable ? entityElement : null;
        });
        if (element && operation !== undefined) {
            var entity = (0, roosterjs_editor_dom_2.getEntityFromElement)(element);
            if (entity) {
                editor.triggerPluginEvent(15 /* EntityOperation */, {
                    operation: operation,
                    rawEvent: event.rawEvent,
                    entity: entity,
                });
            }
        }
        return element;
    }
    /**
     * A content edit feature to split current line into two lines at the cursor when user presses
     * ENTER right before a readonly entity.
     * Browser's default behavior will insert an extra BR tag before the entity which causes an extra
     * empty line. So we override the default behavior here.
     */
    var EnterBeforeReadonlyEntityFeature = {
        keys: [13 /* ENTER */],
        shouldHandleEvent: function (event, editor) {
            return cacheGetNeighborEntityElement(event, editor, true /*isNext*/, false /*collapseOnly*/);
        },
        handleEvent: function (event, editor) {
            var _a, _b, _c;
            event.rawEvent.preventDefault();
            var range = editor.getSelectionRange();
            if (!range) {
                return;
            }
            var node = roosterjs_editor_dom_2.Position.getEnd(range).normalize().node;
            var br = editor.getDocument().createElement('BR');
            (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(br, node.nextSibling);
            var block = editor.getBlockElementAtNode(node);
            var newContainer;
            if (block) {
                newContainer = block.collapseToSingleElement();
                (_b = br.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(br);
            }
            (_c = editor.getSelectionRange()) === null || _c === void 0 ? void 0 : _c.deleteContents();
            if (newContainer === null || newContainer === void 0 ? void 0 : newContainer.nextSibling) {
                editor.select(newContainer.nextSibling, 0 /* Begin */);
            }
        },
    };
    /**
     * A content edit feature to trigger EntityOperation event with operation "RemoveFromEnd" when user
     * press BACKSPACE right after an entity
     */
    var BackspaceAfterEntityFeature = {
        keys: [8 /* BACKSPACE */],
        shouldHandleEvent: function (event, editor) {
            return cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/);
        },
        handleEvent: function (event, editor) {
            cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/, 5 /* RemoveFromEnd */);
        },
    };
    /**
     * A content edit feature to trigger EntityOperation event with operation "RemoveFromStart" when user
     * press DELETE right after an entity
     */
    var DeleteBeforeEntityFeature = {
        keys: [46 /* DELETE */],
        shouldHandleEvent: function (event, editor) {
            return cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/);
        },
        handleEvent: function (event, editor) {
            cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/, 4 /* RemoveFromStart */);
        },
    };
    function cacheGetNeighborEntityElement(event, editor, isNext, collapseOnly, operation) {
        var element = (0, roosterjs_editor_dom_2.cacheGetEventData)(event, 'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly, function () {
            var range = editor.getSelectionRange();
            if (!range || (collapseOnly && !range.collapsed)) {
                return null;
            }
            range.commonAncestorContainer.normalize();
            var pos = roosterjs_editor_dom_2.Position.getEnd(range).normalize();
            var isAtBeginOrEnd = pos.offset == 0 || pos.isAtEnd;
            var entityNode = null;
            if (isAtBeginOrEnd) {
                var traverser = editor.getBodyTraverser(pos.node);
                var sibling = isNext
                    ? pos.offset == 0
                        ? traverser.currentInlineElement
                        : traverser.getNextInlineElement()
                    : pos.isAtEnd
                        ? traverser.currentInlineElement
                        : traverser.getPreviousInlineElement();
                var node = sibling && sibling.getContainerNode();
                if (!collapseOnly) {
                    var block = editor.getBlockElementAtNode(pos.node);
                    if (!block || (node && !block.contains(node))) {
                        node = null;
                    }
                }
                entityNode = node && editor.getElementAtCursor((0, roosterjs_editor_dom_2.getEntitySelector)(), node);
            }
            return entityNode;
        });
        if (element && operation !== undefined) {
            var entity = (0, roosterjs_editor_dom_2.getEntityFromElement)(element);
            if (entity) {
                triggerOperation(entity, editor, operation, event);
            }
        }
        return element;
    }
    /**
     * @requires ExperimentalFeatures.InlineEntityReadOnlyDelimiters to be enabled
     * Content edit feature to move the cursor from Delimiters around Entities when using Right or Left Arrow Keys
     */
    var MoveBetweenDelimitersFeature = {
        keys: [39 /* RIGHT */, 37 /* LEFT */],
        allowFunctionKeys: true,
        shouldHandleEvent: function (event, editor) {
            if (event.rawEvent.altKey ||
                !editor.isFeatureEnabled("InlineEntityReadOnlyDelimiters" /* InlineEntityReadOnlyDelimiters */)) {
                return false;
            }
            var element = editor.getElementAtCursor();
            if (!element) {
                return false;
            }
            var isRTL = (0, roosterjs_editor_dom_2.getComputedStyle)(element, 'direction') === 'rtl';
            var shouldCheckBefore = isRTL == (event.rawEvent.which === 37 /* LEFT */);
            return getIsDelimiterAtCursor(event, editor, shouldCheckBefore);
        },
        handleEvent: function (event, editor) {
            var checkBefore = cacheGetCheckBefore(event);
            var delimiter = cacheDelimiter(event, checkBefore);
            if (!delimiter) {
                return;
            }
            var _a = getRelatedElements(delimiter, checkBefore, editor), delimiterPair = _a.delimiterPair, entity = _a.entity;
            if (delimiterPair && entity && (0, roosterjs_editor_dom_2.matchesSelector)(entity, (0, roosterjs_editor_dom_2.getEntitySelector)())) {
                event.rawEvent.preventDefault();
                editor.runAsync(function () {
                    var positionType = checkBefore
                        ? event.rawEvent.shiftKey
                            ? -3 /* After */
                            : -1 /* End */
                        : -2 /* Before */;
                    var position = new roosterjs_editor_dom_2.Position(delimiterPair, positionType);
                    if (event.rawEvent.shiftKey) {
                        var selection = delimiterPair.ownerDocument.getSelection();
                        selection === null || selection === void 0 ? void 0 : selection.extend(position.node, position.offset);
                    }
                    else {
                        editor.select(position);
                    }
                });
            }
        },
    };
    /**
     * @requires ExperimentalFeatures.InlineEntityReadOnlyDelimiters to be enabled
     * Content edit Feature to trigger a Delete Entity Operation when one of the Delimiter is about to be removed with DELETE or Backspace
     */
    var RemoveEntityBetweenDelimitersFeature = {
        keys: [8 /* BACKSPACE */, 46 /* DELETE */],
        shouldHandleEvent: function (event, editor) {
            if (!editor.isFeatureEnabled("InlineEntityReadOnlyDelimiters" /* InlineEntityReadOnlyDelimiters */)) {
                return false;
            }
            var range = editor.getSelectionRange();
            if (!(range === null || range === void 0 ? void 0 : range.collapsed)) {
                return false;
            }
            var checkBefore = event.rawEvent.which === 46 /* DELETE */;
            var isDelimiter = getIsDelimiterAtCursor(event, editor, checkBefore);
            if (isDelimiter) {
                var delimiter = cacheDelimiter(event, checkBefore);
                var entityElement = checkBefore
                    ? delimiter === null || delimiter === void 0 ? void 0 : delimiter.nextElementSibling
                    : delimiter === null || delimiter === void 0 ? void 0 : delimiter.previousElementSibling;
                return !!cacheEntityBetweenDelimiter(event, editor, checkBefore, entityElement);
            }
            return false;
        },
        handleEvent: function (event, editor) {
            var checkBefore = event.rawEvent.which === 46 /* DELETE */;
            cacheEntityBetweenDelimiter(event, editor, checkBefore, null, checkBefore ? 4 /* RemoveFromStart */ : 5 /* RemoveFromEnd */);
        },
    };
    function getIsDelimiterAtCursor(event, editor, checkBefore) {
        var _a;
        var position = (_a = editor.getFocusedPosition()) === null || _a === void 0 ? void 0 : _a.normalize();
        cacheGetCheckBefore(event, checkBefore);
        if (!position) {
            return false;
        }
        var focusedElement = position.node.nodeType == 3 /* Text */
            ? position.node
            : position.node == position.element
                ? position.element.childNodes.item(position.offset)
                : position.element;
        var data = checkBefore
            ? {
                class: "entityDelimiterBefore" /* DELIMITER_BEFORE */,
                pairClass: "entityDelimiterAfter" /* DELIMITER_AFTER */,
                isAtEndOrBeginning: position.isAtEnd,
            }
            : {
                class: "entityDelimiterAfter" /* DELIMITER_AFTER */,
                pairClass: "entityDelimiterBefore" /* DELIMITER_BEFORE */,
                isAtEndOrBeginning: position.offset == 0,
            };
        var sibling = getNextSibling(editor, focusedElement, checkBefore);
        if (data.isAtEndOrBeginning && sibling) {
            var elAtCursor = editor.getElementAtCursor('.' + data.class, sibling);
            if (elAtCursor && !!shouldHandle(elAtCursor)) {
                return true;
            }
        }
        var entityAtCursor = focusedElement && editor.getElementAtCursor('.' + data.class, focusedElement);
        return !!shouldHandle(entityAtCursor);
        function shouldHandle(element) {
            if (!element) {
                return false;
            }
            var delimiterPair = getRelatedElements(element, checkBefore, editor).delimiterPair;
            return (delimiterPair &&
                (delimiterPair.className || '').indexOf(data.pairClass) > -1 &&
                cacheDelimiter(event, checkBefore, element));
        }
    }
    function getNextSibling(editor, element, checkBefore) {
        var traverser = getBlockTraverser(editor, element);
        if (!traverser) {
            return undefined;
        }
        var traverseFn = function (t) {
            return checkBefore ? t.getNextInlineElement() : t.getPreviousInlineElement();
        };
        var currentInline = traverser.currentInlineElement;
        while (currentInline && currentInline.getContainerNode() === element) {
            currentInline = traverseFn(traverser);
        }
        return currentInline === null || currentInline === void 0 ? void 0 : currentInline.getContainerNode();
    }
    function getBlockTraverser(editor, element) {
        var _a;
        if (!element) {
            return undefined;
        }
        var blockElement = (_a = editor.getBlockElementAtNode(element)) === null || _a === void 0 ? void 0 : _a.getStartNode();
        return blockElement ? roosterjs_editor_dom_1$F.ContentTraverser.createBodyTraverser(blockElement, element) : undefined;
    }
    function cacheDelimiter(event, checkBefore, delimiter) {
        return (0, roosterjs_editor_dom_2.cacheGetEventData)(event, 'delimiter_cache_key_' + checkBefore, function () { return delimiter; });
    }
    function cacheEntityBetweenDelimiter(event, editor, checkBefore, entity, operation) {
        var element = (0, roosterjs_editor_dom_2.cacheGetEventData)(event, 'entity_delimiter_cache_key_' + checkBefore, function () { return entity && editor.getElementAtCursor((0, roosterjs_editor_dom_2.getEntitySelector)(), entity); });
        if (element && operation !== undefined) {
            var entity_1 = (0, roosterjs_editor_dom_2.getEntityFromElement)(element);
            if (entity_1) {
                triggerOperation(entity_1, editor, operation, event);
            }
        }
        return element;
    }
    function triggerOperation(entity, editor, operation, event) {
        var _a = entity.wrapper, nextElementSibling = _a.nextElementSibling, previousElementSibling = _a.previousElementSibling;
        editor.triggerPluginEvent(15 /* EntityOperation */, {
            operation: operation,
            rawEvent: event.rawEvent,
            entity: entity,
        });
        if (entity.isReadonly &&
            !(0, roosterjs_editor_dom_2.isBlockElement)(entity.wrapper) &&
            editor.isFeatureEnabled("InlineEntityReadOnlyDelimiters" /* InlineEntityReadOnlyDelimiters */)) {
            if (event.rawEvent.defaultPrevented) {
                editor.runAsync(function () {
                    if (!editor.contains(entity.wrapper)) {
                        removeDelimiters(nextElementSibling, previousElementSibling);
                    }
                    else {
                        var delimiterAfter = (0, roosterjs_editor_dom_2.addDelimiters)(entity.wrapper)[0];
                        if (delimiterAfter) {
                            editor.select(delimiterAfter, -3 /* After */);
                        }
                    }
                });
            }
            else if ((0, roosterjs_editor_dom_2.getDelimiterFromElement)(nextElementSibling) &&
                (0, roosterjs_editor_dom_2.getDelimiterFromElement)(previousElementSibling)) {
                editor.select((0, roosterjs_editor_dom_2.createRange)(previousElementSibling, nextElementSibling));
            }
        }
    }
    function removeDelimiters(nextElementSibling, previousElementSibling) {
        [nextElementSibling, previousElementSibling].forEach(function (sibling) {
            var _a;
            if ((0, roosterjs_editor_dom_2.getDelimiterFromElement)(sibling)) {
                (_a = sibling === null || sibling === void 0 ? void 0 : sibling.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);
            }
        });
    }
    function cacheGetCheckBefore(event, checkBefore) {
        return !!(0, roosterjs_editor_dom_2.cacheGetEventData)(event, 'Check_Before', function () { return checkBefore; });
    }
    function getRelatedElements(delimiter, checkBefore, editor) {
        var entity = null;
        var delimiterPair = null;
        var traverser = getBlockTraverser(editor, delimiter);
        if (!traverser) {
            return { delimiterPair: delimiterPair, entity: entity };
        }
        var selector = "." + (checkBefore ? "entityDelimiterAfter" /* DELIMITER_AFTER */ : "entityDelimiterBefore" /* DELIMITER_BEFORE */);
        var traverseFn = function (t) {
            return checkBefore ? t.getNextInlineElement() : t.getPreviousInlineElement();
        };
        var getElementFromInline = function (element, selector) {
            var _a;
            var node = element === null || element === void 0 ? void 0 : element.getContainerNode();
            return (_a = (node && editor.getElementAtCursor(selector, node))) !== null && _a !== void 0 ? _a : null;
        };
        var entitySelector = (0, roosterjs_editor_dom_2.getEntitySelector)();
        var current = traverser.currentInlineElement;
        while (current && (!entity || !delimiterPair)) {
            entity = entity || getElementFromInline(current, entitySelector);
            delimiterPair = delimiterPair || getElementFromInline(current, selector);
            // If we found the entity but the next inline after the entity is not a delimiter,
            // it means that the delimiter pair got removed or is invalid, return null instead.
            if (entity && !delimiterPair && !getElementFromInline(current, entitySelector)) {
                delimiterPair = null;
                break;
            }
            current = traverseFn(traverser);
        }
        return { entity: entity, delimiterPair: delimiterPair };
    }
    /**
     * @internal
     */
    entityFeatures.EntityFeatures = {
        clickOnEntity: ClickOnEntityFeature,
        escapeFromEntity: EscapeFromEntityFeature,
        enterBeforeReadonlyEntity: EnterBeforeReadonlyEntityFeature,
        backspaceAfterEntity: BackspaceAfterEntityFeature,
        deleteBeforeEntity: DeleteBeforeEntityFeature,
        moveBetweenDelimitersFeature: MoveBetweenDelimitersFeature,
        removeEntityBetweenDelimiters: RemoveEntityBetweenDelimitersFeature,
    };

    var listFeatures = {};

    var getAutoBulletListStyle$1 = {};

    Object.defineProperty(getAutoBulletListStyle$1, "__esModule", { value: true });
    var bulletListType = {
        '*': 1 /* Disc */,
        '-': 2 /* Dash */,
        '--': 3 /* Square */,
        '->': 5 /* LongArrow */,
        '-->': 8 /* DoubleLongArrow */,
        '=>': 6 /* UnfilledArrow */,
        '>': 4 /* ShortArrow */,
        '': 7 /* Hyphen */,
    };
    var identifyBulletListType = function (bullet) {
        return bulletListType[bullet] || null;
    };
    /**
     * @internal
     * @param textBeforeCursor The trigger character
     * @returns The style of a bullet list triggered by a string
     */
    function getAutoBulletListStyle(textBeforeCursor) {
        var trigger = textBeforeCursor.trim();
        var bulletType = identifyBulletListType(trigger);
        return bulletType;
    }
    getAutoBulletListStyle$1.default = getAutoBulletListStyle;

    var getAutoNumberingListStyle$1 = {};

    var convertAlphaToDecimals$1 = {};

    Object.defineProperty(convertAlphaToDecimals$1, "__esModule", { value: true });
    /**
     * @internal
     * Convert english alphabet numbers into decimal numbers
     * @param letter The letter that needs to be converted
     * @returns
     */
    function convertAlphaToDecimals(letter) {
        var alpha = letter.toLocaleLowerCase();
        if (alpha) {
            var size = alpha.length - 1;
            var number = 26 * size + alpha.charCodeAt(size) - 96;
            return number;
        }
        return null;
    }
    convertAlphaToDecimals$1.default = convertAlphaToDecimals;

    var _a$1, _b, _c, _d, _e, _f;
    Object.defineProperty(getAutoNumberingListStyle$1, "__esModule", { value: true });
    var convertAlphaToDecimals_1 = convertAlphaToDecimals$1;
    var NumberingTypes;
    (function (NumberingTypes) {
        NumberingTypes[NumberingTypes["Decimal"] = 1] = "Decimal";
        NumberingTypes[NumberingTypes["LowerAlpha"] = 2] = "LowerAlpha";
        NumberingTypes[NumberingTypes["UpperAlpha"] = 3] = "UpperAlpha";
        NumberingTypes[NumberingTypes["LowerRoman"] = 4] = "LowerRoman";
        NumberingTypes[NumberingTypes["UpperRoman"] = 5] = "UpperRoman";
    })(NumberingTypes || (NumberingTypes = {}));
    var Character;
    (function (Character) {
        Character[Character["Dot"] = 1] = "Dot";
        Character[Character["Dash"] = 2] = "Dash";
        Character[Character["Parenthesis"] = 3] = "Parenthesis";
        Character[Character["DoubleParenthesis"] = 4] = "DoubleParenthesis";
    })(Character || (Character = {}));
    var characters = {
        '.': 1 /* Dot */,
        '-': 2 /* Dash */,
        ')': 3 /* Parenthesis */,
    };
    var lowerRomanTypes = [
        13 /* LowerRoman */,
        16 /* LowerRomanDash */,
        15 /* LowerRomanDoubleParenthesis */,
        14 /* LowerRomanParenthesis */,
    ];
    var upperRomanTypes = [
        17 /* UpperRoman */,
        20 /* UpperRomanDash */,
        19 /* UpperRomanDoubleParenthesis */,
        18 /* UpperRomanParenthesis */,
    ];
    var numberingTriggers = ['1', 'a', 'A', 'I', 'i'];
    var lowerRomanNumbers = ['i', 'v', 'x', 'l', 'c', 'd', 'm'];
    var upperRomanNumbers = ['I', 'V', 'X', 'L', 'C', 'D', 'M'];
    var identifyNumberingType = function (text, previousListStyle) {
        if (!isNaN(parseInt(text))) {
            return 1 /* Decimal */;
        }
        else if (/[a-z]+/g.test(text)) {
            if ((lowerRomanTypes.indexOf(previousListStyle) > -1 &&
                lowerRomanNumbers.indexOf(text[0]) > -1) ||
                (!previousListStyle && text === 'i')) {
                return 4 /* LowerRoman */;
            }
            else if (previousListStyle || (!previousListStyle && text === 'a')) {
                return 2 /* LowerAlpha */;
            }
        }
        else if (/[A-Z]+/g.test(text)) {
            if ((upperRomanTypes.indexOf(previousListStyle) > -1 &&
                upperRomanNumbers.indexOf(text[0]) > -1) ||
                (!previousListStyle && text === 'I')) {
                return 5 /* UpperRoman */;
            }
            else if (previousListStyle || (!previousListStyle && text === 'A')) {
                return 3 /* UpperAlpha */;
            }
        }
    };
    var numberingListTypes = (_a$1 = {},
        _a$1[1 /* Decimal */] = function (char) { return DecimalsTypes[char] || null; },
        _a$1[2 /* LowerAlpha */] = function (char) { return LowerAlphaTypes[char] || null; },
        _a$1[3 /* UpperAlpha */] = function (char) { return UpperAlphaTypes[char] || null; },
        _a$1[4 /* LowerRoman */] = function (char) { return LowerRomanTypes[char] || null; },
        _a$1[5 /* UpperRoman */] = function (char) { return UpperRomanTypes[char] || null; },
        _a$1);
    var UpperRomanTypes = (_b = {},
        _b[1 /* Dot */] = 17 /* UpperRoman */,
        _b[2 /* Dash */] = 20 /* UpperRomanDash */,
        _b[3 /* Parenthesis */] = 18 /* UpperRomanParenthesis */,
        _b[4 /* DoubleParenthesis */] = 19 /* UpperRomanDoubleParenthesis */,
        _b);
    var LowerRomanTypes = (_c = {},
        _c[1 /* Dot */] = 13 /* LowerRoman */,
        _c[2 /* Dash */] = 16 /* LowerRomanDash */,
        _c[3 /* Parenthesis */] = 14 /* LowerRomanParenthesis */,
        _c[4 /* DoubleParenthesis */] = 15 /* LowerRomanDoubleParenthesis */,
        _c);
    var UpperAlphaTypes = (_d = {},
        _d[1 /* Dot */] = 9 /* UpperAlpha */,
        _d[2 /* Dash */] = 12 /* UpperAlphaDash */,
        _d[3 /* Parenthesis */] = 10 /* UpperAlphaParenthesis */,
        _d[4 /* DoubleParenthesis */] = 11 /* UpperAlphaDoubleParenthesis */,
        _d);
    var LowerAlphaTypes = (_e = {},
        _e[1 /* Dot */] = 5 /* LowerAlpha */,
        _e[2 /* Dash */] = 8 /* LowerAlphaDash */,
        _e[3 /* Parenthesis */] = 6 /* LowerAlphaParenthesis */,
        _e[4 /* DoubleParenthesis */] = 7 /* LowerAlphaDoubleParenthesis */,
        _e);
    var DecimalsTypes = (_f = {},
        _f[1 /* Dot */] = 1 /* Decimal */,
        _f[2 /* Dash */] = 2 /* DecimalDash */,
        _f[3 /* Parenthesis */] = 3 /* DecimalParenthesis */,
        _f[4 /* DoubleParenthesis */] = 4 /* DecimalDoubleParenthesis */,
        _f);
    var identifyNumberingListType = function (numbering, isDoubleParenthesis, previousListStyle) {
        var separatorCharacter = isDoubleParenthesis
            ? 4 /* DoubleParenthesis */
            : characters[numbering[numbering.length - 1]];
        // if separator is not valid, no need to check if the number is valid.
        if (separatorCharacter) {
            var number = isDoubleParenthesis ? numbering.slice(1, -1) : numbering.slice(0, -1);
            var numberingType = identifyNumberingType(number, previousListStyle);
            return numberingType ? numberingListTypes[numberingType](separatorCharacter) : null;
        }
        return null;
    };
    /**
     * @internal
     * @param textBeforeCursor The trigger character
     * @param previousListChain @optional This parameters is used to keep the list chain, if the is not a new list
     * @param previousListStyle @optional The list style of the previous list
     * @returns The style of a numbering list triggered by a string
     */
    function getAutoNumberingListStyle(textBeforeCursor, previousListChain, previousListStyle) {
        var _a;
        var trigger = textBeforeCursor.trim();
        var isDoubleParenthesis = trigger[0] === '(' && trigger[trigger.length - 1] === ')';
        //Only the staring items ['1', 'a', 'A', 'I', 'i'] must trigger a new list. All the other triggers is used to keep the list chain.
        //The index is always the characters before the last character
        var listIndex = isDoubleParenthesis ? trigger.slice(1, -1) : trigger.slice(0, -1);
        var indexNumber = parseInt(listIndex);
        var index = !isNaN(indexNumber) ? indexNumber : (0, convertAlphaToDecimals_1.default)(listIndex);
        if (!index || index < 1) {
            return null;
        }
        if (previousListChain && index > 1) {
            if ((previousListChain.length < 1 && numberingTriggers.indexOf(listIndex) < 0) ||
                ((previousListChain === null || previousListChain === void 0 ? void 0 : previousListChain.length) > 0 &&
                    !((_a = previousListChain[previousListChain.length - 1]) === null || _a === void 0 ? void 0 : _a.canAppendAtCursor(index)))) {
                return null;
            }
        }
        var numberingType = isValidNumbering(listIndex)
            ? identifyNumberingListType(trigger, isDoubleParenthesis, previousListStyle)
            : null;
        return numberingType;
    }
    getAutoNumberingListStyle$1.default = getAutoNumberingListStyle;
    /**
     * Check if index has only numbers or only letters to avoid sequence of character such 1:1. trigger a list.
     * @param index
     * @returns
     */
    function isValidNumbering(index) {
        return Number(index) || /^[A-Za-z\s]*$/.test(index);
    }

    Object.defineProperty(listFeatures, "__esModule", { value: true });
    listFeatures.ListFeatures = void 0;
    var getAutoBulletListStyle_1 = getAutoBulletListStyle$1;
    var getAutoNumberingListStyle_1 = getAutoNumberingListStyle$1;
    var roosterjs_editor_api_1$b = lib$1;
    var roosterjs_editor_dom_1$E = lib$3;
    var PREVIOUS_BLOCK_CACHE_KEY = 'previousBlock';
    var NEXT_BLOCK_CACHE_KEY = 'nextBlock';
    var ListStyleDefinitionMetadata = (0, roosterjs_editor_dom_1$E.createObjectDefinition)({
        orderedStyleType: (0, roosterjs_editor_dom_1$E.createNumberDefinition)(true /** isOptional */, undefined /** value **/, 1 /* Min */, 20 /* Max */),
        unorderedStyleType: (0, roosterjs_editor_dom_1$E.createNumberDefinition)(true /** isOptional */, undefined /** value **/, 1 /* Min */, 9 /* Max */),
    }, true /** isOptional */, true /** allowNull */);
    var shouldHandleIndentationEvent = function (indenting) { return function (event, editor) {
        var _a = event.rawEvent, keyCode = _a.keyCode, altKey = _a.altKey, shiftKey = _a.shiftKey, ctrlKey = _a.ctrlKey, metaKey = _a.metaKey;
        return (!ctrlKey &&
            !metaKey &&
            (keyCode === 9 /* TAB */
                ? !altKey && shiftKey === !indenting
                : shiftKey && altKey && keyCode === (indenting ? 39 /* RIGHT */ : 37 /* LEFT */)) &&
            cacheGetListElement(event, editor));
    }; };
    var handleIndentationEvent = function (indenting) { return function (event, editor) {
        var isRTL = event.rawEvent.keyCode !== 9 /* TAB */ &&
            (0, roosterjs_editor_dom_1$E.getComputedStyle)(editor.getElementAtCursor(), 'direction') == 'rtl';
        (0, roosterjs_editor_api_1$b.setIndentation)(editor, isRTL == indenting ? 1 /* Decrease */ : 0 /* Increase */);
        event.rawEvent.preventDefault();
    }; };
    /**
     * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB
     */
    var IndentWhenTab = {
        keys: roosterjs_editor_dom_1$E.Browser.isMac ? [9 /* TAB */] : [9 /* TAB */, 39 /* RIGHT */],
        shouldHandleEvent: shouldHandleIndentationEvent(true),
        handleEvent: handleIndentationEvent(true),
        allowFunctionKeys: true,
    };
    /**
     * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB
     */
    var OutdentWhenShiftTab = {
        keys: roosterjs_editor_dom_1$E.Browser.isMac ? [9 /* TAB */] : [9 /* TAB */, 37 /* LEFT */],
        shouldHandleEvent: shouldHandleIndentationEvent(false),
        handleEvent: handleIndentationEvent(false),
        allowFunctionKeys: true,
    };
    /**
     * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press
     * BACKSPACE at beginning of a list item
     */
    var MergeInNewLine = {
        keys: [8 /* BACKSPACE */],
        shouldHandleEvent: function (event, editor) {
            var li = editor.getElementAtCursor('LI', null /*startFrom*/, event);
            var range = editor.getSelectionRange();
            return li && (range === null || range === void 0 ? void 0 : range.collapsed) && (0, roosterjs_editor_dom_1$E.isPositionAtBeginningOf)(roosterjs_editor_dom_1$E.Position.getStart(range), li);
        },
        handleEvent: function (event, editor) {
            var li = editor.getElementAtCursor('LI', null /*startFrom*/, event);
            if (li.previousSibling) {
                (0, roosterjs_editor_api_1$b.blockFormat)(editor, function (region, start, end) {
                    var vList = (0, roosterjs_editor_dom_1$E.createVListFromRegion)(region, false /*includeSiblingList*/, li);
                    if (vList) {
                        vList.setIndentation(start, end, 1 /* Decrease */, true /*softOutdent*/);
                        vList.writeBack(editor.isFeatureEnabled("ReuseAllAncestorListElements" /* ReuseAllAncestorListElements */));
                        event.rawEvent.preventDefault();
                    }
                });
            }
            else {
                toggleListAndPreventDefault(event, editor);
            }
        },
        defaultDisabled: true,
    };
    /**
     * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press
     * BACKSPACE at the first and empty line of a list
     */
    var OutdentWhenBackOn1stEmptyLine = {
        keys: [8 /* BACKSPACE */],
        shouldHandleEvent: function (event, editor) {
            var li = editor.getElementAtCursor('LI', null /*startFrom*/, event);
            return (li &&
                (0, roosterjs_editor_dom_1$E.isNodeEmpty)(li) &&
                !li.previousSibling &&
                !li.getElementsByTagName('blockquote').length);
        },
        handleEvent: toggleListAndPreventDefault,
    };
    /**
     * MaintainListChainWhenDelete edit feature, provides the ability to indent the list if user press
     * DELETE before the first item of a list
     */
    var MaintainListChainWhenDelete = {
        keys: [46 /* DELETE */],
        shouldHandleEvent: function (event, editor) {
            var li = editor.getElementAtCursor('LI', null /*startFrom*/, event);
            if (li) {
                return false;
            }
            var isAtEnd = roosterjs_editor_dom_1$E.Position.getEnd(editor.getSelectionRange()).isAtEnd;
            var nextSibling = isAtEnd ? getCacheNextSibling(event, editor) : null;
            var isAtEndAndBeforeLI = editor.getElementAtCursor('LI', nextSibling, event);
            return isAtEndAndBeforeLI;
        },
        handleEvent: function (event, editor) {
            var chains = getListChains(editor);
            editor.runAsync(function (editor) { return (0, roosterjs_editor_api_1$b.commitListChains)(editor, chains); });
        },
    };
    /**
     * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press
     * ENTER at the beginning of an empty line of a list
     */
    var OutdentWhenEnterOnEmptyLine = {
        keys: [13 /* ENTER */],
        shouldHandleEvent: function (event, editor) {
            var li = editor.getElementAtCursor('LI', null /*startFrom*/, event);
            return !event.rawEvent.shiftKey && li && (0, roosterjs_editor_dom_1$E.isNodeEmpty)(li);
        },
        handleEvent: function (event, editor) {
            editor.addUndoSnapshot(function () { return toggleListAndPreventDefault(event, editor, false /* includeSiblingLists */); }, null /*changeSource*/, true /*canUndoByBackspace*/);
        },
        defaultDisabled: !roosterjs_editor_dom_1$E.Browser.isIE && !roosterjs_editor_dom_1$E.Browser.isChrome,
    };
    /**
     * Validate if a block of text is considered a list pattern
     * The regex expression will look for patterns of the form:
     * 1.  1>  1)  1-  (1)
     * @returns if a text is considered a list pattern
     */
    function isAListPattern(textBeforeCursor) {
        var REGEX = /^(\*|-|[0-9]{1,2}\.|[0-9]{1,2}\>|[0-9]{1,2}\)|[0-9]{1,2}\-|\([0-9]{1,2}\))$/;
        return REGEX.test(textBeforeCursor);
    }
    /**
     * AutoBullet edit feature, provides the ability to automatically convert current line into a list.
     * When user input "1. ", convert into a numbering list
     * When user input "- " or "* ", convert into a bullet list
     */
    var AutoBullet = {
        keys: [32 /* SPACE */],
        shouldHandleEvent: function (event, editor) {
            if (!cacheGetListElement(event, editor) &&
                !editor.isFeatureEnabled("AutoFormatList" /* AutoFormatList */)) {
                var searcher = editor.getContentSearcherOfCursor(event);
                var textBeforeCursor = searcher.getSubStringBefore(4);
                // Auto list is triggered if:
                // 1. Text before cursor exactly matches '*', '-' or '1.'
                // 2. There's no non-text inline entities before cursor
                return isAListPattern(textBeforeCursor) && !searcher.getNearestNonTextInlineElement();
            }
            return false;
        },
        handleEvent: function (event, editor) {
            editor.insertContent('&nbsp;');
            event.rawEvent.preventDefault();
            editor.addUndoSnapshot(function () {
                var _a;
                var regions;
                var searcher = editor.getContentSearcherOfCursor();
                var textBeforeCursor = searcher.getSubStringBefore(4);
                var textRange = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/);
                if (!textRange) ;
                else if (textBeforeCursor.indexOf('*') == 0 ||
                    textBeforeCursor.indexOf('-') == 0) {
                    prepareAutoBullet(editor, textRange);
                    (0, roosterjs_editor_api_1$b.toggleBullet)(editor);
                }
                else if (isAListPattern(textBeforeCursor)) {
                    prepareAutoBullet(editor, textRange);
                    (0, roosterjs_editor_api_1$b.toggleNumbering)(editor);
                }
                else if ((regions = editor.getSelectedRegions()) && regions.length == 1) {
                    var num = parseInt(textBeforeCursor);
                    prepareAutoBullet(editor, textRange);
                    (0, roosterjs_editor_api_1$b.toggleNumbering)(editor, num);
                }
                (_a = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/)) === null || _a === void 0 ? void 0 : _a.deleteContents();
            }, null /*changeSource*/, true /*canUndoByBackspace*/);
        },
    };
    /**
     * Requires @see ExperimentalFeatures.AutoFormatList to be enabled
     * AutoBulletList edit feature, provides the ability to automatically convert current line into a bullet list.
     */
    var AutoBulletList = {
        keys: [32 /* SPACE */],
        shouldHandleEvent: function (event, editor) {
            if (!cacheGetListElement(event, editor) &&
                editor.isFeatureEnabled("AutoFormatList" /* AutoFormatList */)) {
                return shouldTriggerList(event, editor, getAutoBulletListStyle_1.default, 2 /* Unordered */);
            }
            return false;
        },
        handleEvent: function (event, editor) {
            editor.insertContent('&nbsp;');
            event.rawEvent.preventDefault();
            editor.addUndoSnapshot(function () {
                var _a;
                var searcher = editor.getContentSearcherOfCursor();
                var textBeforeCursor = searcher.getSubStringBefore(5);
                var textRange = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/);
                var listStyle = (0, getAutoBulletListStyle_1.default)(textBeforeCursor);
                if (textRange) {
                    prepareAutoBullet(editor, textRange);
                    (0, roosterjs_editor_api_1$b.toggleBullet)(editor, listStyle, 'autoToggleList' /** apiNameOverride */);
                }
                (_a = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/)) === null || _a === void 0 ? void 0 : _a.deleteContents();
            }, null /*changeSource*/, true /*canUndoByBackspace*/);
        },
    };
    /**
     * Requires @see ExperimentalFeatures.AutoFormatList to be enabled
     * AutoNumberingList edit feature, provides the ability to automatically convert current line into a numbering list.
     */
    var AutoNumberingList = {
        keys: [32 /* SPACE */],
        shouldHandleEvent: function (event, editor) {
            if (!cacheGetListElement(event, editor) &&
                editor.isFeatureEnabled("AutoFormatList" /* AutoFormatList */)) {
                return shouldTriggerList(event, editor, getAutoNumberingListStyle_1.default, 1 /* Ordered */);
            }
            return false;
        },
        handleEvent: function (event, editor) {
            editor.insertContent('&nbsp;');
            event.rawEvent.preventDefault();
            editor.addUndoSnapshot(function () {
                var _a;
                var searcher = editor.getContentSearcherOfCursor();
                var textBeforeCursor = searcher.getSubStringBefore(5);
                var textRange = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/);
                if (textRange) {
                    var number = isFirstItemOfAList(textBeforeCursor)
                        ? 1
                        : parseInt(textBeforeCursor);
                    var isLi = getPreviousListItem(editor, textRange);
                    var listStyle = (0, getAutoNumberingListStyle_1.default)(textBeforeCursor);
                    prepareAutoBullet(editor, textRange);
                    (0, roosterjs_editor_api_1$b.toggleNumbering)(editor, isLi && number !== 1 ? undefined : number /** startNumber */, listStyle, 'autoToggleList' /** apiNameOverride */);
                }
                (_a = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/)) === null || _a === void 0 ? void 0 : _a.deleteContents();
            }, null /*changeSource*/, true /*canUndoByBackspace*/);
        },
    };
    var getPreviousListItem = function (editor, textRange) {
        var blockElement = editor
            .getBodyTraverser(textRange === null || textRange === void 0 ? void 0 : textRange.startContainer)
            .getPreviousBlockElement();
        var previousNode = blockElement === null || blockElement === void 0 ? void 0 : blockElement.getEndNode();
        return (0, roosterjs_editor_dom_1$E.getTagOfNode)(previousNode) === 'LI' ? previousNode : undefined;
    };
    var getPreviousListType = function (editor, textRange, listType) {
        var type = listType === 1 /* Ordered */ ? 'orderedStyleType' : 'unorderedStyleType';
        var listItem = getPreviousListItem(editor, textRange);
        var list = listItem
            ? (0, roosterjs_editor_dom_1$E.findClosestElementAncestor)(listItem, undefined /** root*/, listType === 1 /* Ordered */ ? 'ol' : 'ul')
            : null;
        var metadata = list ? (0, roosterjs_editor_dom_1$E.getMetadata)(list, ListStyleDefinitionMetadata) : null;
        return metadata ? metadata[type] : null;
    };
    var isFirstItemOfAList = function (item) {
        var number = parseInt(item);
        if (number && number === 1) {
            return 1;
        }
        else {
            var letter = item.replace(/\(|\)|\-|\./g, '').trim();
            return letter.length === 1 && ['i', 'a', 'I', 'A'].indexOf(letter) > -1 ? 1 : undefined;
        }
    };
    /**
     * Maintain the list numbers in list chain
     * e.g. we have two lists:
     * 1, 2, 3 and 4, 5, 6
     * Now we delete list item 2, so the first one becomes "1, 2".
     * This edit feature can maintain the list number of the second list to become "3, 4, 5"
     */
    var MaintainListChain = {
        keys: [13 /* ENTER */, 9 /* TAB */, 46 /* DELETE */, 8 /* BACKSPACE */, 258 /* RANGE */],
        shouldHandleEvent: function (event, editor) {
            return editor
                .queryElements('li', 1 /* OnSelection */)
                .filter(function (li) { return !li.getElementsByTagName('blockquote').length; }).length > 0;
        },
        handleEvent: function (event, editor) {
            var chains = getListChains(editor);
            editor.runAsync(function (editor) { return (0, roosterjs_editor_api_1$b.commitListChains)(editor, chains); });
        },
    };
    function getListChains(editor) {
        return roosterjs_editor_dom_1$E.VListChain.createListChains(editor.getSelectedRegions());
    }
    function getCacheNextSibling(event, editor) {
        var element = (0, roosterjs_editor_dom_1$E.cacheGetEventData)(event, 'nextSibling', function () {
            var _a;
            var range = editor.getSelectionRange();
            var pos = roosterjs_editor_dom_1$E.Position.getEnd(range).normalize();
            var traverser = editor.getBodyTraverser(pos.node);
            return (_a = traverser === null || traverser === void 0 ? void 0 : traverser.getNextBlockElement()) === null || _a === void 0 ? void 0 : _a.getStartNode();
        });
        return element;
    }
    function prepareAutoBullet(editor, range) {
        var block = editor.getBlockElementAtNode(range.startContainer);
        var endNode = block === null || block === void 0 ? void 0 : block.getEndNode();
        if (endNode && (0, roosterjs_editor_dom_1$E.getTagOfNode)(endNode) != 'BR') {
            var br = editor.getDocument().createElement('BR');
            if ((0, roosterjs_editor_dom_1$E.isBlockElement)(endNode)) {
                endNode.appendChild(br);
            }
            else {
                endNode.parentNode.insertBefore(br, endNode.nextSibling);
            }
            editor.select(range.startContainer, range.startOffset);
        }
    }
    function toggleListAndPreventDefault(event, editor, includeSiblingLists) {
        if (includeSiblingLists === void 0) { includeSiblingLists = true; }
        var listInfo = cacheGetListElement(event, editor);
        if (listInfo) {
            var listElement = listInfo[0];
            var tag = (0, roosterjs_editor_dom_1$E.getTagOfNode)(listElement);
            if (tag == 'UL' || tag == 'OL') {
                (0, roosterjs_editor_api_1$b.toggleListType)(editor, tag == 'UL' ? 2 /* Unordered */ : 1 /* Ordered */, null /* startNumber */, includeSiblingLists);
            }
            editor.focus();
            event.rawEvent.preventDefault();
        }
    }
    function cacheGetListElement(event, editor) {
        var li = editor.getElementAtCursor('LI,TABLE', null /*startFrom*/, event);
        var listElement = li && (0, roosterjs_editor_dom_1$E.getTagOfNode)(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);
        return listElement ? [listElement, li] : null;
    }
    function shouldTriggerList(event, editor, getListStyle, listType) {
        var searcher = editor.getContentSearcherOfCursor(event);
        var textBeforeCursor = searcher.getSubStringBefore(4);
        var traverser = editor.getBlockTraverser();
        var text = traverser && traverser.currentBlockElement
            ? traverser.currentBlockElement.getTextContent().slice(0, textBeforeCursor.length)
            : null;
        var isATheBeginning = text && text === textBeforeCursor;
        var listChains = getListChains(editor);
        var textRange = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/);
        var previousListType = getPreviousListType(editor, textRange, listType);
        var isFirstItem = isFirstItemOfAList(textBeforeCursor);
        var listStyle = getListStyle(textBeforeCursor, listChains, previousListType);
        var shouldTriggerNewListStyle = isFirstItem ||
            !previousListType ||
            previousListType === listStyle ||
            listType === 2 /* Unordered */;
        return (isATheBeginning &&
            !searcher.getNearestNonTextInlineElement() &&
            listStyle &&
            shouldTriggerNewListStyle);
    }
    /**
     * MergeListOnBackspaceAfterList edit feature, provides the ability to merge list on backspace on block after a list.
     */
    var MergeListOnBackspaceAfterList = {
        keys: [8 /* BACKSPACE */],
        shouldHandleEvent: function (event, editor) {
            var _a, _b;
            var target = editor.getElementAtCursor();
            if (target) {
                var cursorBlock = (_a = editor.getBlockElementAtNode(target)) === null || _a === void 0 ? void 0 : _a.getStartNode();
                var previousBlock_1 = (_b = cursorBlock === null || cursorBlock === void 0 ? void 0 : cursorBlock.previousElementSibling) !== null && _b !== void 0 ? _b : null;
                if (isList(previousBlock_1)) {
                    var range = editor.getSelectionRange();
                    var searcher = editor.getContentSearcherOfCursor(event);
                    var textBeforeCursor = searcher === null || searcher === void 0 ? void 0 : searcher.getSubStringBefore(4);
                    var nearestInline = searcher === null || searcher === void 0 ? void 0 : searcher.getNearestNonTextInlineElement();
                    if (range && range.collapsed && textBeforeCursor === '' && !nearestInline) {
                        var tempBlock = cursorBlock === null || cursorBlock === void 0 ? void 0 : cursorBlock.nextElementSibling;
                        var nextBlock_1 = isList(tempBlock) ? tempBlock : tempBlock === null || tempBlock === void 0 ? void 0 : tempBlock.firstChild;
                        if (isList(nextBlock_1) &&
                            (0, roosterjs_editor_dom_1$E.getTagOfNode)(previousBlock_1) == (0, roosterjs_editor_dom_1$E.getTagOfNode)(nextBlock_1)) {
                            var element = (0, roosterjs_editor_dom_1$E.cacheGetEventData)(event, PREVIOUS_BLOCK_CACHE_KEY, function () { return previousBlock_1; });
                            var nextElement = (0, roosterjs_editor_dom_1$E.cacheGetEventData)(event, NEXT_BLOCK_CACHE_KEY, function () { return nextBlock_1; });
                            return !!element && !!nextElement;
                        }
                    }
                }
            }
            return false;
        },
        handleEvent: function (event, editor) {
            editor.runAsync(function (editor) {
                var previousList = (0, roosterjs_editor_dom_1$E.cacheGetEventData)(event, PREVIOUS_BLOCK_CACHE_KEY, function () { return null; });
                var targetBlock = (0, roosterjs_editor_dom_1$E.cacheGetEventData)(event, NEXT_BLOCK_CACHE_KEY, function () { return null; });
                var rangeBeforeWriteBack = editor.getSelectionRange();
                if (previousList && targetBlock && rangeBeforeWriteBack) {
                    var fvList = new roosterjs_editor_dom_1$E.VList(previousList);
                    fvList.mergeVList(new roosterjs_editor_dom_1$E.VList(targetBlock));
                    var span = editor.getDocument().createElement('span');
                    span.id = 'restoreRange';
                    rangeBeforeWriteBack.insertNode(span);
                    fvList.writeBack();
                    span = editor.queryElements('#restoreRange')[0];
                    if (span.parentElement) {
                        editor.select(new roosterjs_editor_dom_1$E.Position(span, -3 /* After */));
                        span.parentElement.removeChild(span);
                    }
                }
            });
        },
    };
    /**
     * @internal
     */
    listFeatures.ListFeatures = {
        autoBullet: AutoBullet,
        indentWhenTab: IndentWhenTab,
        outdentWhenShiftTab: OutdentWhenShiftTab,
        outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,
        outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,
        mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,
        maintainListChain: MaintainListChain,
        maintainListChainWhenDelete: MaintainListChainWhenDelete,
        autoNumberingList: AutoNumberingList,
        autoBulletList: AutoBulletList,
        mergeListOnBackspaceAfterList: MergeListOnBackspaceAfterList,
    };
    function isList(element) {
        return (!!element &&
            ((0, roosterjs_editor_dom_1$E.safeInstanceOf)(element, 'HTMLOListElement') || (0, roosterjs_editor_dom_1$E.safeInstanceOf)(element, 'HTMLUListElement')));
    }

    var markdownFeatures = {};

    Object.defineProperty(markdownFeatures, "__esModule", { value: true });
    markdownFeatures.MarkdownFeatures = void 0;
    var roosterjs_editor_dom_1$D = lib$3;
    var ZERO_WIDTH_SPACE = '\u200B';
    function generateBasicMarkdownFeature(key, triggerCharacter, elementTag, useShiftKey) {
        return {
            keys: [key],
            shouldHandleEvent: function (event, editor) {
                return event.rawEvent.shiftKey === useShiftKey &&
                    !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);
            },
            handleEvent: function (event, editor) {
                // runAsync is here to allow the event to complete so autocomplete will present the trigger character.
                editor.runAsync(function (editor) {
                    handleMarkdownEvent(event, editor, triggerCharacter, elementTag);
                });
            },
        };
    }
    function cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter) {
        return (0, roosterjs_editor_dom_1$D.cacheGetEventData)(event, 'MARKDOWN_RANGE', function () {
            var searcher = editor.getContentSearcherOfCursor(event);
            var startPosition;
            var endPosition;
            searcher === null || searcher === void 0 ? void 0 : searcher.forEachTextInlineElement(function (textInlineElement) {
                if (endPosition && startPosition) {
                    return true;
                }
                var inlineTextContent = textInlineElement.getTextContent();
                // special case for immediately preceding character being whitespace
                if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {
                    return false;
                }
                //if the text is pasted, it might create a inner element inside the text element,
                // then is necessary to check the parent block to get whole text
                var parentBlockText = textInlineElement.getParentBlock().getTextContent();
                // special case for consecutive trigger characters
                // check parent block in case of pasted text
                if (parentBlockText[parentBlockText.length - 1].trim() === triggerCharacter) {
                    return false;
                }
                if (!endPosition) {
                    endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);
                }
                if (inlineTextContent[0] == triggerCharacter) {
                    startPosition = textInlineElement.getStartPosition();
                }
                else {
                    var contentIndex = inlineTextContent.length - 1;
                    for (; contentIndex > 0; contentIndex--) {
                        if (startPosition) {
                            return true;
                        }
                        if (inlineTextContent[contentIndex] == triggerCharacter &&
                            inlineTextContent[contentIndex - 1].trim().length == 0) {
                            startPosition = textInlineElement.getStartPosition().move(contentIndex);
                            return true;
                        }
                    }
                }
            });
            return !!startPosition && !!endPosition && (0, roosterjs_editor_dom_1$D.createRange)(startPosition, endPosition);
        });
    }
    function handleMarkdownEvent(event, editor, triggerCharacter, elementTag) {
        editor.addUndoSnapshot(function () {
            var range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);
            var lastTypedTriggerPosition = new roosterjs_editor_dom_1$D.Position(range.endContainer, -1 /* End */);
            var hasLastTypedTrigger = range.endOffset + 1 <= lastTypedTriggerPosition.offset;
            if (!!range && hasLastTypedTrigger) {
                // get the text content range
                var textContentRange = range.cloneRange();
                textContentRange.setStart(textContentRange.startContainer, textContentRange.startOffset + 1);
                var text = textContentRange.extractContents().textContent;
                var textNode = editor.getDocument().createTextNode(text);
                // extract content and put it into a new element.
                var elementToWrap = (0, roosterjs_editor_dom_1$D.wrap)(textNode, elementTag);
                //include last typed character
                range.setEnd(range.endContainer, range.endOffset + 1);
                range.deleteContents();
                // ZWS here ensures we don't end up inside the newly created node.
                var nonPrintedSpaceTextNode = editor
                    .getDocument()
                    .createTextNode(ZERO_WIDTH_SPACE);
                range.insertNode(nonPrintedSpaceTextNode);
                range.insertNode(elementToWrap);
                editor.select(nonPrintedSpaceTextNode, -1 /* End */);
            }
        }, "Format" /* Format */, true /*canUndoByBackspace*/);
    }
    /**
     * Markdown bold feature. Make bold text with markdown shortcuts.
     */
    var MarkdownBold = generateBasicMarkdownFeature(56 /* EIGHT_ASTERISK */, '*', 'b', true /* useShiftKey */);
    /**
     * Markdown italics feature. Make italic text with markdown shortcuts.
     */
    var MarkdownItalic = generateBasicMarkdownFeature(189 /* DASH_UNDERSCORE */, '_', 'i', true /* useShiftKey */);
    /**
     * Markdown strikethrough feature. MAke strikethrough text with markdown shortcuts.
     */
    var MarkdownStrikethrough = generateBasicMarkdownFeature(192 /* GRAVE_TILDE */, '~', 's', true /* useShiftKey */);
    /**
     * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.
     */
    var MarkdownInlineCode = generateBasicMarkdownFeature(192 /* GRAVE_TILDE */, '`', 'code', false /* useShiftKey */);
    /**
     * @internal
     */
    markdownFeatures.MarkdownFeatures = {
        markdownBold: MarkdownBold,
        markdownItalic: MarkdownItalic,
        markdownStrikethru: MarkdownStrikethrough,
        markdownInlineCode: MarkdownInlineCode,
    };

    var quoteFeatures = {};

    Object.defineProperty(quoteFeatures, "__esModule", { value: true });
    quoteFeatures.QuoteFeatures = void 0;
    var roosterjs_editor_api_1$a = lib$1;
    var roosterjs_editor_dom_1$C = lib$3;
    var QUOTE_TAG = 'BLOCKQUOTE';
    var STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');
    /**
     * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when
     * user press BACKSPACE on first and empty line of a BLOCKQUOTE
     */
    var UnquoteWhenBackOnEmpty1stLine = {
        keys: [8 /* BACKSPACE */],
        shouldHandleEvent: function (event, editor) {
            var childOfQuote = cacheGetQuoteChild(event, editor);
            return childOfQuote && (0, roosterjs_editor_dom_1$C.isNodeEmpty)(childOfQuote) && !childOfQuote.previousSibling;
        },
        handleEvent: splitQuote,
    };
    /**
     * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when
     * user press ENTER on an empty line of a BLOCKQUOTE
     */
    var UnquoteWhenEnterOnEmptyLine = {
        keys: [13 /* ENTER */],
        shouldHandleEvent: function (event, editor) {
            var childOfQuote = cacheGetQuoteChild(event, editor);
            var shift = event.rawEvent.shiftKey;
            return !shift && childOfQuote && (0, roosterjs_editor_dom_1$C.isNodeEmpty)(childOfQuote);
        },
        handleEvent: function (event, editor) {
            return editor.addUndoSnapshot(function () { return splitQuote(event, editor); }, null /*changeSource*/, true /*canUndoByBackspace*/);
        },
    };
    function cacheGetQuoteChild(event, editor) {
        return (0, roosterjs_editor_dom_1$C.cacheGetEventData)(event, 'QUOTE_CHILD', function () {
            var quote = editor.getElementAtCursor(STRUCTURED_TAGS);
            if (quote && (0, roosterjs_editor_dom_1$C.getTagOfNode)(quote) == QUOTE_TAG) {
                var pos = editor.getFocusedPosition();
                var block = pos && editor.getBlockElementAtNode(pos.normalize().node);
                if (block) {
                    var node = block.getStartNode() == quote
                        ? block.getStartNode()
                        : block.collapseToSingleElement();
                    return (0, roosterjs_editor_dom_1$C.isNodeEmpty)(node) ? node : null;
                }
            }
            return null;
        });
    }
    function splitQuote(event, editor) {
        editor.addUndoSnapshot(function () {
            var childOfQuote = cacheGetQuoteChild(event, editor);
            var parent;
            var shouldClearFormat;
            if ((0, roosterjs_editor_dom_1$C.getTagOfNode)(childOfQuote) == QUOTE_TAG) {
                childOfQuote = (0, roosterjs_editor_dom_1$C.wrap)((0, roosterjs_editor_dom_1$C.toArray)(childOfQuote.childNodes));
            }
            parent = (0, roosterjs_editor_dom_1$C.splitBalancedNodeRange)(childOfQuote);
            shouldClearFormat = isStyledBlockquote(parent);
            var newParent = (0, roosterjs_editor_dom_1$C.unwrap)(parent);
            editor.select(childOfQuote, 0 /* Begin */);
            if (shouldClearFormat) {
                if ((0, roosterjs_editor_dom_1$C.safeInstanceOf)(newParent, 'HTMLLIElement')) {
                    newParent.style.removeProperty('color');
                }
                (0, roosterjs_editor_api_1$a.clearFormat)(editor);
            }
        });
        event.rawEvent.preventDefault();
    }
    var isStyledBlockquote = function (element) {
        if (element &&
            (0, roosterjs_editor_dom_1$C.safeInstanceOf)(element, 'HTMLQuoteElement') &&
            element.style.borderLeft &&
            element.style.borderColor &&
            element.style.paddingLeft &&
            element.style.color) {
            return true;
        }
        return false;
    };
    /**
     * @internal
     */
    quoteFeatures.QuoteFeatures = {
        unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,
        unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,
    };

    var shortcutFeatures = {};

    Object.defineProperty(shortcutFeatures, "__esModule", { value: true });
    shortcutFeatures.ShortcutFeatures = void 0;
    var roosterjs_editor_dom_1$B = lib$3;
    var roosterjs_editor_api_1$9 = lib$1;
    function createCommand(winKey, macKey, action, disabled) {
        if (disabled === void 0) { disabled = false; }
        if (disabled) {
            return null;
        }
        return {
            winKey: winKey,
            macKey: macKey,
            action: action,
        };
    }
    var commands = [
        createCommand(4096 /* Ctrl */ | 66 /* B */, 8192 /* Meta */ | 66 /* B */, roosterjs_editor_api_1$9.toggleBold),
        createCommand(4096 /* Ctrl */ | 73 /* I */, 8192 /* Meta */ | 73 /* I */, roosterjs_editor_api_1$9.toggleItalic),
        createCommand(4096 /* Ctrl */ | 85 /* U */, 8192 /* Meta */ | 85 /* U */, roosterjs_editor_api_1$9.toggleUnderline),
        createCommand(4096 /* Ctrl */ | 32 /* SPACE */, 8192 /* Meta */ | 32 /* SPACE */, roosterjs_editor_api_1$9.clearFormat),
        createCommand(4096 /* Ctrl */ | 90 /* Z */, 8192 /* Meta */ | 90 /* Z */, function (editor) { return editor.undo(); }),
        createCommand(18 /* ALT */ | 8 /* BACKSPACE */, 18 /* ALT */ | 8 /* BACKSPACE */, function (editor) { return editor.undo(); }, roosterjs_editor_dom_1$B.Browser.isMac /* Option+Backspace to be handled by browsers on Mac */),
        createCommand(4096 /* Ctrl */ | 89 /* Y */, 8192 /* Meta */ | 16384 /* Shift */ | 90 /* Z */, function (editor) { return editor.redo(); }),
        createCommand(4096 /* Ctrl */ | 190 /* PERIOD */, 8192 /* Meta */ | 190 /* PERIOD */, roosterjs_editor_api_1$9.toggleBullet),
        createCommand(4096 /* Ctrl */ | 191 /* FORWARD_SLASH */, 8192 /* Meta */ | 191 /* FORWARD_SLASH */, roosterjs_editor_api_1$9.toggleNumbering),
        createCommand(4096 /* Ctrl */ | 16384 /* Shift */ | 190 /* PERIOD */, 8192 /* Meta */ | 16384 /* Shift */ | 190 /* PERIOD */, function (editor) { return (0, roosterjs_editor_api_1$9.changeFontSize)(editor, 0 /* Increase */); }),
        createCommand(4096 /* Ctrl */ | 16384 /* Shift */ | 188 /* COMMA */, 8192 /* Meta */ | 16384 /* Shift */ | 188 /* COMMA */, function (editor) { return (0, roosterjs_editor_api_1$9.changeFontSize)(editor, 1 /* Decrease */); }),
    ].filter(function (command) { return !!command; });
    /**
     * DefaultShortcut edit feature, provides shortcuts for the following features:
     * Ctrl/Meta+B: toggle bold style
     * Ctrl/Meta+I: toggle italic style
     * Ctrl/Meta+U: toggle underline style
     * Ctrl/Meta+Space: clear formatting
     * Alt+Backspace: undo
     * Ctrl/Meta+Z: undo
     * Ctrl+Y/Meta+Shift+Z: redo
     * Ctrl/Meta+PERIOD: toggle bullet list
     * Ctrl/Meta+/: toggle numbering list
     * Ctrl/Meta+Shift+>: increase font size
     * Ctrl/Meta+Shift+<: decrease font size
     */
    var DefaultShortcut = {
        allowFunctionKeys: true,
        keys: [
            66 /* B */,
            73 /* I */,
            85 /* U */,
            89 /* Y */,
            90 /* Z */,
            188 /* COMMA */,
            190 /* PERIOD */,
            191 /* FORWARD_SLASH */,
            32 /* SPACE */,
            8 /* BACKSPACE */,
        ],
        shouldHandleEvent: cacheGetCommand,
        handleEvent: function (event, editor) {
            var command = cacheGetCommand(event);
            if (command) {
                command.action(editor);
                event.rawEvent.preventDefault();
                event.rawEvent.stopPropagation();
            }
        },
    };
    function cacheGetCommand(event) {
        return (0, roosterjs_editor_dom_1$B.cacheGetEventData)(event, 'DEFAULT_SHORT_COMMAND', function () {
            var e = event.rawEvent;
            var key = 
            // Need to check AltGraph isn't being pressed since some languages (e.g. Polski) use AltGr
            // to input some special characters. In that case, ctrlKey and altKey are both true in Edge,
            // but we should not trigger any shortcut function here. However, we still want to capture
            // the ALT+BACKSPACE combination.
            event.eventType == 0 /* KeyDown */ && !e.getModifierState('AltGraph')
                ? e.which |
                    (e.metaKey && 8192 /* Meta */) |
                    (e.shiftKey && 16384 /* Shift */) |
                    (e.ctrlKey && 4096 /* Ctrl */) |
                    (e.altKey && 18 /* ALT */)
                : 0;
            return key && commands.filter(function (cmd) { return (roosterjs_editor_dom_1$B.Browser.isMac ? cmd.macKey : cmd.winKey) == key; })[0];
        });
    }
    /**
     * @internal
     */
    shortcutFeatures.ShortcutFeatures = {
        defaultShortcut: DefaultShortcut,
    };

    var structuredNodeFeatures = {};

    Object.defineProperty(structuredNodeFeatures, "__esModule", { value: true });
    structuredNodeFeatures.StructuredNodeFeatures = void 0;
    var roosterjs_editor_dom_1$A = lib$3;
    var CHILD_PARENT_TAG_MAP = {
        TD: 'TABLE',
        TH: 'TABLE',
        LI: 'OL,UL',
    };
    var CHILD_SELECTOR = (0, roosterjs_editor_dom_1$A.getObjectKeys)(CHILD_PARENT_TAG_MAP).join(',');
    /**
     * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before
     * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of
     * document
     */
    var InsertLineBeforeStructuredNodeFeature = {
        keys: [13 /* ENTER */],
        shouldHandleEvent: cacheGetStructuredElement,
        handleEvent: function (event, editor) {
            var element = cacheGetStructuredElement(event, editor);
            var div = (0, roosterjs_editor_dom_1$A.createElement)(1 /* EmptyLine */, editor.getDocument());
            editor.addUndoSnapshot(function () {
                element.parentNode.insertBefore(div, element);
                // Select the new line when we are in table. This is the same behavior with Word
                if ((0, roosterjs_editor_dom_1$A.getTagOfNode)(element) == 'TABLE') {
                    editor.select(new roosterjs_editor_dom_1$A.Position(div, 0 /* Begin */).normalize());
                }
            });
            event.rawEvent.preventDefault();
        },
        defaultDisabled: true,
    };
    function cacheGetStructuredElement(event, editor) {
        return (0, roosterjs_editor_dom_1$A.cacheGetEventData)(event, 'FIRST_STRUCTURE', function () {
            // Provide a chance to keep browser default behavior by pressing SHIFT
            var element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);
            if (element) {
                var range = editor.getSelectionRange();
                if (range &&
                    range.collapsed &&
                    (0, roosterjs_editor_dom_1$A.isPositionAtBeginningOf)(roosterjs_editor_dom_1$A.Position.getStart(range), element) &&
                    !editor.getBodyTraverser(element).getPreviousBlockElement()) {
                    return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[(0, roosterjs_editor_dom_1$A.getTagOfNode)(element)]);
                }
            }
            return null;
        });
    }
    /**
     * @internal
     */
    structuredNodeFeatures.StructuredNodeFeatures = {
        insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,
    };

    var tableFeatures = {};

    Object.defineProperty(tableFeatures, "__esModule", { value: true });
    tableFeatures.TableFeatures = void 0;
    var roosterjs_editor_api_1$8 = lib$1;
    var roosterjs_editor_dom_1$z = lib$3;
    /**
     * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table
     */
    var TabInTable = {
        keys: [9 /* TAB */],
        shouldHandleEvent: function (event, editor) {
            return cacheGetTableCell(event, editor) && !cacheIsWholeTableSelected(event, editor);
        },
        handleEvent: function (event, editor) {
            var shift = event.rawEvent.shiftKey;
            var td = cacheGetTableCell(event, editor);
            var vtable = cacheVTable(event, td);
            for (var step = shift ? -1 : 1, row = vtable.row, col = vtable.col + step;; col += step) {
                if (col < 0 || col >= vtable.cells[row].length) {
                    row += step;
                    if (row < 0) {
                        editor.select(vtable.table, -2 /* Before */);
                        break;
                    }
                    else if (row >= vtable.cells.length) {
                        (0, roosterjs_editor_api_1$8.editTable)(editor, 1 /* InsertBelow */);
                        break;
                    }
                    col = shift ? vtable.cells[row].length - 1 : 0;
                }
                var cell = vtable.getCell(row, col);
                if (cell.td) {
                    var newPos = new roosterjs_editor_dom_1$z.Position(cell.td, 0 /* Begin */).normalize();
                    editor.select(newPos);
                    break;
                }
            }
            event.rawEvent.preventDefault();
        },
    };
    /**
     * IndentTableOnTab edit feature, provides the ability to indent the table if it is all cells are selected.
     */
    var IndentTableOnTab = {
        keys: [9 /* TAB */],
        shouldHandleEvent: function (event, editor) {
            return cacheGetTableCell(event, editor) && cacheIsWholeTableSelected(event, editor);
        },
        handleEvent: function (event, editor) {
            event.rawEvent.preventDefault();
            editor.addUndoSnapshot(function () {
                var shift = event.rawEvent.shiftKey;
                var selection = editor.getSelectionRangeEx();
                var td = cacheGetTableCell(event, editor);
                var vtable = cacheVTable(event, td);
                if (shift && editor.getElementAtCursor('blockquote', vtable.table, event)) {
                    (0, roosterjs_editor_api_1$8.setIndentation)(editor, 1 /* Decrease */);
                }
                else if (!shift) {
                    (0, roosterjs_editor_api_1$8.setIndentation)(editor, 0 /* Increase */);
                }
                editor.select(selection.table, selection.coordinates);
            });
        },
    };
    /**
     * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN
     * in table
     */
    var UpDownInTable = {
        keys: [38 /* UP */, 40 /* DOWN */],
        shouldHandleEvent: function (event, editor) {
            return cacheGetTableCell(event, editor) && !cacheIsWholeTableSelected(event, editor);
        },
        handleEvent: function (event, editor) {
            var _a;
            var td = cacheGetTableCell(event, editor);
            var vtable = new roosterjs_editor_dom_1$z.VTable(td);
            var isUp = event.rawEvent.which == 38 /* UP */;
            var step = isUp ? -1 : 1;
            var hasShiftKey = event.rawEvent.shiftKey;
            var selection = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
            var targetTd = null;
            if (selection) {
                var anchorNode_1 = selection.anchorNode, anchorOffset_1 = selection.anchorOffset;
                for (var row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {
                    var cell = vtable.getCell(row, vtable.col);
                    if (cell.td && cell.td != td) {
                        targetTd = cell.td;
                        break;
                    }
                }
                editor.runAsync(function (editor) {
                    var _a;
                    var newContainer = editor.getElementAtCursor();
                    if ((0, roosterjs_editor_dom_1$z.contains)(vtable.table, newContainer) &&
                        !(0, roosterjs_editor_dom_1$z.contains)(td, newContainer, true /*treatSameNodeAsContain*/)) {
                        var newPos = targetTd
                            ? new roosterjs_editor_dom_1$z.Position(targetTd, 0 /* Begin */)
                            : new roosterjs_editor_dom_1$z.Position(vtable.table, isUp ? -2 /* Before */ : -3 /* After */);
                        if (hasShiftKey) {
                            newPos =
                                newPos.node.nodeType == 1 /* Element */ &&
                                    (0, roosterjs_editor_dom_1$z.isVoidHtmlElement)(newPos.node)
                                    ? new roosterjs_editor_dom_1$z.Position(newPos.node, newPos.isAtEnd ? -3 /* After */ : -2 /* Before */)
                                    : newPos;
                            var selection_1 = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
                            selection_1 === null || selection_1 === void 0 ? void 0 : selection_1.setBaseAndExtent(anchorNode_1, anchorOffset_1, newPos.node, newPos.offset);
                        }
                        else {
                            editor.select(newPos.normalize());
                        }
                    }
                });
            }
        },
        defaultDisabled: !roosterjs_editor_dom_1$z.Browser.isChrome && !roosterjs_editor_dom_1$z.Browser.isSafari,
    };
    /**
     * Requires @see ExperimentalFeatures.DeleteTableWithBackspace
     * Delete a table selected with the table selector pressing Backspace key
     */
    var DeleteTableWithBackspace = {
        keys: [8 /* BACKSPACE */],
        shouldHandleEvent: function (event, editor) {
            return editor.isFeatureEnabled("DeleteTableWithBackspace" /* DeleteTableWithBackspace */) &&
                cacheIsWholeTableSelected(event, editor);
        },
        handleEvent: function (event, editor) {
            var td = cacheGetTableCell(event, editor);
            var vtable = new roosterjs_editor_dom_1$z.VTable(td);
            vtable.edit(4 /* DeleteTable */);
            vtable.writeBack();
        },
    };
    function cacheGetTableCell(event, editor) {
        return (0, roosterjs_editor_dom_1$z.cacheGetEventData)(event, 'TABLE_CELL_FOR_TABLE_FEATURES', function () {
            var pos = editor.getFocusedPosition();
            var firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);
            return (firstTd && ((0, roosterjs_editor_dom_1$z.getTagOfNode)(firstTd) == 'LI' ? null : firstTd));
        });
    }
    function cacheIsWholeTableSelected(event, editor) {
        return (0, roosterjs_editor_dom_1$z.cacheGetEventData)(event, 'WHOLE_TABLE_SELECTED_FOR_FEATURES', function () {
            var td = cacheGetTableCell(event, editor);
            var vtable = cacheVTable(event, td);
            var selection = editor.getSelectionRangeEx();
            return (selection.type == 1 /* TableSelection */ &&
                (0, roosterjs_editor_dom_1$z.isWholeTableSelected)(vtable, selection.coordinates));
        });
    }
    function cacheVTable(event, td) {
        return (0, roosterjs_editor_dom_1$z.cacheGetEventData)(event, 'VTABLE_FOR_TABLE_FEATURES', function () {
            return new roosterjs_editor_dom_1$z.VTable(td);
        });
    }
    /**
     * @internal
     */
    tableFeatures.TableFeatures = {
        tabInTable: TabInTable,
        upDownInTable: UpDownInTable,
        indentTableOnTab: IndentTableOnTab,
        deleteTableWithBackspace: DeleteTableWithBackspace,
    };

    var textFeatures = {};

    Object.defineProperty(textFeatures, "__esModule", { value: true });
    textFeatures.TextFeatures = void 0;
    var roosterjs_editor_api_1$7 = lib$1;
    var roosterjs_editor_dom_1$y = lib$3;
    var TAB_SPACES = 6;
    /**
     * Requires @see ExperimentalFeatures.TabKeyTextFeatures to be enabled
     * Provides additional functionality when press Tab:
     *      If Whole Paragraph selected, indent paragraph,
     *      If range is collapsed, add tab spaces
     *      If range is not collapsed but not all the paragraph is selected, replace selection with Tab spaces
     *      If there are more than one block in the selection, indent all selection
     */
    var IndentWhenTabText = {
        keys: [9 /* TAB */],
        shouldHandleEvent: function (event, editor) {
            if (editor.isFeatureEnabled("TabKeyTextFeatures" /* TabKeyTextFeatures */) &&
                !event.rawEvent.shiftKey) {
                var activeElement = editor.getDocument().activeElement;
                var listOrTable = editor.getElementAtCursor('LI,TABLE', null /*startFrom*/, event);
                var entity = editor.getElementAtCursor((0, roosterjs_editor_dom_1$y.getEntitySelector)(), undefined /*startFrom*/, event);
                return (!listOrTable &&
                    (entity ? entity.isContentEditable : activeElement.isContentEditable));
            }
            return false;
        },
        handleEvent: function (event, editor) {
            var selection = editor.getSelectionRangeEx();
            if (selection.type == 0 /* Normal */) {
                editor.addUndoSnapshot(function () {
                    if (selection.areAllCollapsed) {
                        insertTab(editor, event);
                    }
                    else {
                        var ranges = selection.ranges;
                        var range = ranges[0];
                        if (shouldSetIndentation(editor, range)) {
                            (0, roosterjs_editor_api_1$7.setIndentation)(editor, 0 /* Increase */);
                        }
                        else {
                            var tempRange = (0, roosterjs_editor_dom_1$y.createRange)(range.startContainer, range.startOffset);
                            ranges.forEach(function (range) { return range.deleteContents(); });
                            editor.select(tempRange);
                            insertTab(editor, event);
                        }
                    }
                });
                event.rawEvent.preventDefault();
            }
        },
    };
    /**
     * Requires @see ExperimentalFeatures.TabKeyTextFeatures to be enabled
     * If Whole Paragraph selected, outdent paragraph on Tab press
     */
    var OutdentWhenTabText = {
        keys: [9 /* TAB */],
        shouldHandleEvent: function (event, editor) {
            if (event.rawEvent.shiftKey &&
                editor.isFeatureEnabled("TabKeyTextFeatures" /* TabKeyTextFeatures */)) {
                var selection = editor.getSelectionRangeEx();
                return (selection.type == 0 /* Normal */ &&
                    !selection.areAllCollapsed &&
                    editor.getElementAtCursor('blockquote', null, event) &&
                    !editor.getElementAtCursor('LI,TABLE', null /*startFrom*/, event) &&
                    shouldSetIndentation(editor, selection.ranges[0]));
            }
            return false;
        },
        handleEvent: function (event, editor) {
            editor.addUndoSnapshot(function () { return (0, roosterjs_editor_api_1$7.setIndentation)(editor, 1 /* Decrease */); });
            event.rawEvent.preventDefault();
        },
    };
    /**
     * @deprecated
     * Automatically transform -- into hyphen, if typed between two words.
     */
    var AutoHyphen = {
        keys: [],
        shouldHandleEvent: function (event, editor) {
            return false;
        },
        handleEvent: function (event, editor) {
            return false;
        },
        defaultDisabled: true,
    };
    /**
     * @internal
     */
    textFeatures.TextFeatures = {
        indentWhenTabText: IndentWhenTabText,
        outdentWhenTabText: OutdentWhenTabText,
        autoHyphen: AutoHyphen,
    };
    function shouldSetIndentation(editor, range) {
        var result = false;
        var startPosition = roosterjs_editor_dom_1$y.Position.getStart(range);
        var endPosition = roosterjs_editor_dom_1$y.Position.getEnd(range);
        var firstBlock = editor.getBlockElementAtNode(startPosition.node);
        var lastBlock = editor.getBlockElementAtNode(endPosition.node);
        if (!firstBlock || !lastBlock) {
            return false;
        }
        if (!firstBlock.equals(lastBlock)) {
            //If the selections has more than one block, we indent all the blocks in the selection
            return true;
        }
        else {
            //We only indent a single block if all the block is selected.
            var blockStart = new roosterjs_editor_dom_1$y.Position(firstBlock.getStartNode(), 0 /* Begin */);
            var blockEnd = new roosterjs_editor_dom_1$y.Position(firstBlock.getEndNode(), -1 /* End */);
            var rangeBefore = (0, roosterjs_editor_dom_1$y.createRange)(blockStart, roosterjs_editor_dom_1$y.Position.getStart(range));
            var rangeAfter = (0, roosterjs_editor_dom_1$y.createRange)(roosterjs_editor_dom_1$y.Position.getEnd(range), blockEnd);
            if (!result && isRangeEmpty(rangeBefore) && isRangeEmpty(rangeAfter)) {
                result = true;
            }
            return result;
        }
    }
    function isRangeEmpty(range) {
        return (range.toString() == '' &&
            (0, roosterjs_editor_dom_1$y.queryElements)(range.commonAncestorContainer, 'img,table,ul,ol', null, 2 /* InSelection */, range).length == 0);
    }
    function insertTab(editor, event) {
        var span = editor.getDocument().createElement('span');
        var searcher = editor.getContentSearcherOfCursor(event);
        var charsBefore = searcher.getSubStringBefore(Number.MAX_SAFE_INTEGER);
        var numberOfChars = TAB_SPACES - (charsBefore.length % TAB_SPACES);
        var span2;
        var textContent = '';
        for (var index = 0; index < numberOfChars; index++) {
            textContent += '&ensp;';
        }
        editor.insertNode(span);
        if (span.nextElementSibling && (0, roosterjs_editor_dom_1$y.getTagOfNode)(span.nextElementSibling) == 'A') {
            span2 = editor.getDocument().createElement('span');
            span2.textContent = ' ';
            editor.insertNode(span2);
            editor.select((0, roosterjs_editor_dom_1$y.createRange)(span2, -2 /* Before */));
        }
        editor.insertContent(textContent, {
            position: 5 /* Range */,
            range: (0, roosterjs_editor_dom_1$y.createRange)(span, 0 /* Begin */),
            updateCursor: false,
        });
        editor.select((0, roosterjs_editor_dom_1$y.createRange)(span, -3 /* After */));
        if (span2) {
            editor.deleteNode(span2);
        }
    }

    var __assign$8 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$8 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$8.apply(this, arguments);
    };
    Object.defineProperty(getAllFeatures$1, "__esModule", { value: true });
    var autoLinkFeatures_1 = autoLinkFeatures;
    var cursorFeatures_1 = cursorFeatures;
    var entityFeatures_1 = entityFeatures;
    var listFeatures_1 = listFeatures;
    var markdownFeatures_1 = markdownFeatures;
    var quoteFeatures_1 = quoteFeatures;
    var shortcutFeatures_1 = shortcutFeatures;
    var structuredNodeFeatures_1 = structuredNodeFeatures;
    var tableFeatures_1 = tableFeatures;
    var textFeatures_1 = textFeatures;
    var allFeatures = __assign$8(__assign$8(__assign$8(__assign$8(__assign$8(__assign$8(__assign$8(__assign$8(__assign$8(__assign$8({}, listFeatures_1.ListFeatures), quoteFeatures_1.QuoteFeatures), tableFeatures_1.TableFeatures), structuredNodeFeatures_1.StructuredNodeFeatures), autoLinkFeatures_1.AutoLinkFeatures), shortcutFeatures_1.ShortcutFeatures), cursorFeatures_1.CursorFeatures), markdownFeatures_1.MarkdownFeatures), entityFeatures_1.EntityFeatures), textFeatures_1.TextFeatures);
    /**
     * Get all content edit features provided by roosterjs
     */
    function getAllFeatures() {
        return allFeatures;
    }
    getAllFeatures$1.default = getAllFeatures;

    Object.defineProperty(ContentEdit$1, "__esModule", { value: true });
    var getAllFeatures_1 = getAllFeatures$1;
    var roosterjs_editor_dom_1$x = lib$3;
    /**
     * An editor plugin to handle content edit event.
     * The following cases are included:
     * 1. Auto increase/decrease indentation on Tab, Shift+tab
     * 2. Enter, Backspace on empty list item
     * 3. Enter, Backspace on empty blockquote line
     * 4. Auto bullet/numbering
     * 5. Auto link
     * 6. Tab in table
     * 7. Up/Down in table
     * 8. Manage list style
     */
    var ContentEdit = /** @class */ (function () {
        /**
         * Create instance of ContentEdit plugin
         * @param settingsOverride An optional feature set to override default feature settings
         * @param additionalFeatures Optional. More features to add
         */
        function ContentEdit(settingsOverride, additionalFeatures) {
            this.settingsOverride = settingsOverride;
            this.additionalFeatures = additionalFeatures;
            this.editor = undefined;
            this.features = [];
        }
        /**
         * Get a friendly name of  this plugin
         */
        ContentEdit.prototype.getName = function () {
            return 'ContentEdit';
        };
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        ContentEdit.prototype.initialize = function (editor) {
            var _this = this;
            this.editor = editor;
            var allFeatures = (0, getAllFeatures_1.default)();
            (0, roosterjs_editor_dom_1$x.getObjectKeys)(allFeatures).forEach(function (key) {
                var feature = allFeatures[key];
                var hasSettingForKey = _this.settingsOverride && _this.settingsOverride[key] !== undefined;
                if ((hasSettingForKey && _this.settingsOverride[key]) ||
                    (!hasSettingForKey && !feature.defaultDisabled)) {
                    _this.features.push(feature);
                }
            });
            this.features = this.features.concat(this.additionalFeatures || []);
            this.features.forEach(function (feature) { return _this.editor.addContentEditFeature(feature); });
        };
        ContentEdit.prototype.disposeFeatures = function () {
            var _this = this;
            if (this.editor) {
                this.features.forEach(function (feature) { return _this.editor.removeContentEditFeature(feature); });
            }
            this.features = [];
        };
        /**
         * Dispose this plugin
         */
        ContentEdit.prototype.dispose = function () {
            this.disposeFeatures();
            this.editor = undefined;
        };
        return ContentEdit;
    }());
    ContentEdit$1.default = ContentEdit;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAllFeatures = exports.ContentEdit = void 0;
    var ContentEdit_1 = ContentEdit$1;
    Object.defineProperty(exports, "ContentEdit", { enumerable: true, get: function () { return ContentEdit_1.default; } });
    var getAllFeatures_1 = getAllFeatures$1;
    Object.defineProperty(exports, "getAllFeatures", { enumerable: true, get: function () { return getAllFeatures_1.default; } });

    }(ContentEdit$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(ContentEdit$2, exports);

    }(ContentEdit$3));

    var ContextMenu$3 = {};

    var ContextMenu$2 = {};

    var ContextMenu$1 = {};

    Object.defineProperty(ContextMenu$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$w = lib$3;
    /**
     * An editor plugin that support showing a context menu using render() function from options parameter
     */
    var ContextMenu = /** @class */ (function () {
        /**
         * Create a new instance of ContextMenu class
         * @param options An options object to determine how to show/hide the context menu
         */
        function ContextMenu(options) {
            var _this = this;
            this.options = options;
            this.container = null;
            this.editor = null;
            this.isMenuShowing = false;
            this.onDismiss = function () {
                var _a, _b;
                if (_this.container && _this.isMenuShowing) {
                    (_b = (_a = _this.options).dismiss) === null || _b === void 0 ? void 0 : _b.call(_a, _this.container);
                    _this.isMenuShowing = false;
                }
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        ContextMenu.prototype.getName = function () {
            return 'ContextMenu';
        };
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        ContextMenu.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        ContextMenu.prototype.dispose = function () {
            var _a;
            this.onDismiss();
            if ((_a = this.container) === null || _a === void 0 ? void 0 : _a.parentNode) {
                this.container.parentNode.removeChild(this.container);
                this.container = null;
            }
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        ContextMenu.prototype.onPluginEvent = function (event) {
            if (event.eventType == 16 /* ContextMenu */ && event.items.length > 0) {
                var rawEvent = event.rawEvent, items = event.items;
                this.onDismiss();
                if (!this.options.allowDefaultMenu) {
                    rawEvent.preventDefault();
                }
                if (this.initContainer(rawEvent.pageX, rawEvent.pageY)) {
                    this.options.render(this.container, items, this.onDismiss);
                    this.isMenuShowing = true;
                }
            }
        };
        ContextMenu.prototype.initContainer = function (x, y) {
            var _a, _b;
            if (!this.container && this.editor) {
                this.container = (0, roosterjs_editor_dom_1$w.createElement)(5 /* ContextMenuWrapper */, this.editor.getDocument());
                this.editor.getDocument().body.appendChild(this.container);
            }
            (_a = this.container) === null || _a === void 0 ? void 0 : _a.style.setProperty('left', x + 'px');
            (_b = this.container) === null || _b === void 0 ? void 0 : _b.style.setProperty('top', y + 'px');
            return !!this.container;
        };
        return ContextMenu;
    }());
    ContextMenu$1.default = ContextMenu;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextMenu = void 0;
    var ContextMenu_1 = ContextMenu$1;
    Object.defineProperty(exports, "ContextMenu", { enumerable: true, get: function () { return ContextMenu_1.default; } });

    }(ContextMenu$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(ContextMenu$2, exports);

    }(ContextMenu$3));

    var CustomReplace$2 = {};

    var CustomReplace$1 = {};

    var CustomReplace = {};

    Object.defineProperty(CustomReplace, "__esModule", { value: true });
    var makeReplacement = function (sourceString, replacementHTML, matchSourceCaseSensitive, shouldReplace) { return ({
        sourceString: sourceString,
        replacementHTML: replacementHTML,
        matchSourceCaseSensitive: matchSourceCaseSensitive,
        shouldReplace: shouldReplace,
    }); };
    var defaultReplacements = [
        makeReplacement(':)', '', true),
        makeReplacement(';)', '', true),
        makeReplacement(':O', '', true),
        makeReplacement(':o', '', true),
        makeReplacement('<3', '', true),
    ];
    /**
     * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the
     * content edit feature
     */
    var CustomReplacePlugin = /** @class */ (function () {
        /**
         * Create instance of CustomReplace plugin
         * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied
         */
        function CustomReplacePlugin(replacements) {
            if (replacements === void 0) { replacements = defaultReplacements; }
            this.longestReplacementLength = null;
            this.editor = null;
            this.replacements = null;
            this.replacementEndCharacters = null;
            this.updateReplacements(replacements);
        }
        /**
         * Set the replacements that this plugin is looking for.
         * @param newReplacements new set of replacements for this plugin
         */
        CustomReplacePlugin.prototype.updateReplacements = function (newReplacements) {
            this.replacements = newReplacements;
            this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);
            this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);
        };
        /**
         * Get a friendly name of this plugin
         */
        CustomReplacePlugin.prototype.getName = function () {
            return 'CustomReplace';
        };
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        CustomReplacePlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        CustomReplacePlugin.prototype.dispose = function () {
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        CustomReplacePlugin.prototype.onPluginEvent = function (event) {
            var _this = this;
            var _a;
            if (event.eventType != 3 /* Input */ || !this.editor || this.editor.isInIME()) {
                return;
            }
            // Exit early on input events that do not insert a replacement's final character.
            if (!event.rawEvent.data || !((_a = this.replacementEndCharacters) === null || _a === void 0 ? void 0 : _a.has(event.rawEvent.data))) {
                return;
            }
            // Get the matching replacement
            var searcher = this.editor.getContentSearcherOfCursor(event);
            if (!searcher || this.longestReplacementLength == null) {
                return;
            }
            var stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);
            var replacement = this.getMatchingReplacement(stringToSearch);
            if (!replacement ||
                (replacement.shouldReplace &&
                    searcher &&
                    !replacement.shouldReplace(replacement, searcher.getWordBefore(), this.editor))) {
                return;
            }
            // Reconstruct a selection of the text on the document that matches the
            // replacement we selected.
            var matchingText = searcher.getSubStringBefore(replacement.sourceString.length);
            var matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);
            // parse the html string off the dom and inline the resulting element.
            var document = this.editor.getDocument();
            var parsingSpan = document.createElement('span');
            parsingSpan.innerHTML = this.editor.getTrustedHTMLHandler()(replacement.replacementHTML);
            var nodeToInsert = parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;
            // Switch the node for the selection range
            if (matchingRange) {
                this.editor.addUndoSnapshot(function () {
                    var _a;
                    matchingRange.deleteContents();
                    matchingRange.insertNode(nodeToInsert);
                    (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.select(nodeToInsert, -1 /* End */);
                }, undefined /*changeSource*/, true /*canUndoByBackspace*/);
            }
        };
        CustomReplacePlugin.prototype.getMatchingReplacement = function (stringToSearch) {
            if (stringToSearch.length == 0 || !this.replacements) {
                return null;
            }
            var originalStringToSearch = stringToSearch.replace(/\s/g, ' ');
            var lowerCaseStringToSearch = originalStringToSearch.toLocaleLowerCase();
            for (var _i = 0, _a = this.replacements; _i < _a.length; _i++) {
                var replacement = _a[_i];
                var _b = replacement.matchSourceCaseSensitive
                    ? [originalStringToSearch, replacement.sourceString]
                    : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()], sourceMatch = _b[0], replacementMatch = _b[1];
                if (sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==
                    replacementMatch) {
                    return replacement;
                }
            }
            return null;
        };
        return CustomReplacePlugin;
    }());
    CustomReplace.default = CustomReplacePlugin;
    function getLongestReplacementSourceLength(replacements) {
        return Math.max.apply(null, replacements.map(function (replacement) { return replacement.sourceString.length; }));
    }
    function getReplacementEndCharacters(replacements) {
        var endChars = new Set();
        for (var _i = 0, replacements_1 = replacements; _i < replacements_1.length; _i++) {
            var replacement = replacements_1[_i];
            var sourceString = replacement.sourceString;
            if (sourceString.length == 0) {
                continue;
            }
            var lastChar = sourceString[sourceString.length - 1];
            if (!replacement.matchSourceCaseSensitive) {
                endChars.add(lastChar.toLocaleLowerCase());
                endChars.add(lastChar.toLocaleUpperCase());
            }
            else {
                endChars.add(lastChar);
            }
        }
        return endChars;
    }

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CustomReplace = void 0;
    var CustomReplace_1 = CustomReplace;
    Object.defineProperty(exports, "CustomReplace", { enumerable: true, get: function () { return CustomReplace_1.default; } });

    }(CustomReplace$1));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(CustomReplace$1, exports);

    }(CustomReplace$2));

    var CutPasteListChain$3 = {};

    var CutPasteListChain$2 = {};

    var CutPasteListChain$1 = {};

    Object.defineProperty(CutPasteListChain$1, "__esModule", { value: true });
    var roosterjs_editor_api_1$6 = lib$1;
    var roosterjs_editor_dom_1$v = lib$3;
    /**
     * Maintain list numbers of list chain when content is modified by cut/paste/drag&drop
     */
    var CutPasteListChain = /** @class */ (function () {
        function CutPasteListChain() {
            var _this = this;
            this.chains = null;
            this.expectedChangeSource = null;
            this.editor = null;
            this.disposer = null;
            this.onDrop = function () {
                _this.cacheListChains("Drop" /* Drop */);
            };
        }
        /**
         * Get a friendly name of this plugin
         */
        CutPasteListChain.prototype.getName = function () {
            return 'CutPasteListChain';
        };
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        CutPasteListChain.prototype.initialize = function (editor) {
            this.editor = editor;
            this.disposer = this.editor.addDomEventHandler('drop', this.onDrop);
        };
        /**
         * Dispose this plugin
         */
        CutPasteListChain.prototype.dispose = function () {
            var _a;
            (_a = this.disposer) === null || _a === void 0 ? void 0 : _a.call(this);
            this.disposer = null;
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        CutPasteListChain.prototype.onPluginEvent = function (event) {
            switch (event.eventType) {
                case 9 /* BeforeCutCopy */:
                    if (event.isCut) {
                        this.cacheListChains("Cut" /* Cut */);
                    }
                    break;
                case 10 /* BeforePaste */:
                    this.cacheListChains("Paste" /* Paste */);
                    break;
                case 7 /* ContentChanged */:
                    if (this.chains &&
                        this.chains.length > 0 &&
                        this.expectedChangeSource == event.source &&
                        this.editor) {
                        (0, roosterjs_editor_api_1$6.commitListChains)(this.editor, this.chains);
                        this.chains = null;
                        this.expectedChangeSource = null;
                    }
                    break;
            }
        };
        CutPasteListChain.prototype.cacheListChains = function (source) {
            var _a;
            var selectedRegions = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectedRegions();
            if (selectedRegions) {
                this.chains = roosterjs_editor_dom_1$v.VListChain.createListChains(selectedRegions);
                this.expectedChangeSource = source;
            }
        };
        return CutPasteListChain;
    }());
    CutPasteListChain$1.default = CutPasteListChain;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CutPasteListChain = void 0;
    var CutPasteListChain_1 = CutPasteListChain$1;
    Object.defineProperty(exports, "CutPasteListChain", { enumerable: true, get: function () { return CutPasteListChain_1.default; } });

    }(CutPasteListChain$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(CutPasteListChain$2, exports);

    }(CutPasteListChain$3));

    var HyperLink$3 = {};

    var HyperLink$2 = {};

    var HyperLink$1 = {};

    Object.defineProperty(HyperLink$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$u = lib$3;
    /**
     * An editor plugin that show a tooltip for existing link
     */
    var HyperLink = /** @class */ (function () {
        /**
         * Create a new instance of HyperLink class
         * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.
         * Default value is to return the href itself. If null, there will be no tooltip text.
         * @param target (Optional) Target window name for hyperlink. If null, will use "_blank"
         * @param onLinkClick (Optional) Open link callback (return false to use default behavior)
         */
        function HyperLink(getTooltipCallback, target, onLinkClick) {
            var _this = this;
            if (getTooltipCallback === void 0) { getTooltipCallback = function (href) { return href; }; }
            this.getTooltipCallback = getTooltipCallback;
            this.target = target;
            this.onLinkClick = onLinkClick;
            this.originalHref = null;
            this.trackedLink = null;
            this.editor = null;
            this.disposer = null;
            this.onMouse = function (e) {
                var _a, _b;
                var a = (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor('a[href]', e.target);
                var href = a && _this.tryGetHref(a);
                if (href) {
                    (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.setEditorDomAttribute('title', e.type == 'mouseover' ? _this.getTooltipCallback(href, a) : null);
                }
            };
            this.onBlur = function (e) {
                if (_this.trackedLink) {
                    _this.updateLinkHrefIfShouldUpdate();
                }
                _this.resetLinkTracking();
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        HyperLink.prototype.getName = function () {
            return 'Hyperlink';
        };
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        HyperLink.prototype.initialize = function (editor) {
            this.editor = editor;
            this.disposer = editor.addDomEventHandler({
                mouseover: this.onMouse,
                mouseout: this.onMouse,
                blur: this.onBlur,
            });
        };
        /**
         * Dispose this plugin
         */
        HyperLink.prototype.dispose = function () {
            if (this.disposer) {
                this.disposer();
                this.disposer = null;
            }
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        HyperLink.prototype.onPluginEvent = function (event) {
            var _a, _b, _c;
            if (event.eventType == 6 /* MouseUp */ ||
                (event.eventType == 2 /* KeyUp */ &&
                    (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == 32 /* SPACE */)) ||
                event.eventType == 7 /* ContentChanged */) {
                var anchor = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor('A[href]', undefined /*startFrom*/, event);
                var shouldCheckUpdateLink = (anchor && anchor !== this.trackedLink) ||
                    event.eventType == 2 /* KeyUp */ ||
                    event.eventType == 7 /* ContentChanged */;
                if (this.trackedLink &&
                    (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)) {
                    // If cursor has moved out of previously tracked link
                    // update link href if display text doesn't match href anymore.
                    if (shouldCheckUpdateLink) {
                        this.updateLinkHrefIfShouldUpdate();
                    }
                    // If the link's href value was edited, or the cursor has moved out of the
                    // previously tracked link, stop tracking the link.
                    this.resetLinkTracking();
                }
                // Cache link and href value if its href attribute currently matches its display text
                if (!this.trackedLink && anchor && this.doesLinkDisplayMatchHref(anchor)) {
                    this.trackedLink = anchor;
                    this.originalHref = this.tryGetHref(anchor);
                }
            }
            if (event.eventType == 6 /* MouseUp */) {
                var anchor = (_b = this.editor) === null || _b === void 0 ? void 0 : _b.getElementAtCursor('A', event.rawEvent.srcElement);
                if (anchor) {
                    if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {
                        return;
                    }
                    var href = void 0;
                    if ((href = this.tryGetHref(anchor)) &&
                        (0, roosterjs_editor_dom_1$u.isCtrlOrMetaPressed)(event.rawEvent) &&
                        event.rawEvent.button === 0) {
                        event.rawEvent.preventDefault();
                        try {
                            var target = this.target || '_blank';
                            var window_1 = (_c = this.editor) === null || _c === void 0 ? void 0 : _c.getDocument().defaultView;
                            window_1 === null || window_1 === void 0 ? void 0 : window_1.open(href, target);
                        }
                        catch (_d) { }
                    }
                }
            }
        };
        /**
         * Try get href from an anchor element
         * The reason this is put in a try-catch is that
         * it has been seen that accessing href may throw an exception, in particular on IE/Edge
         */
        HyperLink.prototype.tryGetHref = function (anchor) {
            try {
                return anchor ? anchor.href : null;
            }
            catch (_a) {
                return null;
            }
        };
        /**
         * Determines if KeyboardEvent is meant to edit content
         */
        HyperLink.prototype.isContentEditValue = function (event) {
            return ((0, roosterjs_editor_dom_1$u.isCharacterValue)(event) || event.which == 8 /* BACKSPACE */ || event.which == 46 /* DELETE */);
        };
        /**
         * Updates the href of the tracked link if the display text doesn't match href anymore
         */
        HyperLink.prototype.updateLinkHrefIfShouldUpdate = function () {
            if (this.trackedLink && !this.doesLinkDisplayMatchHref(this.trackedLink)) {
                this.updateLinkHref();
            }
        };
        /**
         * Clears the tracked link and its original href value so that it's back to default state
         */
        HyperLink.prototype.resetLinkTracking = function () {
            this.trackedLink = null;
            this.originalHref = '';
        };
        /**
         * Compares the normalized URL of inner text of element to its href to see if they match.
         */
        HyperLink.prototype.doesLinkDisplayMatchHref = function (element) {
            if (element) {
                var display = element.innerText.trim();
                // We first escape the display text so that any text passed into the regex is not
                // treated as a special character.
                var escapedDisplay = display.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                var rule = new RegExp("^(?:https?:\\/\\/)?" + escapedDisplay + "\\/?", 'i');
                var href = this.tryGetHref(element);
                if (href !== null) {
                    return rule.test(href);
                }
            }
            return false;
        };
        /**
         * Update href of an element in place to new display text if it's a valid URL
         */
        HyperLink.prototype.updateLinkHref = function () {
            var _this = this;
            var _a;
            if (this.trackedLink) {
                var linkData_1 = (0, roosterjs_editor_dom_1$u.matchLink)(this.trackedLink.innerText.trim());
                if (linkData_1 !== null) {
                    (_a = this.editor) === null || _a === void 0 ? void 0 : _a.addUndoSnapshot(function () {
                        _this.trackedLink.href = linkData_1.normalizedUrl;
                    });
                }
            }
        };
        return HyperLink;
    }());
    HyperLink$1.default = HyperLink;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HyperLink = void 0;
    var HyperLink_1 = HyperLink$1;
    Object.defineProperty(exports, "HyperLink", { enumerable: true, get: function () { return HyperLink_1.default; } });

    }(HyperLink$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(HyperLink$2, exports);

    }(HyperLink$3));

    var ImageEdit$3 = {};

    var ImageEdit$2 = {};

    var ImageEdit$1 = {};

    var applyChange$1 = {};

    var checkEditInfoState = {};

    (function (exports) {
    var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageEditInfoState = void 0;
    var RESIZE_KEYS = ['widthPx', 'heightPx'];
    var ROTATE_KEYS = ['angleRad'];
    var CROP_KEYS = [
        'leftPercent',
        'rightPercent',
        'topPercent',
        'bottomPercent',
    ];
    var ROTATE_CROP_KEYS = __spreadArray(__spreadArray([], ROTATE_KEYS, true), CROP_KEYS, true);
    var ALL_KEYS = __spreadArray(__spreadArray([], ROTATE_CROP_KEYS, true), RESIZE_KEYS, true);
    (function (ImageEditInfoState) {
        /**
         * Invalid edit info. It means the given edit info object is either null,
         * or not all its member are of correct type
         */
        ImageEditInfoState[ImageEditInfoState["Invalid"] = 0] = "Invalid";
        /**
         * The edit info shows that it is only potentially edited by resizing action.
         * Image is not rotated or cropped, or event not changed at all.
         */
        ImageEditInfoState[ImageEditInfoState["ResizeOnly"] = 1] = "ResizeOnly";
        /**
         * When compare with another edit info, this value can be returned when both current
         * edit info and the other one are not been rotated, and they have same cropping
         * percentages. So that they can share the same image src, only width and height
         * need to be adjusted.
         */
        ImageEditInfoState[ImageEditInfoState["SameWithLast"] = 2] = "SameWithLast";
        /**
         * When this value is returned, it means the image is edited by either cropping or
         * rotation, or both. Image source can't be reused, need to generate a new image src
         * data uri.
         */
        ImageEditInfoState[ImageEditInfoState["FullyChanged"] = 3] = "FullyChanged";
    })(exports.ImageEditInfoState || (exports.ImageEditInfoState = {}));
    /**
     * @internal
     * Check the state of an edit info
     * @param editInfo The edit info to check
     * @param compareTo An optional edit info to compare to
     * @returns If the source edit info is not valid (wrong type, missing field, ...), returns Invalid.
     * If the source edit info doesn't contain any rotation or cropping, returns ResizeOnly
     * If the compare edit info exists, and both of them don't contain rotation, and the have same cropping values,
     * returns SameWithLast. Otherwise, returns FullyChanged
     */
    function checkEditInfoState(editInfo, compareTo) {
        if (!editInfo || !editInfo.src || ALL_KEYS.some(function (key) { return !isNumber(editInfo[key]); })) {
            return 0 /* Invalid */;
        }
        else if (ROTATE_CROP_KEYS.every(function (key) { return areSameNumber(editInfo[key], 0); }) &&
            !editInfo.flippedHorizontal &&
            !editInfo.flippedVertical &&
            (!compareTo || (compareTo && editInfo.angleRad === compareTo.angleRad))) {
            return 1 /* ResizeOnly */;
        }
        else if (compareTo &&
            ROTATE_KEYS.every(function (key) { return areSameNumber(editInfo[key], 0); }) &&
            ROTATE_KEYS.every(function (key) { return areSameNumber(compareTo[key], 0); }) &&
            CROP_KEYS.every(function (key) { return areSameNumber(editInfo[key], compareTo[key]); }) &&
            compareTo.flippedHorizontal === editInfo.flippedHorizontal &&
            compareTo.flippedVertical === editInfo.flippedVertical) {
            return 2 /* SameWithLast */;
        }
        else {
            return 3 /* FullyChanged */;
        }
    }
    exports.default = checkEditInfoState;
    function isNumber(o) {
        return typeof o === 'number';
    }
    function areSameNumber(n1, n2) {
        return Math.abs(n1 - n2) < 1e-3;
    }

    }(checkEditInfoState));

    var generateDataURL$1 = {};

    var getGeneratedImageSize$1 = {};

    Object.defineProperty(getGeneratedImageSize$1, "__esModule", { value: true });
    /**
     * @internal
     * Calculate the target size of an image.
     * For image that is not rotated, target size is the same with resizing/cropping size.
     * For image that is rotated, target size is calculated from resizing/cropping size and its rotate angle
     * Say an image is resized to 100w*100h, cropped 25% on each side, then rotated 45deg, so that cropped size
     * will be (both height and width) 100*(1-0.25-0,25) = 50px, then final image size will be 50*sqrt(2) = 71px
     * @param editInfo The edit info to calculate size from
     * @param beforeCrop True to calculate the full size of original image before crop, false to calculate the size
     * after crop
     * @returns A GeneratedImageSize object which contains original, visible and target target width and height of the image
     */
    function getGeneratedImageSize(editInfo, beforeCrop) {
        var width = editInfo.widthPx, height = editInfo.heightPx, angle = editInfo.angleRad, left = editInfo.leftPercent, right = editInfo.rightPercent, top = editInfo.topPercent, bottom = editInfo.bottomPercent;
        // Original image size before crop and rotate
        var originalWidth = width / (1 - left - right);
        var originalHeight = height / (1 - top - bottom);
        // Visible size
        var visibleWidth = beforeCrop ? originalWidth : width;
        var visibleHeight = beforeCrop ? originalHeight : height;
        // Target size after crop and rotate
        var targetWidth = Math.abs(visibleWidth * Math.cos(angle)) + Math.abs(visibleHeight * Math.sin(angle));
        var targetHeight = Math.abs(visibleWidth * Math.sin(angle)) + Math.abs(visibleHeight * Math.cos(angle));
        return {
            targetWidth: targetWidth,
            targetHeight: targetHeight,
            originalWidth: originalWidth,
            originalHeight: originalHeight,
            visibleWidth: visibleWidth,
            visibleHeight: visibleHeight,
        };
    }
    getGeneratedImageSize$1.default = getGeneratedImageSize;

    Object.defineProperty(generateDataURL$1, "__esModule", { value: true });
    var getGeneratedImageSize_1$2 = getGeneratedImageSize$1;
    /**
     * @internal
     * Generate new dataURL from an image and edit info
     * @param image The image to generate data URL from. It is supposed to have original src loaded
     * @param editInfo Edit info of the image
     * @returns A BASE64 encoded string with image prefix that represents the content of the generated image.
     * If there are rotate/crop/resize info in the edit info, the generated image will also reflect the result.
     * It is possible to throw exception since the original image may not be able to read its content from
     * the code, so better check canRegenerateImage() of the image first.
     * @throws Exception when fail to generate dataURL from canvas
     */
    function generateDataURL(image, editInfo) {
        var angle = editInfo.angleRad, width = editInfo.widthPx, height = editInfo.heightPx, bottom = editInfo.bottomPercent, left = editInfo.leftPercent, right = editInfo.rightPercent, top = editInfo.topPercent, naturalWidth = editInfo.naturalWidth, naturalHeight = editInfo.naturalHeight;
        var imageWidth = naturalWidth * (1 - left - right);
        var imageHeight = naturalHeight * (1 - top - bottom);
        var canvas = document.createElement('canvas');
        var _a = (0, getGeneratedImageSize_1$2.default)(editInfo), targetWidth = _a.targetWidth, targetHeight = _a.targetHeight;
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        var context = canvas.getContext('2d');
        if (context) {
            context.translate(targetWidth / 2, targetHeight / 2);
            context.rotate(angle);
            context.scale(editInfo.flippedHorizontal ? -1 : 1, editInfo.flippedVertical ? -1 : 1);
            context.drawImage(image, naturalWidth * left, naturalHeight * top, imageWidth, imageHeight, -width / 2, -height / 2, width, height);
        }
        return canvas.toDataURL('image/png', 1.0);
    }
    generateDataURL$1.default = generateDataURL;

    var editInfo = {};

    Object.defineProperty(editInfo, "__esModule", { value: true });
    editInfo.getEditInfoFromImage = editInfo.deleteEditInfo = editInfo.saveEditInfo = void 0;
    var checkEditInfoState_1$1 = checkEditInfoState;
    var roosterjs_editor_dom_1$t = lib$3;
    /**
     * @internal
     * Save edit info to image
     * @param image The image to save edit info to
     * @param editInfo The edit info to save
     */
    function saveEditInfo(image, editInfo) {
        if (image) {
            (0, roosterjs_editor_dom_1$t.setMetadata)(image, editInfo);
        }
    }
    editInfo.saveEditInfo = saveEditInfo;
    /**
     * @internal
     * Delete edit info of an image if any
     * @param image The image to delete edit info from
     */
    function deleteEditInfo(image) {
        if (image) {
            (0, roosterjs_editor_dom_1$t.removeMetadata)(image);
        }
    }
    editInfo.deleteEditInfo = deleteEditInfo;
    /**
     * @internal
     * Get image edit info from an image. If the image doesn't have edit info, create one from this image.
     * When create new edit info, it will have width/height set to the image's current client width/height, and
     * natural width/height set to the image's natural width/height, src set to its current src, and all
     * other fields set to 0.
     * @param image The image to get edit info from
     */
    function getEditInfoFromImage(image) {
        var obj = (0, roosterjs_editor_dom_1$t.getMetadata)(image);
        return !obj || (0, checkEditInfoState_1$1.default)(obj) == 0 /* Invalid */
            ? getInitialEditInfo(image)
            : obj;
    }
    editInfo.getEditInfoFromImage = getEditInfoFromImage;
    function getInitialEditInfo(image) {
        return {
            src: image.getAttribute('src') || '',
            widthPx: image.clientWidth,
            heightPx: image.clientHeight,
            naturalWidth: image.naturalWidth,
            naturalHeight: image.naturalHeight,
            leftPercent: 0,
            rightPercent: 0,
            topPercent: 0,
            bottomPercent: 0,
            angleRad: 0,
        };
    }

    Object.defineProperty(applyChange$1, "__esModule", { value: true });
    var checkEditInfoState_1 = checkEditInfoState;
    var generateDataURL_1 = generateDataURL$1;
    var getGeneratedImageSize_1$1 = getGeneratedImageSize$1;
    var editInfo_1$4 = editInfo;
    /**
     * @internal
     * Apply changes from the edit info of an image, write result to the image
     * @param editor The editor object that contains the image
     * @param image The image to apply the change
     * @param editInfo Edit info that contains the changed information of the image
     * @param previousSrc Last src value of the image before the change was made
     * @param editingImage (optional) Image in editing state
     */
    function applyChange(editor, image, editInfo, previousSrc, wasResized, editingImage) {
        var newSrc = '';
        var initEditInfo = (0, editInfo_1$4.getEditInfoFromImage)(editingImage !== null && editingImage !== void 0 ? editingImage : image);
        var state = (0, checkEditInfoState_1.default)(editInfo, initEditInfo);
        switch (state) {
            case 1 /* ResizeOnly */:
                // For resize only case, no need to generate a new image, just reuse the original one
                newSrc = editInfo.src;
                break;
            case 2 /* SameWithLast */:
                // For SameWithLast case, image may be resized but the content is still the same with last one,
                // so no need to create a new image, but just reuse last one
                newSrc = previousSrc;
                break;
            case 3 /* FullyChanged */:
                // For other cases (cropped, rotated, ...) we need to create a new image to reflect the change
                newSrc = (0, generateDataURL_1.default)(editingImage !== null && editingImage !== void 0 ? editingImage : image, editInfo);
                break;
        }
        var srcChanged = newSrc != previousSrc;
        if (srcChanged) {
            // If the src is changed, fire an EditImage event so that plugins knows that a new image is used, and can
            // replace the new src with some other string and it will be used and set to the image
            var event_1 = editor.triggerPluginEvent(19 /* EditImage */, {
                image: image,
                originalSrc: editInfo.src,
                previousSrc: previousSrc,
                newSrc: newSrc,
            });
            newSrc = event_1.newSrc;
        }
        if (newSrc == editInfo.src) {
            // If newSrc is the same with original one, it means there is only size change, but no rotation, no cropping,
            // so we don't need to keep edit info, we can delete it
            (0, editInfo_1$4.deleteEditInfo)(image);
        }
        else {
            // Otherwise, save the new edit info to the image so that next time when we edit the same image, we know
            // the edit info
            (0, editInfo_1$4.saveEditInfo)(image, editInfo);
        }
        // Write back the change to image, and set its new size
        var _a = (0, getGeneratedImageSize_1$1.default)(editInfo), targetWidth = _a.targetWidth, targetHeight = _a.targetHeight;
        image.src = newSrc;
        if (wasResized || state == 3 /* FullyChanged */) {
            image.width = targetWidth;
            image.height = targetHeight;
            image.style.width = targetWidth + 'px';
            image.style.height = targetHeight + 'px';
        }
    }
    applyChange$1.default = applyChange;

    var canRegenerateImage$1 = {};

    Object.defineProperty(canRegenerateImage$1, "__esModule", { value: true });
    /**
     * Check if we can regenerate edited image from the source image.
     * An image can't regenerate result when there is CORS issue of the source content.
     * @param img The image element to test
     * @returns True when we can regenerate the edited image, otherwise false
     */
    function canRegenerateImage(img) {
        if (!img) {
            return false;
        }
        try {
            var canvas = img.ownerDocument.createElement('canvas');
            canvas.width = 10;
            canvas.height = 10;
            var context = canvas.getContext('2d');
            if (context) {
                context.drawImage(img, 0, 0);
                context.getImageData(0, 0, 1, 1);
                return true;
            }
            return false;
        }
        catch (_a) {
            return false;
        }
    }
    canRegenerateImage$1.default = canRegenerateImage;

    var DragAndDropHelper$1 = {};

    Object.defineProperty(DragAndDropHelper$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$s = lib$3;
    /**
     * Generate event names and getXY function based on different platforms to be compatible with desktop and mobile browsers
     */
    var MOUSE_EVENT_INFO_DESKTOP = (function () {
        return {
            MOUSEDOWN: 'mousedown',
            MOUSEMOVE: 'mousemove',
            MOUSEUP: 'mouseup',
            getPageXY: getMouseEventPageXY,
        };
    })();
    var MOUSE_EVENT_INFO_MOBILE = (function () {
        return {
            MOUSEDOWN: 'touchstart',
            MOUSEMOVE: 'touchmove',
            MOUSEUP: 'touchend',
            getPageXY: getTouchEventPageXY,
        };
    })();
    function getMouseEventPageXY(e) {
        return [e.pageX, e.pageY];
    }
    function getTouchEventPageXY(e) {
        var pageX = 0;
        var pageY = 0;
        if (e.targetTouches && e.targetTouches.length > 0) {
            var touch = e.targetTouches[0];
            pageX = touch.pageX;
            pageY = touch.pageY;
        }
        return [pageX, pageY];
    }
    /**
     * @internal
     * A helper class to help manage drag and drop to an HTML element
     */
    var DragAndDropHelper = /** @class */ (function () {
        /**
         * Create a new instance of DragAndDropHelper class
         * @param trigger The trigger element. When user start drag on this element,
         * events will be fired to the handler object
         * @param context Context object that will be passed to handler function when event is fired,
         * so that the handler object knows which element it is triggered from.
         * @param onSubmit A callback that will be invoked when event handler in handler object returns true
         * @param handler The event handler object, see DragAndDropHandler interface for more information
         * @param zoomScale The zoom scale of the editor
         * @param forceMobile A boolean to force the use of touch controls for the helper
         */
        function DragAndDropHelper(trigger, context, onSubmit, handler, zoomScale, forceMobile) {
            var _this = this;
            this.trigger = trigger;
            this.context = context;
            this.onSubmit = onSubmit;
            this.handler = handler;
            this.zoomScale = zoomScale;
            this.initX = 0;
            this.initY = 0;
            this.initValue = undefined;
            this.onMouseDown = function (e) {
                var _a;
                var _b, _c;
                e.preventDefault();
                e.stopPropagation();
                _this.addDocumentEvents();
                _a = _this.dndMouse.getPageXY(e), _this.initX = _a[0], _this.initY = _a[1];
                _this.initValue = (_c = (_b = _this.handler).onDragStart) === null || _c === void 0 ? void 0 : _c.call(_b, _this.context, e);
            };
            this.onMouseMove = function (e) {
                var _a, _b, _c;
                e.preventDefault();
                var _d = _this.dndMouse.getPageXY(e), pageX = _d[0], pageY = _d[1];
                var deltaX = (pageX - _this.initX) / _this.zoomScale;
                var deltaY = (pageY - _this.initY) / _this.zoomScale;
                if (_this.initValue &&
                    ((_b = (_a = _this.handler).onDragging) === null || _b === void 0 ? void 0 : _b.call(_a, _this.context, e, _this.initValue, deltaX, deltaY))) {
                    (_c = _this.onSubmit) === null || _c === void 0 ? void 0 : _c.call(_this, _this.context, _this.trigger);
                }
            };
            this.onMouseUp = function (e) {
                var _a, _b, _c;
                e.preventDefault();
                _this.removeDocumentEvents();
                if ((_b = (_a = _this.handler).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, _this.context, e, _this.initValue)) {
                    (_c = _this.onSubmit) === null || _c === void 0 ? void 0 : _c.call(_this, _this.context, _this.trigger);
                }
            };
            this.dndMouse =
                forceMobile || roosterjs_editor_dom_1$s.Browser.isMobileOrTablet
                    ? MOUSE_EVENT_INFO_MOBILE
                    : MOUSE_EVENT_INFO_DESKTOP;
            trigger.addEventListener(this.dndMouse.MOUSEDOWN, this.onMouseDown);
        }
        /**
         * Dispose this object, remove all event listeners that has been attached
         */
        DragAndDropHelper.prototype.dispose = function () {
            this.trigger.removeEventListener(this.dndMouse.MOUSEDOWN, this.onMouseDown);
            this.removeDocumentEvents();
        };
        Object.defineProperty(DragAndDropHelper.prototype, "mouseType", {
            get: function () {
                return this.dndMouse == MOUSE_EVENT_INFO_MOBILE ? 'touch' : 'mouse';
            },
            enumerable: false,
            configurable: true
        });
        DragAndDropHelper.prototype.addDocumentEvents = function () {
            var doc = this.trigger.ownerDocument;
            doc.addEventListener(this.dndMouse.MOUSEMOVE, this.onMouseMove, true /*useCapture*/);
            doc.addEventListener(this.dndMouse.MOUSEUP, this.onMouseUp, true /*useCapture*/);
        };
        DragAndDropHelper.prototype.removeDocumentEvents = function () {
            var doc = this.trigger.ownerDocument;
            doc.removeEventListener(this.dndMouse.MOUSEMOVE, this.onMouseMove, true /*useCapture*/);
            doc.removeEventListener(this.dndMouse.MOUSEUP, this.onMouseUp, true /*useCapture*/);
        };
        return DragAndDropHelper;
    }());
    DragAndDropHelper$1.default = DragAndDropHelper;

    var Cropper = {};

    var Resizer = {};

    var __assign$7 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$7 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$7.apply(this, arguments);
    };
    Object.defineProperty(Resizer, "__esModule", { value: true });
    Resizer.getResizeBordersHTML = Resizer.getSideResizeHTML = Resizer.getCornerResizeHTML = Resizer.doubleCheckResize = Resizer.rotateCoordinate = Resizer.Resizer = void 0;
    var HandleTypes;
    (function (HandleTypes) {
        HandleTypes[HandleTypes["SquareHandles"] = 0] = "SquareHandles";
        HandleTypes[HandleTypes["CircularHandlesCorner"] = 1] = "CircularHandlesCorner";
    })(HandleTypes || (HandleTypes = {}));
    var RESIZE_HANDLE_SIZE = 10;
    var RESIZE_HANDLE_MARGIN = 3;
    var Xs$1 = ['w', '', 'e'];
    var Ys$1 = ['s', '', 'n'];
    /**
     * @internal
     * The resize drag and drop handler
     */
    Resizer.Resizer = {
        onDragStart: function (_a) {
            var editInfo = _a.editInfo;
            return (__assign$7({}, editInfo));
        },
        onDragging: function (_a, e, base, deltaX, deltaY) {
            var _b;
            var x = _a.x, y = _a.y, editInfo = _a.editInfo, options = _a.options;
            var ratio = base.widthPx > 0 && base.heightPx > 0 ? (base.widthPx * 1.0) / base.heightPx : 0;
            _b = rotateCoordinate(deltaX, deltaY, editInfo.angleRad), deltaX = _b[0], deltaY = _b[1];
            if (options.minWidth !== undefined && options.minHeight !== undefined) {
                var horizontalOnly = x == '';
                var verticalOnly = y == '';
                var shouldPreserveRatio = !(horizontalOnly || verticalOnly) && (options.preserveRatio || e.shiftKey);
                var newWidth = horizontalOnly
                    ? base.widthPx
                    : Math.max(base.widthPx + deltaX * (x == 'w' ? -1 : 1), options.minWidth);
                var newHeight = verticalOnly
                    ? base.heightPx
                    : Math.max(base.heightPx + deltaY * (y == 'n' ? -1 : 1), options.minHeight);
                if (shouldPreserveRatio && ratio > 0) {
                    if (ratio > 1) {
                        // first sure newHeight is rightcalculate newWidth
                        newWidth = newHeight * ratio;
                        if (newWidth < options.minWidth) {
                            newWidth = options.minWidth;
                            newHeight = newWidth / ratio;
                        }
                    }
                    else {
                        // first sure newWidth is rightcalculate newHeight
                        newHeight = newWidth / ratio;
                        if (newHeight < options.minHeight) {
                            newHeight = options.minHeight;
                            newWidth = newHeight * ratio;
                        }
                    }
                }
                editInfo.widthPx = newWidth;
                editInfo.heightPx = newHeight;
                return true;
            }
            else {
                return false;
            }
        },
    };
    /**
     * @internal Calculate the rotated x and y distance for mouse moving
     * @param x Original x distance
     * @param y Original y distance
     * @param angle Rotated angle, in radian
     * @returns rotated x and y distances
     */
    function rotateCoordinate(x, y, angle) {
        if (x == 0 && y == 0) {
            return [0, 0];
        }
        var hypotenuse = Math.sqrt(x * x + y * y);
        angle = Math.atan2(y, x) - angle;
        return [hypotenuse * Math.cos(angle), hypotenuse * Math.sin(angle)];
    }
    Resizer.rotateCoordinate = rotateCoordinate;
    /**
     * @internal
     * Double check if the changed size can satisfy current width of container.
     * When resize an image and preserve ratio, its size can be limited by the size of container.
     * So we need to check the actual size and calculate the size again
     * @param editInfo Edit info of the image
     * @param preserveRatio Whether w/h ratio need to be preserved
     * @param actualWidth Actual width of the image after resize
     * @param actualHeight Actual height of the image after resize
     */
    function doubleCheckResize(editInfo, preserveRatio, actualWidth, actualHeight) {
        var widthPx = editInfo.widthPx, heightPx = editInfo.heightPx;
        var ratio = heightPx > 0 ? widthPx / heightPx : 0;
        actualWidth = Math.floor(actualWidth);
        actualHeight = Math.floor(actualHeight);
        widthPx = Math.floor(widthPx);
        heightPx = Math.floor(heightPx);
        editInfo.widthPx = actualWidth;
        editInfo.heightPx = actualHeight;
        if (preserveRatio && ratio > 0 && (widthPx !== actualWidth || heightPx !== actualHeight)) {
            if (actualWidth < widthPx) {
                editInfo.heightPx = actualWidth / ratio;
            }
            else {
                editInfo.widthPx = actualHeight * ratio;
            }
        }
    }
    Resizer.doubleCheckResize = doubleCheckResize;
    /**
     * @internal
     * Get HTML for resize handles at the corners
     */
    function getCornerResizeHTML(_a, onShowResizeHandle) {
        var resizeBorderColor = _a.borderColor;
        var result = [];
        Xs$1.forEach(function (x) {
            return Ys$1.forEach(function (y) {
                var elementData = (x == '') == (y == '')
                    ? getResizeHandleHTML(x, y, resizeBorderColor, 1 /* CircularHandlesCorner */)
                    : null;
                if (onShowResizeHandle && elementData) {
                    onShowResizeHandle(elementData, x, y);
                }
                if (elementData) {
                    result.push(elementData);
                }
            });
        });
        return result;
    }
    Resizer.getCornerResizeHTML = getCornerResizeHTML;
    /**
     * @internal
     * Get HTML for resize handles on the sides
     */
    function getSideResizeHTML(_a, onShowResizeHandle) {
        var resizeBorderColor = _a.borderColor, isSmallImage = _a.isSmallImage;
        if (isSmallImage) {
            return null;
        }
        var result = [];
        Xs$1.forEach(function (x) {
            return Ys$1.forEach(function (y) {
                var elementData = (x == '') != (y == '')
                    ? getResizeHandleHTML(x, y, resizeBorderColor, 1 /* CircularHandlesCorner */)
                    : null;
                if (onShowResizeHandle && elementData) {
                    onShowResizeHandle(elementData, x, y);
                }
                if (elementData) {
                    result.push(elementData);
                }
            });
        });
        return result;
    }
    Resizer.getSideResizeHTML = getSideResizeHTML;
    /**
     * @internal
     * Get HTML for resize borders
     */
    function getResizeBordersHTML(_a) {
        var resizeBorderColor = _a.borderColor;
        return {
            tag: 'div',
            style: "position:absolute;left:0;right:0;top:0;bottom:0;border:solid 2px " + resizeBorderColor + ";pointer-events:none;",
        };
    }
    Resizer.getResizeBordersHTML = getResizeBordersHTML;
    function getResizeHandleHTML(x, y, borderColor, handleTypes) {
        var leftOrRight = x == 'w' ? 'left' : 'right';
        var topOrBottom = y == 'n' ? 'top' : 'bottom';
        var leftOrRightValue = x == '' ? '50%' : '0px';
        var topOrBottomValue = y == '' ? '50%' : '0px';
        var direction = y + x;
        return x == '' && y == ''
            ? null
            : {
                tag: 'div',
                style: "position:absolute;" + leftOrRight + ":" + leftOrRightValue + ";" + topOrBottom + ":" + topOrBottomValue,
                children: [
                    {
                        tag: 'div',
                        style: setHandleStyle[handleTypes](direction, topOrBottom, leftOrRight, borderColor),
                        className: "r_resizeH" /* ResizeHandle */,
                        dataset: { x: x, y: y },
                    },
                ],
            };
    }
    var setHandleStyle = {
        0: function (direction, leftOrRight, topOrBottom, borderColor) {
            return "position:relative;width:" + RESIZE_HANDLE_SIZE + "px;height:" + RESIZE_HANDLE_SIZE + "px;background-color: " + borderColor + ";cursor:" + direction + "-resize;" + topOrBottom + ":-" + RESIZE_HANDLE_MARGIN + "px;" + leftOrRight + ":-" + RESIZE_HANDLE_MARGIN + "px;";
        },
        1: function (direction, leftOrRight, topOrBottom) {
            return "position:relative;width:" + RESIZE_HANDLE_SIZE + "px;height:" + RESIZE_HANDLE_SIZE + "px;background-color: #FFFFFF;cursor:" + direction + "-resize;" + topOrBottom + ":-" + RESIZE_HANDLE_MARGIN + "px;" + leftOrRight + ":-" + RESIZE_HANDLE_MARGIN + "px;border-radius:100%;border: 2px solid #bfbfbf;box-shadow: 0px 0.36316px 1.36185px rgba(100, 100, 100, 0.25);";
        },
    };

    var __assign$6 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$6 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$6.apply(this, arguments);
    };
    Object.defineProperty(Cropper, "__esModule", { value: true });
    Cropper.getCropHTML = Cropper.Cropper = void 0;
    var Resizer_1$1 = Resizer;
    var CROP_HANDLE_SIZE = 22;
    var CROP_HANDLE_WIDTH = 7;
    var Xs = ['w', 'e'];
    var Ys = ['s', 'n'];
    var ROTATION = {
        sw: 0,
        nw: 90,
        ne: 180,
        se: 270,
    };
    /**
     * @internal
     * Crop handle for DragAndDropHelper
     */
    Cropper.Cropper = {
        onDragStart: function (_a) {
            var editInfo = _a.editInfo;
            return (__assign$6({}, editInfo));
        },
        onDragging: function (_a, e, base, dx, dy) {
            var _b;
            var editInfo = _a.editInfo, x = _a.x, y = _a.y, options = _a.options;
            _b = (0, Resizer_1$1.rotateCoordinate)(dx, dy, editInfo.angleRad), dx = _b[0], dy = _b[1];
            var widthPx = editInfo.widthPx, heightPx = editInfo.heightPx, leftPercent = editInfo.leftPercent, rightPercent = editInfo.rightPercent, topPercent = editInfo.topPercent, bottomPercent = editInfo.bottomPercent;
            var minWidth = options.minWidth, minHeight = options.minHeight;
            var widthPercent = 1 - leftPercent - rightPercent;
            var heightPercent = 1 - topPercent - bottomPercent;
            if (widthPercent > 0 &&
                heightPercent > 0 &&
                minWidth !== undefined &&
                minHeight !== undefined) {
                var fullWidth = widthPx / widthPercent;
                var fullHeight = heightPx / heightPercent;
                var newLeft = x != 'e'
                    ? crop(base.leftPercent, dx, fullWidth, rightPercent, minWidth)
                    : leftPercent;
                var newRight = x != 'w'
                    ? crop(base.rightPercent, -dx, fullWidth, leftPercent, minWidth)
                    : rightPercent;
                var newTop = y != 's'
                    ? crop(base.topPercent, dy, fullHeight, bottomPercent, minHeight)
                    : topPercent;
                var newBottom = y != 'n'
                    ? crop(base.bottomPercent, -dy, fullHeight, topPercent, minHeight)
                    : bottomPercent;
                editInfo.leftPercent = newLeft;
                editInfo.rightPercent = newRight;
                editInfo.topPercent = newTop;
                editInfo.bottomPercent = newBottom;
                editInfo.widthPx = fullWidth * (1 - newLeft - newRight);
                editInfo.heightPx = fullHeight * (1 - newTop - newBottom);
                return true;
            }
            else {
                return false;
            }
        },
    };
    function crop(basePercentage, deltaValue, fullValue, currentPercentage, minValue) {
        var maxValue = fullValue * (1 - currentPercentage) - minValue;
        var newValue = fullValue * basePercentage + deltaValue;
        var validValue = Math.max(Math.min(newValue, maxValue), 0);
        return validValue / fullValue;
    }
    /**
     * @internal
     * Get HTML for crop elements, including 4 overlays (to show dark shadow), 1 container and 4 crop handles
     */
    function getCropHTML() {
        var overlayHTML = {
            tag: 'div',
            style: 'position:absolute;background-color:rgb(0,0,0,0.5);pointer-events:none',
            className: "r_cropO" /* CropOverlay */,
        };
        var containerHTML = {
            tag: 'div',
            style: 'position:absolute;overflow:hidden',
            className: "r_cropC" /* CropContainer */,
            children: [],
        };
        if (containerHTML) {
            Xs.forEach(function (x) { return Ys.forEach(function (y) { var _a; return (_a = containerHTML.children) === null || _a === void 0 ? void 0 : _a.push(getCropHTMLInternal(x, y)); }); });
        }
        return [containerHTML, overlayHTML, overlayHTML, overlayHTML, overlayHTML];
    }
    Cropper.getCropHTML = getCropHTML;
    function getCropHTMLInternal(x, y) {
        var leftOrRight = x == 'w' ? 'left' : 'right';
        var topOrBottom = y == 'n' ? 'top' : 'bottom';
        var rotation = ROTATION[y + x];
        return {
            tag: 'div',
            className: "r_cropH" /* CropHandle */,
            style: "position:absolute;pointer-events:auto;cursor:" + y + x + "-resize;" + leftOrRight + ":0;" + topOrBottom + ":0;width:" + CROP_HANDLE_SIZE + "px;height:" + CROP_HANDLE_SIZE + "px;transform:rotate(" + rotation + "deg)",
            dataset: { x: x, y: y },
            children: getCropHandleHTML(),
        };
    }
    function getCropHandleHTML() {
        var result = [];
        [0, 1].forEach(function (layer) {
            return [0, 1].forEach(function (dir) {
                result.push(getCropHandleHTMLInternal(layer, dir));
            });
        });
        return result;
    }
    function getCropHandleHTMLInternal(layer, dir) {
        var position = dir == 0
            ? "right:" + layer + "px;height:" + (CROP_HANDLE_WIDTH - layer * 2) + "px;"
            : "top:" + layer + "px;width:" + (CROP_HANDLE_WIDTH - layer * 2) + "px;";
        var bgColor = layer == 0 ? 'white' : 'black';
        return {
            tag: 'div',
            style: "position:absolute;left:" + layer + "px;bottom:" + layer + "px;" + position + ";background-color:" + bgColor,
        };
    }

    var Rotator = {};

    var __assign$5 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$5 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$5.apply(this, arguments);
    };
    Object.defineProperty(Rotator, "__esModule", { value: true });
    Rotator.getRotateHTML = Rotator.updateRotateHandlePosition = Rotator.Rotator = void 0;
    var ROTATE_SIZE = 32;
    var ROTATE_GAP = 15;
    var DEG_PER_RAD = 180 / Math.PI;
    var DEFAULT_ROTATE_HANDLE_HEIGHT = ROTATE_SIZE / 2 + ROTATE_GAP;
    var ROTATE_ICON_MARGIN = 8;
    /**
     * @internal
     * The rotate drag and drop handler
     */
    Rotator.Rotator = {
        onDragStart: function (_a) {
            var editInfo = _a.editInfo;
            return (__assign$5({}, editInfo));
        },
        onDragging: function (_a, e, base, deltaX, deltaY) {
            var editInfo = _a.editInfo, options = _a.options;
            var distance = editInfo.heightPx / 2 + DEFAULT_ROTATE_HANDLE_HEIGHT;
            var newX = distance * Math.sin(base.angleRad) + deltaX;
            var newY = distance * Math.cos(base.angleRad) - deltaY;
            var angleInRad = Math.atan2(newX, newY);
            if (!e.altKey && options && options.minRotateDeg !== undefined) {
                var angleInDeg = angleInRad * DEG_PER_RAD;
                var adjustedAngleInDeg = Math.round(angleInDeg / options.minRotateDeg) * options.minRotateDeg;
                angleInRad = adjustedAngleInDeg / DEG_PER_RAD;
            }
            if (editInfo.angleRad != angleInRad) {
                editInfo.angleRad = angleInRad;
                return true;
            }
            else {
                return false;
            }
        },
    };
    /**
     * @internal
     * Move rotate handle. When image is very close to the border of editor, rotate handle may not be visible.
     * Fix it by reduce the distance from image to rotate handle
     */
    function updateRotateHandlePosition(editorRect, rotateCenter, rotateHandle) {
        var rotateHandleRect = rotateHandle.getBoundingClientRect();
        if (rotateHandleRect) {
            var top_1 = rotateHandleRect.top - editorRect.top;
            var left = rotateHandleRect.left - editorRect.left;
            var right = rotateHandleRect.right - editorRect.right;
            var bottom = rotateHandleRect.bottom - editorRect.bottom;
            var adjustedDistance = Number.MAX_SAFE_INTEGER;
            if (top_1 <= 0) {
                adjustedDistance = top_1;
            }
            else if (left <= 0) {
                adjustedDistance = left;
            }
            else if (right >= 0) {
                adjustedDistance = right;
            }
            else if (bottom >= 0) {
                adjustedDistance = bottom;
            }
            var rotateGap = Math.max(Math.min(ROTATE_GAP, adjustedDistance), 0);
            var rotateTop = Math.max(Math.min(ROTATE_SIZE, adjustedDistance - rotateGap), 0);
            rotateCenter.style.top = -rotateGap + 'px';
            rotateCenter.style.height = rotateGap + 'px';
            rotateHandle.style.top = -rotateTop + 'px';
        }
    }
    Rotator.updateRotateHandlePosition = updateRotateHandlePosition;
    /**
     * @internal
     * Get HTML for rotate elements, including the rotate handle with icon, and a line between the handle and the image
     */
    function getRotateHTML(_a) {
        var borderColor = _a.borderColor, rotateHandleBackColor = _a.rotateHandleBackColor;
        var handleLeft = ROTATE_SIZE / 2;
        return [
            {
                tag: 'div',
                className: "r_rotateC" /* RotateCenter */,
                style: "position:absolute;left:50%;width:1px;background-color:" + borderColor + ";top:" + -ROTATE_GAP + "px;height:" + ROTATE_GAP + "px;",
                children: [
                    {
                        tag: 'div',
                        className: "r_rotateH" /* RotateHandle */,
                        style: "position:absolute;background-color:" + rotateHandleBackColor + ";border:solid 1px " + borderColor + ";border-radius:50%;width:" + ROTATE_SIZE + "px;height:" + ROTATE_SIZE + "px;left:-" + handleLeft + "px;cursor:move;top:" + -ROTATE_SIZE + "px;",
                        children: [getRotateIconHTML(borderColor)],
                    },
                ],
            },
        ];
    }
    Rotator.getRotateHTML = getRotateHTML;
    function getRotateIconHTML(borderColor) {
        var _a;
        return {
            tag: 'svg',
            namespace: 'http://www.w3.org/2000/svg',
            style: "width:16px;height:16px;margin: " + ROTATE_ICON_MARGIN + "px " + ROTATE_ICON_MARGIN + "px",
            children: [
                {
                    tag: 'path',
                    namespace: 'http://www.w3.org/2000/svg',
                    attributes: (_a = {
                            d: 'M 10.5,10.0 A 3.8,3.8 0 1 1 6.7,6.3',
                            transform: 'matrix(1.1 1.1 -1.1 1.1 11.6 -10.8)'
                        },
                        _a['fill-opacity'] = '0',
                        _a.stroke = borderColor,
                        _a),
                },
                {
                    tag: 'path',
                    namespace: 'http://www.w3.org/2000/svg',
                    attributes: {
                        d: 'M12.0 3.648l.884-.884.53 2.298-2.298-.53z',
                        stroke: borderColor,
                    },
                },
            ],
        };
    }

    var __assign$4 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$4 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$4.apply(this, arguments);
    };
    var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var _a;
    Object.defineProperty(ImageEdit$1, "__esModule", { value: true });
    var applyChange_1$1 = applyChange$1;
    var canRegenerateImage_1 = canRegenerateImage$1;
    var DragAndDropHelper_1$3 = DragAndDropHelper$1;
    var getGeneratedImageSize_1 = getGeneratedImageSize$1;
    var Cropper_1 = Cropper;
    var editInfo_1$3 = editInfo;
    var Rotator_1 = Rotator;
    var roosterjs_editor_dom_1$r = lib$3;
    var Resizer_1 = Resizer;
    var PI = Math.PI;
    var DIRECTIONS = 8;
    var DirectionRad = (PI * 2) / DIRECTIONS;
    var DirectionOrder = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
    /**
     * Default image edit options
     */
    var DefaultOptions = {
        borderColor: '#DB626C',
        minWidth: 10,
        minHeight: 10,
        preserveRatio: false,
        minRotateDeg: 5,
        imageSelector: 'img',
        rotateIconHTML: '',
        disableCrop: false,
        disableRotate: false,
        disableSideResize: false,
        onSelectState: 7 /* ResizeAndRotate */,
    };
    /**
     * Map the image edit operation to a function that returns editing elements HTML to help
     * build image editing UI
     */
    var ImageEditHTMLMap = (_a = {},
        _a[1 /* CornerResize */] = Resizer_1.getCornerResizeHTML,
        _a[2 /* SideResize */] = Resizer_1.getSideResizeHTML,
        _a[4 /* Rotate */] = Rotator_1.getRotateHTML,
        _a[8 /* Crop */] = Cropper_1.getCropHTML,
        _a);
    /**
     * Default background colors for rotate handle
     */
    var LIGHT_MODE_BGCOLOR = 'white';
    var DARK_MODE_BGCOLOR = '#333';
    /**
     * The biggest area of image with 4 handles
     */
    var MAX_SMALL_SIZE_IMAGE = 10000;
    /**
     * ImageEdit plugin provides the ability to edit an inline image in editor, including image resizing, rotation and cropping
     */
    var ImageEdit = /** @class */ (function () {
        /**
         * Create a new instance of ImageEdit
         * @param options Image editing options
         * @param onShowResizeHandle An optional callback to allow customize resize handle element of image resizing.
         * To customize the resize handle element, add this callback and change the attributes of elementData then it
         * will be picked up by ImageEdit code
         */
        function ImageEdit(options, onShowResizeHandle) {
            var _this = this;
            this.onShowResizeHandle = onShowResizeHandle;
            this.editor = null;
            this.disposer = null;
            // Current editing image
            this.image = null;
            // Image cloned from the current editing image
            this.clonedImage = null;
            // The image wrapper
            this.wrapper = null;
            // Current edit info of the image. All changes user made will be stored in this object.
            // We use this object to update the editing UI, and finally we will use this object to generate
            // the new image if necessary
            this.editInfo = null;
            // Src of the image before current editing
            this.lastSrc = null;
            // Drag and drop helper objects
            this.dndHelpers = [];
            /**
             * Identify if the image was resized by the user.
             */
            this.wasResized = false;
            /**
             * The span element that wraps the image and opens shadow dom
             */
            this.shadowSpan = null;
            /**
             * The span element that wraps the image and opens shadow dom
             */
            this.isCropping = false;
            /**
             * quit editing mode when editor lose focus
             */
            this.onBlur = function () {
                _this.setEditingImage(null, true);
            };
            /**
             * Remove the temp wrapper of the image
             */
            this.removeWrapper = function () {
                if (_this.shadowSpan) {
                    (0, roosterjs_editor_dom_1$r.unwrap)(_this.shadowSpan);
                }
                _this.wrapper = null;
                _this.shadowSpan = null;
            };
            /**
             * Update image edit elements to reflect current editing result
             * @param context
             */
            this.updateWrapper = function (context) {
                var _a, _b;
                var wrapper = _this.wrapper;
                if (wrapper &&
                    _this.editInfo &&
                    _this.image &&
                    _this.clonedImage &&
                    _this.options &&
                    ((_a = _this.shadowSpan) === null || _a === void 0 ? void 0 : _a.parentElement)) {
                    // Prepare: get related editing elements
                    var cropContainers = getEditElements(wrapper, "r_cropC" /* CropContainer */);
                    var cropOverlays = getEditElements(wrapper, "r_cropO" /* CropOverlay */);
                    var resizeHandles = getEditElements(wrapper, "r_resizeH" /* ResizeHandle */);
                    var rotateCenter = getEditElements(wrapper, "r_rotateC" /* RotateCenter */)[0];
                    var rotateHandle = getEditElements(wrapper, "r_rotateH" /* RotateHandle */)[0];
                    var cropHandles = getEditElements(wrapper, "r_cropH" /* CropHandle */);
                    // Cropping and resizing will show different UI, so check if it is cropping here first
                    _this.isCropping = cropContainers.length == 1 && cropOverlays.length == 4;
                    var _c = _this.editInfo, angleRad = _c.angleRad, bottomPercent = _c.bottomPercent, leftPercent = _c.leftPercent, rightPercent = _c.rightPercent, topPercent = _c.topPercent;
                    // Width/height of the image
                    var _d = (0, getGeneratedImageSize_1.default)(_this.editInfo, _this.isCropping), targetWidth = _d.targetWidth, targetHeight = _d.targetHeight, originalWidth = _d.originalWidth, originalHeight = _d.originalHeight, visibleWidth = _d.visibleWidth, visibleHeight = _d.visibleHeight;
                    var marginHorizontal = (targetWidth - visibleWidth) / 2;
                    var marginVertical = (targetHeight - visibleHeight) / 2;
                    var cropLeftPx = originalWidth * leftPercent;
                    var cropRightPx = originalWidth * rightPercent;
                    var cropTopPx = originalHeight * topPercent;
                    var cropBottomPx = originalHeight * bottomPercent;
                    // Update size and margin of the wrapper
                    wrapper.style.margin = marginVertical + "px " + marginHorizontal + "px";
                    wrapper.style.transform = "rotate(" + angleRad + "rad)";
                    setWrapperSizeDimensions(wrapper, _this.image, visibleWidth, visibleHeight);
                    // Update the text-alignment to avoid the image to overflow if the parent element have align center or right
                    // or if the direction is Right To Left
                    wrapper.style.textAlign = isRtl(_this.shadowSpan.parentElement) ? 'right' : 'left';
                    // Update size of the image
                    _this.clonedImage.style.width = getPx(originalWidth);
                    _this.clonedImage.style.height = getPx(originalHeight);
                    if (_this.isCropping) {
                        // For crop, we also need to set position of the overlays
                        setSize(cropContainers[0], cropLeftPx, cropTopPx, cropRightPx, cropBottomPx, undefined, undefined);
                        setSize(cropOverlays[0], 0, 0, cropRightPx, undefined, undefined, cropTopPx);
                        setSize(cropOverlays[1], undefined, 0, 0, cropBottomPx, cropRightPx, undefined);
                        setSize(cropOverlays[2], cropLeftPx, undefined, 0, 0, undefined, cropBottomPx);
                        setSize(cropOverlays[3], 0, cropTopPx, undefined, 0, cropLeftPx, undefined);
                        updateHandleCursor(cropHandles, angleRad);
                    }
                    else {
                        // For rotate/resize, set the margin of the image so that cropped part won't be visible
                        _this.clonedImage.style.margin = -cropTopPx + "px 0 0 " + -cropLeftPx + "px";
                        // Double check resize
                        if ((context === null || context === void 0 ? void 0 : context.elementClass) == "r_resizeH" /* ResizeHandle */) {
                            var clientWidth = wrapper.clientWidth;
                            var clientHeight = wrapper.clientHeight;
                            _this.wasResized = true;
                            (0, Resizer_1.doubleCheckResize)(_this.editInfo, _this.options.preserveRatio || false, clientWidth, clientHeight);
                            _this.updateWrapper();
                        }
                        var viewport = (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.getVisibleViewport();
                        if (rotateHandle && rotateCenter && viewport) {
                            (0, Rotator_1.updateRotateHandlePosition)(viewport, rotateCenter, rotateHandle);
                        }
                        updateHandleCursor(resizeHandles, angleRad);
                    }
                }
            };
            this.options = __assign$4(__assign$4({}, DefaultOptions), (options || {}));
            this.allowedOperations =
                1 /* CornerResize */ |
                    (this.options.disableCrop ? 0 : 8 /* Crop */) |
                    (this.options.disableRotate ? 0 : 4 /* Rotate */) |
                    (this.options.disableSideResize ? 0 : 2 /* SideResize */);
        }
        /**
         * Get a friendly name of this plugin
         */
        ImageEdit.prototype.getName = function () {
            return 'ImageEdit';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        ImageEdit.prototype.initialize = function (editor) {
            var _this = this;
            this.editor = editor;
            this.disposer = editor.addDomEventHandler({
                blur: function () { return _this.onBlur(); },
                dragstart: function (e) {
                    if (_this.image) {
                        e.preventDefault();
                    }
                },
            });
        };
        /**
         * Dispose this plugin
         */
        ImageEdit.prototype.dispose = function () {
            var _a;
            this.clearDndHelpers();
            (_a = this.disposer) === null || _a === void 0 ? void 0 : _a.call(this);
            this.disposer = null;
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param e PluginEvent object
         */
        ImageEdit.prototype.onPluginEvent = function (e) {
            var _a;
            switch (e.eventType) {
                case 22 /* SelectionChanged */:
                    if (e.selectionRangeEx &&
                        e.selectionRangeEx.type === 2 /* ImageSelection */ &&
                        this.options &&
                        this.options.onSelectState !== undefined) {
                        this.setEditingImage(e.selectionRangeEx.image, this.options.onSelectState);
                    }
                    break;
                case 5 /* MouseDown */:
                    // When left click in a image that already in editing mode, do not quit edit mode
                    var mouseTarget = e.rawEvent.target;
                    var button = e.rawEvent.button;
                    if (this.shadowSpan !== mouseTarget ||
                        (this.shadowSpan === mouseTarget && button !== 0) ||
                        this.isCropping) {
                        this.setEditingImage(null);
                    }
                    break;
                case 0 /* KeyDown */:
                    this.setEditingImage(null);
                    break;
                case 7 /* ContentChanged */:
                    //After contentChanged event, the current image wrapper may not be valid any more, remove all of them if any
                    this.removeWrapper();
                    break;
                case 8 /* ExtractContentWithDom */:
                    // When extract content, remove all image info since they may not be valid when load the content again
                    if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.imageSelector) {
                        (0, roosterjs_editor_dom_1$r.toArray)(e.clonedRoot.querySelectorAll(this.options.imageSelector)).forEach(function (img) {
                            (0, editInfo_1$3.deleteEditInfo)(img);
                        });
                    }
                    break;
                case 12 /* BeforeDispose */:
                    this.removeWrapper();
                    break;
            }
        };
        /**
         * Check if the given image edit operation is allowed by this plugin
         * @param operation The image edit operation to check
         * @returns True means it is allowed, otherwise false
         */
        ImageEdit.prototype.isOperationAllowed = function (operation) {
            return !!(this.allowedOperations & operation);
        };
        ImageEdit.prototype.setEditingImage = function (image, operationOrSelect) {
            var _this = this;
            var operation = typeof operationOrSelect === 'number' ? operationOrSelect : 0 /* None */;
            var selectImage = typeof operationOrSelect === 'number' ? false : !!operationOrSelect;
            if (!image &&
                this.image &&
                this.editor &&
                this.editInfo &&
                this.lastSrc &&
                this.clonedImage) {
                // When there is image in editing, clean up any cached objects and elements
                this.clearDndHelpers();
                // Apply the changes, and add undo snapshot if necessary
                (0, applyChange_1$1.default)(this.editor, this.image, this.editInfo, this.lastSrc, this.wasResized, this.clonedImage);
                // Remove editing wrapper
                this.removeWrapper();
                this.editor.addUndoSnapshot(function () { return _this.image; }, "ImageResize" /* ImageResize */);
                if (selectImage) {
                    this.editor.select(this.image);
                }
                this.image = null;
                this.editInfo = null;
                this.lastSrc = null;
                this.clonedImage = null;
                this.isCropping = false;
            }
            if (!this.image && (image === null || image === void 0 ? void 0 : image.isContentEditable) && this.editor) {
                // If there is new image to edit, enter editing mode for this image
                this.editor.addUndoSnapshot();
                this.image = image;
                // Get initial edit info
                this.editInfo = (0, editInfo_1$3.getEditInfoFromImage)(image);
                //Check if the image was resized by the user
                this.wasResized = checkIfImageWasResized(this.image);
                operation =
                    ((0, canRegenerateImage_1.default)(image) ? operation : 3 /* Resize */) &
                        this.allowedOperations;
                // Create and update editing wrapper and elements
                this.createWrapper(operation);
                this.updateWrapper();
                // Init drag and drop
                this.dndHelpers = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], this.createDndHelpers("r_resizeH" /* ResizeHandle */, Resizer_1.Resizer), true), this.createDndHelpers("r_rotateH" /* RotateHandle */, Rotator_1.Rotator), true), this.createDndHelpers("r_cropH" /* CropHandle */, Cropper_1.Cropper), true), this.createDndHelpers("r_cropC" /* CropContainer */, Cropper_1.Cropper), true);
                this.editor.select(this.image);
            }
        };
        /**
         * Flip the image.
         * @param image The image to be flipped
         * @param direction
         */
        ImageEdit.prototype.flipImage = function (image, direction) {
            var _a;
            this.image = image;
            this.editInfo = (0, editInfo_1$3.getEditInfoFromImage)(image);
            var angleRad = this.editInfo.angleRad;
            var isInVerticalPostion = (angleRad >= Math.PI / 2 && angleRad < (3 * Math.PI) / 4) ||
                (angleRad <= -Math.PI / 2 && angleRad > (-3 * Math.PI) / 4);
            if (isInVerticalPostion) {
                if (direction === 'horizontal') {
                    this.editInfo.flippedVertical = !this.editInfo.flippedVertical;
                }
                else {
                    this.editInfo.flippedHorizontal = !this.editInfo.flippedHorizontal;
                }
            }
            else {
                if (direction === 'vertical') {
                    this.editInfo.flippedVertical = !this.editInfo.flippedVertical;
                }
                else {
                    this.editInfo.flippedHorizontal = !this.editInfo.flippedHorizontal;
                }
            }
            this.createWrapper(4 /* Rotate */);
            this.updateWrapper();
            this.setEditingImage(null);
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.select(image);
        };
        /**
         * Rotate the image in radian angle.
         * @param image The image to be rotated
         * @param angleRad The angle in radian that the image must be rotated.
         */
        ImageEdit.prototype.rotateImage = function (image, angleRad) {
            var _a;
            this.image = image;
            this.editInfo = (0, editInfo_1$3.getEditInfoFromImage)(image);
            this.editInfo.angleRad = this.editInfo.angleRad + angleRad;
            this.createWrapper(4 /* Rotate */);
            this.updateWrapper();
            this.setEditingImage(null);
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.select(image);
        };
        /**
         * Create editing wrapper for the image
         */
        ImageEdit.prototype.createWrapper = function (operation) {
            var _this = this;
            var _a, _b;
            if (this.image && this.editor && this.options && this.editInfo) {
                //Clone the image and insert the clone in a entity
                this.clonedImage = this.image.cloneNode(true);
                this.clonedImage.removeAttribute('id');
                this.wrapper = (0, roosterjs_editor_dom_1$r.createElement)(6 /* ImageEditWrapper */, this.image.ownerDocument);
                (_b = (_a = this.wrapper) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.appendChild(this.clonedImage);
                this.wrapper.style.display = roosterjs_editor_dom_1$r.Browser.isSafari ? 'inline-block' : 'inline-flex';
                // Cache current src so that we can compare it after edit see if src is changed
                this.lastSrc = this.image.getAttribute('src');
                // Set image src to original src to help show editing UI, also it will be used when regenerate image dataURL after editing
                if (this.clonedImage) {
                    this.clonedImage.src = this.editInfo.src;
                    setFlipped(this.clonedImage, this.editInfo.flippedHorizontal, this.editInfo.flippedVertical);
                    this.clonedImage.style.position = 'absolute';
                }
                // Get HTML for all edit elements (resize handle, rotate handle, crop handle and overlay, ...) and create HTML element
                var options_1 = {
                    borderColor: getColorString(this.options.borderColor, this.editor.isDarkMode()),
                    rotateIconHTML: this.options.rotateIconHTML,
                    rotateHandleBackColor: this.editor.isDarkMode()
                        ? DARK_MODE_BGCOLOR
                        : LIGHT_MODE_BGCOLOR,
                    isSmallImage: isASmallImage(this.editInfo),
                };
                var htmlData_1 = [(0, Resizer_1.getResizeBordersHTML)(options_1)];
                (0, roosterjs_editor_dom_1$r.getObjectKeys)(ImageEditHTMLMap).forEach(function (thisOperation) {
                    var element = ImageEditHTMLMap[thisOperation](options_1, _this.onShowResizeHandle);
                    if ((operation & thisOperation) == thisOperation && element) {
                        (0, roosterjs_editor_dom_1$r.arrayPush)(htmlData_1, element);
                    }
                });
                htmlData_1.forEach(function (data) {
                    var element = (0, roosterjs_editor_dom_1$r.createElement)(data, _this.image.ownerDocument);
                    if (element && _this.wrapper) {
                        _this.wrapper.appendChild(element);
                    }
                });
                this.insertImageWrapper(this.wrapper);
            }
        };
        ImageEdit.prototype.insertImageWrapper = function (wrapper) {
            if (this.image) {
                this.shadowSpan = (0, roosterjs_editor_dom_1$r.wrap)(this.image, 'span');
                var shadowRoot = this.shadowSpan.attachShadow({
                    mode: 'open',
                });
                this.shadowSpan.style.verticalAlign = 'bottom';
                shadowRoot.appendChild(wrapper);
            }
        };
        /**
         * Create drag and drop helpers
         * @param wrapper
         * @param elementClass
         * @param dragAndDrop
         */
        ImageEdit.prototype.createDndHelpers = function (elementClass, dragAndDrop) {
            var _this = this;
            var wrapper = this.wrapper;
            return wrapper && this.editInfo
                ? getEditElements(wrapper, elementClass).map(function (element) {
                    return new DragAndDropHelper_1$3.default(element, {
                        editInfo: _this.editInfo,
                        options: _this.options,
                        elementClass: elementClass,
                        x: element.dataset.x,
                        y: element.dataset.y,
                    }, _this.updateWrapper, dragAndDrop, _this.editor ? _this.editor.getZoomScale() : 1);
                })
                : [];
        };
        /**
         * Clean up drag and drop helpers
         */
        ImageEdit.prototype.clearDndHelpers = function () {
            var _a;
            (_a = this.dndHelpers) === null || _a === void 0 ? void 0 : _a.forEach(function (helper) { return helper.dispose(); });
            this.dndHelpers = [];
        };
        return ImageEdit;
    }());
    ImageEdit$1.default = ImageEdit;
    function setSize(element, left, top, right, bottom, width, height) {
        element.style.left = left !== undefined ? getPx(left) : element.style.left;
        element.style.top = top !== undefined ? getPx(top) : element.style.top;
        element.style.right = right !== undefined ? getPx(right) : element.style.right;
        element.style.bottom = bottom !== undefined ? getPx(bottom) : element.style.bottom;
        element.style.width = width !== undefined ? getPx(width) : element.style.width;
        element.style.height = height !== undefined ? getPx(height) : element.style.height;
    }
    function setWrapperSizeDimensions(wrapper, image, width, height) {
        var hasBorder = image.style.borderStyle;
        if (hasBorder) {
            var borderWidth = image.style.borderWidth ? 2 * parseInt(image.style.borderWidth) : 2;
            wrapper.style.width = getPx(width + borderWidth);
            wrapper.style.height = getPx(height + borderWidth);
            return;
        }
        wrapper.style.width = getPx(width);
        wrapper.style.height = getPx(height);
    }
    function getPx(value) {
        return value + 'px';
    }
    function getEditElements(wrapper, elementClass) {
        return (0, roosterjs_editor_dom_1$r.toArray)(wrapper.querySelectorAll('.' + elementClass));
    }
    function isRtl(element) {
        return (0, roosterjs_editor_dom_1$r.safeInstanceOf)(element, 'HTMLElement')
            ? (0, roosterjs_editor_dom_1$r.getComputedStyle)(element, 'direction') == 'rtl'
            : false;
    }
    function handleRadIndexCalculator(angleRad) {
        var idx = Math.round(angleRad / DirectionRad) % DIRECTIONS;
        return idx < 0 ? idx + DIRECTIONS : idx;
    }
    function rotateHandles(y, x, angleRad) {
        var radIndex = handleRadIndexCalculator(angleRad);
        var originalDirection = y + x;
        var originalIndex = DirectionOrder.indexOf(originalDirection);
        var rotatedIndex = originalIndex >= 0 && originalIndex + radIndex;
        return rotatedIndex ? DirectionOrder[rotatedIndex % DIRECTIONS] : '';
    }
    /**
     * Rotate the resizer and cropper handles according to the image position.
     * @param handles The resizer handles.
     * @param angleRad The angle that the image was rotated.
     */
    function updateHandleCursor(handles, angleRad) {
        handles.map(function (handle) {
            var y = handle.dataset.y;
            var x = handle.dataset.x;
            if (y && x) {
                handle.style.cursor = rotateHandles(y, x, angleRad) + "-resize";
            }
        });
    }
    /**
     * Check if the current image was resized by the user
     * @param image the current image
     * @returns if the user resized the image, returns true, otherwise, returns false
     */
    function checkIfImageWasResized(image) {
        var width = image.width, height = image.height, style = image.style;
        var isMaxWidthInitial = style.maxWidth === '' || style.maxWidth === 'initial' || style.maxWidth === 'auto';
        if (isMaxWidthInitial &&
            (isFixedNumberValue(style.height) ||
                isFixedNumberValue(style.width) ||
                isFixedNumberValue(width) ||
                isFixedNumberValue(height))) {
            return true;
        }
        else {
            return false;
        }
    }
    function isFixedNumberValue(value) {
        var numberValue = typeof value === 'string' ? parseInt(value) : value;
        return !isNaN(numberValue);
    }
    function isASmallImage(editInfo) {
        var widthPx = editInfo.widthPx, heightPx = editInfo.heightPx;
        return widthPx && heightPx && widthPx * widthPx < MAX_SMALL_SIZE_IMAGE ? true : false;
    }
    function getColorString(color, isDarkMode) {
        if (typeof color === 'string') {
            return color.trim();
        }
        return isDarkMode ? color.darkModeColor.trim() : color.lightModeColor.trim();
    }
    function setFlipped(element, flipppedHorizontally, flipppedVertically) {
        element.style.transform = "scale(" + (flipppedHorizontally ? '-1' : '1') + ", " + (flipppedVertically ? '-1' : '1') + ")";
    }

    var resizeByPercentage$1 = {};

    var getTargetSizeByPercentage$1 = {};

    Object.defineProperty(getTargetSizeByPercentage$1, "__esModule", { value: true });
    /**
     * @internal
     * Get target size of an image with a percentage
     * @param editInfo
     * @param percentage
     * @returns [width, height] array
     */
    function getTargetSizeByPercentage(editInfo, percentage) {
        var naturalWidth = editInfo.naturalWidth, naturalHeight = editInfo.naturalHeight, left = editInfo.leftPercent, top = editInfo.topPercent, right = editInfo.rightPercent, bottom = editInfo.bottomPercent;
        var width = naturalWidth * (1 - left - right) * percentage;
        var height = naturalHeight * (1 - top - bottom) * percentage;
        return { width: width, height: height };
    }
    getTargetSizeByPercentage$1.default = getTargetSizeByPercentage;

    var isResizedTo$1 = {};

    Object.defineProperty(isResizedTo$1, "__esModule", { value: true });
    var getTargetSizeByPercentage_1$1 = getTargetSizeByPercentage$1;
    var editInfo_1$2 = editInfo;
    /**
     * Check if the image is already resized to the given percentage
     * @param image The image to check
     * @param percentage The percentage to check
     */
    function isResizedTo(image, percentage) {
        var editInfo = (0, editInfo_1$2.getEditInfoFromImage)(image);
        if (editInfo) {
            var _a = (0, getTargetSizeByPercentage_1$1.default)(editInfo, percentage), width = _a.width, height = _a.height;
            return (Math.round(width) == Math.round(editInfo.widthPx) &&
                Math.round(height) == Math.round(editInfo.heightPx));
        }
        return false;
    }
    isResizedTo$1.default = isResizedTo;

    Object.defineProperty(resizeByPercentage$1, "__esModule", { value: true });
    var applyChange_1 = applyChange$1;
    var getTargetSizeByPercentage_1 = getTargetSizeByPercentage$1;
    var isResizedTo_1 = isResizedTo$1;
    var editInfo_1$1 = editInfo;
    /**
     * Resize the image by percentage of its natural size. If the image is cropped or rotated,
     * the final size will also calculated with crop and rotate info.
     * @param editor The editor that contains the image
     * @param image The image to resize
     * @param percentage Percentage to resize to
     * @param minWidth Minimum width
     * @param minHeight Minimum height
     */
    function resizeByPercentage(editor, image, percentage, minWidth, minHeight) {
        var editInfo = (0, editInfo_1$1.getEditInfoFromImage)(image);
        if (!(0, isResizedTo_1.default)(image, percentage)) {
            loadImage(image, image.src, function () {
                if (!editor.isDisposed() && editor.contains(image) && editInfo) {
                    var lastSrc_1 = image.getAttribute('src');
                    var _a = (0, getTargetSizeByPercentage_1.default)(editInfo, percentage), width = _a.width, height = _a.height;
                    editInfo.widthPx = Math.max(width, minWidth);
                    editInfo.heightPx = Math.max(height, minHeight);
                    editor.addUndoSnapshot(function () {
                        (0, applyChange_1.default)(editor, image, editInfo, lastSrc_1 || '', true /*wasResized*/);
                    }, "ImageResize" /* ImageResize */);
                }
            });
        }
    }
    resizeByPercentage$1.default = resizeByPercentage;
    function loadImage(img, src, callback) {
        img.onload = function () {
            img.onload = null;
            img.onerror = null;
            callback();
        };
        img.onerror = function () {
            img.onload = null;
            img.onerror = null;
            callback();
        };
        img.src = src;
    }

    var resetImage$1 = {};

    Object.defineProperty(resetImage$1, "__esModule", { value: true });
    var editInfo_1 = editInfo;
    /**
     * Remove explicit width & height attributes on the image element.
     * @param editor The editor that contains the image
     * @param image The image to remove w/h from
     */
    function resetImage(editor, image) {
        editor.addUndoSnapshot(function () {
            image.style.width = '';
            image.style.height = '';
            image.style.maxWidth = '100%';
            image.removeAttribute('width');
            image.removeAttribute('height');
            (0, editInfo_1.deleteEditInfo)(image);
        }, "ImageResize" /* ImageResize */);
    }
    resetImage$1.default = resetImage;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resetImage = exports.isResizedTo = exports.resizeByPercentage = exports.canRegenerateImage = exports.ImageEdit = void 0;
    var ImageEdit_1 = ImageEdit$1;
    Object.defineProperty(exports, "ImageEdit", { enumerable: true, get: function () { return ImageEdit_1.default; } });
    var canRegenerateImage_1 = canRegenerateImage$1;
    Object.defineProperty(exports, "canRegenerateImage", { enumerable: true, get: function () { return canRegenerateImage_1.default; } });
    var resizeByPercentage_1 = resizeByPercentage$1;
    Object.defineProperty(exports, "resizeByPercentage", { enumerable: true, get: function () { return resizeByPercentage_1.default; } });
    var isResizedTo_1 = isResizedTo$1;
    Object.defineProperty(exports, "isResizedTo", { enumerable: true, get: function () { return isResizedTo_1.default; } });
    var resetImage_1 = resetImage$1;
    Object.defineProperty(exports, "resetImage", { enumerable: true, get: function () { return resetImage_1.default; } });

    }(ImageEdit$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(ImageEdit$2, exports);

    }(ImageEdit$3));

    var ImageResize$3 = {};

    var ImageResize$2 = {};

    var ImageResize$1 = {};

    var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(ImageResize$1, "__esModule", { value: true });
    var ImageEdit_1 = ImageEdit$1;
    /**
     * @deprecated Use ImageEdit plugin instead
     */
    var ImageResize = /** @class */ (function (_super) {
        __extends$1(ImageResize, _super);
        /**
         * Create a new instance of ImageResize
         * @param minWidth Minimum width of image when resize in pixel, default value is 10
         * @param minHeight Minimum height of image when resize in pixel, default value is 10
         * @param selectionBorderColor Color of resize border and handles, default value is #DB626C
         * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false
         * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note
         * that the tag must be IMG regardless what the selector is
         */
        function ImageResize(minWidth, minHeight, selectionBorderColor, forcePreserveRatio, resizableImageSelector) {
            if (minWidth === void 0) { minWidth = 10; }
            if (minHeight === void 0) { minHeight = 10; }
            if (selectionBorderColor === void 0) { selectionBorderColor = '#DB626C'; }
            if (forcePreserveRatio === void 0) { forcePreserveRatio = false; }
            if (resizableImageSelector === void 0) { resizableImageSelector = 'img'; }
            return _super.call(this, {
                minHeight: minHeight,
                minWidth: minWidth,
                borderColor: selectionBorderColor,
                preserveRatio: forcePreserveRatio,
                imageSelector: resizableImageSelector,
            }) || this;
        }
        /**
         * @deprecated
         */
        ImageResize.prototype.showResizeHandle = function (img) {
            this.setEditingImage(img, 3 /* Resize */);
        };
        /**
         * @deprecated
         */
        ImageResize.prototype.hideResizeHandle = function (selectImageAfterUnSelect) {
            this.setEditingImage(null /*image*/, selectImageAfterUnSelect);
        };
        return ImageResize;
    }(ImageEdit_1.default));
    ImageResize$1.default = ImageResize;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageResize = void 0;
    var ImageResize_1 = ImageResize$1;
    Object.defineProperty(exports, "ImageResize", { enumerable: true, get: function () { return ImageResize_1.default; } });

    }(ImageResize$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(ImageResize$2, exports);

    }(ImageResize$3));

    var Paste$3 = {};

    var Paste$2 = {};

    var Paste$1 = {};

    var convertPasteContentForSingleImage$1 = {};

    Object.defineProperty(convertPasteContentForSingleImage$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$q = lib$3;
    /**
     * @internal
     * Convert pasted content if there are HTML and Image data in the Clipboard
     * @param event The BeforePaste event
     */
    function convertPasteContentForSingleImage(event, trustedHTMLHandler) {
        var fragment = event.fragment, clipboardData = event.clipboardData;
        var html = clipboardData.html, image = clipboardData.image;
        if (html && image) {
            //If there are Html in the clipboard, and the html body only have one img children, use the HTML
            var doc = new DOMParser().parseFromString(trustedHTMLHandler(html), 'text/html');
            (0, roosterjs_editor_dom_1$q.moveChildNodes)(fragment, doc === null || doc === void 0 ? void 0 : doc.body);
        }
    }
    convertPasteContentForSingleImage$1.default = convertPasteContentForSingleImage;

    var convertPastedContentForLI$1 = {};

    Object.defineProperty(convertPastedContentForLI$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$p = lib$3;
    /**
     * @internal
     * Convert content copied from Teams to be well-formed
     */
    function convertPastedContentForLI(fragment) {
        // Sometimes it is possible that we get LI nodes directly under DIV.
        // In that case we need to convert DIV to UL. It is also possible to be OL, but we don't know it.
        // So always assume it is UL here, and later user can change it.
        if (isPureLiNode(fragment)) {
            (0, roosterjs_editor_dom_1$p.wrap)((0, roosterjs_editor_dom_1$p.toArray)(fragment.childNodes), 'UL');
        }
        else if ((0, roosterjs_editor_dom_1$p.safeInstanceOf)(fragment.firstChild, 'HTMLElement') &&
            isPureLiNode(fragment.firstChild)) {
            (0, roosterjs_editor_dom_1$p.changeElementTag)(fragment.firstChild, 'UL');
        }
    }
    convertPastedContentForLI$1.default = convertPastedContentForLI;
    function isPureLiNode(node) {
        if (node && !node.nextSibling && ['OL', 'UL', 'MENU'].indexOf((0, roosterjs_editor_dom_1$p.getTagOfNode)(node)) < 0) {
            var hasLi_1 = false;
            if ((0, roosterjs_editor_dom_1$p.toArray)(node.childNodes).every(function (childNode) {
                var _a;
                if ((0, roosterjs_editor_dom_1$p.safeInstanceOf)(childNode, 'Text') && !((_a = childNode.nodeValue) === null || _a === void 0 ? void 0 : _a.trim())) {
                    return true;
                }
                else if ((0, roosterjs_editor_dom_1$p.getTagOfNode)(childNode) == 'LI') {
                    hasLi_1 = true;
                    return true;
                }
                else {
                    return false;
                }
            }) &&
                hasLi_1) {
                return true;
            }
        }
        return false;
    }

    var convertPastedContentFromExcel$1 = {};

    Object.defineProperty(convertPastedContentFromExcel$1, "__esModule", { value: true });
    convertPastedContentFromExcel$1.excelHandler = void 0;
    var roosterjs_editor_dom_1$o = lib$3;
    var LAST_TD_END_REGEX = /<\/\s*td\s*>((?!<\/\s*tr\s*>)[\s\S])*$/i;
    var LAST_TR_END_REGEX = /<\/\s*tr\s*>((?!<\/\s*table\s*>)[\s\S])*$/i;
    var LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;
    var LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;
    var DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';
    /**
     * @internal
     * Convert pasted content from Excel, add borders when source doc doesn't have a border
     * @param event The BeforePaste event
     */
    function convertPastedContentFromExcel(event, trustedHTMLHandler) {
        var fragment = event.fragment, sanitizingOption = event.sanitizingOption, htmlBefore = event.htmlBefore, clipboardData = event.clipboardData;
        var html = excelHandler(clipboardData.html, htmlBefore);
        if (clipboardData.html != html) {
            var doc = new DOMParser().parseFromString(trustedHTMLHandler(html), 'text/html');
            (0, roosterjs_editor_dom_1$o.moveChildNodes)(fragment, doc === null || doc === void 0 ? void 0 : doc.body);
        }
        (0, roosterjs_editor_dom_1$o.chainSanitizerCallback)(sanitizingOption.elementCallbacks, 'TD', function (element) {
            if (element.style.borderStyle == 'none') {
                element.style.border = DEFAULT_BORDER_STYLE;
            }
            return true;
        });
    }
    convertPastedContentFromExcel$1.default = convertPastedContentFromExcel;
    /**
     * @internal Export for test only
     * @param html Source html
     */
    function excelHandler(html, htmlBefore) {
        if (html.match(LAST_TD_END_REGEX)) {
            var trMatch = htmlBefore.match(LAST_TR_REGEX);
            var tr = trMatch ? trMatch[0] : '<TR>';
            html = tr + html + '</TR>';
        }
        if (html.match(LAST_TR_END_REGEX)) {
            var tableMatch = htmlBefore.match(LAST_TABLE_REGEX);
            var table = tableMatch ? tableMatch[0] : '<TABLE>';
            html = table + html + '</TABLE>';
        }
        return html;
    }
    convertPastedContentFromExcel$1.excelHandler = excelHandler;

    var convertPastedContentFromOfficeOnline$1 = {};

    var constants = {};

    Object.defineProperty(constants, "__esModule", { value: true });
    constants.WAC_IDENTIFY_SELECTOR = constants.PROG_ID_NAME = constants.GOOGLE_SHEET_NODE_NAME = void 0;
    /**
     * @internal
     * Node attribute used to identify if the content is from Google Sheets.
     */
    constants.GOOGLE_SHEET_NODE_NAME = 'google-sheets-html-origin';
    /**
     * @internal
     * Name of the HTMLMeta Property that provides the Office App Source of the pasted content
     */
    constants.PROG_ID_NAME = 'ProgId';
    /**
     * @internal
     * Selector used to identify Wac Elements
     */
    constants.WAC_IDENTIFY_SELECTOR = 'ul[class^="BulletListStyle"]>.OutlineElement,ol[class^="NumberListStyle"]>.OutlineElement,span.WACImageContainer';

    var convertPastedContentFromWordOnline$1 = {};

    var ListItemBlock = {};

    Object.defineProperty(ListItemBlock, "__esModule", { value: true });
    ListItemBlock.createListItemBlock = void 0;
    /**
     * @internal
     * Initialize an empty ListItemBlock
     */
    function createListItemBlock(listItem) {
        if (listItem === void 0) { listItem = null; }
        return {
            startElement: listItem,
            endElement: listItem,
            insertPositionNode: null,
            listItemContainers: listItem ? [listItem] : [],
        };
    }
    ListItemBlock.createListItemBlock = createListItemBlock;

    Object.defineProperty(convertPastedContentFromWordOnline$1, "__esModule", { value: true });
    convertPastedContentFromWordOnline$1.isWordOnlineWithList = void 0;
    var ListItemBlock_1 = ListItemBlock;
    var roosterjs_editor_dom_1$n = lib$3;
    var WORD_ONLINE_IDENTIFYING_SELECTOR = 'div.ListContainerWrapper>ul[class^="BulletListStyle"],div.ListContainerWrapper>ol[class^="NumberListStyle"],span.WACImageContainer > img';
    var LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';
    var IMAGE_CONTAINER_ELEMENT_CLASS_NAME = 'WACImageContainer';
    //When the list style is a symbol and the value is not in the clipboard, WordOnline
    var VALID_LIST_STYLE_CHAR_CODES = [
        '111',
        '9643',
        '9830', //''
    ];
    /**
     * @internal
     */
    function isWordOnlineWithList(fragment) {
        return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));
    }
    convertPastedContentFromWordOnline$1.isWordOnlineWithList = isWordOnlineWithList;
    // Word Online pasted content DOM structure as of July 12th 2019
    //<html>
    //  <body>
    //      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste
    //          <div class="OutlineElement">  ----------> text content
    //              <p></p>
    //          </div>
    //          <div class="ListItemWrapper">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper
    //              <ul>                                       list items in the same list can be divided into different ListItemWrapper
    //                  <li></li>                              list items in the same list can also be divided into different Outline Group;
    //                  <li></li>
    //              </ul>
    //          </div>
    //      </div>
    //      <div class='OutlineGroup'>
    //          <div class="ListItemWrapper">  ----------> list items: for ordered list, each items has it's own wrapper
    //              <ol>
    //                  <li></li>
    //              </ol>
    //          </div>
    //          <div class="ListItemWrapper">
    //              <ol>
    //                  <li></li>
    //              </ol>
    //          </div>
    //      </div>
    //  </body>
    //</html>
    //
    /**
     * @internal
     * Convert text copied from word online into text that's workable with rooster editor
     * @param fragment Document fragment that is being pasted into editor.
     */
    function convertPastedContentFromWordOnline(fragment) {
        sanitizeListItemContainer(fragment);
        var listItemBlocks = getListItemBlocks(fragment);
        listItemBlocks.forEach(function (itemBlock) {
            // There are cases where consecutive List Elements are separated into different nodes:
            // <div>
            //   <div>
            //      <ol></ol>
            //   </div>
            //   <div>
            //      <ol></ol>
            //   </div>
            // </div>
            // <div>
            //   <div>
            //      <ol></ol>
            //   </div>
            // </div>
            // in the above case we want to collapse the two root level div into one and unwrap the list item nodes.
            // after the following flattening the list will become following:
            //
            // <div>
            //    <ol></ol>
            // </div>
            // <div>
            //    <ol></ol>
            // </div>
            // <div>
            //    <ol></ol>
            // </div>
            // Then we are start processing.
            flattenListBlock(fragment, itemBlock);
            // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.
            itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;
            var convertedListElement;
            var doc = fragment.ownerDocument;
            itemBlock.listItemContainers.forEach(function (listItemContainer) {
                var listType = getContainerListType(listItemContainer); // list type that is contained by iterator.
                // Initialize processed element with proper listType if this is the first element
                if (!convertedListElement) {
                    convertedListElement = createNewList(listItemContainer, doc, listType);
                }
                // Get all list items(<li>) in the current iterator element.
                var currentListItems = (0, roosterjs_editor_dom_1$n.toArray)(listItemContainer.querySelectorAll('li'));
                currentListItems.forEach(function (item) {
                    // If item is in root level and the type of list changes then
                    // insert the current list into body and then reinitialize the convertedListElement
                    // Word Online is using data-aria-level to determine the the depth of the list item.
                    var itemLevel = parseInt(item.getAttribute('data-aria-level'));
                    // In first level list, there are cases where a consecutive list item DIV may have different list type
                    // When that happens we need to insert the processed elements into the document, then change the list type
                    // and keep the processing going.
                    if ((0, roosterjs_editor_dom_1$n.getTagOfNode)(convertedListElement) != listType && itemLevel == 1) {
                        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);
                        convertedListElement = createNewList(listItemContainer, doc, listType);
                    }
                    insertListItem(convertedListElement, item, listType, doc);
                });
            });
            insertConvertedListToDoc(convertedListElement, fragment, itemBlock);
            // Once we finish the process the list items and put them into a list.
            // After inserting the processed element,
            // we need to remove all the non processed node from the parent node.
            var parentContainer = itemBlock.startElement.parentNode;
            if (parentContainer) {
                itemBlock.listItemContainers.forEach(function (listItemContainer) {
                    parentContainer.removeChild(listItemContainer);
                });
            }
        });
        var imageNodes = getImageNodes(fragment);
        imageNodes.forEach(function (node) {
            //   Structure when pasting Word Wac Image as of 10/22/2021
            //   <span class='WACImageContainer'>
            //        <img class="WACImage" >
            //        <span style="display:block">
            //        </span>
            //   </span>
            //
            //   Since the second span inside of WACImageContainer have style display block it displays an additional space at the bottom of the image.
            //   Removing the nodes that are not img will resolve the additional space
            if ((0, roosterjs_editor_dom_1$n.safeInstanceOf)(node, 'HTMLSpanElement')) {
                node.childNodes.forEach(function (childNode) {
                    if ((0, roosterjs_editor_dom_1$n.getTagOfNode)(childNode) != 'IMG') {
                        childNode.parentElement.removeChild(childNode);
                    }
                });
            }
        });
    }
    convertPastedContentFromWordOnline$1.default = convertPastedContentFromWordOnline;
    function createNewList(listItemContainer, doc, tag) {
        var _a;
        var newList = doc.createElement(tag);
        var startAttribute = (_a = listItemContainer.firstElementChild) === null || _a === void 0 ? void 0 : _a.getAttribute('start');
        if (startAttribute) {
            newList.setAttribute('start', startAttribute);
        }
        return newList;
    }
    /**
     * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class
     * However the html might be malformed, this function is to split all the other elements out of ListContainerWrapper
     * @param fragment pasted document that contains all the list element.
     */
    function sanitizeListItemContainer(fragment) {
        var listItemContainerListEl = (0, roosterjs_editor_dom_1$n.toArray)(fragment.querySelectorAll(WORD_ONLINE_IDENTIFYING_SELECTOR));
        listItemContainerListEl.forEach(function (el) {
            var replaceRegex = new RegExp("\\b" + LIST_CONTAINER_ELEMENT_CLASS_NAME + "\\b", 'g');
            if (el.previousSibling) {
                var prevParent = (0, roosterjs_editor_dom_1$n.splitParentNode)(el, true);
                prevParent.className = prevParent.className.replace(replaceRegex, '');
            }
            if (el.nextSibling) {
                var nextParent = (0, roosterjs_editor_dom_1$n.splitParentNode)(el, false);
                nextParent.className = nextParent.className.replace(replaceRegex, '');
            }
        });
    }
    /**
     * Take all the list items in the document, and group the consecutive list times in a list block;
     * @param fragment pasted document that contains all the list element.
     */
    function getListItemBlocks(fragment) {
        var listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);
        var result = [];
        var curListItemBlock;
        for (var i = 0; i < listElements.length; i++) {
            var curItem = listElements[i];
            if (!curListItemBlock) {
                curListItemBlock = (0, ListItemBlock_1.createListItemBlock)(curItem);
            }
            else {
                var listItemContainers = curListItemBlock.listItemContainers;
                var lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];
                if (curItem == lastItemInCurBlock.nextSibling ||
                    (0, roosterjs_editor_dom_1$n.getFirstLeafNode)(curItem) ==
                        (0, roosterjs_editor_dom_1$n.getNextLeafSibling)(lastItemInCurBlock.parentNode, lastItemInCurBlock)) {
                    listItemContainers.push(curItem);
                    curListItemBlock.endElement = curItem;
                }
                else {
                    curListItemBlock.endElement = lastItemInCurBlock;
                    result.push(curListItemBlock);
                    curListItemBlock = (0, ListItemBlock_1.createListItemBlock)(curItem);
                }
            }
        }
        if ((curListItemBlock === null || curListItemBlock === void 0 ? void 0 : curListItemBlock.listItemContainers.length) > 0) {
            result.push(curListItemBlock);
        }
        return result;
    }
    /**
     * Flatten the list items, so that all the consecutive list items are under the same parent.
     * @param fragment Root element of that contains the element.
     * @param listItemBlock The list item block needed to be flattened.
     */
    function flattenListBlock(fragment, listItemBlock) {
        var collapsedListItemSections = (0, roosterjs_editor_dom_1$n.collapseNodes)(fragment, listItemBlock.startElement, listItemBlock.endElement, true);
        collapsedListItemSections.forEach(function (section) {
            if ((0, roosterjs_editor_dom_1$n.getTagOfNode)(section.firstChild) == 'DIV') {
                (0, roosterjs_editor_dom_1$n.unwrap)(section);
            }
        });
    }
    /**
     * Get the list type that the container contains. If there is no list in the container
     * return null;
     * @param listItemContainer Container that contains a list
     */
    function getContainerListType(listItemContainer) {
        var tag = (0, roosterjs_editor_dom_1$n.getTagOfNode)(listItemContainer.firstChild);
        return tag == 'UL' || tag == 'OL' ? tag : null;
    }
    /**
     * Insert list item into the correct position of a list
     * @param listRootElement Root element of the list that is accepting a coming element.
     * @param itemToInsert List item that needed to be inserted.
     * @param listType Type of list(ul/ol)
     */
    function insertListItem(listRootElement, itemToInsert, listType, doc) {
        var _a;
        if (!listType) {
            return;
        }
        // Get item level from 'data-aria-level' attribute
        var itemLevel = parseInt((_a = itemToInsert.getAttribute('data-aria-level')) !== null && _a !== void 0 ? _a : '');
        // Try to reuse the List Marker
        var style = itemToInsert.getAttribute('data-leveltext');
        if (listType == 'UL' &&
            style &&
            VALID_LIST_STYLE_CHAR_CODES.indexOf(style.charCodeAt(0).toString()) > -1) {
            itemToInsert.style.listStyleType = "\"" + style + "  \"";
        }
        var curListLevel = listRootElement; // Level iterator to find the correct place for the current element.
        // if the itemLevel is 1 it means the level iterator is at the correct place.
        while (itemLevel > 1) {
            if (!curListLevel.firstChild) {
                // If the current level is empty, create empty list within the current level
                // then move the level iterator into the next level.
                curListLevel.appendChild(doc.createElement(listType));
                curListLevel = curListLevel.firstElementChild;
            }
            else {
                // If the current level is not empty, the last item in the needs to be a UL or OL
                // and the level iterator should move to the UL/OL at the last position.
                var lastChild = curListLevel.lastElementChild;
                var lastChildTag = (0, roosterjs_editor_dom_1$n.getTagOfNode)(lastChild);
                if (lastChildTag == 'UL' || lastChildTag == 'OL') {
                    // If the last child is a list(UL/OL), then move the level iterator to last child.
                    curListLevel = lastChild;
                }
                else {
                    // If the last child is not a list, then append a new list to the level
                    // and move the level iterator to the new level.
                    curListLevel.appendChild(doc.createElement(listType));
                    curListLevel = curListLevel.lastElementChild;
                }
            }
            itemLevel--;
        }
        // Once the level iterator is at the right place, then append the list item in the level.
        curListLevel.appendChild(itemToInsert);
    }
    /**
     * Insert the converted list item into the correct place.
     * @param convertedListElement List element that is converted from list item block
     * @param fragment Root element of that contains the converted listItemBlock
     * @param listItemBlock List item block that was converted.
     */
    function insertConvertedListToDoc(convertedListElement, fragment, listItemBlock) {
        if (!convertedListElement) {
            return;
        }
        var insertPositionNode = listItemBlock.insertPositionNode;
        if (insertPositionNode) {
            var parentNode = insertPositionNode.parentNode;
            if (parentNode) {
                parentNode.insertBefore(convertedListElement, insertPositionNode);
            }
        }
        else {
            var parentNode = listItemBlock.startElement.parentNode;
            if (parentNode) {
                parentNode.appendChild(convertedListElement);
            }
            else {
                fragment.appendChild(convertedListElement);
            }
        }
    }
    function getImageNodes(fragment) {
        return fragment.querySelectorAll('.' + IMAGE_CONTAINER_ELEMENT_CLASS_NAME);
    }

    Object.defineProperty(convertPastedContentFromOfficeOnline$1, "__esModule", { value: true });
    var constants_1$6 = constants;
    var convertPastedContentFromWordOnline_1 = convertPastedContentFromWordOnline$1;
    /**
     * @internal
     * Convert pasted content from Office Online
     * Once it is known that the document is from WAC
     * We need to remove the display property and margin from all the list item
     * @param event The BeforePaste event
     */
    function convertPastedContentFromOfficeOnline(fragment) {
        fragment.querySelectorAll(constants_1$6.WAC_IDENTIFY_SELECTOR).forEach(function (el) {
            el.style.display = null;
            el.style.margin = null;
        });
        // call conversion function if the pasted content is from word online and
        // has list element in the pasted content.
        if ((0, convertPastedContentFromWordOnline_1.isWordOnlineWithList)(fragment)) {
            (0, convertPastedContentFromWordOnline_1.default)(fragment);
        }
    }
    convertPastedContentFromOfficeOnline$1.default = convertPastedContentFromOfficeOnline;

    var convertPastedContentFromPowerPoint$1 = {};

    Object.defineProperty(convertPastedContentFromPowerPoint$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$m = lib$3;
    /**
     * @internal
     * Convert pasted content from PowerPoint
     * @param event The BeforePaste event
     */
    function convertPastedContentFromPowerPoint(event, trustedHTMLHandler) {
        var fragment = event.fragment, clipboardData = event.clipboardData;
        if (clipboardData.html && !clipboardData.text && clipboardData.image) {
            // It is possible that PowerPoint copied both image and HTML but not plain text.
            // We always prefer HTML if any.
            var doc = new DOMParser().parseFromString(trustedHTMLHandler(clipboardData.html), 'text/html');
            (0, roosterjs_editor_dom_1$m.moveChildNodes)(fragment, doc === null || doc === void 0 ? void 0 : doc.body);
        }
    }
    convertPastedContentFromPowerPoint$1.default = convertPastedContentFromPowerPoint;

    var convertPastedContentFromWord$1 = {};

    var commentsRemoval$1 = {};

    Object.defineProperty(commentsRemoval$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$l = lib$3;
    var MSO_COMMENT_PARENT = 'mso-comment-parent';
    var MSO_COMMENT_REFERENCE = 'mso-comment-reference';
    var MSO_COMMENT_DATE = 'mso-comment-date';
    var MSO_COMMENT_ANCHOR_HREF_REGEX = /#_msocom_/;
    var MSO_SPECIAL_CHARACTER = 'mso-special-character';
    var MSO_SPECIAL_CHARACTER_COMMENT = 'comment';
    var MSO_COMMENT_CONTINUATION = 'mso-comment-continuation';
    var MSO_ELEMENT = 'mso-element';
    var MSO_ELEMENT_COMMENT_LIST = 'comment-list';
    var MSO_COMMENT_DONE = 'mso-comment-done';
    /**
     * @internal
     * Removes comments when pasting Word content.
     */
    function commentsRemoval(elementCallbacks, styleCallbacks) {
        // 1st Step, Remove SPAN elements added after each comment.
        // Word adds multiple elements for comments as SPAN elements.
        // In this step we remove these elements:
        // Structure as of 4/18/2022
        // 1.   <span style="mso-special-character:comment">&nbsp;</span>
        // 2.   <span style="mso-comment-continuation:3">
        //          <span>
        //              <span style="font-size:8.0pt">
        //              <a href="#_msocom_2">[RS2]</a>
        //              <span style="mso-special-character:comment">&nbsp;</span>
        //              </span>
        //          </span>
        //      </span>
        (0, roosterjs_editor_dom_1$l.chainSanitizerCallback)(elementCallbacks, 'SPAN', function (element) {
            var _a;
            var styles = (0, roosterjs_editor_dom_1$l.getStyles)(element);
            if (styles[MSO_SPECIAL_CHARACTER] == MSO_SPECIAL_CHARACTER_COMMENT) {
                (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(element);
            }
            return true;
        });
        // 2nd Step, Modify Anchor elements.
        // 1.   When the element was selected to add a comment in Word, the selection is converted to
        //      an anchor element, so we change the tag to span.
        // 2.   Word also adds some Anchor elements with the following structure:
        //      Structure as of 4/18/2022
        //      <a href="#_msocom_{number}">[SS3]</a>
        //      In this step we remove this Anchor elements.
        (0, roosterjs_editor_dom_1$l.chainSanitizerCallback)(elementCallbacks, 'A', function (element) {
            var _a;
            if ((0, roosterjs_editor_dom_1$l.safeInstanceOf)(element, 'HTMLAnchorElement') &&
                MSO_COMMENT_ANCHOR_HREF_REGEX.test(element.href)) {
                (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(element);
            }
            return true;
        });
        // 3rd Step, remove List of comments.
        // When the document have a long thread of comments, these comments are appended
        // at the end of the copied fragment, we also need to remove it.
        // Structure as of 4/18/2022
        //
        // <div style="mso-element:comment-list">
        //   <hr width="33%" size="1" align="left">
        //   <div style="mso-element:comment"> ... </div>
        //   <div style="mso-element:comment"> ... </div>
        //   <div style="mso-element:comment"> ... </div>
        //   </div>
        // </div>
        (0, roosterjs_editor_dom_1$l.chainSanitizerCallback)(elementCallbacks, 'DIV', function (element) {
            var styles = (0, roosterjs_editor_dom_1$l.getStyles)(element);
            if (styles[MSO_ELEMENT] == MSO_ELEMENT_COMMENT_LIST) {
                (0, roosterjs_editor_dom_1$l.moveChildNodes)(element);
            }
            return true;
        });
        /**
         * Remove styles related to Office Comments that can cause unwanted behaviors
         * depending on the user client
         */
        [
            MSO_COMMENT_REFERENCE,
            MSO_COMMENT_DATE,
            MSO_COMMENT_PARENT,
            MSO_COMMENT_CONTINUATION,
            MSO_COMMENT_DONE,
        ].forEach(function (style) { return (0, roosterjs_editor_dom_1$l.chainSanitizerCallback)(styleCallbacks, style, function () { return false; }); });
    }
    commentsRemoval$1.default = commentsRemoval;

    var wordConverter = {};

    var WordCustomData = {};

    Object.defineProperty(WordCustomData, "__esModule", { value: true });
    WordCustomData.getObject = WordCustomData.setObject = WordCustomData.createCustomData = void 0;
    /** NodeId attribute */
    var NODE_ID_ATTRIBUTE_NAME = 'NodeId';
    /**
     * @internal
     * Create an empty WordCustomData
     */
    function createCustomData() {
        return {
            dict: {},
            nextNodeId: 1,
        };
    }
    WordCustomData.createCustomData = createCustomData;
    /**
     * @internal
     * Sets the specified object data
     */
    function setObject(wordCustomData, element, key, value) {
        // Get the id for the element
        if (element.nodeType == 1 /* Element */) {
            var id = getAndSetNodeId(wordCustomData, element);
            if (id != '') {
                // Get the values for the element
                if (!wordCustomData.dict[id]) {
                    // First time dictionary creation
                    wordCustomData.dict[id] = {};
                }
                wordCustomData.dict[id][key] = value;
            }
        }
    }
    WordCustomData.setObject = setObject;
    /**
     * @internal
     * Reads the specified object data
     */
    function getObject(wordCustomData, element, key) {
        if (element.nodeType == 1 /* Element */) {
            var id = getAndSetNodeId(wordCustomData, element);
            if (id != '') {
                return wordCustomData.dict[id] && wordCustomData.dict[id][key];
            }
        }
        return null;
    }
    WordCustomData.getObject = getObject;
    /**
     * Get the unique id for the specified node...
     */
    function getAndSetNodeId(wordCustomData, element) {
        var id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);
        if (!id) {
            id = wordCustomData.nextNodeId.toString();
            wordCustomData.nextNodeId++;
            element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);
        }
        return id;
    }

    Object.defineProperty(wordConverter, "__esModule", { value: true });
    wordConverter.createWordConverter = void 0;
    var WordCustomData_1$1 = WordCustomData;
    /**
     * @internal
     * create an empty WordConverter
     */
    function createWordConverter() {
        return {
            nextUniqueId: 1,
            numBulletsConverted: 0,
            numNumberedConverted: 0,
            wordConverterArgs: null,
            wordCustomData: (0, WordCustomData_1$1.createCustomData)(),
        };
    }
    wordConverter.createWordConverter = createWordConverter;

    var WordConverterArguments = {};

    var LevelLists = {};

    Object.defineProperty(LevelLists, "__esModule", { value: true });
    LevelLists.createLevelLists = void 0;
    /**
     * @internal
     * create an empty LevelLists
     */
    function createLevelLists() {
        return {
            listsMetadata: {},
            currentUniqueListId: -1,
        };
    }
    LevelLists.createLevelLists = createLevelLists;

    Object.defineProperty(WordConverterArguments, "__esModule", { value: true });
    WordConverterArguments.createWordConverterArguments = void 0;
    var LevelLists_1$1 = LevelLists;
    /**
     * @internal
     * create an empty WordConverterArguments
     */
    function createWordConverterArguments(nodes) {
        return {
            nodes: nodes,
            currentIndex: 0,
            lists: {},
            listItems: [],
            currentListIdsByLevels: [(0, LevelLists_1$1.createLevelLists)()],
            lastProcessedItem: null,
        };
    }
    WordConverterArguments.createWordConverterArguments = createWordConverterArguments;

    var converterUtils = {};

    Object.defineProperty(converterUtils, "__esModule", { value: true });
    converterUtils.processNodeConvert = converterUtils.processNodesDiscovery = void 0;
    var LevelLists_1 = LevelLists;
    var WordCustomData_1 = WordCustomData;
    var roosterjs_editor_dom_1$k = lib$3;
    /** Word list metadata style name */
    var LOOKUP_DEPTH = 5;
    /** Name for the word list id property in the custom data */
    var UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';
    /** Word list metadata style name */
    var MSO_LIST_STYLE_NAME = 'mso-list';
    /** Regular expression to match line breaks */
    var LINE_BREAKS = /[\n|\r]/gi;
    /**
     * @internal
     * Handles the pass 1: Discovery
     * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.
     * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these
     * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.
     */
    function processNodesDiscovery(wordConverter) {
        var args = wordConverter.wordConverterArgs;
        while (args.currentIndex < args.nodes.length) {
            var node = args.nodes.item(args.currentIndex);
            // Try to get the list metadata for the specified node
            var itemMetadata = getListItemMetadata(node);
            if (itemMetadata) {
                var levelInfo = args.currentListIdsByLevels[itemMetadata.level - 1] || (0, LevelLists_1.createLevelLists)();
                args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;
                // We need to drop some list information if this is not an item next to another
                if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {
                    // This list item is not next to the previous one. This means that there is some content in between them
                    // so we need to reset our list of list ids per level
                    resetCurrentLists(args);
                }
                // Get the list metadata for the list that will hold this item
                var listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];
                if (!listMetadata) {
                    // Get the first item fake bullet.. This will be used later to check what is the right type of list
                    var firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);
                    // This is a the first item of a list.. We'll create the list metadata using the information
                    // we already have from this first item
                    listMetadata = {
                        numberOfItems: 0,
                        uniqueListId: wordConverter.nextUniqueId++,
                        firstFakeBullet: firstFakeBullet,
                        // If the bullet we got is empty or not found, we ignore the list out.. this means
                        // that this is not an item we need to convert of that the format doesn't match what
                        // we are expecting
                        ignore: !firstFakeBullet || firstFakeBullet.length == 0,
                        // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second
                        // item, we'll perform a better comparison, but for one item lists, this will be check that will determine the list type
                        tagName: getFakeBulletTagName(firstFakeBullet),
                    };
                    levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;
                    args.lists[listMetadata.uniqueListId.toString()] = listMetadata;
                }
                else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {
                    // This is the second item we've seen for this list.. we'll compare the 2 fake bullet
                    // items we have an decide if we create ordered or unordered lists based on this.
                    // This is the best way we can do this since we cannot read the metadata that Word
                    // puts in the head of the HTML...
                    var secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);
                    listMetadata.tagName =
                        listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';
                }
                // Set the unique id to the list
                itemMetadata.uniqueListId = listMetadata.uniqueListId;
                // Check if we need to ignore this list... we'll either know already that we need to ignore
                // it, or we'll know it because the previous list items are not next to this one
                if (listMetadata.ignore ||
                    (listMetadata.tagName == 'OL' &&
                        listMetadata.numberOfItems > 0 &&
                        levelInfo.currentUniqueListId != itemMetadata.uniqueListId)) {
                    // We need to ignore this item... and we also need to forget about the lists that
                    // are not at the root level
                    listMetadata.ignore = true;
                    args.currentListIdsByLevels[0].currentUniqueListId = -1;
                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);
                }
                else {
                    // This is an item we don't need to ignore... If added lists deep under this one before
                    // we'll drop their ids from the list of ids per level.. this is because this list item
                    // breaks the deeper lists.
                    if (args.currentListIdsByLevels.length > itemMetadata.level) {
                        args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, itemMetadata.level);
                    }
                    levelInfo.currentUniqueListId = itemMetadata.uniqueListId;
                    // Add the list item into the list of items to be processed
                    args.listItems.push(itemMetadata);
                    listMetadata.numberOfItems++;
                }
                args.lastProcessedItem = node;
            }
            else {
                // Here, we know that this is not a list item, but we'll want to check if it is one "no bullet" list items...
                // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will
                // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but
                // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips
                // the list conversion thinking that the list items are not together...
                var last = args.lastProcessedItem;
                if (last &&
                    getRealPreviousSibling(node) == last &&
                    node.tagName == last.tagName &&
                    node.className == last.className) {
                    // Add 2 line breaks and move all the nodes to the last item
                    last.appendChild(last.ownerDocument.createElement('br'));
                    last.appendChild(last.ownerDocument.createElement('br'));
                    (0, roosterjs_editor_dom_1$k.moveChildNodes)(last, node, true /*keepExistingChildren*/);
                    // Remove the item that we don't need anymore
                    node.parentNode.removeChild(node);
                }
            }
            // Move to the next element are return true if more elements need to be processed
            args.currentIndex++;
        }
        return args.listItems.length > 0;
    }
    converterUtils.processNodesDiscovery = processNodesDiscovery;
    /**
     * @internal
     * Handles the pass 2: Conversion
     * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the
     * conversion needed
     */
    function processNodeConvert(wordConverter) {
        var args = wordConverter.wordConverterArgs;
        args.currentIndex = 0;
        while (args.currentIndex < args.listItems.length) {
            var metadata = args.listItems[args.currentIndex];
            var node = metadata.originalNode;
            var listMetadata = args.lists[metadata.uniqueListId.toString()];
            if (!listMetadata.ignore) {
                // We have a list item that we need to convert, get or create the list
                // that hold this item out
                var list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);
                if (list) {
                    // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes
                    cleanupListIgnore(node, LOOKUP_DEPTH);
                    // Create a new list item and transfer the children
                    var li = node.ownerDocument.createElement('LI');
                    if ((0, roosterjs_editor_dom_1$k.getTagOfNode)(node).startsWith('H')) {
                        var clone = node.cloneNode(true /* deep */);
                        clone.style.textIndent = '';
                        clone.style.marginLeft = '';
                        clone.style.marginRight = '';
                        li.appendChild(clone);
                    }
                    else {
                        (0, roosterjs_editor_dom_1$k.moveChildNodes)(li, node);
                    }
                    // Append the list item into the list
                    list.appendChild(li);
                    // Remove the node we just converted
                    node.parentNode.removeChild(node);
                    if (listMetadata.tagName == 'UL') {
                        wordConverter.numBulletsConverted++;
                    }
                    else {
                        wordConverter.numNumberedConverted++;
                    }
                }
            }
            args.currentIndex++;
        }
        return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;
    }
    converterUtils.processNodeConvert = processNodeConvert;
    /**
     * Gets or creates the list (UL or OL) that holds this item out based on the
     * items content and the specified metadata
     */
    function getOrCreateListForNode(wordConverter, node, metadata, listMetadata) {
        // First get the last list next to this node under the specified level. This code
        // path will return the list or will create lists if needed
        var list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);
        // Here use the unique list ID to detect if we have the right list...
        // it is possible to have 2 different lists next to each other with different formats, so
        // we want to detect this an create separate lists for those cases
        var listId = (0, WordCustomData_1.getObject)(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA);
        // If we have a list with and ID, but the ID is different than the ID for this list item, this
        // is a completely new list, so we'll append a new list for that
        if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {
            var newList = node.ownerDocument.createElement(listMetadata.tagName);
            list.parentNode.insertBefore(newList, list.nextSibling);
            list = newList;
        }
        // Set the list id into the custom data
        (0, WordCustomData_1.setObject)(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA, metadata.uniqueListId);
        // This call will convert the list if needed to the right type of list required. This can happen
        // on the cases where the first list item for this list is located after a deeper list. for that
        // case, we will have created a UL for it, and we may need to convert it
        return convertListIfNeeded(wordConverter, list, listMetadata);
    }
    /**
     * Converts the list between UL and OL if needed, by using the fake bullet and
     * information already stored in the list itself
     */
    function convertListIfNeeded(wordConverter, list, listMetadata) {
        // Check if we need to convert the list out
        if (listMetadata.tagName != (0, roosterjs_editor_dom_1$k.getTagOfNode)(list)) {
            // We have the wrong list type.. convert it, set the id again and transfer all the children
            var newList = list.ownerDocument.createElement(listMetadata.tagName);
            (0, WordCustomData_1.setObject)(wordConverter.wordCustomData, newList, UNIQUE_LIST_ID_CUSTOM_DATA, (0, WordCustomData_1.getObject)(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA));
            (0, roosterjs_editor_dom_1$k.moveChildNodes)(newList, list);
            list.parentNode.insertBefore(newList, list);
            list.parentNode.removeChild(list);
            list = newList;
        }
        return list;
    }
    /**
     * Gets or creates the specified list
     */
    function recurringGetOrCreateListAtNode(node, level, listMetadata) {
        var parent = null;
        var possibleList;
        if (level == 1) {
            // Root case, we'll check if the list is the previous sibling of the node
            possibleList = getRealPreviousSibling(node);
        }
        else {
            // If we get here, we are looking for level 2 or deeper... get the upper list
            // and check if the last element is a list
            parent = recurringGetOrCreateListAtNode(node, level - 1, null);
            possibleList = parent.lastChild;
        }
        // Check the element that we got and verify that it is a list
        if (possibleList && possibleList.nodeType == 1 /* Element */) {
            var tag = (0, roosterjs_editor_dom_1$k.getTagOfNode)(possibleList);
            if (tag == 'UL' || tag == 'OL') {
                // We have a list.. use it
                return possibleList;
            }
        }
        // If we get here, it means we don't have a list and we need to create one
        // this code path will always create new lists as UL lists
        var newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');
        if (level == 1) {
            // For level 1, we'll insert the list before the node
            node.parentNode.insertBefore(newList, node);
        }
        else {
            // Any level 2 or above, we insert the list as the last
            // child of the upper level list
            parent.appendChild(newList);
        }
        return newList;
    }
    /**
     * Cleans up the node children by removing the children marked as mso-list: Ignore.
     * This nodes hold the fake bullet information that Word puts in and when
     * conversion is happening, we want to get rid of these elements
     */
    function cleanupListIgnore(node, levels) {
        var nodesToRemove = [];
        for (var child = node.firstChild; child; child = child.nextSibling) {
            // Clean up the item internally first if we need to based on the number of levels
            if (child.nodeType == 1 /* Element */ && levels > 1) {
                cleanupListIgnore(child, levels - 1);
            }
            // Try to convert word comments into ignore elements if we haven't done so for this element
            child = fixWordListComments(child, true /*removeComments*/);
            // Check if we can remove this item out
            if (isEmptySpan(child) || isIgnoreNode(child)) {
                nodesToRemove.push(child);
            }
        }
        nodesToRemove.forEach(function (child) { return node.removeChild(child); });
    }
    /**
     * Reads the word list meta dada out of the specified node. If the node
     * is not a Word list item, it returns null.
     */
    function getListItemMetadata(node) {
        if (node.nodeType == 1 /* Element */) {
            var listAttribute = getStyleValue(node, MSO_LIST_STYLE_NAME);
            if (listAttribute && listAttribute.length > 0) {
                try {
                    // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0
                    // Where:
                    // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; meta data
                    // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but
                    // for almost all cases, it maps to the list indentation (or level). We'll use it as the
                    // list indentation value
                    // (2) Contains a specific list identifier.
                    // Example value: "l0 level1 lfo1"
                    var listProps = listAttribute.split(' ');
                    if (listProps.length == 3) {
                        return {
                            level: parseInt(listProps[1].substr('level'.length)),
                            wordListId: listAttribute,
                            originalNode: node,
                            uniqueListId: 0,
                        };
                    }
                }
                catch (e) { }
            }
        }
        return null;
    }
    function isFakeBullet(fakeBullet) {
        return ['o', '', '', '-'].indexOf(fakeBullet) >= 0;
    }
    /** Given a fake bullet text, returns the type of list that should be used for it */
    function getFakeBulletTagName(fakeBullet) {
        return isFakeBullet(fakeBullet) ? 'UL' : 'OL';
    }
    /**
     * Finds the fake bullet text out of the specified node and returns it. For images, it will return
     * a bullet string. If not found, it returns null...
     */
    function getFakeBulletText(node, levels) {
        // Word uses the following format for their bullets:
        // &lt;p style="mso-list:l1 level1 lfo2"&gt;
        // &lt;span style="..."&gt;
        // &lt;span style="mso-list:Ignore"&gt;1.&lt;span style="..."&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;
        // &lt;/span&gt;
        // Content here...
        // &lt;/p&gt;
        //
        // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That
        // text or image node will be the fake bullet we are looking for
        var result = null;
        var child = node.firstChild;
        while (!result && child) {
            // First, check if we need to convert the Word list comments into real elements
            child = fixWordListComments(child, true /*removeComments*/);
            // Check if this is the node that holds the fake bullets (mso-list: Ignore)
            if (isIgnoreNode(child)) {
                // Yes... this is the node that holds either the text or image data
                result = child.textContent.trim();
                // This is the case for image case
                if (result.length == 0) {
                    result = 'o';
                }
            }
            else if (child.nodeType == 1 /* Element */ && levels > 1) {
                // If this is an element and we are not in the last level, try to get the fake bullet
                // out of the child
                result = getFakeBulletText(child, levels - 1);
            }
            child = child.nextSibling;
        }
        return result;
    }
    /**
     * If the specified element is a Word List comments, this code verifies and fixes
     * the markup when needed to ensure that Chrome bullet conversions work as expected
     * -----
     * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into
     * &lt;span style="mso-list:Ignore"&gt;&lt;/span&gt;... Chrome has a bug where it drops the
     * styles of the span, but we'll use these comments to recreate them out
     */
    function fixWordListComments(child, removeComments) {
        if (child.nodeType == 8 /* Comment */) {
            var value = child.data;
            if (value && value.trim().toLowerCase() == '[if !supportlists]') {
                // We have a list ignore start, find the end.. We know is not more than
                // 3 nodes away, so we'll optimize our checks
                var nextElement = child;
                var endComment = null;
                for (var j = 0; j < 4; j++) {
                    nextElement = getRealNextSibling(nextElement);
                    if (!nextElement) {
                        break;
                    }
                    if (nextElement.nodeType == 8 /* Comment */) {
                        value = nextElement.data;
                        if (value && value.trim().toLowerCase() == '[endif]') {
                            endComment = nextElement;
                            break;
                        }
                    }
                }
                // if we found the end node, wrap everything out
                if (endComment) {
                    var newSpan = child.ownerDocument.createElement('span');
                    newSpan.setAttribute('style', 'mso-list: ignore');
                    nextElement = getRealNextSibling(child);
                    while (nextElement != endComment) {
                        nextElement = nextElement.nextSibling;
                        newSpan.appendChild(nextElement.previousSibling);
                    }
                    // Insert the element out and use that one as the current child
                    endComment.parentNode.insertBefore(newSpan, endComment);
                    // Remove the comments out if the call specified it out
                    if (removeComments) {
                        child.parentNode.removeChild(child);
                        endComment.parentNode.removeChild(endComment);
                    }
                    // Last, make sure we return the new element out instead of the comment
                    child = newSpan;
                }
            }
        }
        return child;
    }
    /** Finds the real previous sibling, ignoring empty text nodes */
    function getRealPreviousSibling(node) {
        var prevSibling = node;
        do {
            prevSibling = prevSibling.previousSibling;
        } while (prevSibling && isEmptyTextNode(prevSibling));
        return prevSibling;
    }
    /** Finds the real next sibling, ignoring empty text nodes */
    function getRealNextSibling(node) {
        var nextSibling = node;
        do {
            nextSibling = nextSibling.nextSibling;
        } while (nextSibling && isEmptyTextNode(nextSibling));
        return nextSibling;
    }
    /**
     * Checks if the specified node is marked as a mso-list: Ignore. These
     * nodes need to be ignored when a list item is converted into standard
     * HTML lists
     */
    function isIgnoreNode(node) {
        if (node.nodeType == 1 /* Element */) {
            var listAttribute = getStyleValue(node, MSO_LIST_STYLE_NAME);
            if (listAttribute &&
                listAttribute.length > 0 &&
                listAttribute.trim().toLowerCase() == 'ignore') {
                return true;
            }
        }
        return false;
    }
    /** Checks if the specified node is an empty span. */
    function isEmptySpan(node) {
        return (0, roosterjs_editor_dom_1$k.getTagOfNode)(node) == 'SPAN' && !node.firstChild;
    }
    /** Reads the specified style value from the node */
    function getStyleValue(node, styleName) {
        // Word uses non-standard names for the metadata that puts in the style of the element...
        // Most browsers will not provide the information for those nonstandard values through the node.style
        // property, so the only reliable way to read them is to get the attribute directly and do
        // the required parsing..
        return (0, roosterjs_editor_dom_1$k.getStyles)(node)[styleName] || null;
    }
    /** Checks if the node is an empty text node that can be ignored */
    function isEmptyTextNode(node) {
        // No node is empty
        if (!node) {
            return true;
        }
        // Empty text node is empty
        if (node.nodeType == 3 /* Text */) {
            var value = node.nodeValue;
            value = value.replace(LINE_BREAKS, '');
            return value.trim().length == 0;
        }
        // Span or Font with an empty child node is empty
        var tagName = (0, roosterjs_editor_dom_1$k.getTagOfNode)(node);
        if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {
            return isEmptyTextNode(node.firstChild);
        }
        // If not found, then this is not empty
        return false;
    }
    /** Resets the list */
    function resetCurrentLists(args) {
        for (var i = 0; i < args.currentListIdsByLevels.length; i++) {
            var ll = args.currentListIdsByLevels[i];
            if (ll) {
                ll.currentUniqueListId = -1;
            }
        }
    }

    Object.defineProperty(convertPastedContentFromWord$1, "__esModule", { value: true });
    var commentsRemoval_1 = commentsRemoval$1;
    var roosterjs_editor_dom_1$j = lib$3;
    var wordConverter_1 = wordConverter;
    var WordConverterArguments_1 = WordConverterArguments;
    var converterUtils_1 = converterUtils;
    var PERCENTAGE_REGEX = /%/;
    var DEFAULT_BROWSER_LINE_HEIGHT_PERCENTAGE = 120;
    var LIST_ELEMENTS_SELECTOR = 'p,h1,h2,h3,h4,h5,h6';
    /**
     * @internal
     * Converts all the Word generated list items in the specified node into standard HTML UL and OL tags
     */
    function convertPastedContentFromWord(event) {
        var sanitizingOption = event.sanitizingOption, fragment = event.fragment;
        // Preserve <o:p> when its innerHTML is "&nbsp;" to avoid dropping an empty line
        (0, roosterjs_editor_dom_1$j.chainSanitizerCallback)(sanitizingOption.elementCallbacks, 'O:P', function (element) {
            (0, roosterjs_editor_dom_1$j.moveChildNodes)(element);
            element.appendChild(element.ownerDocument.createTextNode('\u00A0')); // &nbsp;
            return true;
        });
        var wordConverter = (0, wordConverter_1.createWordConverter)();
        // First find all the nodes that we need to check for list item information
        // This call will return all the p and header elements under the root node.. These are the elements that
        // Word uses a list items, so we'll only process them and avoid walking the whole tree.
        var elements = fragment.querySelectorAll(LIST_ELEMENTS_SELECTOR);
        if (elements.length > 0) {
            wordConverter.wordConverterArgs = (0, WordConverterArguments_1.createWordConverterArguments)(elements);
            if ((0, converterUtils_1.processNodesDiscovery)(wordConverter)) {
                (0, converterUtils_1.processNodeConvert)(wordConverter);
            }
        }
        // If the List style contains marginBottom = 0in, the space after the list is going to be too narrow.
        // Remove this style so the list displays correctly.
        ['OL', 'UL'].forEach(function (tag) {
            (0, roosterjs_editor_dom_1$j.chainSanitizerCallback)(sanitizingOption.elementCallbacks, tag, function (element) {
                if (element.style.marginBottom == '0in') {
                    element.style.marginBottom = '';
                }
                return true;
            });
        });
        //If the line height is less than the browser default line height, line between the text is going to be too narrow
        (0, roosterjs_editor_dom_1$j.chainSanitizerCallback)(sanitizingOption.cssStyleCallbacks, 'line-height', function (value) {
            var parsedLineHeight;
            if (PERCENTAGE_REGEX.test(value) &&
                !isNaN((parsedLineHeight = parseInt(value))) &&
                parsedLineHeight < DEFAULT_BROWSER_LINE_HEIGHT_PERCENTAGE) {
                return false;
            }
            return true;
        });
        (0, commentsRemoval_1.default)(sanitizingOption.elementCallbacks, sanitizingOption.cssStyleCallbacks);
    }
    convertPastedContentFromWord$1.default = convertPastedContentFromWord;

    var getPasteSource$1 = {};

    var documentContainWacElements$1 = {};

    Object.defineProperty(documentContainWacElements$1, "__esModule", { value: true });
    var constants_1$5 = constants;
    /**
     * @internal
     * Check whether the fragment provided contain Wac Elements
     * @param props Properties related to the PasteEvent
     * @returns
     */
    var documentContainWacElements = function (props) {
        var fragment = props.fragment;
        return !!fragment.querySelector(constants_1$5.WAC_IDENTIFY_SELECTOR);
    };
    documentContainWacElements$1.default = documentContainWacElements;

    var isExcelDesktopDocument$1 = {};

    Object.defineProperty(isExcelDesktopDocument$1, "__esModule", { value: true });
    var constants_1$4 = constants;
    var EXCEL_ATTRIBUTE_NAME = 'xmlns:x';
    var EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';
    var EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';
    /**
     * @internal
     * Checks whether the Array provided contains strings that identify Excel Desktop documents
     * @param props Properties related to the PasteEvent
     * @returns
     */
    var isExcelDesktopDocument = function (props) {
        var htmlAttributes = props.htmlAttributes;
        return (htmlAttributes[EXCEL_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE ||
            htmlAttributes[constants_1$4.PROG_ID_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE);
    };
    isExcelDesktopDocument$1.default = isExcelDesktopDocument;

    var isGoogleSheetDocument$1 = {};

    Object.defineProperty(isGoogleSheetDocument$1, "__esModule", { value: true });
    var constants_1$3 = constants;
    /**
     * @internal
     * Checks whether the fragment provided contain elements from Google sheets
     * @param props Properties related to the PasteEvent
     * @returns
     */
    var isGoogleSheetDocument = function (props) {
        var fragment = props.fragment;
        return !!fragment.querySelector(constants_1$3.GOOGLE_SHEET_NODE_NAME);
    };
    isGoogleSheetDocument$1.default = isGoogleSheetDocument;

    var isPowerPointDesktopDocument$1 = {};

    Object.defineProperty(isPowerPointDesktopDocument$1, "__esModule", { value: true });
    var constants_1$2 = constants;
    var POWERPOINT_ATTRIBUTE_VALUE = 'PowerPoint.Slide';
    /**
     * @internal
     * Checks whether the Array provided contains strings that identify Power Point Desktop documents
     * @param props Properties related to the PasteEvent
     * @returns
     */
    var isPowerPointDesktopDocument = function (props) {
        return props.htmlAttributes[constants_1$2.PROG_ID_NAME] == POWERPOINT_ATTRIBUTE_VALUE;
    };
    isPowerPointDesktopDocument$1.default = isPowerPointDesktopDocument;

    var isWordDesktopDocument$1 = {};

    Object.defineProperty(isWordDesktopDocument$1, "__esModule", { value: true });
    var constants_1$1 = constants;
    var WORD_ATTRIBUTE_NAME = 'xmlns:w';
    var WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';
    var WORD_PROG_ID = 'Word.Document';
    /**
     * @internal
     * Checks whether the Array provided contains strings that identify Word Desktop documents
     * @param props Properties related to the PasteEvent
     * @returns
     */
    var isWordDesktopDocument = function (props) {
        var htmlAttributes = props.htmlAttributes;
        return (htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE ||
            htmlAttributes[constants_1$1.PROG_ID_NAME] == WORD_PROG_ID);
    };
    isWordDesktopDocument$1.default = isWordDesktopDocument;

    var shouldConvertToSingleImage$1 = {};

    Object.defineProperty(shouldConvertToSingleImage$1, "__esModule", { value: true });
    /**
     * @internal
     * Checks whether the fragment only contains a single image to paste
     * and the editor have the ConvertSingleImageBody Experimental feature
     * @param props Properties related to the PasteEvent
     * @returns
     */
    var shouldConvertToSingleImage = function (props) {
        var _a;
        var shouldConvertSingleImage = props.shouldConvertSingleImage, clipboardData = props.clipboardData;
        return (shouldConvertSingleImage &&
            ((_a = clipboardData.htmlFirstLevelChildTags) === null || _a === void 0 ? void 0 : _a.length) == 1 &&
            clipboardData.htmlFirstLevelChildTags[0] == 'IMG');
    };
    shouldConvertToSingleImage$1.default = shouldConvertToSingleImage;

    Object.defineProperty(getPasteSource$1, "__esModule", { value: true });
    var documentContainWacElements_1 = documentContainWacElements$1;
    var isExcelDesktopDocument_1 = isExcelDesktopDocument$1;
    var isGoogleSheetDocument_1 = isGoogleSheetDocument$1;
    var isPowerPointDesktopDocument_1 = isPowerPointDesktopDocument$1;
    var isWordDesktopDocument_1 = isWordDesktopDocument$1;
    var shouldConvertToSingleImage_1 = shouldConvertToSingleImage$1;
    var getSourceFunctions = new Map([
        [0 /* WordDesktop */, isWordDesktopDocument_1.default],
        [1 /* ExcelDesktop */, isExcelDesktopDocument_1.default],
        [2 /* PowerPointDesktop */, isPowerPointDesktopDocument_1.default],
        [4 /* WacComponents */, documentContainWacElements_1.default],
        [3 /* GoogleSheets */, isGoogleSheetDocument_1.default],
        [6 /* SingleImage */, shouldConvertToSingleImage_1.default],
    ]);
    /**
     * @internal
     * This function tries to get the source of the Pasted content
     * @param event the before paste event
     * @param shouldConvertSingleImage Whether convert single image is enabled.
     * @returns The Type of pasted content, if no type found will return {KnownSourceType.Default}
     */
    function getPasteSource(event, shouldConvertSingleImage) {
        var htmlAttributes = event.htmlAttributes, clipboardData = event.clipboardData, fragment = event.fragment;
        var result = null;
        var param = {
            htmlAttributes: htmlAttributes,
            fragment: fragment,
            shouldConvertSingleImage: shouldConvertSingleImage,
            clipboardData: clipboardData,
        };
        getSourceFunctions.forEach(function (func, key) {
            if (!result && func(param)) {
                result = key;
            }
        });
        return result !== null && result !== void 0 ? result : 5 /* Default */;
    }
    getPasteSource$1.default = getPasteSource;

    var handleLineMerge$1 = {};

    Object.defineProperty(handleLineMerge$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$i = lib$3;
    /**
     * @internal
     * Process pasted content, if there are multiple blocks that are not wrapped by a shared ancestor node,
     * change the tag of first and last node to be SPAN so that it will be merged into current block
     * @param root Root node of content to process
     */
    function handleLineMerge(root) {
        var traverser = roosterjs_editor_dom_1$i.ContentTraverser.createBodyTraverser(root);
        var blocks = [];
        for (var block = traverser === null || traverser === void 0 ? void 0 : traverser.currentBlockElement; block; block = traverser.getNextBlockElement()) {
            blocks.push({
                start: block.getStartNode(),
                end: block.getEndNode(),
            });
        }
        if (blocks.length > 0) {
            var blocksLength = blocks.length - 1;
            processBlock(blocks[0]);
            processBlock(blocks[blocksLength]);
            checkAndAddBr(root, blocks[0], true /*isFirst*/);
            checkAndAddBr(root, blocks[blocksLength], false /*isFirst*/, blocks[0]);
        }
    }
    handleLineMerge$1.default = handleLineMerge;
    function processBlock(block) {
        var _a, _b;
        var start = block.start, end = block.end;
        if (start == end && (0, roosterjs_editor_dom_1$i.getTagOfNode)(start) == 'DIV') {
            var node = (0, roosterjs_editor_dom_1$i.changeElementTag)(start, 'SPAN');
            block.start = node;
            block.end = node;
            if ((0, roosterjs_editor_dom_1$i.getTagOfNode)(node.lastChild) == 'BR') {
                node.removeChild(node.lastChild);
            }
        }
        else if ((0, roosterjs_editor_dom_1$i.getTagOfNode)(end) == 'BR') {
            var node = end.ownerDocument.createTextNode('');
            (_a = end.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(node, end);
            block.end = node;
            (_b = end.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(end);
        }
    }
    function checkAndAddBr(root, block, isFirst, firstBlock) {
        var _a, _b, _c, _d;
        var blockElement = (0, roosterjs_editor_dom_1$i.getBlockElementAtNode)(root, block.start);
        var sibling = isFirst
            ? (0, roosterjs_editor_dom_1$i.getNextLeafSibling)(root, block.end)
            : (0, roosterjs_editor_dom_1$i.getPreviousLeafSibling)(root, block.start);
        if (!sibling) {
            return;
        }
        if (blockElement === null || blockElement === void 0 ? void 0 : blockElement.contains(sibling)) {
            var br = (_a = block.start.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement('br');
            if (br) {
                var blockToUse = isFirst ? block.end : block.start;
                (_b = blockToUse.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(br, isFirst ? block.end.nextSibling : block.start);
            }
        }
        else if (firstBlock &&
            firstBlock.end == firstBlock.start &&
            (0, roosterjs_editor_dom_1$i.getTagOfNode)(firstBlock.end) == 'SPAN') {
            // If the first block and the last block are Siblings, add a BR before so the only two
            // lines that are being pasted are not merged.
            var previousSibling = (0, roosterjs_editor_dom_1$i.getPreviousLeafSibling)(root, block.start);
            if (firstBlock.end.contains(previousSibling) &&
                !(0, roosterjs_editor_dom_1$i.findClosestElementAncestor)(block.start, root, 'li')) {
                var br = (_c = block.start.ownerDocument) === null || _c === void 0 ? void 0 : _c.createElement('br');
                if (br) {
                    (_d = block.start.parentNode) === null || _d === void 0 ? void 0 : _d.insertBefore(br, block.start);
                }
            }
        }
    }

    var sanitizeHtmlColorsFromPastedContent$1 = {};

    var deprecatedColorList = {};

    /**
     * @internal
     * List of deprecated colors that should be removed
     */
    Object.defineProperty(deprecatedColorList, "__esModule", { value: true });
    deprecatedColorList.DeprecatedColorList = void 0;
    deprecatedColorList.DeprecatedColorList = [
        'activeborder',
        'activecaption',
        'appworkspace',
        'background',
        'buttonhighlight',
        'buttonshadow',
        'captiontext',
        'inactiveborder',
        'inactivecaption',
        'inactivecaptiontext',
        'infobackground',
        'infotext',
        'menu',
        'menutext',
        'scrollbar',
        'threeddarkshadow',
        'threedface',
        'threedhighlight',
        'threedlightshadow',
        'threedfhadow',
        'window',
        'windowframe',
        'windowtext',
    ];

    Object.defineProperty(sanitizeHtmlColorsFromPastedContent$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$h = lib$3;
    var deprecatedColorList_1 = deprecatedColorList;
    /**
     * @internal
     * Remove the deprecated colors from pasted content
     * @param sanitizingOption the sanitizingOption of BeforePasteEvent
     * */
    function sanitizeHtmlColorsFromPastedContent(sanitizingOption) {
        ['color', 'background-color'].forEach(function (property) {
            (0, roosterjs_editor_dom_1$h.chainSanitizerCallback)(sanitizingOption.cssStyleCallbacks, property, function (value) { return deprecatedColorList_1.DeprecatedColorList.indexOf(value) < 0; });
        });
    }
    sanitizeHtmlColorsFromPastedContent$1.default = sanitizeHtmlColorsFromPastedContent;

    var sanitizeLinks$1 = {};

    Object.defineProperty(sanitizeLinks$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$g = lib$3;
    var HTTP = 'http:';
    var HTTPS = 'https:';
    var NOTES = 'notes:';
    /**
     * @internal
     * Clear local paths and remove link
     * @param sanitizingOption the sanitizingOption of BeforePasteEvent
     * */
    function sanitizeLinks(sanitizingOption) {
        (0, roosterjs_editor_dom_1$g.chainSanitizerCallback)(sanitizingOption.attributeCallbacks, 'href', function (value, element) { return validateLink(value, element); });
    }
    sanitizeLinks$1.default = sanitizeLinks;
    function validateLink(link, htmlElement) {
        var url;
        try {
            url = new URL(link);
        }
        catch (_a) {
            url = undefined;
        }
        if (url &&
            (url.protocol === HTTP ||
                url.protocol === HTTPS ||
                url.protocol === NOTES) /* whitelist Notes protocol */) {
            return link;
        }
        htmlElement.removeAttribute('href');
        return '';
    }

    Object.defineProperty(Paste$1, "__esModule", { value: true });
    var convertPasteContentForSingleImage_1 = convertPasteContentForSingleImage$1;
    var convertPastedContentForLI_1 = convertPastedContentForLI$1;
    var convertPastedContentFromExcel_1 = convertPastedContentFromExcel$1;
    var convertPastedContentFromOfficeOnline_1 = convertPastedContentFromOfficeOnline$1;
    var convertPastedContentFromPowerPoint_1 = convertPastedContentFromPowerPoint$1;
    var convertPastedContentFromWord_1 = convertPastedContentFromWord$1;
    var getPasteSource_1 = getPasteSource$1;
    var handleLineMerge_1 = handleLineMerge$1;
    var sanitizeHtmlColorsFromPastedContent_1 = sanitizeHtmlColorsFromPastedContent$1;
    var sanitizeLinks_1 = sanitizeLinks$1;
    var constants_1 = constants;
    /**
     * Paste plugin, handles BeforePaste event and reformat some special content, including:
     * 1. Content copied from Word
     * 2. Content copied from Excel
     * 3. Content copied from Word Online or OneNote Online
     */
    var Paste = /** @class */ (function () {
        /**
         * Construct a new instance of Paste class
         * @param unknownTagReplacement Replace solution of unknown tags, default behavior is to replace with SPAN
         * @param convertSingleImageBody When enabled, if clipboard HTML contains a single image, we reuse the image without modifying the src attribute.
         *                               When disabled, pasted image src attribute will use the dataUri from clipboard data -- By Default disabled.
         */
        function Paste(unknownTagReplacement, convertSingleImageBody) {
            if (unknownTagReplacement === void 0) { unknownTagReplacement = 'SPAN'; }
            if (convertSingleImageBody === void 0) { convertSingleImageBody = false; }
            this.unknownTagReplacement = unknownTagReplacement;
            this.convertSingleImageBody = convertSingleImageBody;
        }
        /**
         * Get a friendly name of  this plugin
         */
        Paste.prototype.getName = function () {
            return 'Paste';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        Paste.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        Paste.prototype.dispose = function () {
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        Paste.prototype.onPluginEvent = function (event) {
            if (event.eventType == 10 /* BeforePaste */) {
                var fragment = event.fragment, sanitizingOption = event.sanitizingOption;
                var trustedHTMLHandler = this.editor.getTrustedHTMLHandler();
                switch ((0, getPasteSource_1.default)(event, this.convertSingleImageBody)) {
                    case 0 /* WordDesktop */:
                        // Handle HTML copied from Word
                        (0, convertPastedContentFromWord_1.default)(event);
                        break;
                    case 1 /* ExcelDesktop */:
                        // Handle HTML copied from Excel
                        (0, convertPastedContentFromExcel_1.default)(event, trustedHTMLHandler);
                        break;
                    case 2 /* PowerPointDesktop */:
                        (0, convertPastedContentFromPowerPoint_1.default)(event, trustedHTMLHandler);
                        break;
                    case 4 /* WacComponents */:
                        (0, convertPastedContentFromOfficeOnline_1.default)(fragment);
                        break;
                    case 3 /* GoogleSheets */:
                        sanitizingOption.additionalTagReplacements[constants_1.GOOGLE_SHEET_NODE_NAME] = '*';
                        break;
                    case 6 /* SingleImage */:
                        (0, convertPasteContentForSingleImage_1.default)(event, trustedHTMLHandler);
                        break;
                    case 5 /* Default */:
                        (0, convertPastedContentForLI_1.default)(fragment);
                        (0, handleLineMerge_1.default)(fragment);
                        break;
                }
                (0, sanitizeLinks_1.default)(sanitizingOption);
                (0, sanitizeHtmlColorsFromPastedContent_1.default)(sanitizingOption);
                // Replace unknown tags with SPAN
                sanitizingOption.unknownTagReplacement = this.unknownTagReplacement;
            }
        };
        return Paste;
    }());
    Paste$1.default = Paste;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Paste = void 0;
    var Paste_1 = Paste$1;
    Object.defineProperty(exports, "Paste", { enumerable: true, get: function () { return Paste_1.default; } });

    }(Paste$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(Paste$2, exports);

    }(Paste$3));

    var Picker$1 = {};

    var Picker = {};

    var PickerPlugin$1 = {};

    Object.defineProperty(PickerPlugin$1, "__esModule", { value: true });
    var roosterjs_editor_api_1$5 = lib$1;
    var roosterjs_editor_dom_1$f = lib$3;
    // Character codes.
    // IE11 uses different character codes. which are noted below.
    // If adding a new key, test in IE to figure out what the code is.
    var BACKSPACE_CHAR_CODE = 'Backspace';
    var TAB_CHAR_CODE = 'Tab';
    var ENTER_CHAR_CODE = 'Enter';
    var ESC_CHAR_CODE = !roosterjs_editor_dom_1$f.Browser.isIE ? 'Escape' : 'Esc';
    var LEFT_ARROW_CHAR_CODE = !roosterjs_editor_dom_1$f.Browser.isIE ? 'ArrowLeft' : 'Left';
    var UP_ARROW_CHAR_CODE = !roosterjs_editor_dom_1$f.Browser.isIE ? 'ArrowUp' : 'Up';
    var RIGHT_ARROW_CHAR_CODE = !roosterjs_editor_dom_1$f.Browser.isIE ? 'ArrowRight' : 'Right';
    var DOWN_ARROW_CHAR_CODE = !roosterjs_editor_dom_1$f.Browser.isIE ? 'ArrowDown' : 'Down';
    var DELETE_CHAR_CODE = !roosterjs_editor_dom_1$f.Browser.isIE ? 'Delete' : 'Del';
    // Input event input types.
    var DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';
    // Unidentified key, the code for Android keyboard events.
    var UNIDENTIFIED_KEY = 'Unidentified';
    // the char code for Android keyboard events on Webview below 51.
    var UNIDENTIFIED_CODE = [0, 229];
    /**
     * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including
     * - Show picker when special trigger key is pressed
     * - Hide picker
     * - Change selection in picker by Up/Down/Left/Right
     * - Apply selected item in picker
     *
     * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.
     */
    var PickerPlugin = /** @class */ (function () {
        function PickerPlugin(dataProvider, pickerOptions) {
            this.dataProvider = dataProvider;
            this.pickerOptions = pickerOptions;
            // For detecting backspace in Android
            this.isPendingInputEventHandling = false;
        }
        /**
         * Get a friendly name
         */
        PickerPlugin.prototype.getName = function () {
            return 'Picker';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        PickerPlugin.prototype.initialize = function (editor) {
            var _this = this;
            this.editor = editor;
            this.dataProvider.onInitalize(function (htmlNode) {
                _this.editor.focus();
                var wordToReplace = _this.getWord(null);
                // Safari drops our focus out so we get an empty word to replace when we call getWord.
                // We fall back to using the lastKnownRange to try to get around this.
                if ((!wordToReplace || wordToReplace.length == 0) && _this.lastKnownRange) {
                    _this.editor.select(_this.lastKnownRange);
                    wordToReplace = _this.getWord(null);
                }
                var insertNode = function () {
                    if (wordToReplace) {
                        (0, roosterjs_editor_api_1$5.replaceWithNode)(_this.editor, wordToReplace, htmlNode, true /* exactMatch */);
                    }
                    else {
                        _this.editor.insertNode(htmlNode);
                    }
                    _this.setIsSuggesting(false);
                };
                _this.editor.addUndoSnapshot(insertNode, _this.pickerOptions.changeSource, _this.pickerOptions.handleAutoComplete);
            }, function (isSuggesting) {
                _this.setIsSuggesting(isSuggesting);
            }, editor);
        };
        /**
         * Dispose this plugin
         */
        PickerPlugin.prototype.dispose = function () {
            this.editor = null;
            this.isSuggesting = null;
            this.blockSuggestions = null;
            this.eventHandledOnKeyDown = null;
            this.lastKnownRange = null;
            this.isPendingInputEventHandling = null;
            this.currentInputLength = null;
            this.newInputLength = null;
            this.dataProvider.onDispose();
        };
        /**
         * Check if the plugin should handle the given event exclusively.
         * Handle an event exclusively means other plugin will not receive this event in
         * onPluginEvent method.
         * If two plugins will return true in willHandleEventExclusively() for the same event,
         * the final result depends on the order of the plugins are added into editor
         * @param event The event to check
         */
        PickerPlugin.prototype.willHandleEventExclusively = function (event) {
            return (this.isSuggesting &&
                (event.eventType == 0 /* KeyDown */ ||
                    event.eventType == 2 /* KeyUp */ ||
                    event.eventType == 3 /* Input */));
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        PickerPlugin.prototype.onPluginEvent = function (event) {
            switch (event.eventType) {
                case 7 /* ContentChanged */:
                    if (event.source == "SetContent" /* SetContent */ && this.dataProvider.onContentChanged) {
                        // Stop suggesting since content is fully changed
                        if (this.isSuggesting) {
                            this.setIsSuggesting(false);
                        }
                        // Undo and other major changes to document content fire this type of event.
                        // Inform the data provider of the current picker placed elements in the body.
                        var elementIds_1 = [];
                        this.editor.queryElements("[id^='" + this.pickerOptions.elementIdPrefix + "']", function (element) {
                            if (element.id) {
                                elementIds_1.push(element.id);
                            }
                        });
                        this.dataProvider.onContentChanged(elementIds_1);
                    }
                    break;
                case 0 /* KeyDown */:
                    this.eventHandledOnKeyDown = false;
                    if (this.isAndroidKeyboardEvent(event)) {
                        // On Android, the key for KeyboardEvent is "Unidentified" or undefined,
                        // so handling should be done using the input rather than key down event
                        // Since the key down event happens right before the input event, calculate the input
                        // length here in preparation for onAndroidInputEvent
                        this.currentInputLength = this.calcInputLength(event);
                        this.isPendingInputEventHandling = true;
                    }
                    else {
                        this.onKeyDownEvent(event);
                        this.isPendingInputEventHandling = false;
                    }
                    break;
                case 3 /* Input */:
                    if (this.isPendingInputEventHandling) {
                        this.onAndroidInputEvent(event);
                    }
                    break;
                case 2 /* KeyUp */:
                    if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {
                        this.onKeyUpDomEvent(event);
                        this.isPendingInputEventHandling = false;
                    }
                    break;
                case 6 /* MouseUp */:
                    if (this.isSuggesting) {
                        this.setIsSuggesting(false);
                    }
                    break;
                case 14 /* Scroll */:
                    if (this.dataProvider.onScroll) {
                        // Dispatch scroll event to data provider
                        this.dataProvider.onScroll(event.scrollContainer);
                    }
                    break;
            }
        };
        PickerPlugin.prototype.setLastKnownRange = function (range) {
            this.lastKnownRange = range;
        };
        PickerPlugin.prototype.setIsSuggesting = function (isSuggesting) {
            this.isSuggesting = isSuggesting;
            if (!isSuggesting) {
                this.setLastKnownRange(null);
            }
            this.dataProvider.onIsSuggestingChanged(isSuggesting);
            this.setAriaOwns(isSuggesting);
            this.setAriaActiveDescendant(isSuggesting ? 0 : null);
        };
        PickerPlugin.prototype.cancelDefaultKeyDownEvent = function (event) {
            this.eventHandledOnKeyDown = true;
            event.rawEvent.preventDefault();
            event.rawEvent.stopImmediatePropagation();
        };
        PickerPlugin.prototype.getIdValue = function (node) {
            var element = node;
            return element.attributes && element.attributes.getNamedItem('id')
                ? element.attributes.getNamedItem('id').value
                : null;
        };
        PickerPlugin.prototype.getWordBeforeCursor = function (event) {
            var searcher = this.editor.getContentSearcherOfCursor(event);
            return searcher ? searcher.getWordBefore() : null;
        };
        PickerPlugin.prototype.replaceNode = function (currentNode, replacementNode) {
            if (currentNode) {
                this.editor.deleteNode(currentNode);
            }
            if (replacementNode) {
                this.editor.insertNode(replacementNode);
            }
        };
        PickerPlugin.prototype.getRangeUntilAt = function (event) {
            var _this = this;
            var positionContentSearcher = this.editor.getContentSearcherOfCursor(event);
            var startPos;
            var endPos;
            positionContentSearcher.forEachTextInlineElement(function (textInline) {
                var hasMatched = false;
                var nodeContent = textInline.getTextContent();
                var nodeIndex = nodeContent ? nodeContent.length : -1;
                while (nodeIndex >= 0) {
                    if (nodeContent[nodeIndex] == _this.pickerOptions.triggerCharacter) {
                        startPos = textInline.getStartPosition().move(nodeIndex);
                        hasMatched = true;
                        break;
                    }
                    nodeIndex--;
                }
                if (hasMatched) {
                    endPos = textInline.getEndPosition();
                }
                return hasMatched;
            });
            return (0, roosterjs_editor_dom_1$f.createRange)(startPos, endPos) || this.editor.getDocument().createRange();
        };
        PickerPlugin.prototype.shouldHandleKeyUpEvent = function (event) {
            // onKeyUpDomEvent should only be called when a key that produces a character value is pressed
            // This check will always fail on Android since the KeyboardEvent's key is "Unidentified" or undefined
            // However, we don't need to check for modifier events on mobile, so can ignore this check
            return (this.isAndroidKeyboardEvent(event) ||
                (0, roosterjs_editor_dom_1$f.isCharacterValue)(event.rawEvent) ||
                (this.isSuggesting && !(0, roosterjs_editor_dom_1$f.isModifierKey)(event.rawEvent)));
        };
        PickerPlugin.prototype.onKeyUpDomEvent = function (event) {
            if (this.isSuggesting) {
                // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.
                var wordBeforeCursor = this.getWord(event);
                var wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);
                var trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();
                // If we hit a case where wordBeforeCursor is just the trigger character,
                // that means we've gotten a onKeyUp event right after it's been typed.
                // Otherwise, update the query string when:
                // 1. There's an actual value
                // 2. That actual value isn't just pure whitespace
                // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)
                // Otherwise, we want to dismiss the picker plugin's UX.
                if (wordBeforeCursor == this.pickerOptions.triggerCharacter ||
                    (trimmedWordBeforeCursor &&
                        trimmedWordBeforeCursor.length > 0 &&
                        trimmedWordBeforeCursor.split(' ').length <= 4)) {
                    this.dataProvider.queryStringUpdated(trimmedWordBeforeCursor, wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor);
                    this.setLastKnownRange(this.editor.getSelectionRange());
                }
                else {
                    this.setIsSuggesting(false);
                }
            }
            else {
                var wordBeforeCursor = this.getWordBeforeCursor(event);
                if (!this.blockSuggestions) {
                    if (wordBeforeCursor != null &&
                        wordBeforeCursor.split(' ').length <= 4 &&
                        wordBeforeCursor[0] == this.pickerOptions.triggerCharacter) {
                        this.setIsSuggesting(true);
                        var wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);
                        var trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();
                        this.dataProvider.queryStringUpdated(trimmedWordBeforeCursor, wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor);
                        this.setLastKnownRange(this.editor.getSelectionRange());
                        if (this.dataProvider.setCursorPoint) {
                            // Determine the bounding rectangle for the @mention
                            var searcher = this.editor.getContentSearcherOfCursor(event);
                            var rangeNode = this.editor.getDocument().createRange();
                            var nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();
                            var rangeStartSuccessfullySet = this.setRangeStart(rangeNode, nodeBeforeCursor, wordBeforeCursor);
                            if (!rangeStartSuccessfullySet) {
                                // VSO 24891: Out of range error is occurring because nodeBeforeCursor
                                // is not including the trigger character. In this case, the node before
                                // the node before cursor is the trigger character, and this is where the range should start.
                                var nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;
                                this.setRangeStart(rangeNode, nodeBeforeNodeBeforeCursor, this.pickerOptions.triggerCharacter);
                            }
                            var rect = rangeNode.getBoundingClientRect();
                            // Safari's support for range.getBoundingClientRect is incomplete.
                            // We perform this check to fall back to getClientRects in case it's at the page origin.
                            if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {
                                rect = rangeNode.getClientRects()[0];
                            }
                            if (rect) {
                                rangeNode.detach();
                                // Display the @mention popup in the correct place
                                var targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };
                                var bufferZone = (rect.bottom - rect.top) / 2;
                                this.dataProvider.setCursorPoint(targetPoint, bufferZone);
                            }
                        }
                    }
                }
                else {
                    if (wordBeforeCursor != null &&
                        wordBeforeCursor[0] != this.pickerOptions.triggerCharacter) {
                        this.blockSuggestions = false;
                    }
                }
            }
        };
        PickerPlugin.prototype.onKeyDownEvent = function (event) {
            var keyboardEvent = event.rawEvent;
            if (this.isSuggesting) {
                if (keyboardEvent.key == ESC_CHAR_CODE) {
                    this.setIsSuggesting(false);
                    this.blockSuggestions = true;
                    this.cancelDefaultKeyDownEvent(event);
                }
                else if (keyboardEvent.key == BACKSPACE_CHAR_CODE) {
                    // #483: If we are backspacing over the trigger character that triggered this Picker
                    // then we need to hide the Picker
                    var wordBeforeCursor = this.getWord(event);
                    if (wordBeforeCursor == this.pickerOptions.triggerCharacter) {
                        this.setIsSuggesting(false);
                    }
                }
                else if (this.dataProvider.shiftHighlight &&
                    (this.pickerOptions.isHorizontal
                        ? keyboardEvent.key == LEFT_ARROW_CHAR_CODE ||
                            keyboardEvent.key == RIGHT_ARROW_CHAR_CODE
                        : keyboardEvent.key == UP_ARROW_CHAR_CODE ||
                            keyboardEvent.key == DOWN_ARROW_CHAR_CODE)) {
                    this.dataProvider.shiftHighlight(this.pickerOptions.isHorizontal
                        ? keyboardEvent.key == RIGHT_ARROW_CHAR_CODE
                        : keyboardEvent.key == DOWN_ARROW_CHAR_CODE);
                    if (this.dataProvider.getSelectedIndex) {
                        this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());
                    }
                    this.cancelDefaultKeyDownEvent(event);
                }
                else if (this.dataProvider.selectOption &&
                    (keyboardEvent.key == ENTER_CHAR_CODE || keyboardEvent.key == TAB_CHAR_CODE)) {
                    this.dataProvider.selectOption();
                    this.cancelDefaultKeyDownEvent(event);
                }
                else ;
            }
            else {
                if (keyboardEvent.key == BACKSPACE_CHAR_CODE) {
                    var nodeRemoved = this.tryRemoveNode(event);
                    if (nodeRemoved) {
                        this.cancelDefaultKeyDownEvent(event);
                    }
                }
                else if (keyboardEvent.key == DELETE_CHAR_CODE) {
                    var searcher = this.editor.getContentSearcherOfCursor(event);
                    var nodeAfterCursor = searcher.getInlineElementAfter()
                        ? searcher.getInlineElementAfter().getContainerNode()
                        : null;
                    var nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;
                    if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {
                        var replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);
                        this.replaceNode(nodeAfterCursor, replacementNode);
                        this.cancelDefaultKeyDownEvent(event);
                    }
                }
            }
        };
        PickerPlugin.prototype.onAndroidInputEvent = function (event) {
            this.newInputLength = this.calcInputLength(event);
            if (this.newInputLength < this.currentInputLength ||
                event.rawEvent.inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE) {
                var nodeRemoved = this.tryRemoveNode(event);
                if (nodeRemoved) {
                    this.eventHandledOnKeyDown = true;
                }
            }
        };
        PickerPlugin.prototype.calcInputLength = function (event) {
            var wordBeforeCursor = this.getInlineElementBeforeCursor(event);
            return wordBeforeCursor ? wordBeforeCursor.length : 0;
        };
        PickerPlugin.prototype.tryRemoveNode = function (event) {
            var searcher = this.editor.getContentSearcherOfCursor(event);
            var inlineElementBefore = searcher.getInlineElementBefore();
            var nodeBeforeCursor = inlineElementBefore
                ? inlineElementBefore.getContainerNode()
                : null;
            var nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;
            var inlineElementAfter = searcher.getInlineElementAfter();
            if (nodeId &&
                nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&
                (inlineElementAfter == null || !(inlineElementAfter instanceof roosterjs_editor_dom_1$f.PartialInlineElement))) {
                var replacementNode_1 = this.dataProvider.onRemove(nodeBeforeCursor, true);
                if (replacementNode_1) {
                    this.replaceNode(nodeBeforeCursor, replacementNode_1);
                    if (this.isPendingInputEventHandling) {
                        this.editor.runAsync(function (editor) {
                            editor.select(replacementNode_1, -3 /* After */);
                        });
                    }
                    else {
                        this.editor.select(replacementNode_1, -3 /* After */);
                    }
                }
                else {
                    this.editor.deleteNode(nodeBeforeCursor);
                }
                return true;
            }
            return false;
        };
        PickerPlugin.prototype.getWord = function (event) {
            var wordFromRange = this.getRangeUntilAt(event).toString();
            var wordFromCache = this.getWordBeforeCursor(event);
            // VSO 24891: In picker, trigger and mention are separated into two nodes.
            // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,
            // so wordFromCache is what we want to return.
            if (wordFromRange == this.pickerOptions.triggerCharacter &&
                wordFromRange != wordFromCache) {
                return wordFromCache;
            }
            return wordFromRange;
        };
        PickerPlugin.prototype.setRangeStart = function (rangeNode, node, target) {
            var nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;
            if (nodeOffset > -1) {
                rangeNode.setStart(node, nodeOffset);
                return true;
            }
            return false;
        };
        PickerPlugin.prototype.setAriaOwns = function (isSuggesting) {
            this.editor.setEditorDomAttribute('aria-owns', isSuggesting && this.pickerOptions.suggestionsLabel
                ? this.pickerOptions.suggestionsLabel
                : null);
        };
        PickerPlugin.prototype.setAriaActiveDescendant = function (selectedIndex) {
            this.editor.setEditorDomAttribute('aria-activedescendant', selectedIndex != null && this.pickerOptions.suggestionLabelPrefix
                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()
                : null);
        };
        PickerPlugin.prototype.getInlineElementBeforeCursor = function (event) {
            var searcher = this.editor.getContentSearcherOfCursor(event);
            var element = searcher ? searcher.getInlineElementBefore() : null;
            return element ? element.getTextContent() : null;
        };
        PickerPlugin.prototype.isAndroidKeyboardEvent = function (event) {
            // Check keyboard events on Android for further handling.
            // On Android Webview later 51, the KeyboardEvent's key is "Unidentified".
            // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,
            // so using the charCode property, which is 0 or 229.
            return (event.rawEvent.key == UNIDENTIFIED_KEY ||
                (event.rawEvent.key == undefined &&
                    UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1));
        };
        return PickerPlugin;
    }());
    PickerPlugin$1.default = PickerPlugin;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PickerPlugin = void 0;
    var PickerPlugin_1 = PickerPlugin$1;
    Object.defineProperty(exports, "PickerPlugin", { enumerable: true, get: function () { return PickerPlugin_1.default; } });

    }(Picker));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(Picker, exports);

    }(Picker$1));

    var TableResize$3 = {};

    var TableResize$2 = {};

    var TableResize$1 = {};

    var TableEditor$1 = {};

    var CellResizer = {};

    Object.defineProperty(CellResizer, "__esModule", { value: true });
    var DragAndDropHelper_1$2 = DragAndDropHelper$1;
    var roosterjs_editor_dom_1$e = lib$3;
    var CELL_RESIZER_WIDTH = 4;
    var MIN_CELL_WIDTH$1 = 30;
    /**
     * @internal
     */
    function createCellResizer(td, zoomScale, isRTL, isHorizontal, onStart, onEnd, onShowHelperElement) {
        var document = td.ownerDocument;
        var createElementData = {
            tag: 'div',
            style: "position: fixed; cursor: " + (isHorizontal ? 'row' : 'col') + "-resize; user-select: none",
        };
        onShowHelperElement === null || onShowHelperElement === void 0 ? void 0 : onShowHelperElement(createElementData, 'CellResizer');
        var div = (0, roosterjs_editor_dom_1$e.createElement)(createElementData, document);
        document.body.appendChild(div);
        var context = { td: td, isRTL: isRTL, zoomScale: zoomScale, onStart: onStart };
        var setPosition = isHorizontal ? setHorizontalPosition : setVerticalPosition;
        setPosition(context, div);
        var handler = {
            onDragStart: onDragStart$1,
            onDragging: isHorizontal ? onDraggingHorizontal : onDraggingVertical,
            onDragEnd: onEnd,
        };
        var featureHandler = new DragAndDropHelper_1$2.default(div, context, setPosition, handler, zoomScale);
        return { node: td, div: div, featureHandler: featureHandler };
    }
    CellResizer.default = createCellResizer;
    function onDragStart$1(context, event) {
        var td = context.td, isRTL = context.isRTL, zoomScale = context.zoomScale, onStart = context.onStart;
        var vTable = new roosterjs_editor_dom_1$e.VTable(td, true /*normalizeSize*/, zoomScale);
        var rect = (0, roosterjs_editor_dom_1$e.normalizeRect)(td.getBoundingClientRect());
        if (rect) {
            onStart();
            // calculate and retrieve the cells of the two columns shared by the current vertical resizer
            var currentCells = vTable.getCellsWithBorder(isRTL ? rect.left : rect.right, !isRTL);
            var nextCells = vTable.getCellsWithBorder(isRTL ? rect.left : rect.right, isRTL);
            return {
                vTable: vTable,
                currentCells: currentCells,
                nextCells: nextCells,
                initialX: event.pageX,
            };
        }
        else {
            return { vTable: vTable, currentCells: [], nextCells: [], initialX: 0 }; // Just a fallback
        }
    }
    function onDraggingHorizontal(context, event, initValue, deltaX, deltaY) {
        var td = context.td, zoomScale = context.zoomScale;
        var vTable = initValue.vTable;
        vTable.table.removeAttribute('height');
        vTable.table.style.height = null;
        vTable.forEachCellOfCurrentRow(function (cell) {
            if (cell.td) {
                cell.td.style.height = cell.td == td ? cell.height / zoomScale + deltaY + "px" : null;
            }
        });
        // To avoid apply format styles when the table is being resizing, the skipApplyFormat is set to true.
        vTable.writeBack(true /**skipApplyFormat*/);
        return true;
    }
    function onDraggingVertical(context, event, initValue, deltaX) {
        var isRTL = context.isRTL, zoomScale = context.zoomScale;
        var vTable = initValue.vTable, nextCells = initValue.nextCells, currentCells = initValue.currentCells, initialX = initValue.initialX;
        if (!canResizeColumns(event.pageX, currentCells, nextCells, isRTL, zoomScale)) {
            return false;
        }
        // Since we allow the user to resize the table width on adjusting the border of the last cell,
        // we need to make the table width resizable by setting it as null;
        // We also allow the user to resize the table width if Shift key is pressed
        var isLastCell = nextCells.length == 0;
        var isShiftPressed = event.shiftKey;
        if (isLastCell || isShiftPressed) {
            vTable.table.style.width = null;
        }
        var newWidthList = new Map();
        currentCells.forEach(function (td) {
            var rect = (0, roosterjs_editor_dom_1$e.normalizeRect)(td.getBoundingClientRect());
            if (rect) {
                td.style.wordBreak = 'break-word';
                td.style.whiteSpace = 'normal';
                td.style.boxSizing = 'border-box';
                var newWidth = getHorizontalDistance(rect, event.pageX, !isRTL) / zoomScale;
                newWidthList.set(td, newWidth);
            }
        });
        newWidthList.forEach(function (newWidth, td) {
            td.style.width = newWidth + "px";
        });
        if (!isShiftPressed) {
            nextCells.forEach(function (td) {
                var width = td.rowSpan > 1 ? 0 : td.getBoundingClientRect().right - initialX;
                td.style.wordBreak = 'break-word';
                td.style.whiteSpace = 'normal';
                td.style.boxSizing = 'border-box';
                td.style.width = td.rowSpan > 1 ? '' : width / zoomScale - deltaX + 'px';
            });
        }
        // To avoid apply format styles when the table is being resizing, the skipApplyFormat is set to true.
        vTable.writeBack(true /**skipApplyFormat*/);
        return true;
    }
    function getHorizontalDistance(rect, pos, toLeft) {
        return toLeft ? pos - rect.left : rect.right - pos;
    }
    function setHorizontalPosition(context, trigger) {
        var td = context.td;
        var rect = (0, roosterjs_editor_dom_1$e.normalizeRect)(td.getBoundingClientRect());
        if (rect) {
            trigger.style.top = rect.bottom - CELL_RESIZER_WIDTH + 'px';
            trigger.style.left = rect.left + 'px';
            trigger.style.width = rect.right - rect.left + 'px';
            trigger.style.height = CELL_RESIZER_WIDTH + 'px';
        }
    }
    function setVerticalPosition(context, trigger) {
        var td = context.td, isRTL = context.isRTL;
        var rect = (0, roosterjs_editor_dom_1$e.normalizeRect)(td.getBoundingClientRect());
        if (rect) {
            trigger.style.top = rect.top + 'px';
            trigger.style.left = (isRTL ? rect.left : rect.right) - CELL_RESIZER_WIDTH + 1 + 'px';
            trigger.style.width = CELL_RESIZER_WIDTH + 'px';
            trigger.style.height = rect.bottom - rect.top + 'px';
        }
    }
    /**
     *
     * @param newPos The position to where we want to move the vertical border
     * @returns if the move is allowed, or, if any of the cells on either side of the vertical border is smaller than
     * the minimum width, such move is not allowed
     */
    function canResizeColumns(newPos, currentCells, nextCells, isRTL, zoomScale) {
        for (var i = 0; i < currentCells.length; i++) {
            var td = currentCells[i];
            var rect = (0, roosterjs_editor_dom_1$e.normalizeRect)(td.getBoundingClientRect());
            if (rect) {
                var width = getHorizontalDistance(rect, newPos, !isRTL) / zoomScale;
                if (width < MIN_CELL_WIDTH$1) {
                    return false;
                }
            }
        }
        for (var i = 0; i < nextCells.length; i++) {
            var td = nextCells[i];
            var width = Number.MAX_SAFE_INTEGER;
            if (td) {
                var rect = (0, roosterjs_editor_dom_1$e.normalizeRect)(td.getBoundingClientRect());
                if (rect) {
                    width = getHorizontalDistance(rect, newPos, isRTL) / zoomScale;
                }
            }
            if (width < MIN_CELL_WIDTH$1) {
                return false;
            }
        }
        return true;
    }

    var TableInserter = {};

    Object.defineProperty(TableInserter, "__esModule", { value: true });
    var roosterjs_editor_dom_1$d = lib$3;
    var INSERTER_COLOR = '#4A4A4A';
    var INSERTER_COLOR_DARK_MODE = 'white';
    var INSERTER_SIDE_LENGTH = 12;
    var INSERTER_BORDER_SIZE = 1;
    /**
     * @internal
     */
    function createTableInserter(editor, td, isRTL, isHorizontal, onInsert, onShowHelperElement) {
        var table = editor.getElementAtCursor('table', td);
        var tdRect = (0, roosterjs_editor_dom_1$d.normalizeRect)(td.getBoundingClientRect());
        var tableRect = table ? (0, roosterjs_editor_dom_1$d.getIntersectedRect)([table], [editor.getVisibleViewport()]) : null;
        // set inserter position
        if (tdRect && tableRect) {
            var document_1 = td.ownerDocument;
            var createElementData = getInsertElementData(isHorizontal, editor.isDarkMode(), isRTL, editor.getDefaultFormat().backgroundColor || 'white');
            onShowHelperElement === null || onShowHelperElement === void 0 ? void 0 : onShowHelperElement(createElementData, 'TableInserter');
            var div = (0, roosterjs_editor_dom_1$d.createElement)(createElementData, document_1);
            if (isHorizontal) {
                div.style.left = (isRTL
                    ? tdRect.right
                    : tdRect.left - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)) + "px";
                div.style.top = tdRect.bottom - 8 + "px";
                div.firstChild.style.width = tableRect.right - tableRect.left + "px";
            }
            else {
                div.style.left = (isRTL ? tdRect.left - 8 : tdRect.right - 8) + "px";
                div.style.top = tdRect.top - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE) + "px";
                div.firstChild.style.height = tableRect.bottom - tableRect.top + "px";
            }
            document_1.body.appendChild(div);
            var handler = new TableInsertHandler(div, td, isHorizontal, editor, onInsert);
            return { div: div, featureHandler: handler, node: td };
        }
        return null;
    }
    TableInserter.default = createTableInserter;
    var TableInsertHandler = /** @class */ (function () {
        function TableInsertHandler(div, td, isHorizontal, editor, onInsert) {
            var _this = this;
            this.div = div;
            this.td = td;
            this.isHorizontal = isHorizontal;
            this.editor = editor;
            this.onInsert = onInsert;
            this.insertTd = function () {
                var vtable = new roosterjs_editor_dom_1$d.VTable(_this.td);
                if (!_this.isHorizontal) {
                    vtable.normalizeTableCellSize(_this.editor.getZoomScale());
                    // Since adding new column will cause table width to change, we need to remove width properties
                    vtable.table.removeAttribute('width');
                    vtable.table.style.width = null;
                }
                vtable.edit(_this.isHorizontal ? 1 /* InsertBelow */ : 3 /* InsertRight */);
                vtable.writeBack();
                _this.onInsert(vtable.table);
            };
            this.div.addEventListener('click', this.insertTd);
        }
        TableInsertHandler.prototype.dispose = function () {
            this.div.removeEventListener('click', this.insertTd);
            this.div = null;
            this.editor = null;
        };
        return TableInsertHandler;
    }());
    function getInsertElementData(isHorizontal, isDark, isRTL, backgroundColor) {
        var inserterColor = isDark ? INSERTER_COLOR_DARK_MODE : INSERTER_COLOR;
        var outerDivStyle = "position: fixed; width: " + INSERTER_SIDE_LENGTH + "px; height: " + INSERTER_SIDE_LENGTH + "px; font-size: 16px; color: " + inserterColor + "; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid " + INSERTER_BORDER_SIZE + "px " + inserterColor + "; border-radius: 50%; background-color: " + backgroundColor;
        var leftOrRight = isRTL ? 'right' : 'left';
        var childBaseStyles = "position: absolute; box-sizing: border-box; background-color: " + backgroundColor + ";";
        var childInfo = {
            tag: 'div',
            style: childBaseStyles +
                (isHorizontal
                    ? leftOrRight + ": 12px; top: 5px; height: 3px; border-top: 1px solid " + inserterColor + "; border-bottom: 1px solid " + inserterColor + "; border-right: 1px solid " + inserterColor + "; border-left: 0px;"
                    : "left: 5px; top: 12px; width: 3px; border-left: 1px solid " + inserterColor + "; border-right: 1px solid " + inserterColor + "; border-bottom: 1px solid " + inserterColor + "; border-top: 0px;"),
        };
        return {
            tag: 'div',
            style: outerDivStyle,
            children: [childInfo, '+'],
        };
    }

    var TableResizer = {};

    Object.defineProperty(TableResizer, "__esModule", { value: true });
    var DragAndDropHelper_1$1 = DragAndDropHelper$1;
    var roosterjs_editor_dom_1$c = lib$3;
    var TABLE_RESIZER_LENGTH$1 = 12;
    var MIN_CELL_WIDTH = 30;
    var MIN_CELL_HEIGHT = 20;
    /**
     * @internal
     */
    function createTableResizer(table, zoomScale, isRTL, onStart, onDragEnd, onShowHelperElement) {
        var document = table.ownerDocument;
        var createElementData = {
            tag: 'div',
            style: "position: fixed; cursor: " + (isRTL ? 'ne' : 'nw') + "-resize; user-select: none; border: 1px solid #808080",
        };
        onShowHelperElement === null || onShowHelperElement === void 0 ? void 0 : onShowHelperElement(createElementData, 'TableResizer');
        var div = (0, roosterjs_editor_dom_1$c.createElement)(createElementData, document);
        div.style.width = TABLE_RESIZER_LENGTH$1 + "px";
        div.style.height = TABLE_RESIZER_LENGTH$1 + "px";
        document.body.appendChild(div);
        var context = {
            isRTL: isRTL,
            table: table,
            zoomScale: zoomScale,
            onStart: onStart,
        };
        setResizeDivPosition(context, div);
        var featureHandler = new DragAndDropHelper_1$1.default(div, context, setResizeDivPosition, {
            onDragStart: onDragStart,
            onDragging: onDragging,
            onDragEnd: onDragEnd,
        }, zoomScale);
        return { node: table, div: div, featureHandler: featureHandler };
    }
    TableResizer.default = createTableResizer;
    function onDragStart(context) {
        context.onStart();
        return {
            originalRect: context.table.getBoundingClientRect(),
            vTable: new roosterjs_editor_dom_1$c.VTable(context.table, true /*normalizeTable*/, context.zoomScale),
        };
    }
    function onDragging(context, event, initValue, deltaX, deltaY) {
        var isRTL = context.isRTL, zoomScale = context.zoomScale;
        var originalRect = initValue.originalRect, vTable = initValue.vTable;
        var ratioX = 1.0 + (deltaX / originalRect.width) * zoomScale * (isRTL ? -1 : 1);
        var ratioY = 1.0 + (deltaY / originalRect.height) * zoomScale;
        var shouldResizeX = Math.abs(ratioX - 1.0) > 1e-3;
        var shouldResizeY = Math.abs(ratioY - 1.0) > 1e-3;
        if (shouldResizeX || shouldResizeY) {
            for (var i = 0; i < vTable.cells.length; i++) {
                for (var j = 0; j < vTable.cells[i].length; j++) {
                    var cell = vTable.cells[i][j];
                    if (cell.td) {
                        if (shouldResizeX) {
                            // the width of some external table is fixed, we need to make it resizable
                            vTable.table.style.width = null;
                            var newWidth = (cell.width * ratioX) / zoomScale;
                            cell.td.style.boxSizing = 'border-box';
                            if (newWidth >= MIN_CELL_WIDTH) {
                                cell.td.style.wordBreak = 'break-word';
                                cell.td.style.whiteSpace = 'normal';
                                cell.td.style.width = newWidth + "px";
                            }
                        }
                        if (shouldResizeY) {
                            // the height of some external table is fixed, we need to make it resizable
                            vTable.table.style.height = null;
                            if (j == 0) {
                                var newHeight = (cell.height * ratioY) / zoomScale;
                                if (newHeight >= MIN_CELL_HEIGHT) {
                                    cell.td.style.height = newHeight + "px";
                                }
                            }
                            else {
                                cell.td.style.height = null;
                            }
                        }
                    }
                }
            }
            // To avoid apply format styles when the table is being resizing, the skipApplyFormat is set to true.
            vTable.writeBack(true /**skipApplyFormat*/);
            return true;
        }
        else {
            return false;
        }
    }
    function setResizeDivPosition(context, trigger) {
        var table = context.table, isRTL = context.isRTL;
        var rect = (0, roosterjs_editor_dom_1$c.normalizeRect)(table.getBoundingClientRect());
        if (rect) {
            trigger.style.top = rect.bottom + "px";
            trigger.style.left = isRTL
                ? rect.left - TABLE_RESIZER_LENGTH$1 - 2 + "px"
                : rect.right + "px";
        }
    }

    var TableSelector = {};

    Object.defineProperty(TableSelector, "__esModule", { value: true });
    var DragAndDropHelper_1 = DragAndDropHelper$1;
    var roosterjs_editor_dom_1$b = lib$3;
    var TABLE_SELECTOR_LENGTH = 12;
    var TABLE_SELECTOR_ID = '_Table_Selector';
    /**
     * @internal
     */
    function createTableSelector(table, zoomScale, editor, onFinishDragging, onShowHelperElement, contentDiv) {
        var rect = (0, roosterjs_editor_dom_1$b.normalizeRect)(table.getBoundingClientRect());
        if (!isTableTopVisible(editor, rect, contentDiv)) {
            return null;
        }
        var document = table.ownerDocument;
        var createElementData = {
            tag: 'div',
            style: 'position: fixed; cursor: all-scroll; user-select: none; border: 1px solid #808080',
        };
        onShowHelperElement === null || onShowHelperElement === void 0 ? void 0 : onShowHelperElement(createElementData, 'TableSelector');
        var div = (0, roosterjs_editor_dom_1$b.createElement)(createElementData, document);
        div.id = TABLE_SELECTOR_ID;
        div.style.width = TABLE_SELECTOR_LENGTH + "px";
        div.style.height = TABLE_SELECTOR_LENGTH + "px";
        document.body.appendChild(div);
        var context = {
            table: table,
            zoomScale: zoomScale,
            rect: rect,
        };
        setSelectorDivPosition(context, div);
        var onDragEnd = function (context, event) {
            if (event.target == div) {
                onFinishDragging(context.table);
            }
            return false;
        };
        var featureHandler = new DragAndDropHelper_1.default(div, context, setSelectorDivPosition, {
            onDragEnd: onDragEnd,
        }, zoomScale);
        return { div: div, featureHandler: featureHandler, node: table };
    }
    TableSelector.default = createTableSelector;
    function setSelectorDivPosition(context, trigger) {
        var rect = context.rect;
        if (rect) {
            trigger.style.top = rect.top - TABLE_SELECTOR_LENGTH + "px";
            trigger.style.left = rect.left - TABLE_SELECTOR_LENGTH - 2 + "px";
        }
    }
    function isTableTopVisible(editor, rect, contentDiv) {
        var visibleViewport = editor.getVisibleViewport();
        if (contentDiv && (0, roosterjs_editor_dom_1$b.safeInstanceOf)(contentDiv, 'HTMLElement') && visibleViewport && rect) {
            var containerRect = (0, roosterjs_editor_dom_1$b.normalizeRect)(contentDiv.getBoundingClientRect());
            return containerRect.top <= rect.top && visibleViewport.top <= rect.top;
        }
        return true;
    }

    var TableEditorFeature = {};

    Object.defineProperty(TableEditorFeature, "__esModule", { value: true });
    TableEditorFeature.disposeTableEditFeature = void 0;
    /**
     * @internal
     */
    function disposeTableEditFeature(resizer) {
        var _a, _b, _c;
        if (resizer) {
            (_b = (_a = resizer.div) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(resizer.div);
            resizer.div = null;
            (_c = resizer.featureHandler) === null || _c === void 0 ? void 0 : _c.dispose();
            resizer.featureHandler = null;
        }
    }
    TableEditorFeature.disposeTableEditFeature = disposeTableEditFeature;

    Object.defineProperty(TableEditor$1, "__esModule", { value: true });
    var CellResizer_1 = CellResizer;
    var TableInserter_1 = TableInserter;
    var TableResizer_1 = TableResizer;
    var TableSelector_1 = TableSelector;
    var TableEditorFeature_1 = TableEditorFeature;
    var roosterjs_editor_dom_1$a = lib$3;
    var INSERTER_HOVER_OFFSET = 5;
    /**
     * @internal
     *
     * A table has 6 hot areas to be resized/edited (take LTR example):
     *
     *   [6]  [                ]
     *       +[      1         ]+--------------------+
     *       |[                ]|                    |
     *      [ ]               [ ]                    |
     *      [ ]               [ ]                    |
     *      [2]               [3]                    |
     *      [ ]               [ ]                    |
     *      [ ][       4       ]|                    |
     *       +------------------+--------------------+
     *       |                  |                    |
     *       |                  |                    |
     *       |                  |                    |
     *       +------------------+--------------------+
     *                                                [5]
     *
     * 1 - Hover area to show insert column button
     * 2 - Hover area to show insert row button
     * 3 - Hover area to show vertical resizing bar
     * 4 - Hover area to show horizontal resizing bar
     * 5 - Hover area to show whole table resize button
     * 6 - Hover area to show whole table selector button
     *
     * When set a different current table or change current TD, we need to update these areas
     */
    var TableEditor = /** @class */ (function () {
        function TableEditor(editor, table, onChanged, onShowHelperElement, contentDiv) {
            var _this = this;
            this.editor = editor;
            this.table = table;
            this.onChanged = onChanged;
            this.onShowHelperElement = onShowHelperElement;
            // 1, 2 - Insert a column or a row
            this.horizontalInserter = null;
            this.verticalInserter = null;
            // 3, 4 - Resize a column or a row from a cell
            this.horizontalResizer = null;
            this.verticalResizer = null;
            this.onFinishEditing = function () {
                _this.editor.focus();
                _this.editor.select(_this.start, _this.end);
                _this.editor.addUndoSnapshot(null /*callback*/, "Format" /* Format */);
                _this.onChanged();
                _this.isCurrentlyEditing = false;
                return false;
            };
            this.onStartTableResize = function () {
                _this.isCurrentlyEditing = true;
                _this.onStartResize();
            };
            this.onStartCellResize = function () {
                _this.isCurrentlyEditing = true;
                _this.disposeTableResizer();
                _this.onStartResize();
            };
            this.onInserted = function (table) {
                _this.editor.transformToDarkColor(table);
                _this.disposeTableResizer();
                _this.onFinishEditing();
            };
            /**
             * Public only for testing purposes
             * @param table the table to select
             */
            this.onSelect = function (table) {
                _this.editor.focus();
                if (table) {
                    var vTable = new roosterjs_editor_dom_1$a.VTable(table);
                    if (vTable.cells) {
                        var rows = vTable.cells.length - 1;
                        var lastCellIndex_1 = 0;
                        vTable.cells[rows].forEach(function (cell, index) {
                            lastCellIndex_1 = index;
                        });
                        var selection = {
                            firstCell: {
                                x: 0,
                                y: 0,
                            },
                            lastCell: {
                                y: rows,
                                x: lastCellIndex_1,
                            },
                        };
                        _this.editor.select(table, selection);
                    }
                }
            };
            this.isRTL = (0, roosterjs_editor_dom_1$a.getComputedStyle)(table, 'direction') == 'rtl';
            var zoomScale = editor.getZoomScale();
            this.tableResizer = (0, TableResizer_1.default)(table, zoomScale, this.isRTL, this.onStartTableResize, this.onFinishEditing, this.onShowHelperElement);
            this.tableSelector = (0, TableSelector_1.default)(table, zoomScale, editor, this.onSelect, this.onShowHelperElement, contentDiv);
            this.isCurrentlyEditing = false;
        }
        TableEditor.prototype.dispose = function () {
            this.disposeTableResizer();
            this.disposeCellResizers();
            this.disposeTableInserter();
            this.disposeTableSelector();
        };
        TableEditor.prototype.isEditing = function () {
            return this.isCurrentlyEditing;
        };
        TableEditor.prototype.onMouseMove = function (x, y) {
            var _a;
            for (var i = 0; i < this.table.rows.length; i++) {
                var tr = this.table.rows[i];
                var j = 0;
                for (; j < tr.cells.length; j++) {
                    var td = tr.cells[j];
                    var tableRect = (0, roosterjs_editor_dom_1$a.normalizeRect)(this.table.getBoundingClientRect());
                    var tdRect = (0, roosterjs_editor_dom_1$a.normalizeRect)(td.getBoundingClientRect());
                    if (!tdRect || !tableRect) {
                        continue;
                    }
                    var lessThanBottom = y <= tdRect.bottom;
                    var lessThanRight = this.isRTL ? x >= tdRect.right : x <= tdRect.right;
                    if (lessThanRight && lessThanBottom) {
                        var isOnLeftOrRight = this.isRTL
                            ? tdRect.right <= tableRect.right && tdRect.right >= tableRect.right - 1
                            : tdRect.left >= tableRect.left && tdRect.left <= tableRect.left + 1;
                        if (i === 0 && y <= tdRect.top + INSERTER_HOVER_OFFSET) {
                            var center = (tdRect.left + tdRect.right) / 2;
                            var isOnRightHalf = this.isRTL ? x < center : x > center;
                            this.setInserterTd(isOnRightHalf ? td : tr.cells[j - 1], false /*isHorizontal*/);
                        }
                        else if (j == 0 &&
                            (this.isRTL
                                ? x >= tdRect.right - INSERTER_HOVER_OFFSET
                                : x <= tdRect.left + INSERTER_HOVER_OFFSET) &&
                            isOnLeftOrRight) {
                            var tdAbove = (_a = this.table.rows[i - 1]) === null || _a === void 0 ? void 0 : _a.cells[0];
                            var tdAboveRect = tdAbove
                                ? (0, roosterjs_editor_dom_1$a.normalizeRect)(tdAbove.getBoundingClientRect())
                                : null;
                            var isTdNotAboveMerged = !tdAboveRect
                                ? null
                                : this.isRTL
                                    ? tdAboveRect.right === tdRect.right
                                    : tdAboveRect.left === tdRect.left;
                            this.setInserterTd(y < (tdRect.top + tdRect.bottom) / 2 && isTdNotAboveMerged
                                ? tdAbove
                                : td, true /*isHorizontal*/);
                        }
                        else {
                            this.setInserterTd(null);
                        }
                        this.setResizingTd(td);
                        break;
                    }
                }
                if (j < tr.cells.length) {
                    break;
                }
            }
        };
        TableEditor.prototype.setResizingTd = function (td) {
            if (this.horizontalResizer && this.horizontalResizer.node != td) {
                this.disposeCellResizers();
            }
            if (!this.horizontalResizer && td) {
                var zoomScale = this.editor.getZoomScale();
                this.horizontalResizer = (0, CellResizer_1.default)(td, zoomScale, this.isRTL, true /*isHorizontal*/, this.onStartCellResize, this.onFinishEditing, this.onShowHelperElement);
                this.verticalResizer = (0, CellResizer_1.default)(td, zoomScale, this.isRTL, false /*isHorizontal*/, this.onStartCellResize, this.onFinishEditing, this.onShowHelperElement);
            }
        };
        /**
         * create or remove TableInserter
         * @param td td to attach to, set this to null to remove inserters (both horizontal and vertical)
         */
        TableEditor.prototype.setInserterTd = function (td, isHorizontal) {
            var inserter = isHorizontal ? this.horizontalInserter : this.verticalInserter;
            if (td === null || (inserter && inserter.node != td)) {
                this.disposeTableInserter();
            }
            if (!this.horizontalInserter && !this.verticalInserter && td) {
                var newInserter = (0, TableInserter_1.default)(this.editor, td, this.isRTL, !!isHorizontal, this.onInserted, this.onShowHelperElement);
                if (isHorizontal) {
                    this.horizontalInserter = newInserter;
                }
                else {
                    this.verticalInserter = newInserter;
                }
            }
        };
        TableEditor.prototype.disposeTableResizer = function () {
            if (this.tableResizer) {
                (0, TableEditorFeature_1.disposeTableEditFeature)(this.tableResizer);
                this.tableResizer = null;
            }
        };
        TableEditor.prototype.disposeTableInserter = function () {
            if (this.horizontalInserter) {
                (0, TableEditorFeature_1.disposeTableEditFeature)(this.horizontalInserter);
                this.horizontalInserter = null;
            }
            if (this.verticalInserter) {
                (0, TableEditorFeature_1.disposeTableEditFeature)(this.verticalInserter);
                this.verticalInserter = null;
            }
        };
        TableEditor.prototype.disposeCellResizers = function () {
            if (this.horizontalResizer) {
                (0, TableEditorFeature_1.disposeTableEditFeature)(this.horizontalResizer);
                this.horizontalResizer = null;
            }
            if (this.verticalResizer) {
                (0, TableEditorFeature_1.disposeTableEditFeature)(this.verticalResizer);
                this.verticalResizer = null;
            }
        };
        TableEditor.prototype.disposeTableSelector = function () {
            if (this.tableSelector) {
                (0, TableEditorFeature_1.disposeTableEditFeature)(this.tableSelector);
                this.tableSelector = null;
            }
        };
        TableEditor.prototype.onStartResize = function () {
            this.isCurrentlyEditing = true;
            var range = this.editor.getSelectionRange();
            if (range) {
                this.start = roosterjs_editor_dom_1$a.Position.getStart(range);
                this.end = roosterjs_editor_dom_1$a.Position.getEnd(range);
            }
            this.editor.addUndoSnapshot();
        };
        return TableEditor;
    }());
    TableEditor$1.default = TableEditor;

    Object.defineProperty(TableResize$1, "__esModule", { value: true });
    var TableEditor_1 = TableEditor$1;
    var roosterjs_editor_dom_1$9 = lib$3;
    var TABLE_RESIZER_LENGTH = 12;
    /**
     * TableResize plugin, provides the ability to resize a table by drag-and-drop
     */
    var TableResize = /** @class */ (function () {
        /**
         * Construct a new instance of TableResize plugin
         * @param onShowHelperElement An optional callback to allow customize helper element of table resizing.
         * To customize the helper element, add this callback and change the attributes of elementData then it
         * will be picked up by TableResize code
         */
        function TableResize(onShowHelperElement) {
            var _this = this;
            this.onShowHelperElement = onShowHelperElement;
            this.tableRectMap = null;
            this.onMouseMove = function (e) {
                var _a;
                if (e.buttons > 0) {
                    return;
                }
                _this.ensureTableRects();
                var editorWindow = _this.editor.getDocument().defaultView;
                var x = e.pageX - editorWindow.scrollX;
                var y = e.pageY - editorWindow.scrollY;
                var currentTable = null;
                for (var i = _this.tableRectMap.length - 1; i >= 0; i--) {
                    var _b = _this.tableRectMap[i], table = _b.table, rect = _b.rect;
                    if (x >= rect.left - TABLE_RESIZER_LENGTH &&
                        x <= rect.right + TABLE_RESIZER_LENGTH &&
                        y >= rect.top - TABLE_RESIZER_LENGTH &&
                        y <= rect.bottom + TABLE_RESIZER_LENGTH) {
                        currentTable = table;
                        break;
                    }
                }
                _this.setTableEditor(currentTable, e);
                (_a = _this.tableEditor) === null || _a === void 0 ? void 0 : _a.onMouseMove(x, y);
            };
            this.invalidateTableRects = function () {
                _this.tableRectMap = null;
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        TableResize.prototype.getName = function () {
            return 'TableResize';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        TableResize.prototype.initialize = function (editor) {
            this.editor = editor;
            this.onMouseMoveDisposer = this.editor.addDomEventHandler({ mousemove: this.onMouseMove });
        };
        /**
         * Dispose this plugin
         */
        TableResize.prototype.dispose = function () {
            this.onMouseMoveDisposer();
            this.invalidateTableRects();
            this.disposeTableEditor();
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        TableResize.prototype.onPluginEvent = function (e) {
            switch (e.eventType) {
                case 3 /* Input */:
                case 7 /* ContentChanged */:
                case 14 /* Scroll */:
                case 21 /* ZoomChanged */:
                    this.setTableEditor(null);
                    this.invalidateTableRects();
                    break;
            }
        };
        TableResize.prototype.setTableEditor = function (table, e) {
            if (this.tableEditor && !this.tableEditor.isEditing() && table != this.tableEditor.table) {
                this.disposeTableEditor();
            }
            if (!this.tableEditor && table) {
                this.tableEditor = new TableEditor_1.default(this.editor, table, this.invalidateTableRects, this.onShowHelperElement, e.currentTarget);
            }
        };
        TableResize.prototype.disposeTableEditor = function () {
            var _a;
            (_a = this.tableEditor) === null || _a === void 0 ? void 0 : _a.dispose();
            this.tableEditor = null;
        };
        TableResize.prototype.ensureTableRects = function () {
            var _this = this;
            if (!this.tableRectMap) {
                this.tableRectMap = [];
                this.editor.queryElements('table', function (table) {
                    if (table.isContentEditable) {
                        var rect = (0, roosterjs_editor_dom_1$9.normalizeRect)(table.getBoundingClientRect());
                        if (rect) {
                            _this.tableRectMap.push({
                                table: table,
                                rect: rect,
                            });
                        }
                    }
                });
            }
        };
        return TableResize;
    }());
    TableResize$1.default = TableResize;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableResize = void 0;
    var TableResize_1 = TableResize$1;
    Object.defineProperty(exports, "TableResize", { enumerable: true, get: function () { return TableResize_1.default; } });

    }(TableResize$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(TableResize$2, exports);

    }(TableResize$3));

    var Watermark$3 = {};

    var Watermark$2 = {};

    var Watermark$1 = {};

    Object.defineProperty(Watermark$1, "__esModule", { value: true });
    var roosterjs_editor_dom_1$8 = lib$3;
    var roosterjs_editor_api_1$4 = lib$1;
    var ENTITY_TYPE = 'WATERMARK_WRAPPER';
    /**
     * A watermark plugin to manage watermark string for roosterjs
     */
    var Watermark = /** @class */ (function () {
        /**
         * Create an instance of Watermark plugin
         * @param watermark The watermark string
         */
        function Watermark(watermark, format, customClass) {
            var _this = this;
            this.watermark = watermark;
            this.customClass = customClass;
            this.editor = null;
            this.disposer = null;
            this.showHideWatermark = function () {
                if (!_this.editor) {
                    return;
                }
                var hasFocus = _this.editor.hasFocus();
                var watermarks = _this.editor.queryElements((0, roosterjs_editor_dom_1$8.getEntitySelector)(ENTITY_TYPE));
                var isShowing = watermarks.length > 0;
                if (hasFocus && isShowing) {
                    watermarks.forEach(_this.removeWatermark);
                    _this.editor.focus();
                }
                else if (!hasFocus && !isShowing && _this.editor.isEmpty()) {
                    var newEntity = (0, roosterjs_editor_api_1$4.insertEntity)(_this.editor, ENTITY_TYPE, _this.editor.getDocument().createTextNode(_this.watermark), false /*isBlock*/, false /*isReadonly*/, 0 /* Begin */);
                    if (_this.customClass) {
                        newEntity.wrapper.classList.add(_this.customClass);
                    }
                }
            };
            this.removeWatermark = function (wrapper) {
                var _a;
                var parentNode = wrapper.parentNode;
                parentNode === null || parentNode === void 0 ? void 0 : parentNode.removeChild(wrapper);
                // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line
                if (parentNode &&
                    ((_a = _this.editor) === null || _a === void 0 ? void 0 : _a.contains(parentNode)) &&
                    (0, roosterjs_editor_dom_1$8.getTagOfNode)(parentNode) == 'DIV' &&
                    !parentNode.firstChild) {
                    parentNode.appendChild(_this.editor.getDocument().createElement('BR'));
                }
            };
            this.format = format || {
                fontSize: '14px',
                textColors: {
                    lightModeColor: '#AAAAAA',
                    darkModeColor: '#6B6B6B',
                },
            };
        }
        /**
         * Get a friendly name of  this plugin
         */
        Watermark.prototype.getName = function () {
            return 'Watermark';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        Watermark.prototype.initialize = function (editor) {
            this.editor = editor;
            this.disposer = this.editor.addDomEventHandler({
                focus: this.showHideWatermark,
                blur: this.showHideWatermark,
            });
        };
        /**
         * Dispose this plugin
         */
        Watermark.prototype.dispose = function () {
            var _a;
            (_a = this.disposer) === null || _a === void 0 ? void 0 : _a.call(this);
            this.disposer = null;
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        Watermark.prototype.onPluginEvent = function (event) {
            var _a;
            if (event.eventType == 11 /* EditorReady */ ||
                (event.eventType == 7 /* ContentChanged */ &&
                    ((_a = event.data) === null || _a === void 0 ? void 0 : _a.type) != ENTITY_TYPE)) {
                this.showHideWatermark();
            }
            else if (event.eventType == 15 /* EntityOperation */ &&
                event.entity.type == ENTITY_TYPE &&
                this.editor) {
                var operation = event.operation, wrapper = event.entity.wrapper;
                if (operation == 8 /* ReplaceTemporaryContent */) {
                    this.removeWatermark(wrapper);
                }
                else if (event.operation == 0 /* NewEntity */) {
                    (0, roosterjs_editor_dom_1$8.applyFormat)(wrapper, this.format, this.editor.isDarkMode(), this.editor.getDarkColorHandler());
                    wrapper.spellcheck = false;
                }
            }
        };
        return Watermark;
    }());
    Watermark$1.default = Watermark;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Watermark = void 0;
    var Watermark_1 = Watermark$1;
    Object.defineProperty(exports, "Watermark", { enumerable: true, get: function () { return Watermark_1.default; } });

    }(Watermark$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(Watermark$2, exports);

    }(Watermark$3));

    var TableCellSelection$3 = {};

    var TableCellSelection$2 = {};

    var TableCellSelection$1 = {};

    var normalizeTableSelection$1 = {};

    Object.defineProperty(normalizeTableSelection$1, "__esModule", { value: true });
    /**
     * @internal
     * Make the first Cell of a table selection always be on top of the last cell.
     * @param input Table selection
     * @returns Table Selection where the first cell is always going to be first selected in the table
     * and the last cell always going to be last selected in the table.
     */
    function normalizeTableSelection(vTable) {
        var _a = (vTable === null || vTable === void 0 ? void 0 : vTable.selection) || {}, firstCell = _a.firstCell, lastCell = _a.lastCell;
        if (!vTable || !vTable.selection || !firstCell || !lastCell) {
            return null;
        }
        var cells = vTable.cells;
        var newFirst = {
            x: Math.min(firstCell.x, lastCell.x),
            y: Math.min(firstCell.y, lastCell.y),
        };
        var newLast = {
            x: Math.max(firstCell.x, lastCell.x),
            y: Math.max(firstCell.y, lastCell.y),
        };
        var fixCoordinates = function (coord) {
            if (coord.x < 0) {
                coord.x = 0;
            }
            if (coord.y < 0) {
                coord.y = 0;
            }
            if (coord.y >= cells.length) {
                coord.y = cells.length - 1;
            }
            var rowsCells = cells[coord.y].length;
            if (coord.x >= rowsCells) {
                coord.x = rowsCells - 1;
            }
        };
        fixCoordinates(newFirst);
        fixCoordinates(newLast);
        return { firstCell: newFirst, lastCell: newLast };
    }
    normalizeTableSelection$1.default = normalizeTableSelection;

    var DeleteTableContents = {};

    Object.defineProperty(DeleteTableContents, "__esModule", { value: true });
    DeleteTableContents.DeleteTableContents = void 0;
    var roosterjs_editor_dom_1$7 = lib$3;
    /**
     * @internal
     * Feature that when Backspace is pressed and there is Table Selection, delete the contents inside of the selection
     */
    DeleteTableContents.DeleteTableContents = {
        keys: [46 /* DELETE */, 8 /* BACKSPACE */],
        shouldHandleEvent: function (_, editor) {
            var selection = editor.getSelectionRangeEx();
            return selection.type == 1 /* TableSelection */;
        },
        handleEvent: function (_, editor) {
            var selection = editor.getSelectionRangeEx();
            if (selection.type == 1 /* TableSelection */) {
                editor.addUndoSnapshot(function () {
                    editor.getSelectedRegions().forEach(function (region) {
                        if ((0, roosterjs_editor_dom_1$7.safeInstanceOf)(region.rootNode, 'HTMLTableCellElement')) {
                            deleteNodeContents(region.rootNode, editor);
                        }
                    });
                });
            }
        },
    };
    function deleteNodeContents(element, editor) {
        var range = new Range();
        range.selectNodeContents(element);
        range.deleteContents();
        element.appendChild(editor.getDocument().createElement('br'));
    }

    var getCellCoordinates$1 = {};

    Object.defineProperty(getCellCoordinates$1, "__esModule", { value: true });
    getCellCoordinates$1.getCellCoordinates = void 0;
    /**
     * @internal
     * Gets the coordinates of a cell
     * @param cellInput The cell the to find the coordinates
     * @returns Coordinates of the cell, null if not found
     */
    function getCellCoordinates(vTable, cellInput) {
        var result;
        if (vTable === null || vTable === void 0 ? void 0 : vTable.cells) {
            for (var indexY = 0; indexY < vTable.cells.length; indexY++) {
                for (var indexX = 0; indexX < vTable.cells[indexY].length; indexX++) {
                    if (cellInput == vTable.cells[indexY][indexX].td) {
                        result = {
                            x: indexX,
                            y: indexY,
                        };
                    }
                }
            }
        }
        return result;
    }
    getCellCoordinates$1.getCellCoordinates = getCellCoordinates;

    Object.defineProperty(TableCellSelection$1, "__esModule", { value: true });
    var normalizeTableSelection_1 = normalizeTableSelection$1;
    var DeleteTableContents_1 = DeleteTableContents;
    var getCellCoordinates_1 = getCellCoordinates$1;
    var roosterjs_editor_dom_1$6 = lib$3;
    var TABLE_CELL_SELECTOR = 'td,th';
    var LEFT_CLICK = 1;
    var RIGHT_CLICK = 3;
    var IGNORE_KEY_UP_KEYS = [
        16 /* SHIFT */,
        18 /* ALT */,
        91 /* META_LEFT */,
        17 /* CTRL_LEFT */,
        44 /* PRINT_SCREEN */,
    ];
    /**
     * TableCellSelectionPlugin help highlight table cells
     */
    var TableCellSelection = /** @class */ (function () {
        function TableCellSelection() {
            var _this = this;
            this.onMouseMove = function (event) {
                if (!_this.editor.contains(event.target)) {
                    return;
                }
                //If already in table selection and the new target is contained in the last target cell, no need to
                //Apply selection styles again.
                if (_this.tableSelection && (0, roosterjs_editor_dom_1$6.contains)(_this.lastTarget, event.target, true)) {
                    updateSelection(_this.editor, _this.firstTarget, 0);
                    event.preventDefault();
                    return;
                }
                if ((0, roosterjs_editor_dom_1$6.getTagOfNode)(event.target) == 'TABLE') {
                    event.preventDefault();
                    return;
                }
                _this.setData(event.target);
                // If there is a first target, but is not inside a table, no more actions to perform.
                if (_this.firstTarget && !_this.firstTable) {
                    return;
                }
                //Ignore if
                // Is a DIV that only contains a Table
                // If the event target is not contained in the editor.
                if ((_this.lastTarget.lastChild == _this.lastTarget.firstChild &&
                    (0, roosterjs_editor_dom_1$6.getTagOfNode)(_this.lastTarget.lastChild) == 'TABLE' &&
                    (0, roosterjs_editor_dom_1$6.getTagOfNode)(_this.lastTarget) == 'DIV') ||
                    !_this.editor.contains(_this.lastTarget)) {
                    event.preventDefault();
                    return;
                }
                _this.prepareSelection();
                var isNewTDContainingFirstTable = (0, roosterjs_editor_dom_1$6.safeInstanceOf)(_this.lastTarget, 'HTMLTableCellElement')
                    ? (0, roosterjs_editor_dom_1$6.contains)(_this.lastTarget, _this.firstTable)
                    : false;
                if ((_this.firstTable && _this.firstTable == _this.targetTable) ||
                    isNewTDContainingFirstTable) {
                    //When starting selection inside of a table and ends inside of the same table.
                    _this.selectionInsideTableMouseMove(event);
                }
                else if (_this.tableSelection) {
                    _this.restoreSelection();
                }
                if (_this.tableSelection) {
                    updateSelection(_this.editor, _this.firstTarget, 0);
                    event.preventDefault();
                }
            };
            this.onMouseUp = function () {
                if (_this.editor) {
                    _this.removeMouseUpEventListener();
                }
            };
            this.lastTarget = null;
            this.firstTarget = null;
            this.tableSelection = false;
            this.tableRange = {
                firstCell: null,
                lastCell: null,
            };
            this.startedSelection = false;
        }
        /**
         * Get a friendly name of  this plugin
         */
        TableCellSelection.prototype.getName = function () {
            return 'TableCellSelection';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        TableCellSelection.prototype.initialize = function (editor) {
            this.editor = editor;
            this.editor.addContentEditFeature(DeleteTableContents_1.DeleteTableContents);
        };
        /**
         * Dispose this plugin
         */
        TableCellSelection.prototype.dispose = function () {
            this.editor.select(null);
            this.removeMouseUpEventListener();
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        TableCellSelection.prototype.onPluginEvent = function (event) {
            if (this.editor) {
                switch (event.eventType) {
                    case 17 /* EnteredShadowEdit */:
                        var selection = this.editor.getSelectionRangeEx();
                        if (selection.type == 1 /* TableSelection */) {
                            this.tableRange = selection.coordinates;
                            this.firstTable = selection.table;
                            this.tableSelection = true;
                            this.editor.select(selection.table, null);
                        }
                        break;
                    case 18 /* LeavingShadowEdit */:
                        if (this.firstTable && this.tableSelection && this.tableRange) {
                            var table = this.editor.queryElements('#' + this.firstTable.id);
                            if (table.length == 1) {
                                this.firstTable = table[0];
                                this.editor.select(this.firstTable, this.tableRange);
                            }
                        }
                        break;
                    case 5 /* MouseDown */:
                        if (!this.startedSelection) {
                            this.handleMouseDownEvent(event);
                        }
                        break;
                    case 0 /* KeyDown */:
                        if (!this.startedSelection) {
                            this.handleKeyDownEvent(event);
                        }
                        else {
                            event.rawEvent.preventDefault();
                        }
                        break;
                    case 2 /* KeyUp */:
                        if (!this.startedSelection) {
                            this.handleKeyUpEvent(event);
                        }
                        else {
                            event.rawEvent.preventDefault();
                        }
                        break;
                    case 14 /* Scroll */:
                        if (this.startedSelection) {
                            this.handleScrollEvent();
                        }
                        break;
                    case 20 /* BeforeSetContent */:
                        if (this.tableRange) {
                            this.tableRange = null;
                            this.firstTable = null;
                            this.tableSelection = false;
                            this.editor.select(null);
                        }
                        break;
                }
            }
        };
        /**
         * Handle Scroll Event and mantains the selection range,
         * Since when we scroll the cursor does not trigger the on Mouse Move event
         * The table selection gets removed.
         */
        TableCellSelection.prototype.handleScrollEvent = function () {
            this.setData(this.editor.getElementAtCursor());
            if (this.firstTable == this.targetTable) {
                if (this.tableSelection) {
                    this.vTable.selection.lastCell = (0, getCellCoordinates_1.getCellCoordinates)(this.vTable, this.lastTarget);
                    this.selectTable();
                    this.tableRange.lastCell = this.vTable.selection.lastCell;
                    updateSelection(this.editor, this.firstTarget, 0);
                }
            }
            else if (this.tableSelection) {
                this.restoreSelection();
            }
        };
        //#region Key events
        /**
         * Handles the on key event.
         * @param event the plugin event
         */
        TableCellSelection.prototype.handleKeyDownEvent = function (event) {
            var _this = this;
            var _a;
            var _b = event.rawEvent, shiftKey = _b.shiftKey, ctrlKey = _b.ctrlKey, metaKey = _b.metaKey, which = _b.which, defaultPrevented = _b.defaultPrevented;
            if ((shiftKey && (ctrlKey || metaKey)) || which == 16 /* SHIFT */ || defaultPrevented) {
                this.preventKeyUp = defaultPrevented;
                return;
            }
            if (shiftKey) {
                if (!this.firstTarget) {
                    var pos = this.editor.getFocusedPosition();
                    var cell = pos && getCellAtCursor(this.editor, pos.node);
                    this.firstTarget = this.firstTarget || cell;
                }
                //If first target is not a table cell, we should ignore this plugin
                if (!(0, roosterjs_editor_dom_1$6.safeInstanceOf)(this.firstTarget, 'HTMLTableCellElement')) {
                    return;
                }
                this.editor.runAsync(function (editor) {
                    var pos = editor.getFocusedPosition();
                    var newTarget = _this.tableSelection ? _this.lastTarget : pos === null || pos === void 0 ? void 0 : pos.node;
                    if (newTarget) {
                        _this.setData(newTarget);
                    }
                    if (_this.firstTable == _this.targetTable) {
                        if (!_this.shouldConvertToTableSelection() && !_this.tableSelection) {
                            return;
                        }
                        //When selection start and end is inside of the same table
                        _this.handleKeySelectionInsideTable(event);
                    }
                    else if (_this.tableSelection) {
                        if (_this.firstTable) {
                            _this.editor.select(_this.firstTable, null);
                        }
                        _this.tableSelection = false;
                    }
                });
            }
            else if (((_a = this.editor.getSelectionRangeEx()) === null || _a === void 0 ? void 0 : _a.type) == 1 /* TableSelection */ &&
                (!(0, roosterjs_editor_dom_1$6.isCtrlOrMetaPressed)(event.rawEvent) || which == 36 /* HOME */ || which == 35 /* END */)) {
                this.editor.select(null);
            }
        };
        TableCellSelection.prototype.handleKeyUpEvent = function (event) {
            var _a = event.rawEvent, shiftKey = _a.shiftKey, which = _a.which, ctrlKey = _a.ctrlKey;
            if (!shiftKey &&
                !ctrlKey &&
                this.firstTarget &&
                !this.preventKeyUp &&
                IGNORE_KEY_UP_KEYS.indexOf(which) == -1) {
                this.clearState();
            }
            this.preventKeyUp = false;
        };
        TableCellSelection.prototype.handleKeySelectionInsideTable = function (event) {
            this.firstTarget = getCellAtCursor(this.editor, this.firstTarget);
            this.lastTarget = getCellAtCursor(this.editor, this.lastTarget);
            updateSelection(this.editor, this.firstTarget, 0);
            this.vTable = this.vTable || new roosterjs_editor_dom_1$6.VTable(this.firstTable);
            this.tableRange = {
                firstCell: (0, getCellCoordinates_1.getCellCoordinates)(this.vTable, this.firstTarget),
                lastCell: this.getNextTD(event),
            };
            if (!this.tableRange.lastCell ||
                this.tableRange.lastCell.y > this.vTable.cells.length - 1 ||
                this.tableRange.lastCell.y == -1) {
                //When selection is moving from inside of a table to outside
                this.lastTarget = this.editor.getElementAtCursor(TABLE_CELL_SELECTOR + ',div', this.firstTable);
                if ((0, roosterjs_editor_dom_1$6.safeInstanceOf)(this.lastTarget, 'HTMLTableCellElement')) {
                    this.prepareSelection();
                }
                else {
                    var position = new roosterjs_editor_dom_1$6.Position(this.targetTable, this.tableRange.lastCell.y == null || this.tableRange.lastCell.y == -1
                        ? -2 /* Before */
                        : -3 /* After */);
                    var sel = this.editor.getDocument().defaultView.getSelection();
                    var anchorNode = sel.anchorNode, anchorOffset = sel.anchorOffset;
                    this.editor.select(sel.getRangeAt(0));
                    sel.setBaseAndExtent(anchorNode, anchorOffset, position.node, position.offset);
                    this.lastTarget = position.node;
                    event.rawEvent.preventDefault();
                    return;
                }
            }
            this.vTable.selection = this.tableRange;
            this.selectTable();
            var isBeginAboveEnd = this.isAfter(this.firstTarget, this.lastTarget);
            var targetPosition = new roosterjs_editor_dom_1$6.Position(this.lastTarget, isBeginAboveEnd ? 0 /* Begin */ : -1 /* End */);
            updateSelection(this.editor, targetPosition.node, targetPosition.offset);
            this.tableSelection = true;
            event.rawEvent.preventDefault();
        };
        //#endregion
        //#region Mouse events
        TableCellSelection.prototype.handleMouseDownEvent = function (event) {
            var _this = this;
            var _a = event.rawEvent, which = _a.which, shiftKey = _a.shiftKey;
            if (which == RIGHT_CLICK && this.tableSelection) {
                //If the user is right clicking To open context menu
                var td = this.editor.getElementAtCursor(TABLE_CELL_SELECTOR);
                var coord = (0, getCellCoordinates_1.getCellCoordinates)(this.vTable, td);
                if (coord) {
                    var _b = (0, normalizeTableSelection_1.default)(this.vTable), firstCell = _b.firstCell, lastCell = _b.lastCell;
                    if (coord.y >= firstCell.y &&
                        coord.y <= lastCell.y &&
                        coord.x >= firstCell.x &&
                        coord.x <= lastCell.x) {
                        this.firstTarget = this.vTable.getCell(firstCell.y, firstCell.x).td;
                        this.lastTarget = this.vTable.getCell(lastCell.y, lastCell.x).td;
                        if (this.firstTarget && this.lastTarget) {
                            var selection = this.editor.getDocument().defaultView.getSelection();
                            selection.setBaseAndExtent(this.firstTarget, 0, this.lastTarget, 0);
                            this.selectTable();
                        }
                        return;
                    }
                }
            }
            if (which == LEFT_CLICK && !shiftKey) {
                this.clearState();
                if (getTableAtCursor(this.editor, event.rawEvent.target)) {
                    this.editor
                        .getDocument()
                        .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);
                    this.editor
                        .getDocument()
                        .addEventListener('mousemove', this.onMouseMove, true /*setCapture*/);
                    this.startedSelection = true;
                }
            }
            if (which == LEFT_CLICK && shiftKey) {
                this.editor.runAsync(function (editor) {
                    var sel = editor.getDocument().defaultView.getSelection();
                    var first = getCellAtCursor(editor, sel.anchorNode);
                    var last = getCellAtCursor(editor, sel.focusNode);
                    var firstTable = getTableAtCursor(editor, first);
                    var targetTable = getTableAtCursor(editor, first);
                    if (firstTable == targetTable &&
                        (0, roosterjs_editor_dom_1$6.safeInstanceOf)(first, 'HTMLTableCellElement') &&
                        (0, roosterjs_editor_dom_1$6.safeInstanceOf)(last, 'HTMLTableCellElement')) {
                        _this.vTable = new roosterjs_editor_dom_1$6.VTable(first);
                        var firstCord = (0, getCellCoordinates_1.getCellCoordinates)(_this.vTable, first);
                        var lastCord = (0, getCellCoordinates_1.getCellCoordinates)(_this.vTable, last);
                        _this.vTable.selection = {
                            firstCell: firstCord,
                            lastCell: lastCord,
                        };
                        _this.firstTarget = first;
                        _this.lastTarget = last;
                        _this.selectTable();
                        _this.tableRange = _this.vTable.selection;
                        _this.tableSelection = true;
                        _this.firstTable = firstTable;
                        _this.targetTable = targetTable;
                        updateSelection(editor, first, 0);
                    }
                });
            }
        };
        TableCellSelection.prototype.restoreSelection = function () {
            if (this.firstTable) {
                this.editor.select(this.firstTable, null);
            }
            this.tableSelection = false;
            var isBeginAboveEnd = this.isAfter(this.firstTarget, this.lastTarget);
            var targetPosition = new roosterjs_editor_dom_1$6.Position(this.lastTarget, isBeginAboveEnd ? -1 /* End */ : 0 /* Begin */);
            var firstTargetRange = new Range();
            if (this.firstTarget) {
                firstTargetRange.selectNodeContents(this.firstTarget);
            }
            updateSelection(this.editor, this.firstTarget, isBeginAboveEnd
                ? roosterjs_editor_dom_1$6.Position.getEnd(firstTargetRange).offset
                : roosterjs_editor_dom_1$6.Position.getStart(firstTargetRange).offset, targetPosition.element, targetPosition.offset);
        };
        /**
         * @internal
         * Public only for unit testing
         * @param event mouse event
         */
        TableCellSelection.prototype.selectionInsideTableMouseMove = function (event) {
            var _a;
            if (this.lastTarget != this.firstTarget) {
                updateSelection(this.editor, this.firstTarget, 0);
                if (this.firstTable != this.targetTable &&
                    ((_a = this.targetTable) === null || _a === void 0 ? void 0 : _a.contains(this.firstTable))) {
                    //If selection started in a table that is inside of another table and moves to parent table
                    //Make the firstTarget the TD of the parent table.
                    this.firstTarget = this.editor.getElementAtCursor(TABLE_CELL_SELECTOR, this.lastTarget);
                }
                if (this.firstTable) {
                    this.tableSelection = true;
                    this.vTable = this.vTable || new roosterjs_editor_dom_1$6.VTable(this.firstTable);
                    this.tableRange = {
                        firstCell: (0, getCellCoordinates_1.getCellCoordinates)(this.vTable, this.firstTarget),
                        lastCell: (0, getCellCoordinates_1.getCellCoordinates)(this.vTable, this.lastTarget),
                    };
                    this.vTable.selection = this.tableRange;
                    this.selectTable();
                }
                event.preventDefault();
            }
            else if (this.lastTarget == this.firstTarget && this.tableSelection) {
                this.vTable = new roosterjs_editor_dom_1$6.VTable(this.firstTable);
                var cell = (0, getCellCoordinates_1.getCellCoordinates)(this.vTable, this.firstTarget);
                this.tableRange = {
                    firstCell: cell,
                    lastCell: cell,
                };
                this.vTable.selection = this.tableRange;
                this.selectTable();
            }
        };
        TableCellSelection.prototype.removeMouseUpEventListener = function () {
            if (this.startedSelection) {
                this.startedSelection = false;
                this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);
                this.editor.getDocument().removeEventListener('mousemove', this.onMouseMove, true);
            }
        };
        //#endregion
        //#region utils
        TableCellSelection.prototype.clearState = function () {
            this.editor.select(null);
            this.vTable = null;
            this.firstTarget = null;
            this.lastTarget = null;
            this.tableRange = {
                firstCell: null,
                lastCell: null,
            };
            this.tableSelection = false;
            this.firstTable = null;
            this.targetTable = null;
        };
        TableCellSelection.prototype.getNextTD = function (event) {
            this.lastTarget = this.editor.getElementAtCursor(TABLE_CELL_SELECTOR, this.lastTarget);
            if ((0, roosterjs_editor_dom_1$6.safeInstanceOf)(this.lastTarget, 'HTMLTableCellElement')) {
                var coordinates = (0, getCellCoordinates_1.getCellCoordinates)(this.vTable, this.lastTarget);
                if (this.tableSelection) {
                    switch (event.rawEvent.which) {
                        case 39 /* RIGHT */:
                            coordinates.x += this.lastTarget.colSpan;
                            if (this.vTable.cells[coordinates.y][coordinates.x] == null) {
                                coordinates.x = this.vTable.cells[coordinates.y].length - 1;
                                coordinates.y++;
                            }
                            break;
                        case 37 /* LEFT */:
                            if (coordinates.x == 0) {
                                coordinates.y--;
                            }
                            else {
                                coordinates.x--;
                            }
                            break;
                        case 38 /* UP */:
                            coordinates.y--;
                            break;
                        case 40 /* DOWN */:
                            coordinates.y++;
                            break;
                    }
                }
                if (coordinates.y >= 0 && coordinates.x >= 0) {
                    this.lastTarget = this.vTable.getTd(coordinates.y, coordinates.x);
                }
                return coordinates;
            }
            return null;
        };
        //Check if the selection started in a inner table.
        TableCellSelection.prototype.prepareSelection = function () {
            var _a, _b, _c, _d;
            var isNewTargetTableContained = this.lastTarget != this.firstTarget &&
                ((_a = this.firstTable) === null || _a === void 0 ? void 0 : _a.contains((0, roosterjs_editor_dom_1$6.findClosestElementAncestor)(this.targetTable, this.firstTable, TABLE_CELL_SELECTOR)));
            if (isNewTargetTableContained && this.tableSelection) {
                while (isNewTargetTableContained) {
                    this.lastTarget = (0, roosterjs_editor_dom_1$6.findClosestElementAncestor)(this.targetTable, this.firstTable, TABLE_CELL_SELECTOR);
                    this.targetTable = getTableAtCursor(this.editor, this.lastTarget);
                    isNewTargetTableContained =
                        this.lastTarget != this.firstTarget &&
                            ((_b = this.firstTable) === null || _b === void 0 ? void 0 : _b.contains((0, roosterjs_editor_dom_1$6.findClosestElementAncestor)(this.targetTable, this.firstTable, TABLE_CELL_SELECTOR)));
                }
            }
            var isFirstTargetTableContained = this.lastTarget != this.firstTarget &&
                ((_c = this.targetTable) === null || _c === void 0 ? void 0 : _c.contains((0, roosterjs_editor_dom_1$6.findClosestElementAncestor)(this.firstTable, this.targetTable, TABLE_CELL_SELECTOR)));
            if (isFirstTargetTableContained && this.tableSelection) {
                while (isFirstTargetTableContained) {
                    this.firstTarget = (0, roosterjs_editor_dom_1$6.findClosestElementAncestor)(this.firstTable, this.targetTable, TABLE_CELL_SELECTOR);
                    this.firstTable = this.editor.getElementAtCursor('table', this.firstTarget);
                    isFirstTargetTableContained =
                        this.lastTarget != this.firstTarget &&
                            ((_d = this.targetTable) === null || _d === void 0 ? void 0 : _d.contains((0, roosterjs_editor_dom_1$6.findClosestElementAncestor)(this.firstTable, this.targetTable, TABLE_CELL_SELECTOR)));
                }
            }
        };
        TableCellSelection.prototype.setData = function (eventTarget) {
            var pos = this.editor.getFocusedPosition();
            if (pos) {
                this.firstTarget = this.firstTarget || getCellAtCursor(this.editor, pos.node);
                if (this.firstTarget.nodeType == Node.TEXT_NODE) {
                    this.firstTarget = this.editor.getElementAtCursor(TABLE_CELL_SELECTOR, this.firstTarget);
                }
                if (!this.editor.contains(this.firstTarget) && this.lastTarget) {
                    this.firstTarget = this.lastTarget;
                }
            }
            this.firstTable = getTableAtCursor(this.editor, this.firstTarget);
            this.lastTarget = getCellAtCursor(this.editor, eventTarget);
            this.targetTable = getTableAtCursor(this.editor, this.lastTarget);
        };
        TableCellSelection.prototype.isAfter = function (node1, node2) {
            var _a, _b, _c, _d;
            if (node1 && node2) {
                if (node2.contains(node1)) {
                    var r1 = (_b = (_a = node1).getBoundingClientRect) === null || _b === void 0 ? void 0 : _b.call(_a);
                    var r2 = (_d = (_c = node2).getBoundingClientRect) === null || _d === void 0 ? void 0 : _d.call(_c);
                    if (r1 && r2) {
                        return r1.top > r2.top && r1.bottom < r2.bottom;
                    }
                }
                var position = new roosterjs_editor_dom_1$6.Position(node1, -1 /* End */);
                return position.isAfter(new roosterjs_editor_dom_1$6.Position(node2, -1 /* End */));
            }
            return false;
        };
        // if the user selected all the text in a cell and started selecting another TD, we should convert to vSelection
        TableCellSelection.prototype.shouldConvertToTableSelection = function () {
            var _this = this;
            if (!this.firstTable || !this.editor) {
                return false;
            }
            var regions = this.editor.getSelectedRegions();
            if (regions.length == 1) {
                return false;
            }
            var result = true;
            regions.forEach(function (value) {
                if (!(0, roosterjs_editor_dom_1$6.contains)(_this.firstTable, value.rootNode)) {
                    result = false;
                }
            });
            return result;
        };
        TableCellSelection.prototype.selectTable = function () {
            var _a;
            if (this.editor && this.vTable) {
                (_a = this.editor) === null || _a === void 0 ? void 0 : _a.select(this.vTable.table, (0, normalizeTableSelection_1.default)(this.vTable));
            }
        };
        return TableCellSelection;
    }());
    TableCellSelection$1.default = TableCellSelection;
    function updateSelection(editor, start, offset, end, endOffset) {
        var selection = editor.getDocument().defaultView.getSelection();
        end = end || start;
        endOffset = endOffset || offset;
        selection.setBaseAndExtent(start, offset, end, endOffset);
    }
    function getCellAtCursor(editor, node) {
        if (editor) {
            return editor.getElementAtCursor(TABLE_CELL_SELECTOR, node) || node;
        }
        return node;
    }
    function getTableAtCursor(editor, node) {
        if (editor) {
            return editor.getElementAtCursor('table', node);
        }
        return null;
    }

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableCellSelection = void 0;
    var TableCellSelection_1 = TableCellSelection$1;
    Object.defineProperty(exports, "TableCellSelection", { enumerable: true, get: function () { return TableCellSelection_1.default; } });

    }(TableCellSelection$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(TableCellSelection$2, exports);

    }(TableCellSelection$3));

    var AutoFormat$3 = {};

    var AutoFormat$2 = {};

    var AutoFormat$1 = {};

    Object.defineProperty(AutoFormat$1, "__esModule", { value: true });
    var specialCharacters = /[`!@#$%^&*()_+\=\[\]{};':"\\|,.<>\/?~]/;
    /**
     * Automatically transform -- into hyphen, if typed between two words.
     */
    var AutoFormat = /** @class */ (function () {
        function AutoFormat() {
            this.editor = null;
            this.lastKeyTyped = null;
        }
        /**
         * Get a friendly name of this plugin
         */
        AutoFormat.prototype.getName = function () {
            return 'AutoFormat';
        };
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        AutoFormat.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        AutoFormat.prototype.dispose = function () {
            this.editor = null;
            this.lastKeyTyped = null;
        };
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        AutoFormat.prototype.onPluginEvent = function (event) {
            var _this = this;
            if (!this.editor) {
                return;
            }
            if (event.eventType === 7 /* ContentChanged */ ||
                event.eventType === 5 /* MouseDown */ ||
                event.eventType === 6 /* MouseUp */) {
                this.lastKeyTyped = '';
            }
            if (event.eventType === 1 /* KeyPress */) {
                var keyTyped = event.rawEvent.key;
                if (keyTyped && keyTyped.length > 1) {
                    this.lastKeyTyped = '';
                }
                if (this.lastKeyTyped === '-' &&
                    !specialCharacters.test(keyTyped) &&
                    keyTyped !== ' ' &&
                    keyTyped !== '-') {
                    var searcher = this.editor.getContentSearcherOfCursor(event);
                    var textBeforeCursor = searcher === null || searcher === void 0 ? void 0 : searcher.getSubStringBefore(3);
                    var dashes = searcher === null || searcher === void 0 ? void 0 : searcher.getSubStringBefore(2);
                    var isPrecededByADash = (textBeforeCursor === null || textBeforeCursor === void 0 ? void 0 : textBeforeCursor[0]) === '-';
                    var isPrecededByASpace = (textBeforeCursor === null || textBeforeCursor === void 0 ? void 0 : textBeforeCursor[0]) === ' ';
                    if (isPrecededByADash ||
                        isPrecededByASpace ||
                        (typeof textBeforeCursor === 'string' &&
                            specialCharacters.test(textBeforeCursor[0])) ||
                        dashes !== '--') {
                        return;
                    }
                    var textRange_1 = searcher === null || searcher === void 0 ? void 0 : searcher.getRangeFromText(dashes, true /* exactMatch */);
                    var nodeHyphen_1 = document.createTextNode('');
                    this.editor.addUndoSnapshot(function () {
                        if (textRange_1) {
                            textRange_1.deleteContents();
                            textRange_1.insertNode(nodeHyphen_1);
                            _this.editor.select(nodeHyphen_1, -1 /* End */);
                        }
                    }, "Format" /* Format */, true /*canUndoByBackspace*/, { formatApiName: 'autoHyphen' });
                    //After the substitution the last key typed needs to be cleaned
                    this.lastKeyTyped = null;
                }
                else {
                    this.lastKeyTyped = keyTyped;
                }
            }
        };
        return AutoFormat;
    }());
    AutoFormat$1.default = AutoFormat;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutoFormat = void 0;
    var AutoFormat_1 = AutoFormat$1;
    Object.defineProperty(exports, "AutoFormat", { enumerable: true, get: function () { return AutoFormat_1.default; } });

    }(AutoFormat$2));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(AutoFormat$2, exports);

    }(AutoFormat$3));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(ContentEdit$3, exports);
    __exportStar(ContextMenu$3, exports);
    __exportStar(CustomReplace$2, exports);
    __exportStar(CutPasteListChain$3, exports);
    __exportStar(HyperLink$3, exports);
    __exportStar(ImageEdit$3, exports);
    __exportStar(ImageResize$3, exports);
    __exportStar(Paste$3, exports);
    __exportStar(Picker$1, exports);
    __exportStar(TableResize$3, exports);
    __exportStar(Watermark$3, exports);
    __exportStar(TableCellSelection$3, exports);
    __exportStar(AutoFormat$3, exports);

    }(lib));

    var require$$2 = /*@__PURE__*/getAugmentedNamespace(ContextualMenu);

    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(createContextMenuPlugin$1, "__esModule", { value: true });
    var React$7 = react.exports;
    var roosterjs_editor_plugins_1$1 = lib;
    var ContextualMenu_1 = require$$2;
    var renderReactComponent_1$2 = renderReactComponent$1;
    function normalizeItems(items) {
        var dividerKey = 0;
        return items.map(function (item) {
            return item || {
                name: '-',
                key: 'divider_' + (dividerKey++).toString(),
            };
        });
    }
    var ContextMenuPlugin = /** @class */ (function (_super) {
        __extends(ContextMenuPlugin, _super);
        function ContextMenuPlugin() {
            var _this = _super.call(this, {
                render: function (container, items, onDismiss) {
                    var normalizedITems = normalizeItems(items);
                    if (normalizedITems.length > 0) {
                        _this.disposer = (0, renderReactComponent_1$2.renderReactComponent)(_this.uiUtilities, React$7.createElement(ContextualMenu_1.ContextualMenu, { target: container, onDismiss: onDismiss, items: normalizedITems }));
                    }
                },
                dismiss: function (_) {
                    var _a;
                    (_a = _this.disposer) === null || _a === void 0 ? void 0 : _a.call(_this);
                    _this.disposer = null;
                },
            }) || this;
            _this.uiUtilities = null;
            _this.disposer = null;
            return _this;
        }
        ContextMenuPlugin.prototype.setUIUtilities = function (uiUtilities) {
            this.uiUtilities = uiUtilities;
        };
        return ContextMenuPlugin;
    }(roosterjs_editor_plugins_1$1.ContextMenu));
    /**
     * Create a new instance of ContextMenu plugin with context menu implementation based on FluentUI.
     */
    function createContextMenuPlugin() {
        return new ContextMenuPlugin();
    }
    createContextMenuPlugin$1.default = createContextMenuPlugin;

    var createContextMenuProvider$1 = {};

    var __assign$3 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$3 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$3.apply(this, arguments);
    };
    Object.defineProperty(createContextMenuProvider$1, "__esModule", { value: true });
    var getLocalizedString_1 = getLocalizedString$1;
    var roosterjs_editor_dom_1$5 = lib$3;
    /**
     * A plugin of editor to provide context menu items
     */
    var ContextMenuProviderImpl = /** @class */ (function () {
        /**
         * Create a new instance of ContextMenuProviderImpl class
         * @param menuName Name of this group of menus
         * @param items Menu items that will be show
         * @param strings Localized strings of these menu items
         * @param shouldAddMenuItems A general checker to decide if we should add this group of menu items
         */
        function ContextMenuProviderImpl(menuName, items, strings, shouldAddMenuItems, context) {
            this.menuName = menuName;
            this.items = items;
            this.strings = strings;
            this.shouldAddMenuItems = shouldAddMenuItems;
            this.context = context;
            this.editor = null;
            this.targetNode = null;
            this.uiUtilities = null;
        }
        /**
         * Get a friendly name of  this plugin
         */
        ContextMenuProviderImpl.prototype.getName = function () {
            return this.menuName;
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        ContextMenuProviderImpl.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        /**
         * Dispose this plugin
         */
        ContextMenuProviderImpl.prototype.dispose = function () {
            this.editor = null;
        };
        ContextMenuProviderImpl.prototype.getContextMenuItems = function (node) {
            var _this = this;
            var _a;
            this.targetNode = node;
            return this.editor && ((_a = this.shouldAddMenuItems) === null || _a === void 0 ? void 0 : _a.call(this, this.editor, node))
                ? this.items
                    .filter(function (item) { return !item.shouldShow || item.shouldShow(_this.editor, node, _this.context); })
                    .map(function (item) { return _this.convertMenuItems(item); })
                : [];
        };
        ContextMenuProviderImpl.prototype.setUIUtilities = function (uiUtilities) {
            this.uiUtilities = uiUtilities;
        };
        ContextMenuProviderImpl.prototype.convertMenuItems = function (item) {
            var _this = this;
            return {
                key: item.key,
                data: item,
                text: (0, getLocalizedString_1.default)(this.strings, item.key, item.unlocalizedText),
                ariaLabel: (0, getLocalizedString_1.default)(this.strings, item.key, item.unlocalizedText),
                onClick: function () { return _this.onClick(item, item.key); },
                subMenuProps: item.subItems
                    ? __assign$3({ onItemClick: function (_, menuItem) { return menuItem && _this.onClick(item, menuItem.data); }, items: (0, roosterjs_editor_dom_1$5.getObjectKeys)(item.subItems).map(function (key) {
                            var _a;
                            return ({
                                key: key,
                                data: key,
                                text: (0, getLocalizedString_1.default)(_this.strings, key, (_a = item.subItems) === null || _a === void 0 ? void 0 : _a[key]),
                                className: item.itemClassName,
                                onRender: item.itemRender
                                    ? function (subItem) { var _a; return (_a = item.itemRender) === null || _a === void 0 ? void 0 : _a.call(item, subItem, function () { return _this.onClick(item, key); }); }
                                    : undefined,
                            });
                        }) }, (item.commandBarSubMenuProperties || {})) : undefined,
            };
        };
        ContextMenuProviderImpl.prototype.onClick = function (item, key) {
            if (this.editor && this.targetNode && this.uiUtilities) {
                item.onClick(key, this.editor, this.targetNode, this.strings, this.uiUtilities, this.context);
            }
        };
        return ContextMenuProviderImpl;
    }());
    /**
     * Create a new instance of ContextMenuProviderImpl class
     * @param menuName Name of this group of menus
     * @param items Menu items that will be show
     * @param strings Localized strings of these menu items
     * @param shouldAddMenuItems A general checker to decide if we should add this group of menu items
     */
    function createContextMenuProvider(menuName, items, strings, shouldAddMenuItems, context) {
        return new ContextMenuProviderImpl(menuName, items, strings, shouldAddMenuItems, context);
    }
    createContextMenuProvider$1.default = createContextMenuProvider;

    var createListEditMenuProvider$1 = {};

    Object.defineProperty(createListEditMenuProvider$1, "__esModule", { value: true });
    var createContextMenuProvider_1$2 = createContextMenuProvider$1;
    var showInputDialog_1$1 = showInputDialog$1;
    var roosterjs_editor_dom_1$4 = lib$3;
    var roosterjs_editor_api_1$3 = lib$1;
    var ListNumberResetMenuItem = {
        key: 'menuNameListNumberReset',
        unlocalizedText: 'Restart at 1',
        onClick: function (_, editor, node) {
            var li = editor.getElementAtCursor('LI', node);
            (0, roosterjs_editor_api_1$3.setOrderedListNumbering)(editor, li, 1);
        },
    };
    var ListNumberEditMenuItem = {
        key: 'menuNameListNumberEdit',
        unlocalizedText: 'Set numbering value',
        onClick: function (_, editor, node, strings, uiUtilities) {
            var listAndLi = getEditingList(editor, node);
            if (listAndLi) {
                var list = listAndLi.list, li_1 = listAndLi.li;
                var startNumber_1 = list.start;
                for (var child = list.firstChild; child; child = child.nextSibling) {
                    if (child === li_1) {
                        break;
                    }
                    else if ((0, roosterjs_editor_dom_1$4.safeInstanceOf)(child, 'HTMLLIElement')) {
                        startNumber_1 += 1;
                    }
                }
                (0, showInputDialog_1$1.default)(uiUtilities, 'menuNameListNumberEdit', 'Set numbering value', {
                    value: {
                        labelKey: 'dialogTextSetListNumber',
                        unlocalizedLabel: 'Set value to',
                        initValue: startNumber_1.toString(),
                    },
                }, strings).then(function (values) {
                    editor.focus();
                    if (values) {
                        var result = parseInt(values.value);
                        if (result > 0 && result != startNumber_1) {
                            (0, roosterjs_editor_api_1$3.setOrderedListNumbering)(editor, li_1, Math.floor(result));
                        }
                    }
                });
            }
        },
    };
    function getEditingList(editor, node) {
        var li = editor.getElementAtCursor('LI', node);
        var list = li && editor.getElementAtCursor('ol', li);
        return (list === null || list === void 0 ? void 0 : list.isContentEditable) ? { list: list, li: li } : null;
    }
    /**
     * Create a new instance of ContextMenuProvider to support list number editing functionalities in context menu
     * @returns A new ContextMenuProvider
     */
    function createListEditMenuProvider(strings) {
        return (0, createContextMenuProvider_1$2.default)('listEdit', [ListNumberResetMenuItem, ListNumberEditMenuItem], strings, function (editor, node) { return !!getEditingList(editor, node); });
    }
    createListEditMenuProvider$1.default = createListEditMenuProvider;

    var createImageEditMenuProvider$1 = {};

    Object.defineProperty(createImageEditMenuProvider$1, "__esModule", { value: true });
    var createContextMenuProvider_1$1 = createContextMenuProvider$1;
    var showInputDialog_1 = showInputDialog$1;
    var roosterjs_editor_dom_1$3 = lib$3;
    var roosterjs_editor_api_1$2 = lib$1;
    var roosterjs_editor_plugins_1 = lib;
    var ImageAltTextMenuItem = {
        key: 'menuNameImageAltText',
        unlocalizedText: 'Add alternate text',
        onClick: function (_, editor, node, strings, uiUtilities) {
            var image = node;
            var initValue = image.alt;
            (0, showInputDialog_1.default)(uiUtilities, 'menuNameImageAltText', 'Add alternate text', {
                altText: {
                    labelKey: null,
                    unlocalizedLabel: null,
                    initValue: initValue,
                },
            }, strings).then(function (values) {
                editor.focus();
                editor.select(image);
                if (values) {
                    (0, roosterjs_editor_api_1$2.setImageAltText)(editor, values.altText);
                }
            });
        },
    };
    var ImageResizeMenuItem = {
        key: 'menuNameImageResize',
        unlocalizedText: 'Size',
        subItems: {
            menuNameImageSizeBestFit: 'Best fit',
            menuNameImageSizeSmall: 'Small',
            menuNameImageSizeMedium: 'Medium',
            menuNameImageSizeOriginal: 'Original',
        },
        onClick: function (key, editor, node) {
            editor.addUndoSnapshot(function () {
                var percentage = 0;
                switch (key) {
                    case 'menuNameImageSizeSmall':
                        percentage = 0.25;
                        break;
                    case 'menuNameImageSizeMedium':
                        percentage = 0.5;
                        break;
                    case 'menuNameImageSizeOriginal':
                        percentage = 1;
                        break;
                }
                if (percentage > 0) {
                    (0, roosterjs_editor_plugins_1.resizeByPercentage)(editor, node, percentage, 10 /*minWidth*/, 10 /*minHeight*/);
                }
                else {
                    (0, roosterjs_editor_plugins_1.resetImage)(editor, node);
                }
            });
        },
    };
    var ImageRotateMenuItem = {
        key: 'menuNameImageRotate',
        unlocalizedText: 'Rotate image',
        subItems: {
            menuNameImageRotateLeft: 'Left',
            menuNameImageRotateRight: 'Right',
        },
        shouldShow: function (_, node, imageEdit) {
            return (!!(imageEdit === null || imageEdit === void 0 ? void 0 : imageEdit.isOperationAllowed(4 /* Rotate */)) &&
                (0, roosterjs_editor_plugins_1.canRegenerateImage)(node));
        },
        onClick: function (key, editor, node, strings, uiUtilities, imageEdit) {
            editor.addUndoSnapshot(function () {
                switch (key) {
                    case 'menuNameImageRotateLeft':
                        imageEdit === null || imageEdit === void 0 ? void 0 : imageEdit.rotateImage(node, -Math.PI / 2);
                        break;
                    case 'menuNameImageRotateRight':
                        imageEdit === null || imageEdit === void 0 ? void 0 : imageEdit.rotateImage(node, Math.PI / 2);
                        break;
                }
            });
        },
    };
    var ImageFlipMenuItem = {
        key: 'menuNameImageFlip',
        unlocalizedText: 'Flip image',
        subItems: {
            menuNameImageRotateFlipHorizontally: 'Flip Horizontally',
            menuNameImageRotateFlipVertically: 'Flip Vertically',
        },
        shouldShow: function (_, node, imageEdit) {
            return (!!(imageEdit === null || imageEdit === void 0 ? void 0 : imageEdit.isOperationAllowed(4 /* Rotate */)) &&
                (0, roosterjs_editor_plugins_1.canRegenerateImage)(node));
        },
        onClick: function (key, editor, node, strings, uiUtilities, imageEdit) {
            editor.addUndoSnapshot(function () {
                switch (key) {
                    case 'menuNameImageRotateFlipHorizontally':
                        imageEdit === null || imageEdit === void 0 ? void 0 : imageEdit.flipImage(node, 'horizontal');
                        break;
                    case 'menuNameImageRotateFlipVertically':
                        imageEdit === null || imageEdit === void 0 ? void 0 : imageEdit.flipImage(node, 'vertical');
                        break;
                }
            });
        },
    };
    var ImageCropMenuItem = {
        key: 'menuNameImageCrop',
        unlocalizedText: 'Crop image',
        shouldShow: function (_, node, imageEdit) {
            return (!!(imageEdit === null || imageEdit === void 0 ? void 0 : imageEdit.isOperationAllowed(8 /* Crop */)) &&
                (0, roosterjs_editor_plugins_1.canRegenerateImage)(node));
        },
        onClick: function (_, editor, node, strings, uiUtilities, imageEdit) {
            imageEdit === null || imageEdit === void 0 ? void 0 : imageEdit.setEditingImage(node, 8 /* Crop */);
        },
    };
    var ImageRemoveMenuItem = {
        key: 'menuNameImageRemove',
        unlocalizedText: 'Remove image',
        onClick: function (_, editor, node, strings, uiUtilities, imageEdit) {
            if (editor.contains(node)) {
                editor.addUndoSnapshot(function () {
                    editor.deleteNode(node);
                    imageEdit === null || imageEdit === void 0 ? void 0 : imageEdit.setEditingImage(null /*editingImage*/);
                }, 'DeleteImage');
            }
        },
    };
    function shouldShowImageEditItems(editor, node) {
        return (0, roosterjs_editor_dom_1$3.safeInstanceOf)(node, 'HTMLImageElement') && node.isContentEditable;
    }
    /**
     * Create a new instance of ContextMenuProvider to support image editing functionalities in context menu
     * @returns A new ContextMenuProvider
     */
    function createImageEditMenuProvider(imageEditPlugin, strings) {
        return (0, createContextMenuProvider_1$1.default)('imageEdit', [
            ImageAltTextMenuItem,
            ImageResizeMenuItem,
            ImageCropMenuItem,
            ImageRemoveMenuItem,
            ImageRotateMenuItem,
            ImageFlipMenuItem,
        ], strings, shouldShowImageEditItems, imageEditPlugin);
    }
    createImageEditMenuProvider$1.default = createImageEditMenuProvider;

    var createTableEditMenuProvider$1 = {};

    var __assign$2 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$2 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };
    Object.defineProperty(createTableEditMenuProvider$1, "__esModule", { value: true });
    var createContextMenuProvider_1 = createContextMenuProvider$1;
    var roosterjs_editor_api_1$1 = lib$1;
    var renderColorPicker_1 = renderColorPicker$1;
    var getClassNamesForColorPicker_1 = getClassNamesForColorPicker;
    var backgroundColors_1 = backgroundColors;
    var TableEditOperationMap = {
        menuNameTableInsertAbove: 0 /* InsertAbove */,
        menuNameTableInsertBelow: 1 /* InsertBelow */,
        menuNameTableInsertLeft: 2 /* InsertLeft */,
        menuNameTableInsertRight: 3 /* InsertRight */,
        menuNameTableDeleteTable: 4 /* DeleteTable */,
        menuNameTableDeleteColumn: 5 /* DeleteColumn */,
        menuNameTableDeleteRow: 6 /* DeleteRow */,
        menuNameTableMergeAbove: 7 /* MergeAbove */,
        menuNameTableMergeBelow: 8 /* MergeBelow */,
        menuNameTableMergeLeft: 9 /* MergeLeft */,
        menuNameTableMergeRight: 10 /* MergeRight */,
        menuNameTableMergeCells: 11 /* MergeCells */,
        menuNameTableSplitHorizontally: 12 /* SplitHorizontally */,
        menuNameTableSplitVertically: 13 /* SplitVertically */,
        menuNameTableAlignLeft: 17 /* AlignCellLeft */,
        menuNameTableAlignCenter: 18 /* AlignCellCenter */,
        menuNameTableAlignRight: 19 /* AlignCellRight */,
        menuNameTableAlignTop: 20 /* AlignCellTop */,
        menuNameTableAlignMiddle: 21 /* AlignCellMiddle */,
        menuNameTableAlignBottom: 22 /* AlignCellBottom */,
        menuNameTableAlignTableLeft: 15 /* AlignLeft */,
        menuNameTableAlignTableCenter: 14 /* AlignCenter */,
        menuNameTableAlignTableRight: 16 /* AlignRight */,
    };
    var ColorValues = __assign$2(__assign$2({}, backgroundColors_1.BackgroundColors), { 
        // Add this value to satisfy compiler
        menuNameTableCellShade: null });
    function onClick(key, editor) {
        editor.focus();
        var operation = TableEditOperationMap[key];
        if (typeof operation === 'number') {
            (0, roosterjs_editor_api_1$1.editTable)(editor, operation);
        }
    }
    var TableEditInsertMenuItem = {
        key: 'menuNameTableInsert',
        unlocalizedText: 'Insert',
        subItems: {
            menuNameTableInsertAbove: 'Insert above',
            menuNameTableInsertBelow: 'Insert below',
            menuNameTableInsertLeft: 'Insert left',
            menuNameTableInsertRight: 'Insert right',
        },
        onClick: onClick,
    };
    var TableEditDeleteMenuItem = {
        key: 'menuNameTableDelete',
        unlocalizedText: 'Delete',
        subItems: {
            menuNameTableDeleteColumn: 'Delete column',
            menuNameTableDeleteRow: 'Delete row',
            menuNameTableDeleteTable: 'Delete table',
        },
        onClick: onClick,
    };
    var TableEditMergeMenuItem = {
        key: 'menuNameTableMerge',
        unlocalizedText: 'Merge',
        subItems: {
            menuNameTableMergeAbove: 'Merge above',
            menuNameTableMergeBelow: 'Merge below',
            menuNameTableMergeLeft: 'Merge left',
            menuNameTableMergeRight: 'Merge right',
            '-': '-',
            menuNameTableMergeCells: 'Merge selected cells',
        },
        onClick: onClick,
    };
    var TableEditSplitMenuItem = {
        key: 'menuNameTableSplit',
        unlocalizedText: 'Split',
        subItems: {
            menuNameTableSplitHorizontally: 'Split horizontally',
            menuNameTableSplitVertically: 'Split vertically',
        },
        onClick: onClick,
    };
    var TableEditAlignMenuItem = {
        key: 'menuNameTableAlign',
        unlocalizedText: 'Align cell',
        subItems: {
            menuNameTableAlignLeft: 'Align left',
            menuNameTableAlignCenter: 'Align center',
            menuNameTableAlignRight: 'Align right',
            '-': '-',
            menuNameTableAlignTop: 'Align top',
            menuNameTableAlignMiddle: 'Align middle',
            menuNameTableAlignBottom: 'Align bottom',
        },
        onClick: onClick,
    };
    var TableEditAlignTableMenuItem = {
        key: 'menuNameTableAlignTable',
        unlocalizedText: 'Align table',
        subItems: {
            menuNameTableAlignTableLeft: 'Align left',
            menuNameTableAlignTableCenter: 'Align center',
            menuNameTableAlignTableRight: 'Align right',
        },
        onClick: onClick,
    };
    var TableEditCellShadeMenuItem = {
        key: 'menuNameTableCellShade',
        unlocalizedText: 'Shading',
        subItems: backgroundColors_1.BackgroundColorDropDownItems,
        onClick: function (key, editor) {
            (0, roosterjs_editor_api_1$1.applyCellShading)(editor, ColorValues[key]);
        },
        itemRender: function (item, click) { return (0, renderColorPicker_1.renderColorPicker)(item, ColorValues, click); },
        itemClassName: (0, getClassNamesForColorPicker_1.getColorPickerItemClassName)(),
        commandBarSubMenuProperties: {
            className: (0, getClassNamesForColorPicker_1.getColorPickerContainerClassName)(),
        },
    };
    function getEditingTable(editor, node) {
        var td = editor.getElementAtCursor('TD,TH', node);
        var table = td && editor.getElementAtCursor('table', td);
        return (table === null || table === void 0 ? void 0 : table.isContentEditable) ? { table: table, td: td } : null;
    }
    /**
     * Create a new instance of ContextMenuProvider to support table editing functionalities in context menu
     * @returns A new ContextMenuProvider
     */
    function createTableEditMenuProvider(strings) {
        return (0, createContextMenuProvider_1.default)('tableEdit', [
            TableEditInsertMenuItem,
            TableEditDeleteMenuItem,
            TableEditMergeMenuItem,
            TableEditSplitMenuItem,
            TableEditAlignMenuItem,
            TableEditAlignTableMenuItem,
            TableEditCellShadeMenuItem,
        ], strings, function (editor, node) { return !!getEditingTable(editor, node); });
    }
    createTableEditMenuProvider$1.default = createTableEditMenuProvider;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTableEditMenuProvider = exports.createImageEditMenuProvider = exports.createListEditMenuProvider = exports.createContextMenuProvider = exports.createContextMenuPlugin = void 0;
    var createContextMenuPlugin_1 = createContextMenuPlugin$1;
    Object.defineProperty(exports, "createContextMenuPlugin", { enumerable: true, get: function () { return createContextMenuPlugin_1.default; } });
    var createContextMenuProvider_1 = createContextMenuProvider$1;
    Object.defineProperty(exports, "createContextMenuProvider", { enumerable: true, get: function () { return createContextMenuProvider_1.default; } });
    var createListEditMenuProvider_1 = createListEditMenuProvider$1;
    Object.defineProperty(exports, "createListEditMenuProvider", { enumerable: true, get: function () { return createListEditMenuProvider_1.default; } });
    var createImageEditMenuProvider_1 = createImageEditMenuProvider$1;
    Object.defineProperty(exports, "createImageEditMenuProvider", { enumerable: true, get: function () { return createImageEditMenuProvider_1.default; } });
    var createTableEditMenuProvider_1 = createTableEditMenuProvider$1;
    Object.defineProperty(exports, "createTableEditMenuProvider", { enumerable: true, get: function () { return createTableEditMenuProvider_1.default; } });

    }(contextMenu));

    var pasteOptions = {};

    var createPasteOptionPlugin$1 = {};

    var showPasteOptionPane$1 = {};

    var buttons = {};

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ButtonKeys = exports.Buttons = void 0;
    /**
     * @internal
     */
    exports.Buttons = {
        pasteOptionPasteAsIs: {
            unlocalizedText: 'Paste as is',
            shortcut: 'P',
            icon: 'Paste',
        },
        pasteOptionPasteText: {
            unlocalizedText: 'Paste text',
            shortcut: 'T',
            icon: 'PasteAsText',
        },
        pasteOptionMergeFormat: {
            unlocalizedText: 'Paste text and merge format',
            shortcut: 'M',
            icon: 'ClipboardList',
        },
    };
    /**
     * @internal
     */
    exports.ButtonKeys = Object.keys(exports.Buttons);

    }(buttons));

    var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(Callout);

    var require$$5 = /*@__PURE__*/getAugmentedNamespace(Icon);

    Object.defineProperty(showPasteOptionPane$1, "__esModule", { value: true });
    var React$6 = react.exports;
    var buttons_1$1 = buttons;
    var Callout_1$1 = require$$1$1;
    var index_1 = common;
    var roosterjs_editor_dom_1$2 = lib$3;
    var Icon_1$1 = require$$5;
    var Button_1 = require$$6;
    var Utilities_1$3 = require$$2$2;
    var Styling_1 = require$$10;
    var renderReactComponent_1$1 = renderReactComponent$1;
    var Theme_1 = require$$12;
    var getPasteOptionClassNames = (0, Utilities_1$3.memoizeFunction)(function (theme) {
        var palette = theme.palette;
        return (0, Styling_1.mergeStyleSets)({
            pastePane: {
                paddingLeft: '4px',
                minWidth: '72px',
            },
            optionPane: {
                textAlign: 'center',
                padding: '4px',
            },
            icon: {
                fontSize: '14px',
            },
            buttonsContainer: {
                justifyContent: 'center',
                display: 'flex',
            },
            button: {
                width: '32px',
                height: '32px',
                margin: '0 4px 4px 0',
                borderRadius: '2px',
                flex: '0 0 auto',
                '&:hover': {
                    backgroundColor: palette.themeLighter,
                },
            },
            isChecked: {
                backgroundColor: palette.themeLight,
                '&:hover': {
                    backgroundColor: palette.themeLighter,
                },
            },
        });
    });
    function PasteOptionButton(props) {
        var buttonName = props.buttonName, paste = props.paste, strings = props.strings, className = props.className;
        var button = buttons_1$1.Buttons[buttonName];
        var onClick = React$6.useCallback(function () {
            paste(buttonName);
        }, [paste, buttonName]);
        return (React$6.createElement(Button_1.IconButton, { className: className, onClick: onClick, title: (0, index_1.getLocalizedString)(strings, buttonName, button.unlocalizedText) +
                (button.shortcut ? " (" + button.shortcut + ")" : ''), iconProps: { iconName: button.icon } }));
    }
    var PasteOptionComponent = React$6.forwardRef(function PasteOptionFunc(props, ref) {
        var strings = props.strings, position = props.position, paste = props.paste, dismiss = props.dismiss, isRtl = props.isRtl;
        var theme = (0, Theme_1.useTheme)();
        var classNames = getPasteOptionClassNames(theme);
        var _a = React$6.useState(null), selectedKey = _a[0], setSelectedKey = _a[1];
        var rect = position && (0, roosterjs_editor_dom_1$2.getPositionRect)(position);
        var target = rect && { x: props.isRtl ? rect.left : rect.right, y: rect.bottom };
        React$6.useImperativeHandle(ref, function () { return ({
            dismiss: dismiss,
            setSelectedKey: setSelectedKey,
            getSelectedKey: function () { return selectedKey; },
        }); }, [dismiss, paste, isRtl, selectedKey, setSelectedKey]);
        var buttonPane = React$6.useRef(null);
        var onDismiss = React$6.useCallback(function (evt) {
            var target = evt instanceof FocusEvent && evt.relatedTarget instanceof Node
                ? evt.relatedTarget
                : null;
            var clickOnButtonPane = target &&
                buttonPane.current &&
                (buttonPane.current == target || buttonPane.current.contains(target));
            if (!clickOnButtonPane) {
                dismiss();
            }
        }, [dismiss]);
        var onClickShowSubMenu = React$6.useCallback(function (event) {
            setSelectedKey(buttons_1$1.ButtonKeys[0]);
            event.preventDefault();
            event.stopPropagation();
        }, [setSelectedKey]);
        return (React$6.createElement(Callout_1$1.Callout, { gapSpace: 10, isBeakVisible: false, target: target, directionalHint: isRtl ? Callout_1$1.DirectionalHint.bottomRightEdge : Callout_1$1.DirectionalHint.bottomLeftEdge, directionalHintForRTL: Callout_1$1.DirectionalHint.bottomRightEdge, preventDismissOnScroll: true, onDismiss: onDismiss },
            React$6.createElement("div", { ref: buttonPane, className: classNames.pastePane },
                React$6.createElement("div", { onClick: onClickShowSubMenu, className: classNames.optionPane },
                    React$6.createElement(Icon_1$1.Icon, { iconName: 'Paste', className: classNames.icon }),
                    (0, index_1.getLocalizedString)(strings, 'pasteOptionPaneText', '(Ctrl)')),
                selectedKey && (React$6.createElement("div", { className: classNames.buttonsContainer }, (0, roosterjs_editor_dom_1$2.getObjectKeys)(buttons_1$1.Buttons).map(function (key) { return (React$6.createElement(PasteOptionButton, { key: key, strings: strings, paste: paste, buttonName: key, className: classNames.button +
                        ' ' +
                        (selectedKey == key ? classNames.isChecked : '') })); }))))));
    });
    /**
     * @internal Show paste open pane component
     * @param uiUtilities The UI utilities object to help render component
     * @param position Target position
     * @param strings Localize string for this component
     * @param onPaste A callback to be called when user click on a paste button
     * @param ref Reference object for this component
     */
    function showPasteOptionPane(uiUtilities, position, onPaste, ref, strings) {
        var disposer = null;
        var onDismiss = function () {
            disposer === null || disposer === void 0 ? void 0 : disposer();
            disposer = null;
        };
        disposer = (0, renderReactComponent_1$1.renderReactComponent)(uiUtilities, React$6.createElement(PasteOptionComponent, { ref: ref, position: position, strings: strings, isRtl: uiUtilities.isRightToLeft(), dismiss: onDismiss, paste: onPaste }));
    }
    showPasteOptionPane$1.default = showPasteOptionPane;

    Object.defineProperty(createPasteOptionPlugin$1, "__esModule", { value: true });
    var React$5 = react.exports;
    var showPasteOptionPane_1 = showPasteOptionPane$1;
    var buttons_1 = buttons;
    var PasteOptionPlugin = /** @class */ (function () {
        function PasteOptionPlugin(strings) {
            var _this = this;
            this.strings = strings;
            this.clipboardData = null;
            this.editor = null;
            this.uiUtilities = null;
            this.pasteOptionRef = React$5.createRef();
            this.onPaste = function (key) {
                var _a;
                if (_this.clipboardData && _this.editor) {
                    _this.editor.focus();
                    switch (key) {
                        case 'pasteOptionPasteAsIs':
                            _this.editor.paste(_this.clipboardData);
                            break;
                        case 'pasteOptionPasteText':
                            _this.editor.paste(_this.clipboardData, true /*pasteAsText*/);
                            break;
                        case 'pasteOptionMergeFormat':
                            _this.editor.paste(_this.clipboardData, false /*pasteAsText*/, true /*applyCurrentFormat*/);
                            break;
                    }
                    (_a = _this.pasteOptionRef.current) === null || _a === void 0 ? void 0 : _a.setSelectedKey(key);
                }
            };
        }
        PasteOptionPlugin.prototype.getName = function () {
            return 'PasteOption';
        };
        PasteOptionPlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        PasteOptionPlugin.prototype.dispose = function () {
            var _a;
            (_a = this.pasteOptionRef.current) === null || _a === void 0 ? void 0 : _a.dismiss();
            this.editor = null;
        };
        PasteOptionPlugin.prototype.onPluginEvent = function (event) {
            var _a;
            if (event.eventType == 14 /* Scroll */) {
                if (this.pasteOptionRef.current) {
                    this.showPasteOptionPane();
                }
            }
            else if (this.pasteOptionRef.current) {
                this.handlePasteOptionPaneEvent(event);
            }
            else if (event.eventType == 7 /* ContentChanged */) {
                if (event.source == 'Paste') {
                    var clipboardData = event.data;
                    // Only show paste option when we pasted HTML with some format
                    if ((clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.text) && ((_a = clipboardData.types) === null || _a === void 0 ? void 0 : _a.indexOf('text/html')) >= 0) {
                        this.clipboardData = clipboardData;
                        this.showPasteOptionPane();
                    }
                }
            }
        };
        PasteOptionPlugin.prototype.setUIUtilities = function (uiUtilities) {
            this.uiUtilities = uiUtilities;
        };
        PasteOptionPlugin.prototype.handlePasteOptionPaneEvent = function (event) {
            var _a;
            if (event.eventType == 0 /* KeyDown */ && this.pasteOptionRef.current) {
                var selectedKey = this.pasteOptionRef.current.getSelectedKey();
                if (!selectedKey) {
                    switch (event.rawEvent.which) {
                        case 17 /* CTRL_LEFT */:
                            this.pasteOptionRef.current.setSelectedKey(buttons_1.ButtonKeys[0]);
                            cancelEvent(event.rawEvent);
                            break;
                        case 27 /* ESCAPE */:
                            this.pasteOptionRef.current.dismiss();
                            cancelEvent(event.rawEvent);
                            break;
                        default:
                            this.pasteOptionRef.current.dismiss();
                            break;
                    }
                }
                else {
                    var keyboardEvent = event.rawEvent;
                    if (keyboardEvent.which != 17 /* CTRL_LEFT */ && keyboardEvent.ctrlKey) {
                        // Dismiss the paste option when pressing hotkey CTRL+<any key>
                        this.pasteOptionRef.current.dismiss();
                        return;
                    }
                    for (var i = 0; i < buttons_1.ButtonKeys.length; i++) {
                        var key = buttons_1.ButtonKeys[i];
                        var button = buttons_1.Buttons[key];
                        if (button.shortcut == String.fromCharCode(keyboardEvent.which)) {
                            this.onPaste(key);
                            cancelEvent(keyboardEvent);
                            return;
                        }
                    }
                    switch (keyboardEvent.which) {
                        case 27 /* ESCAPE */:
                            this.pasteOptionRef.current.dismiss();
                            break;
                        case 37 /* LEFT */:
                        case 39 /* RIGHT */:
                            var buttonCount = buttons_1.ButtonKeys.length;
                            var diff = (keyboardEvent.which == 39 /* RIGHT */) == ((_a = this.uiUtilities) === null || _a === void 0 ? void 0 : _a.isRightToLeft())
                                ? -1
                                : 1;
                            this.pasteOptionRef.current.setSelectedKey(buttons_1.ButtonKeys[(buttons_1.ButtonKeys.indexOf(selectedKey) + diff + buttonCount) % buttonCount]);
                            break;
                        case 13 /* ENTER */:
                            this.onPaste(selectedKey);
                            break;
                        case 17 /* CTRL_LEFT */:
                            // Noop
                            break;
                        default:
                            this.pasteOptionRef.current.dismiss();
                            return;
                    }
                    cancelEvent(keyboardEvent);
                }
            }
        };
        PasteOptionPlugin.prototype.showPasteOptionPane = function () {
            var _a, _b;
            (_a = this.pasteOptionRef.current) === null || _a === void 0 ? void 0 : _a.dismiss();
            var focusedPosition = (_b = this.editor) === null || _b === void 0 ? void 0 : _b.getFocusedPosition();
            if (focusedPosition && this.uiUtilities) {
                (0, showPasteOptionPane_1.default)(this.uiUtilities, focusedPosition, this.onPaste, this.pasteOptionRef, this.strings);
            }
        };
        return PasteOptionPlugin;
    }());
    function cancelEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Create a new instance of PasteOption plugin to show an option pane when paste, so that user can choose
     * an option to change the paste result, including:
     * - Paste as is
     * - Paste as text
     * - Paste and merge format
     * @param strings Localized string for this plugin
     * @returns A paste option plugin
     */
    function createPasteOptionPlugin(strings) {
        return new PasteOptionPlugin(strings);
    }
    createPasteOptionPlugin$1.default = createPasteOptionPlugin;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPasteOptionPlugin = void 0;
    var createPasteOptionPlugin_1 = createPasteOptionPlugin$1;
    Object.defineProperty(exports, "createPasteOptionPlugin", { enumerable: true, get: function () { return createPasteOptionPlugin_1.default; } });

    }(pasteOptions));

    var colorPicker = {};

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTextColorValue = exports.getBackgroundColorValue = void 0;
    var backgroundColors_1 = backgroundColors;
    Object.defineProperty(exports, "getBackgroundColorValue", { enumerable: true, get: function () { return backgroundColors_1.getBackgroundColorValue; } });
    var textColors_1 = textColors;
    Object.defineProperty(exports, "getTextColorValue", { enumerable: true, get: function () { return textColors_1.getTextColorValue; } });

    }(colorPicker));

    var emoji = {};

    var createEmojiPlugin$1 = {};

    var showEmojiCallout$1 = {};

    var EmojiPane = {};

    var EmojiIcon$1 = {};

    var __assign$1 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$1 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };
    Object.defineProperty(EmojiIcon$1, "__esModule", { value: true });
    var React$4 = react.exports;
    var Utilities_1$2 = require$$2$2;
    /**
     * @internal
     * Emoji icon component
     */
    function EmojiIcon(props) {
        var _a;
        var emoji = props.emoji, onClick = props.onClick, isSelected = props.isSelected, onMouseOver = props.onMouseOver, onFocus = props.onFocus, strings = props.strings, id = props.id, classNames = props.classNames;
        var content = emoji.description && strings[emoji.description];
        return (React$4.createElement("button", __assign$1({ id: id, role: "option", className: (0, Utilities_1$2.css)(classNames.emoji, (_a = {},
                _a[classNames.emojiSelected] = isSelected,
                _a)), onClick: onClick, onMouseOver: onMouseOver, onFocus: onFocus, "data-is-focusable": true, "aria-label": content, "aria-selected": isSelected }, getDataAndAriaProps(props)), emoji.codePoint || ''));
    }
    EmojiIcon$1.default = EmojiIcon;
    function reduceObject(object, callback) {
        if (!object) {
            return object;
        }
        return Object.keys(object).reduce(function (result, key) {
            if (callback(key)) {
                result[key] = object[key];
            }
            return result;
        }, {});
    }
    function getDataAndAriaProps(props) {
        return reduceObject(props || {}, function (propName) { return propName.indexOf('data-') === 0 || propName.indexOf('aria-') === 0; });
    }

    var EmojiNavBar$1 = {};

    var emojiList = {};

    (function (exports) {
    var _a, _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forEachEmoji = exports.forEachEmojiFamily = exports.EmojiFabricIconCharacterMap = exports.EmojiList = exports.EmojiFamilyKeys = exports.CommonEmojis = exports.MoreEmoji = void 0;
    var roosterjs_editor_dom_1 = lib$3;
    var Common1 = createEmoji('1f60a', ':) :-)');
    var common2 = createEmoji('1f609', ';) ;-)');
    var common3 = createEmoji('02764', '<3');
    var common4 = createEmoji('1f61e', ':( :-(');
    var common5 = createEmoji('1f603', ':D :-D');
    /**
     * @internal
     */
    exports.MoreEmoji = {
        key: 'more',
        description: 'emjDMore',
        codePoint: '',
    };
    /**
     * @internal
     */
    exports.CommonEmojis = [Common1, common2, common3, common4, common5, exports.MoreEmoji];
    (function (EmojiFamilyKeys) {
        EmojiFamilyKeys["People"] = "People";
        EmojiFamilyKeys["Nature"] = "Nature";
        EmojiFamilyKeys["Activities"] = "Activities";
        EmojiFamilyKeys["Food"] = "Food";
        EmojiFamilyKeys["Travel"] = "Travel";
        EmojiFamilyKeys["Symbols"] = "Symbols";
        EmojiFamilyKeys["Objects"] = "Objects";
    })(exports.EmojiFamilyKeys || (exports.EmojiFamilyKeys = {}));
    /**
     * @internal
     * NOTE: name for an emoji should be in lower case
     */
    exports.EmojiList = (_a = {},
        _a["People" /* People */] = [
            createEmoji('1f601'),
            createEmoji('1f602'),
            common5,
            createEmoji('1f604'),
            createEmoji('1f605'),
            createEmoji('1f606'),
            createEmoji('1f607'),
            common2,
            Common1,
            createEmoji('1f642'),
            createEmoji('1f60b'),
            createEmoji('1f60c'),
            createEmoji('1f60d'),
            createEmoji('1f618'),
            createEmoji('1f61a'),
            createEmoji('1f61c'),
            createEmoji('1f61d', ':p :P :-p :-P'),
            createEmoji('1f60e', 'B) B-)'),
            createEmoji('1f60f'),
            createEmoji('1f636'),
            createEmoji('1f610', ':| :-|'),
            createEmoji('1f612'),
            createEmoji('1f633'),
            common4,
            createEmoji('1f620'),
            createEmoji('1f621'),
            createEmoji('1f614'),
            createEmoji('1f623'),
            createEmoji('1f616'),
            createEmoji('1f62b'),
            createEmoji('1f629'),
            createEmoji('1f624'),
            createEmoji('1f631'),
            createEmoji('1f628'),
            createEmoji('1f630'),
            createEmoji('1f625'),
            createEmoji('1f622'),
            createEmoji('1f62a'),
            createEmoji('1f613'),
            createEmoji('1f62d'),
            createEmoji('1f635'),
            createEmoji('1f632', ':o :O :-o :-O'),
            createEmoji('1f637'),
            createEmoji('1f4a4'),
            createEmojiWithNoKeyword('1f608'),
            createEmoji('1f47f'),
            createEmojiWithNoKeyword('1f479'),
            createEmojiWithNoKeyword('1f47a'),
            createEmoji('1f480'),
            createEmoji('1f47b'),
            createEmoji('1f47d'),
            createEmoji('1f63a'),
            createEmoji('1f638'),
            createEmoji('1f639'),
            createEmoji('1f63b'),
            createEmoji('1f63c'),
            createEmoji('1f63d'),
            createEmojiWithNoKeyword('1f640'),
            createEmoji('1f63f'),
            createEmoji('1f63e'),
            createEmoji('1f64c'),
            createEmoji('1f44f'),
            createEmoji('1f44b'),
            createEmoji('1f44d'),
            createEmoji('1f44e'),
            createEmoji('1f44a'),
            createEmoji('0270a'),
            createEmoji('0270b'),
            createEmoji('0270c'),
            createEmoji('1f44c'),
            createEmojiWithNoKeyword('1f450'),
            createEmojiWithNoKeyword('1f596'),
            createEmoji('1f4aa'),
            createEmoji('1f64f'),
            createEmoji('1f446'),
            createEmoji('1f447'),
            createEmoji('1f448'),
            createEmoji('1f449'),
            createEmoji('1f485'),
            createEmoji('1f444'),
            createEmoji('1f445'),
            createEmoji('1f442'),
            createEmoji('1f443'),
            createEmoji('1f440'),
            createEmojiWithNoKeyword('1f464'),
            createEmoji('1f476'),
            createEmoji('1f466'),
            createEmoji('1f467'),
            createEmoji('1f468'),
            createEmoji('1f469'),
            createEmoji('1f471'),
            createEmoji('1f474'),
            createEmoji('1f475'),
            createEmojiWithNoKeyword('1f472'),
            createEmojiWithNoKeyword('1f473'),
            createEmoji('1f46e'),
            createEmoji('1f477'),
            createEmoji('1f482'),
            createEmoji('1f385'),
            createEmoji('1f47c'),
            createEmoji('1f478'),
            createEmoji('1f470'),
            createEmoji('1f6b6'),
            createEmoji('1f3c3'),
            createEmoji('1f483'),
            createEmoji('1f46f'),
            createEmoji('1f46b'),
            createEmojiWithNoKeyword('1f647'),
            createEmoji('1f481'),
            createEmoji('1f645'),
            createEmoji('1f646'),
            createEmoji('1f64b'),
            createEmoji('1f64e'),
            createEmoji('1f64d'),
            createEmoji('1f487'),
            createEmoji('1f486'),
            createEmoji('1f491'),
            createEmoji('1f48f'),
            createEmoji('1f46a'),
            createEmoji('1f45a'),
            createEmoji('1f455'),
            createEmoji('1f456'),
            createEmoji('1f454'),
            createEmoji('1f457'),
            createEmoji('1f459'),
            createEmoji('1f458'),
            createEmoji('1f484'),
            createEmoji('1f48b'),
            createEmoji('1f463'),
            createEmojiWithNoKeyword('1f460'),
            createEmoji('1f461'),
            createEmoji('1f462'),
            createEmoji('1f45e'),
            createEmoji('1f45f'),
            createEmoji('1f452'),
            createEmoji('1f3a9'),
            createEmoji('1f393'),
            createEmoji('1f451'),
            createEmoji('1f392'),
            createEmoji('1f45d'),
            createEmoji('1f45b'),
            createEmoji('1f45c'),
            createEmoji('1f4bc'),
            createEmoji('1f453'),
            createEmoji('1f48d'),
            createEmoji('1f302'),
        ],
        _a["Nature" /* Nature */] = [
            createEmoji('1f436'),
            createEmoji('1f431'),
            createEmoji('1f42d'),
            createEmoji('1f439'),
            createEmoji('1f430'),
            createEmoji('1f43b'),
            createEmoji('1f43c'),
            createEmojiWithNoKeyword('1f428'),
            createEmoji('1f42f'),
            createEmoji('1f42e'),
            createEmoji('1f437'),
            createEmoji('1f43d'),
            createEmoji('1f438'),
            createEmoji('1f419'),
            createEmoji('1f435'),
            createEmoji('1f648'),
            createEmoji('1f649'),
            createEmoji('1f64a'),
            createEmoji('1f412'),
            createEmoji('1f427'),
            createEmoji('1f426'),
            createEmojiWithNoKeyword('1f424'),
            createEmoji('1f423'),
            createEmoji('1f425'),
            createEmoji('1f43a'),
            createEmoji('1f417'),
            createEmoji('1f434'),
            createEmoji('1f41d'),
            createEmoji('1f41b'),
            createEmoji('1f40c'),
            createEmoji('1f41e'),
            createEmoji('1f41c'),
            createEmoji('1f40d'),
            createEmoji('1f422'),
            createEmoji('1f420'),
            createEmoji('1f41f'),
            createEmoji('1f421'),
            createEmoji('1f42c'),
            createEmoji('1f433'),
            createEmoji('1f414'),
            createEmoji('1f42b'),
            createEmoji('1f418'),
            createEmoji('1f411'),
            createEmoji('1f40e'),
            createEmoji('1f429'),
            createEmoji('1f43e'),
            createEmoji('1f432'),
            createEmoji('1f335'),
            createEmoji('1f384'),
            createEmoji('1f334'),
            createEmoji('1f331'),
            createEmoji('1f33f'),
            createEmoji('1f340'),
            createEmojiWithNoKeyword('1f38d'),
            createEmojiWithNoKeyword('1f38b'),
            createEmoji('1f343'),
            createEmoji('1f342'),
            createEmoji('1f341'),
            createEmoji('1f33e'),
            createEmoji('1f33a'),
            createEmoji('1f33b'),
            createEmoji('1f339'),
            createEmoji('1f33c'),
            createEmoji('1f337'),
            createEmoji('1f338'),
            createEmoji('1f344'),
            createEmoji('1f490'),
            createEmoji('1f330'),
            createEmoji('1f383'),
            createEmoji('1f41a'),
            createEmojiWithNoKeyword('1f30f'),
            createEmoji('1f315'),
            createEmoji('1f311'),
            createEmoji('1f313'),
            createEmoji('1f314'),
            createEmoji('1f31b'),
            createEmoji('1f319'),
            createEmoji('02b50'),
            createEmoji('1f31f'),
            createEmojiWithNoKeyword('1f4ab'),
            createEmoji('02728'),
            createEmojiWithNoKeyword('02600'),
            createEmojiWithNoKeyword('026c5'),
            createEmoji('02601'),
            createEmoji('026a1'),
            createEmoji('1f525'),
            createEmoji('1f4a5'),
            createEmoji('02744'),
            createEmoji('026c4'),
            createEmoji('1f4a8'),
            createEmoji('02614'),
            createEmojiWithNoKeyword('1f4a7'),
            createEmojiWithNoKeyword('1f4a6'),
            createEmoji('1f30a'),
        ],
        _a["Activities" /* Activities */] = [
            createEmoji('026bd'),
            createEmoji('1f3c0'),
            createEmoji('1f3c8'),
            createEmoji('026be'),
            createEmoji('1f3be'),
            createEmoji('1f3b1'),
            createEmoji('026f3'),
            createEmoji('1f3bf'),
            createEmoji('1f3c2'),
            createEmoji('1f3a3'),
            createEmoji('1f3ca'),
            createEmoji('1f3c4'),
            createEmoji('1f3c6'),
            createEmoji('1f3bd'),
            createEmoji('1f3ab'),
            createEmoji('1f3ad'),
            createEmoji('1f3a8'),
            createEmoji('1f3aa'),
            createEmoji('1f3a4'),
            createEmoji('1f3a7'),
            createEmoji('1f3bc'),
            createEmoji('1f3b9'),
            createEmoji('1f3b7'),
            createEmoji('1f3ba'),
            createEmoji('1f3b8'),
            createEmoji('1f3bb'),
            createEmoji('1f3ac'),
            createEmoji('1f3ae'),
            createEmoji('1f47e'),
            createEmoji('1f3af'),
            createEmoji('1f3b2'),
            createEmoji('1f3b0'),
            createEmoji('1f3b3'),
        ],
        _a["Food" /* Food */] = [
            createEmoji('1f34f'),
            createEmoji('1f34e'),
            createEmoji('1f34a'),
            createEmoji('1f34c'),
            createEmoji('1f349'),
            createEmoji('1f347'),
            createEmoji('1f353'),
            createEmoji('1f348'),
            createEmoji('1f352'),
            createEmoji('1f351'),
            createEmoji('1f34d'),
            createEmoji('1f345'),
            createEmoji('1f346'),
            createEmoji('1f33d'),
            createEmoji('1f360'),
            createEmoji('1f35e'),
            createEmoji('1f357'),
            createEmoji('1f356'),
            createEmoji('1f364'),
            createEmoji('1f373'),
            createEmoji('1f354'),
            createEmoji('1f35f'),
            createEmoji('1f355'),
            createEmoji('1f35d'),
            createEmoji('1f35c'),
            createEmoji('1f372'),
            createEmoji('1f365'),
            createEmoji('1f363'),
            createEmoji('1f371'),
            createEmoji('1f35b'),
            createEmoji('1f359'),
            createEmoji('1f35a'),
            createEmoji('1f358'),
            createEmoji('1f362'),
            createEmoji('1f361'),
            createEmojiWithNoKeyword('1f367'),
            createEmoji('1f368'),
            createEmoji('1f366'),
            createEmoji('1f370'),
            createEmoji('1f36f'),
            createEmoji('1f382'),
            createEmoji('1f36e'),
            createEmoji('1f36c'),
            createEmoji('1f36d'),
            createEmoji('1f36b'),
            createEmoji('1f369'),
            createEmoji('1f36a'),
            createEmoji('1f37a'),
            createEmoji('1f37b'),
            createEmoji('1f377'),
            createEmoji('1f378'),
            createEmoji('1f379'),
            createEmoji('1f376'),
            createEmoji('1f375'),
            createEmoji('02615'),
            createEmoji('1f374'),
        ],
        _a["Travel" /* Travel */] = [
            createEmoji('1f697'),
            createEmoji('1f695'),
            createEmoji('1f687'),
            createEmojiWithNoKeyword('1f699'),
            createEmoji('1f68c'),
            createEmoji('1f693'),
            createEmoji('1f69a'),
            createEmojiWithNoKeyword('1f691'),
            createEmoji('1f692'),
            createEmoji('1f6b2'),
            createEmoji('1f6a8'),
            createEmoji('1f683'),
            createEmoji('1f684'),
            createEmojiWithNoKeyword('1f685'),
            createEmoji('1f689'),
            createEmoji('02708'),
            createEmoji('026f5'),
            createEmojiWithNoKeyword('1f6a4'),
            createEmoji('1f680'),
            createEmoji('1f4ba'),
            createEmoji('02693'),
            createEmoji('1f6a7'),
            createEmoji('026fd'),
            createEmoji('1f68f'),
            createEmoji('1f6a5'),
            createEmoji('1f3c1'),
            createEmoji('1f6a2'),
            createEmoji('1f3a1'),
            createEmoji('1f3a2'),
            createEmoji('1f3a0'),
            createEmoji('1f301'),
            createEmojiWithNoKeyword('1f5fc'),
            createEmoji('1f3ed'),
            createEmoji('026f2'),
            createEmojiWithNoKeyword('1f391'),
            createEmojiWithNoKeyword('1f5fb'),
            createEmojiWithNoKeyword('1f30b'),
            createEmojiWithNoKeyword('1f5fe'),
            createEmoji('1f305'),
            createEmoji('1f304'),
            createEmoji('1f307'),
            createEmoji('1f306'),
            createEmoji('1f303'),
            createEmoji('1f309'),
            createEmoji('1f30c'),
            createEmoji('1f387'),
            createEmoji('1f386'),
            createEmoji('1f308'),
            createEmoji('1f3f0'),
            createEmojiWithNoKeyword('1f3ef'),
            createEmoji('1f5fd'),
            createEmoji('1f3e0'),
            createEmoji('1f3e1'),
            createEmoji('1f3e2'),
            createEmoji('1f3ec'),
            createEmoji('026fa'),
            createEmojiWithNoKeyword('1f3e3'),
            createEmojiWithNoKeyword('1f3e5'),
            createEmoji('1f3e6'),
            createEmoji('1f3e8'),
            createEmoji('1f3ea'),
            createEmoji('1f3eb'),
            createEmojiWithNoKeyword('1f3e9'),
            createEmoji('1f492'),
            createEmoji('026ea'),
            createEmoji('1f320'),
        ],
        _a["Symbols" /* Symbols */] = [
            common3,
            createEmoji('1f49b'),
            createEmoji('1f49a'),
            createEmoji('1f499'),
            createEmoji('1f494'),
            createEmoji('1f49c'),
            createEmoji('1f495'),
            createEmoji('1f493'),
            createEmoji('1f49e'),
            createEmoji('1f497'),
            createEmoji('1f498'),
            createEmoji('1f496'),
            createEmoji('1f49d'),
            createEmoji('1f49f'),
            createEmojiWithNoKeyword('1f52f'),
            createEmojiWithNoKeyword('026ce'),
            createEmoji('02648'),
            createEmoji('02649'),
            createEmoji('0264a'),
            createEmoji('0264b'),
            createEmoji('0264c'),
            createEmoji('0264d'),
            createEmoji('0264e'),
            createEmoji('0264f'),
            createEmoji('02650'),
            createEmoji('02651'),
            createEmoji('02652'),
            createEmoji('02653'),
            createEmojiWithNoKeyword('1f194'),
            createEmojiWithNoKeyword('1f4f4'),
            createEmojiWithNoKeyword('1f4f3'),
            createEmojiWithNoKeyword('1f19a'),
            createEmojiWithNoKeyword('1f4ae'),
            createEmojiWithNoKeyword('1f18e'),
            createEmojiWithNoKeyword('1f191'),
            createEmojiWithNoKeyword('1f198'),
            createEmojiWithNoKeyword('026d4'),
            createEmoji('1f4db'),
            createEmoji('1f6ab'),
            createEmojiWithNoKeyword('0274c'),
            createEmojiWithNoKeyword('02b55'),
            createEmojiWithNoKeyword('1f4a2'),
            createEmoji('02668'),
            createEmojiWithNoKeyword('1f51e'),
            createEmojiWithNoKeyword('02757'),
            createEmojiWithNoKeyword('02755'),
            createEmojiWithNoKeyword('02753'),
            createEmojiWithNoKeyword('02754'),
            createEmojiWithNoKeyword('02049'),
            createEmojiWithNoKeyword('1f4af'),
            createEmoji('1f531'),
            createEmojiWithNoKeyword('0303d'),
            createEmoji('026a0'),
            createEmojiWithNoKeyword('1f530'),
            createEmojiWithNoKeyword('1f22f'),
            createEmojiWithNoKeyword('1f4b9'),
            createEmoji('02733'),
            createEmojiWithNoKeyword('0274e'),
            createEmojiWithNoKeyword('02705'),
            createEmojiWithNoKeyword('1f4a0'),
            createEmoji('1f300'),
            createEmoji('1f3e7'),
            createEmoji('0267f'),
            createEmoji('1f6ad'),
            createEmojiWithNoKeyword('1f6be'),
            createEmoji('02734'),
            createEmoji('1f17f'),
            createEmoji('1f6b9'),
            createEmoji('1f6ba'),
            createEmojiWithNoKeyword('1f6bc'),
            createEmoji('1f6bb'),
            createEmoji('1f3a6'),
            createEmoji('1f4f6'),
            createEmojiWithNoKeyword('1f201'),
            createEmojiWithNoKeyword('1f196'),
            createEmojiWithNoKeyword('0267b'),
            createEmojiWithNoKeyword('1f197'),
            createEmojiWithNoKeyword('1f192'),
            createEmoji('02747'),
            createEmojiWithNoKeyword('1f195'),
            createEmojiWithNoKeyword('1f193'),
            createEmojiWithNoKeyword('1f51f'),
            createEmojiWithNoKeyword('1f522'),
            createEmojiWithNoKeyword('023ea'),
            createEmojiWithNoKeyword('023e9'),
            createEmojiWithNoKeyword('1f53c'),
            createEmojiWithNoKeyword('1f53d'),
            createEmojiWithNoKeyword('023eb'),
            createEmojiWithNoKeyword('023ec'),
            createEmojiWithNoKeyword('1f199'),
            createEmojiWithNoKeyword('02139'),
            createEmojiWithNoKeyword('1f524'),
            createEmojiWithNoKeyword('1f521'),
            createEmojiWithNoKeyword('1f520'),
            createEmojiWithNoKeyword('1f523'),
            createEmoji('1f3b5'),
            createEmoji('1f3b6'),
            createEmojiWithNoKeyword('03030'),
            createEmojiWithNoKeyword('027bf'),
            createEmojiWithNoKeyword('02714'),
            createEmoji('1f503'),
            createEmojiWithNoKeyword('02795'),
            createEmojiWithNoKeyword('02796'),
            createEmojiWithNoKeyword('02797'),
            createEmojiWithNoKeyword('02716'),
            createEmojiWithNoKeyword('027b0'),
            createEmojiWithNoKeyword('1f4b2'),
            createEmojiWithNoKeyword('1f4b1'),
            createEmojiWithNoKeyword('1f51a'),
            createEmojiWithNoKeyword('1f519'),
            createEmojiWithNoKeyword('1f51b'),
            createEmojiWithNoKeyword('1f51d'),
            createEmojiWithNoKeyword('1f51c'),
            createEmojiWithNoKeyword('02611'),
            createEmojiWithNoKeyword('1f518'),
            createEmojiWithNoKeyword('026ab'),
            createEmojiWithNoKeyword('1f534'),
            createEmojiWithNoKeyword('1f535'),
            createEmojiWithNoKeyword('1f539'),
            createEmojiWithNoKeyword('1f538'),
            createEmojiWithNoKeyword('1f536'),
            createEmojiWithNoKeyword('1f537'),
            createEmojiWithNoKeyword('1f53a'),
            createEmojiWithNoKeyword('1f53b'),
            createEmojiWithNoKeyword('02b1b'),
            createEmojiWithNoKeyword('02b1c'),
            createEmojiWithNoKeyword('1f532'),
            createEmojiWithNoKeyword('1f533'),
            createEmojiWithNoKeyword('1f50a'),
            createEmoji('1f4e3'),
            createEmojiWithNoKeyword('1f4e2'),
            createEmoji('1f514'),
            createEmojiWithNoKeyword('1f004'),
            createEmoji('1f0cf'),
            createEmojiWithNoKeyword('1f3b4'),
            createEmojiWithNoKeyword('1f4ac'),
            createEmoji('1f550'),
            createEmoji('1f551'),
            createEmoji('1f552'),
            createEmoji('1f553'),
            createEmoji('1f554'),
            createEmoji('1f555'),
            createEmoji('1f556'),
            createEmoji('1f557'),
            createEmoji('1f558'),
            createEmoji('1f559'),
            createEmoji('1f55a'),
            createEmoji('1f55b'),
            createEmojiWithNoKeyword('1f236'),
            createEmojiWithNoKeyword('1f250'),
            createEmojiWithNoKeyword('1f239'),
            createEmojiWithNoKeyword('1f21a'),
            createEmojiWithNoKeyword('1f232'),
            createEmojiWithNoKeyword('1f251'),
            createEmojiWithNoKeyword('1f234'),
            createEmojiWithNoKeyword('1f233'),
            createEmojiWithNoKeyword('1f23a'),
            createEmojiWithNoKeyword('1f235'),
        ],
        _a["Objects" /* Objects */] = [
            createEmojiWithNoKeyword('0231a'),
            createEmoji('1f4f1'),
            createEmojiWithNoKeyword('1f4f2'),
            createEmoji('1f4bb'),
            createEmojiWithNoKeyword('1f4bd'),
            createEmoji('1f4be'),
            createEmoji('1f4bf'),
            createEmoji('1f4c0'),
            createEmoji('1f4fc'),
            createEmoji('1f4f7'),
            createEmoji('1f4f9'),
            createEmoji('1f3a5'),
            createEmoji('1f4de'),
            createEmojiWithNoKeyword('0260e'),
            createEmoji('1f4df'),
            createEmoji('1f4e0'),
            createEmoji('1f4fa'),
            createEmoji('1f4fb'),
            createEmojiWithNoKeyword('023f0'),
            createEmojiWithNoKeyword('0231b'),
            createEmojiWithNoKeyword('023f3'),
            createEmoji('1f4e1'),
            createEmoji('1f50b'),
            createEmoji('1f50c'),
            createEmoji('1f4a1'),
            createEmoji('1f526'),
            createEmojiWithNoKeyword('1f4b8'),
            createEmoji('1f4b5'),
            createEmoji('1f4b4'),
            createEmoji('1f4b0'),
            createEmoji('1f4b3'),
            createEmoji('1f48e'),
            createEmoji('1f527'),
            createEmoji('1f528'),
            createEmoji('1f529'),
            createEmojiWithNoKeyword('1f52b'),
            createEmoji('1f4a3'),
            createEmoji('1f52a'),
            createEmoji('1f6ac'),
            createEmoji('1f52e'),
            createEmoji('1f488'),
            createEmoji('1f48a'),
            createEmoji('1f489'),
            createEmoji('1f516'),
            createEmoji('1f6bd'),
            createEmoji('1f6c0'),
            createEmoji('1f511'),
            createEmoji('1f6aa'),
            createEmojiWithNoKeyword('1f5ff'),
            createEmoji('1f388'),
            createEmojiWithNoKeyword('1f38f'),
            createEmoji('1f380'),
            createEmoji('1f381'),
            createEmoji('1f38a'),
            createEmoji('1f389'),
            createEmojiWithNoKeyword('1f38e'),
            createEmoji('1f390'),
            createEmojiWithNoKeyword('1f38c'),
            createEmojiWithNoKeyword('1f3ee'),
            createEmoji('02709'),
            createEmoji('1f4e9'),
            createEmoji('1f4e8'),
            createEmoji('1f48c'),
            createEmoji('1f4e7'),
            createEmoji('1f4ee'),
            createEmoji('1f4ea'),
            createEmoji('1f4eb'),
            createEmoji('1f4e6'),
            createEmojiWithNoKeyword('1f4e5'),
            createEmojiWithNoKeyword('1f4e4'),
            createEmojiWithNoKeyword('1f4dc'),
            createEmojiWithNoKeyword('1f4c3'),
            createEmojiWithNoKeyword('1f4d1'),
            createEmoji('1f4ca'),
            createEmoji('1f4c8'),
            createEmoji('1f4c9'),
            createEmojiWithNoKeyword('1f4c4'),
            createEmoji('1f4c5'),
            createEmojiWithNoKeyword('1f4c6'),
            createEmojiWithNoKeyword('1f4c7'),
            createEmoji('1f4cb'),
            createEmoji('1f4c1'),
            createEmojiWithNoKeyword('1f4c2'),
            createEmoji('1f4f0'),
            createEmoji('1f4d3'),
            createEmojiWithNoKeyword('1f4d5'),
            createEmojiWithNoKeyword('1f4d7'),
            createEmojiWithNoKeyword('1f4d8'),
            createEmojiWithNoKeyword('1f4d9'),
            createEmojiWithNoKeyword('1f4d4'),
            createEmoji('1f4d2'),
            createEmoji('1f4da'),
            createEmojiWithNoKeyword('1f4d6'),
            createEmojiWithNoKeyword('1f517'),
            createEmoji('1f4ce'),
            createEmoji('02702'),
            createEmojiWithNoKeyword('1f4d0'),
            createEmoji('1f4cf'),
            createEmoji('1f4cc'),
            createEmoji('1f4cd'),
            createEmojiWithNoKeyword('1f6a9'),
            createEmoji('1f510'),
            createEmoji('1f512'),
            createEmoji('1f513'),
            createEmoji('1f50f'),
            createEmojiWithNoKeyword('02712'),
            createEmoji('1f4dd'),
            createEmoji('0270f'),
            createEmoji('1f50d'),
            createEmojiWithNoKeyword('1f50e'),
        ],
        _a);
    /**
     * @internal
     */
    exports.EmojiFabricIconCharacterMap = (_b = {},
        _b["Activities" /* Activities */] = 'Soccer',
        _b["Food" /* Food */] = 'EatDrink',
        _b["Nature" /* Nature */] = 'FangBody',
        _b["Objects" /* Objects */] = 'Lightbulb',
        _b["People" /* People */] = 'Emoji2',
        _b["Symbols" /* Symbols */] = 'Heart',
        _b["Travel" /* Travel */] = 'Car',
        _b);
    /**
     * @internal
     */
    function forEachEmojiFamily(callback) {
        var families = (0, roosterjs_editor_dom_1.getObjectKeys)(exports.EmojiList);
        for (var _i = 0, families_1 = families; _i < families_1.length; _i++) {
            var family = families_1[_i];
            if (!callback(exports.EmojiList[family], family)) {
                break;
            }
        }
    }
    exports.forEachEmojiFamily = forEachEmojiFamily;
    /**
     * @internal
     */
    function forEachEmoji(callback) {
        forEachEmojiFamily(function (emojis) {
            for (var _i = 0, emojis_1 = emojis; _i < emojis_1.length; _i++) {
                var emoji = emojis_1[_i];
                if (!callback(emoji)) {
                    return false;
                }
            }
            return true;
        });
    }
    exports.forEachEmoji = forEachEmoji;
    // get emoji code point from an emoji key
    function getEmojiCodePoint(key) {
        var unicode = parseInt(key, 16);
        if (isNaN(unicode)) {
            return null;
        }
        // All emojis have codepoints between the following ranges:
        // 0x1F7000 - 0x1F700 -> has surrogate pairs
        // 0x00023 - 0x04000 -> does not have surrogate pairs
        var surrogatePairs;
        if (unicode >= 0x1f000 && unicode <= 0x1f700) {
            var hi = Math.floor((unicode - 0x10000) / 0x400) + 0xd800;
            var lo = ((unicode - 0x10000) % 0x400) + 0xdc00;
            surrogatePairs = [hi, lo];
        }
        else if (unicode >= 0x00023 && unicode <= 0x04000) {
            surrogatePairs = [unicode];
        }
        return String.fromCharCode.apply(String, surrogatePairs);
    }
    function createEmoji(key, shortcut) {
        var _a;
        return {
            key: key,
            description: "emjD" + key,
            keywords: "emjK" + key,
            shortcut: shortcut,
            codePoint: (_a = getEmojiCodePoint(key)) !== null && _a !== void 0 ? _a : undefined,
        };
    }
    function createEmojiWithNoKeyword(key) {
        var _a;
        return { key: key, description: "emjD" + key, codePoint: (_a = getEmojiCodePoint(key)) !== null && _a !== void 0 ? _a : undefined };
    }

    }(emojiList));

    var require$$1 = /*@__PURE__*/getAugmentedNamespace(Tooltip);

    Object.defineProperty(EmojiNavBar$1, "__esModule", { value: true });
    var React$3 = react.exports;
    var Utilities_1$1 = require$$2$2;
    var emojiList_1$2 = emojiList;
    var FocusZone_1 = require$$7;
    var roosterjs_editor_dom_1$1 = lib$3;
    var Icon_1 = require$$5;
    var Tooltip_1$1 = require$$1;
    /**
     * @internal
     */
    function EmojiNavBar(props) {
        var currentSelected = props.currentSelected, getTabId = props.getTabId, _a = props.strings, strings = _a === void 0 ? {} : _a, classNames = props.classNames;
        var keys = (0, roosterjs_editor_dom_1$1.getObjectKeys)(emojiList_1$2.EmojiList);
        var onFamilyClick = function (key) {
            if (props.onClick) {
                props.onClick(key);
            }
        };
        return (
        // for each emoji family key, create a button to use as nav bar
        React$3.createElement("div", { className: classNames.navBar, role: "tablist" },
            React$3.createElement(FocusZone_1.FocusZone, { direction: FocusZone_1.FocusZoneDirection.horizontal }, keys.map(function (key, index) {
                var _a;
                var selected = key === currentSelected;
                var friendlyName = strings[key];
                return (React$3.createElement(Tooltip_1$1.TooltipHost, { hostClassName: classNames.navBarTooltip, content: friendlyName, key: key },
                    React$3.createElement("button", { className: (0, Utilities_1$1.css)(classNames.navBarButton, (_a = {},
                            _a[classNames.selected] = selected,
                            _a)), key: key, onClick: onFamilyClick.bind(onclick, key), id: getTabId === null || getTabId === void 0 ? void 0 : getTabId(key), role: "tab", "aria-selected": selected, "aria-label": friendlyName, "data-is-focusable": "true", "aria-posinset": index + 1, tabIndex: 0, "aria-setsize": keys.length },
                        React$3.createElement(Icon_1.Icon, { iconName: emojiList_1$2.EmojiFabricIconCharacterMap[key] }))));
            }))));
    }
    EmojiNavBar$1.default = EmojiNavBar;

    var EmojiStatusBar$1 = {};

    Object.defineProperty(EmojiStatusBar$1, "__esModule", { value: true });
    var React$2 = react.exports;
    var Tooltip_1 = require$$1;
    var NO_SUGGESTIONS = 'emjDNoSuggetions';
    /**
     * @internal
     * Emoji status bar component
     */
    function EmojiStatusBar(props) {
        var emoji = props.emoji, strings = props.strings, hasResult = props.hasResult, classNames = props.classNames;
        if (!hasResult) {
            var noResultDescription = strings[NO_SUGGESTIONS];
            return (React$2.createElement("div", { className: classNames.statusBar },
                React$2.createElement("div", { style: { display: 'none' }, "aria-live": "polite" }, noResultDescription),
                React$2.createElement("div", { className: classNames.statusBarNoResultDetailsContainer },
                    React$2.createElement(Tooltip_1.TooltipHost, { content: noResultDescription, overflowMode: Tooltip_1.TooltipOverflowMode.Parent },
                        React$2.createElement("span", { role: "alert" }, noResultDescription)))));
        }
        var icon = emoji ? emoji.codePoint : '';
        var description = (emoji === null || emoji === void 0 ? void 0 : emoji.description) ? strings[emoji.description] : '';
        return (React$2.createElement("div", { className: classNames.statusBar },
            React$2.createElement("i", { className: classNames.statusBarIcon, role: "presentation", "aria-hidden": "true" }, icon),
            React$2.createElement("div", { className: classNames.statusBarDetailsContainer },
                React$2.createElement("div", { className: classNames.statusBarDetails },
                    React$2.createElement(Tooltip_1.TooltipHost, { content: description, overflowMode: Tooltip_1.TooltipOverflowMode.Parent }, description)))));
    }
    EmojiStatusBar$1.default = EmojiStatusBar;

    var searchEmojis$1 = {};

    Object.defineProperty(searchEmojis$1, "__esModule", { value: true });
    searchEmojis$1.searchEmojis = void 0;
    var emojiList_1$1 = emojiList;
    /**
     * @internal
     */
    function searchEmojis(search, strings) {
        var shortcutMatch = matchShortcut(search);
        search = search.toLowerCase();
        var fullMatch = shortcutMatch ? [shortcutMatch] : [];
        var partialMatch = [];
        var partialSearch = ' ' + (search[0] == ':' ? search.substr(1) : search);
        (0, emojiList_1$1.forEachEmoji)(function (emoji) {
            var keywords = (emoji.keywords && strings[emoji.keywords]) || '';
            var searchableKeywords = emoji.keywords ? ' ' + keywords.toLowerCase() + ' ' : '';
            var index = searchableKeywords.indexOf(partialSearch);
            if (index >= 0) {
                (searchableKeywords[index + partialSearch.length] == ' '
                    ? fullMatch
                    : partialMatch).push(emoji);
            }
            return true;
        });
        return fullMatch.concat(partialMatch);
    }
    searchEmojis$1.searchEmojis = searchEmojis;
    function matchShortcut(search) {
        var result = null;
        search = ' ' + search + ' ';
        (0, emojiList_1$1.forEachEmoji)(function (emoji) {
            if (emoji.shortcut && (' ' + emoji.shortcut + ' ').indexOf(search) >= 0) {
                result = emoji;
                return false;
            }
            return true;
        });
        return result;
    }

    (function (exports) {
    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.showEmojiPane = exports.EmojiPaneNavigateDirection = exports.EmojiPaneMode = void 0;
    var React = react.exports;
    var EmojiIcon_1 = EmojiIcon$1;
    var EmojiNavBar_1 = EmojiNavBar$1;
    var EmojiStatusBar_1 = EmojiStatusBar$1;
    var Callout_1 = require$$1$1;
    var emojiList_1 = emojiList;
    var Utilities_1 = require$$2$2;
    var FocusZone_1 = require$$7;
    var index_1 = common;
    var TextField_1 = require$$9;
    var Utilities_2 = require$$2$2;
    var Styling_1 = require$$10;
    var searchEmojis_1 = searchEmojis$1;
    var Theme_1 = require$$12;
    // "When a div contains an element that is bigger (either taller or wider) than the parent and has the property
    // overflow-x or overflow-y set to any value, then it can receive the focus."
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1069739
    var TabIndexForFirefoxBug = -1;
    var EmojisPerRow = 7;
    var EmojiVisibleRowCount = 5;
    var EmojiVisibleWithoutNavBarRowCount = 6;
    var EmojiHeightPx = 40;
    var VerticalDirectionKeys = [Utilities_1.KeyCodes.up, Utilities_1.KeyCodes.down];
    var DirectionKeys = [
        Utilities_1.KeyCodes.left,
        Utilities_1.KeyCodes.right,
        Utilities_1.KeyCodes.up,
        Utilities_1.KeyCodes.down,
        Utilities_1.KeyCodes.home,
        Utilities_1.KeyCodes.end,
    ];
    var TooltipCalloutProps = {
        isBeakVisible: true,
        beakWidth: 16,
        gapSpace: 0,
        setInitialFocus: true,
        doNotLayer: false,
        directionalHint: Callout_1.DirectionalHint.bottomCenter,
    };
    (function (EmojiPaneMode) {
        EmojiPaneMode[EmojiPaneMode["Quick"] = 0] = "Quick";
        EmojiPaneMode[EmojiPaneMode["Partial"] = 1] = "Partial";
        EmojiPaneMode[EmojiPaneMode["Full"] = 2] = "Full";
    })(exports.EmojiPaneMode || (exports.EmojiPaneMode = {}));
    (function (EmojiPaneNavigateDirection) {
        EmojiPaneNavigateDirection[EmojiPaneNavigateDirection["Horizontal"] = 0] = "Horizontal";
        EmojiPaneNavigateDirection[EmojiPaneNavigateDirection["Vertical"] = 1] = "Vertical";
    })(exports.EmojiPaneNavigateDirection || (exports.EmojiPaneNavigateDirection = {}));
    var AriaAttributes = {
        ActiveDescendant: 'aria-activedescendant',
        AutoComplete: 'aria-autocomplete',
        Controls: 'aria-controls',
        Expanded: 'aria-expanded',
        HasPopup: 'aria-haspopup',
        Owns: 'aria-owns',
        Pressed: 'aria-pressed',
    };
    var EmojiPane = React.forwardRef(function EmojiPaneFunc(props, ref) {
        var searchBox;
        var emojiBody;
        var input;
        var _a = React.useState(0), index = _a[0], setIndex = _a[1];
        var _b = React.useState(0 /* Quick */), mode = _b[0], setMode = _b[1];
        var _c = React.useState(emojiList_1.CommonEmojis), currentEmojiList = _c[0], setCurrentEmojiList = _c[1];
        var _d = React.useState("People" /* People */), currentFamily = _d[0], setCurrentFamily = _d[1];
        var _e = React.useState(':'), search = _e[0], setSearchString = _e[1];
        var _f = React.useState(''), searchInBox = _f[0], setSearchInBox = _f[1];
        var theme = (0, Theme_1.useTheme)();
        var classNames = getEmojiPaneClassName(theme);
        var listId = "EmojiPane" + props.baseId;
        var navigate = React.useCallback(function (change, direction) {
            if (!direction) {
                direction = 0 /* Horizontal */;
            }
            if (direction === 1 /* Vertical */ && index !== -1) {
                change *= EmojisPerRow;
            }
            var newIndex = index + change;
            var length = currentEmojiList.length;
            if (newIndex >= 0 && newIndex < length) {
                setIndex(newIndex);
                return newIndex;
            }
            return -1;
        }, [index]);
        var normalizeSearchText = React.useCallback(function (text, colonIncluded) {
            if (text == null) {
                return '';
            }
            if (colonIncluded) {
                text = text.substr(1);
            }
            return text.trim();
        }, []);
        var getEmojiElementIdByIndex = React.useCallback(function (index) {
            var emoji = currentEmojiList[index];
            if (emoji) {
                return getEmojiIconId(emoji);
            }
            return null;
        }, [currentEmojiList]);
        var getSelectedEmoji = React.useCallback(function () {
            return currentEmojiList[index];
        }, [currentEmojiList, index]);
        var showFullPicker = React.useCallback(function (fullSearchText) {
            var normalizedSearchValue = normalizeSearchText(fullSearchText, true);
            var newMode = normalizedSearchValue.length === 0 ? 2 /* Full */ : 1 /* Partial */;
            setIndex(newMode === 2 /* Full */ ? -1 : 0);
            setMode(newMode);
            setCurrentEmojiList(getSearchResult(normalizedSearchValue, newMode));
            setSearchString(fullSearchText);
            setSearchInBox(normalizedSearchValue);
        }, [mode]);
        var setSearch = React.useCallback(function (value) {
            var normalizedSearchValue = normalizeSearchText(value, false);
            setIndex(0);
            setCurrentEmojiList(getSearchResult(normalizedSearchValue, mode));
            setSearchString(value);
        }, [index, search, currentEmojiList]);
        var getSearchResult = React.useCallback(function (searchValue, mode) {
            var isQuickMode = mode === 0 /* Quick */;
            if (!searchValue) {
                return isQuickMode ? currentEmojiList : emojiList_1.EmojiList[currentFamily];
            }
            var emojiList = (0, searchEmojis_1.searchEmojis)(searchValue, props.strings);
            return isQuickMode ? emojiList.slice(0, 5).concat([emojiList_1.MoreEmoji]) : emojiList;
        }, [mode, currentFamily, currentEmojiList]);
        var getEmojiIconId = React.useCallback(function (emoji) { return listId + "-" + emoji.key; }, [listId]);
        React.useImperativeHandle(ref, function () { return ({
            navigate: navigate,
            getEmojiElementIdByIndex: getEmojiElementIdByIndex,
            showFullPicker: showFullPicker,
            getSearchResult: getSearchResult,
            setSearch: setSearch,
            getSelectedEmoji: getSelectedEmoji,
            normalizeSearchText: normalizeSearchText,
            getEmojiIconId: getEmojiIconId,
        }); }, [
            navigate,
            getEmojiElementIdByIndex,
            showFullPicker,
            getSearchResult,
            setSearch,
            getEmojiIconId,
            getSelectedEmoji,
            normalizeSearchText,
        ]);
        var renderQuickPicker = function (props, index, currentEmojiList) {
            var strings = props.strings;
            var selectedEmoji = getSelectedEmoji();
            var target = selectedEmoji ? "#" + getEmojiIconId(selectedEmoji) : undefined;
            var content = (selectedEmoji === null || selectedEmoji === void 0 ? void 0 : selectedEmoji.description) ? strings[selectedEmoji.description] : undefined;
            var emojiList = renderCurrentEmojiIcons(index, currentEmojiList);
            // note: we're using a callout since TooltipHost does not support manual trigger, and we need to show the tooltip since quick picker is shown
            // as an autocomplete menu (false focus based on transferring navigation keyboard event)
            return (React.createElement("div", { id: listId, role: "listbox" },
                emojiList,
                React.createElement("div", { id: listId, role: "listbox", className: (0, Utilities_1.css)(classNames.quickPicker, classNames.roosterEmojiPane) },
                    React.createElement(Callout_1.Callout, __assign({}, TooltipCalloutProps, { role: "tooltip", target: target, hidden: !content || !emojiList, className: classNames.tooltip }), content))));
        };
        var renderFullPicker = function (props, index, searchInBox, currentFamily, currentEmojiList) {
            var _a;
            var searchDisabled = props.searchDisabled, searchBoxString = props.searchBoxString;
            var emojiId = getEmojiIconId(getSelectedEmoji());
            var autoCompleteAttributes = (_a = {},
                _a[AriaAttributes.AutoComplete] = 'list',
                _a[AriaAttributes.Expanded] = 'true',
                _a[AriaAttributes.HasPopup] = 'listbox',
                _a[AriaAttributes.Owns] = listId,
                _a);
            if (emojiId) {
                autoCompleteAttributes[AriaAttributes.ActiveDescendant] = emojiId;
            }
            return (React.createElement("div", { className: classNames.roosterEmojiPane },
                !searchDisabled && (React.createElement(TextField_1.TextField, __assign({ role: "combobox", componentRef: function (ref) { return searchRefCallback(ref); }, value: searchInBox, onChange: onSearchChange, inputClassName: classNames.emojiTextInput, onKeyPress: onSearchKeyPress, onKeyDown: onSearchKeyDown, onFocus: onSearchFocus, placeholder: (0, index_1.getLocalizedString)(searchBoxString, 'emojiSearchPlaceholder', 'Search...'), ariaLabel: (0, index_1.getLocalizedString)(searchBoxString, 'emojiSearchInputAriaLabel', 'Search...') }, autoCompleteAttributes))),
                mode === 2 /* Full */
                    ? renderFullList(props, index, currentFamily, currentEmojiList)
                    : renderPartialList(props, index, currentEmojiList)));
        };
        var onSearchFocus = function (e) {
            input = e.target;
        };
        var onSearchKeyPress = function (e) {
            if (!e || e.which !== Utilities_1.KeyCodes.enter) {
                return;
            }
            if (index >= 0 && currentEmojiList && currentEmojiList.length > 0) {
                onSelect(e, currentEmojiList[index]);
            }
        };
        var onSearchKeyDown = function (e) {
            if (!e || DirectionKeys.indexOf(e.which) < 0) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();
            if (e.which === Utilities_1.KeyCodes.home) {
                setIndex(0);
                emojiBody.scrollTop = 0;
                return;
            }
            if (e.which === Utilities_1.KeyCodes.end) {
                setIndex(currentEmojiList.length - 1);
                emojiBody.scrollTop = emojiBody.scrollHeight; // scrollHeight will be larger than max
                return;
            }
            var direction = VerticalDirectionKeys.indexOf(e.which) < 0
                ? 0 /* Horizontal */
                : 1 /* Vertical */;
            var newIndex = navigate(e.which === Utilities_1.KeyCodes.left || e.which === Utilities_1.KeyCodes.up ? -1 : 1, direction);
            if (newIndex > -1) {
                var visibleRowCount = mode === 2 /* Full */
                    ? EmojiVisibleRowCount
                    : EmojiVisibleWithoutNavBarRowCount;
                var currentRow = Math.floor(newIndex / EmojisPerRow);
                var visibleTop = emojiBody.scrollTop;
                var visibleBottom = visibleTop + visibleRowCount * EmojiHeightPx;
                var currentRowTop = currentRow * EmojiHeightPx;
                var currentRowBottom = currentRowTop + EmojiHeightPx;
                if (visibleTop <= currentRowTop && visibleBottom >= currentRowBottom) {
                    return; // row is visible, so exit
                }
                emojiBody.scrollTop = currentRow * EmojiHeightPx;
            }
        };
        var renderCurrentEmojiIcons = function (index, currentEmojiList) {
            var strings = props.strings;
            return currentEmojiList.map(function (emoji, emojiIndex) { return (React.createElement(EmojiIcon_1.default, { strings: strings, id: getEmojiIconId(emoji), key: emoji.key, onMouseOver: function () { return setIndex(emojiIndex); }, onFocus: function () { return setIndex(emojiIndex); }, emoji: emoji, classNames: classNames, isSelected: index === emojiIndex, onClick: function (e) { return onSelect(e, emoji); }, "aria-posinset": index + 1, "aria-setsize": currentEmojiList.length })); });
        };
        var renderPartialList = function (props, index, currentEmojiList) {
            var strings = props.strings, hideStatusBar = props.hideStatusBar, statusBarProps = props.statusBarProps;
            var hasResult = currentEmojiList && currentEmojiList.length > 0;
            return (React.createElement("div", null,
                React.createElement("div", { className: classNames.partialList, "data-is-scrollable": true, tabIndex: TabIndexForFirefoxBug, ref: onEmojiBodyRef },
                    React.createElement(FocusZone_1.FocusZone, { id: listId, role: "listbox", className: classNames.fullListContent, ref: focusZoneRefCallback }, renderCurrentEmojiIcons(index, currentEmojiList))),
                !hideStatusBar && (React.createElement(EmojiStatusBar_1.default, __assign({ classNames: classNames, strings: strings }, statusBarProps, { hasResult: hasResult, emoji: getSelectedEmoji() })))));
        };
        var renderFullList = function (props, index, currentFamily, currentEmojiList) {
            var strings = props.strings, hideStatusBar = props.hideStatusBar, navBarProps = props.navBarProps, statusBarProps = props.statusBarProps;
            var hasResult = currentEmojiList && currentEmojiList.length > 0;
            return (React.createElement("div", { className: classNames.fullList },
                React.createElement("div", { className: classNames.fullListBody, "data-is-scrollable": true, tabIndex: TabIndexForFirefoxBug, ref: onEmojiBodyRef },
                    React.createElement(EmojiNavBar_1.default, __assign({ strings: strings }, navBarProps, { onClick: pivotClick, currentSelected: currentFamily, getTabId: getTabId, classNames: classNames })),
                    React.createElement("div", { role: "tabpanel", "aria-labelledby": getTabId(currentFamily) },
                        React.createElement("div", null,
                            React.createElement(FocusZone_1.FocusZone, { id: listId, role: "listbox", className: classNames.fullListContent, ref: focusZoneRefCallback }, renderCurrentEmojiIcons(index, currentEmojiList))))),
                !hideStatusBar && (React.createElement(EmojiStatusBar_1.default, __assign({ classNames: classNames, strings: strings }, statusBarProps, { hasResult: hasResult, emoji: getSelectedEmoji() })))));
        };
        var onEmojiBodyRef = function (ref) {
            emojiBody = ref;
        };
        var pivotClick = function (selected) {
            var currentFamily = selected;
            setCurrentEmojiList(emojiList_1.EmojiList[currentFamily]);
            setCurrentFamily(currentFamily);
        };
        var getTabId = function (itemKey) {
            return "family_" + itemKey + "_" + props.baseId;
        };
        var searchRefCallback = function (ref) {
            if (ref) {
                searchBox = ref;
                if (searchBox === null || searchBox === void 0 ? void 0 : searchBox.value) {
                    searchBox.focus();
                    searchBox.setSelectionStart(searchBox.value.length);
                }
            }
        };
        var focusZoneRefCallback = function (ref) {
            if (props.searchDisabled && ref) {
                ref.focus();
            }
            if (input) {
                // make sure to announce the active descending after the focus zone containing the emojis is ready
                input.removeAttribute(AriaAttributes.ActiveDescendant);
                var emojiId_1 = getEmojiIconId(getSelectedEmoji());
                // we need to delay so NVDA will announce the first selection
                if (emojiId_1) {
                    setTimeout(function () { return input.setAttribute(AriaAttributes.ActiveDescendant, emojiId_1); }, 0);
                }
            }
        };
        var onSearchChange = function (_, newValue) {
            if (typeof newValue === 'string') {
                var normalizedSearchValue = normalizeSearchText(newValue, false);
                var newMode = normalizedSearchValue.length === 0 ? 2 /* Full */ : 1 /* Partial */;
                setIndex(newMode === 2 /* Full */ ? -1 : 0);
                setCurrentEmojiList(getSearchResult(normalizedSearchValue, mode));
                setSearchInBox(newValue);
                setMode(newMode);
            }
        };
        var onSelect = function (e, emoji) {
            e.stopPropagation();
            e.preventDefault();
            if (props.onSelect) {
                props.onSelect(emoji, search);
            }
        };
        var renderPane = function (props, index, searchInBox, currentFamily, currentEmojiList) {
            return mode === 0 /* Quick */
                ? renderQuickPicker(props, index, currentEmojiList)
                : renderFullPicker(props, index, searchInBox, currentFamily, currentEmojiList);
        };
        return React.createElement(React.Fragment, null, renderPane(props, index, searchInBox, currentFamily, currentEmojiList));
    });
    /**
     * @internal
     * Emoji pane component
     */
    function showEmojiPane(onSelect, strings, paneRef, baseId, searchBoxString) {
        return (React.createElement(EmojiPane, { ref: paneRef, baseId: baseId, searchBoxString: searchBoxString, strings: strings, onSelect: onSelect }));
    }
    exports.showEmojiPane = showEmojiPane;
    var calcMaxHeight = function () {
        var buttonHeight = 40;
        var rowsOfIcons = 6; // including family bar if shown
        var bottomPaddingForContent = 5;
        var maxHeightForContent = rowsOfIcons * buttonHeight + bottomPaddingForContent;
        return maxHeightForContent.toString() + 'px';
    };
    var calcPaneWidth = function () {
        var buttonWidth = 40;
        var pivotItemCount = 7;
        var paneHorizontalPadding = 1;
        var paneWidth = buttonWidth * pivotItemCount + 2 * paneHorizontalPadding;
        return paneWidth.toString() + 'px';
    };
    var getEmojiPaneClassName = (0, Utilities_2.memoizeFunction)(function (theme) {
        var palette = theme.palette;
        return (0, Styling_1.mergeStyleSets)({
            quickPicker: {
                overflowY: 'hidden',
                ':after': {
                    content: '',
                    position: 'absolute',
                    left: '0px',
                    top: '0px',
                    bottom: '0px',
                    right: '0px',
                    zIndex: 1,
                    borderWidth: '1px',
                    borderStyle: 'solid',
                    borderColor: 'rgb(255, 255, 255)',
                    borderImage: 'initial',
                    outline: 'rgb(102, 102, 102) solid 1px',
                },
            },
            tooltip: {
                padding: '8px',
            },
            emojiTextInput: {
                padding: '6px',
            },
            partialList: {
                maxHeight: calcMaxHeight(),
                overflow: 'hidden',
                overflowY: 'scroll',
            },
            fullListContent: {
                width: calcPaneWidth(),
            },
            fullListBody: {
                maxHeight: calcMaxHeight(),
                overflow: 'hidden',
                overflowY: 'scroll',
                height: calcMaxHeight(),
            },
            fullList: {
                position: 'relative',
            },
            roosterEmojiPane: {
                padding: '1px',
                background: palette.white,
            },
            emoji: {
                fontSize: '18px',
                width: '40px',
                height: '40px',
                border: '0',
                position: 'relative',
                background: palette.white,
                transition: 'backgorund 0.5s ease-in-out',
            },
            emojiSelected: {
                background: palette.neutralLight,
            },
            navBar: {
                top: '-1px',
                zIndex: 10,
                position: 'sticky',
            },
            navBarTooltip: {
                display: 'inline-block',
            },
            navBarButton: {
                height: '40px',
                width: '40px',
                border: '0',
                borderBottom: 'solid 1px',
                padding: 0,
                marginBottom: 0,
                display: 'inline-block',
                color: palette.themeDark,
                background: palette.white,
                '&:hover': {
                    cursor: 'default',
                },
            },
            selected: {
                borderBottom: '2px solid',
                borderBottomColor: palette.themeDark,
            },
            statusBar: {
                borderTop: 'solid 1px',
                height: '50px',
                overflow: 'hidden',
                position: 'relative',
                background: palette.white,
            },
            statusBarIcon: {
                padding: '4px',
                fontSize: '25px',
                display: 'inline-block',
                fontStyle: 'normal',
                fontWeight: 'normal',
                lineHeight: '40px',
            },
            statusBarDetailsContainer: {
                padding: '0 4px',
                lineHeight: '50px',
                position: 'absolute',
                display: 'inline-block',
                left: '40px',
                right: '0',
                top: '0',
            },
            statusBarDetails: {
                fontWeight: 'bold',
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
            },
            statusBarNoResultDetailsContainer: {
                lineHeight: '50px',
                position: 'absolute',
                display: 'inline-block',
                top: '0',
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                left: '0',
                padding: '0 8px',
            },
        });
    });

    }(EmojiPane));

    Object.defineProperty(showEmojiCallout$1, "__esModule", { value: true });
    var React$1 = react.exports;
    var Callout_1 = require$$1$1;
    var EmojiPane_1 = EmojiPane;
    var renderReactComponent_1 = renderReactComponent$1;
    var EmojiICallout = React$1.forwardRef(function EmojiCalloutFunc(props, ref) {
        var cursorRect = props.cursorRect, strings = props.strings, onSelectFromPane = props.onSelectFromPane, onHideCallout = props.onHideCallout, searchBoxString = props.searchBoxString, dismiss = props.dismiss, paneRef = props.paneRef, baseId = props.baseId;
        var _a = React$1.useState(true), isCalloutVisible = _a[0], toggleIsCalloutVisible = _a[1];
        React$1.useImperativeHandle(ref, function () { return ({
            dismiss: dismiss,
        }); }, [dismiss]);
        var point = {
            x: cursorRect.left,
            y: (cursorRect.top + cursorRect.bottom) / 2,
        };
        var gap = (cursorRect.bottom - cursorRect.top) / 2 + 5;
        if (!isCalloutVisible) {
            onHideCallout();
        }
        var toogleCallout = React$1.useCallback(function () {
            toggleIsCalloutVisible(false);
            dismiss();
        }, [dismiss]);
        return (React$1.createElement(React$1.Fragment, null, isCalloutVisible && (React$1.createElement(Callout_1.Callout, { target: point, directionalHint: Callout_1.DirectionalHint.bottomAutoEdge, isBeakVisible: false, gapSpace: gap, onDismiss: toogleCallout }, (0, EmojiPane_1.showEmojiPane)(onSelectFromPane, strings, paneRef, baseId, searchBoxString)))));
    });
    /**
     * @internal
     * Enable emoji callout
     */
    function showEmojiCallout(uiUtilities, cursorRect, strings, onSelectFromPane, paneRef, emojiCalloutRef, onHideCallout, baseId, searchBoxString) {
        var disposer = null;
        var onDismiss = function () {
            disposer === null || disposer === void 0 ? void 0 : disposer();
            disposer = null;
        };
        disposer = (0, renderReactComponent_1.renderReactComponent)(uiUtilities, React$1.createElement(EmojiICallout, { ref: emojiCalloutRef, cursorRect: cursorRect, strings: strings, onSelectFromPane: onSelectFromPane, paneRef: paneRef, onHideCallout: onHideCallout, searchBoxString: searchBoxString, baseId: baseId, dismiss: onDismiss }));
    }
    showEmojiCallout$1.default = showEmojiCallout;

    var EmojiStrings = {};

    Object.defineProperty(EmojiStrings, "__esModule", { value: true });
    EmojiStrings.EmojiFamilyStrings = EmojiStrings.EmojiKeywordStrings = EmojiStrings.EmojiDescriptionStrings = void 0;
    /**
     * @internal
     * Emoji Description
     */
    EmojiStrings.EmojiDescriptionStrings = {
        emjDMore: 'More',
        emjDNoSuggetions: 'No suggestions found',
        emjD0270a: 'Raised fist',
        emjD0270b: 'Raised hand',
        emjD0270c: 'Victory hand',
        emjD02764: 'Red heart',
        emjD1f440: 'Eyes',
        emjD1f442: 'Ear',
        emjD1f443: 'Nose',
        emjD1f444: 'Mouth',
        emjD1f445: 'Tongue',
        emjD1f446: 'Up-pointing backhand index finger',
        emjD1f447: 'Down-pointing backhand index finger',
        emjD1f448: 'Left-pointing backhand index finger',
        emjD1f449: 'Right-pointing backhand index finger',
        emjD1f44a: 'Fist bump',
        emjD1f44b: 'Waving hand',
        emjD1f44c: 'OK hand',
        emjD1f44d: 'Thumbs up',
        emjD1f44e: 'Thumbs down',
        emjD1f44f: 'Clapping hands',
        emjD1f450: 'Open hands',
        emjD1f590: 'Raised hand with fingers splayed',
        emjD1f595: 'Middle finger',
        emjD1f596: 'Raised hand with part between middle and ring fingers',
        emjD1f464: 'Bust in silhouette',
        emjD1f466: 'Boy',
        emjD1f467: 'Girl',
        emjD1f468: 'Man',
        emjD1f469: 'Woman',
        emjD1f46a: 'Family',
        emjD1f46b: 'Man and woman holding hands',
        emjD1f46e: 'Police officer',
        emjD1f46f: 'Woman with bunny ears',
        emjD1f470: 'Bride with veil',
        emjD1f471: 'Person with blond hair',
        emjD1f472: 'Man with gua pi mao',
        emjD1f473: 'Man with turban',
        emjD1f474: 'Older man',
        emjD1f475: 'Older woman',
        emjD1f476: 'Baby',
        emjD1f477: 'Construction worker',
        emjD1f481: 'Information desk person',
        emjD1f482: 'Guardsman',
        emjD1f48b: 'Kiss mark',
        emjD1f493: 'Beating heart',
        emjD1f494: 'Broken heart',
        emjD1f495: 'Two hearts',
        emjD1f496: 'Sparkling heart',
        emjD1f497: 'Growing heart',
        emjD1f498: 'Heart with arrow',
        emjD1f499: 'Blue heart',
        emjD1f49a: 'Green heart',
        emjD1f49b: 'Yellow heart',
        emjD1f49c: 'Purple heart',
        emjD1f49d: 'Heart with ribbon',
        emjD1f49e: 'Revolving hearts',
        emjD1f49f: 'Heart decoration',
        emjD1f601: 'Grinning face with smiling eyes',
        emjD1f602: 'Face with tears of joy',
        emjD1f603: 'Smiling face with open mouth',
        emjD1f604: 'Smiling face with open mouth and smiling eyes',
        emjD1f605: 'Smiling face with open mouth and cold sweat',
        emjD1f606: 'Smiling face with open mouth and tightly closed eyes',
        emjD1f607: 'Smiling face with halo',
        emjD1f608: 'Smiling face with horns',
        emjD1f609: 'Winking face',
        emjD1f60a: 'Smiling face with smiling eyes',
        emjD1f60b: 'Face savoring delicious food',
        emjD1f60c: 'Relieved face',
        emjD1f60d: 'Smiling face with heart-shaped eyes',
        emjD1f60e: 'Smiling face with sunglasses',
        emjD1f60f: 'Smirking face',
        emjD1f610: 'Neutral face',
        emjD1f612: 'Unamused face',
        emjD1f613: 'Face with cold sweat',
        emjD1f614: 'Pensive face',
        emjD1f616: 'Confounded face',
        emjD1f618: 'Face throwing a kiss',
        emjD1f61a: 'Kissing face with closed eyes',
        emjD1f61c: 'Face with stuck-out tongue and winking eye',
        emjD1f61d: 'Face with stuck-out tongue and tightly closed eyes',
        emjD1f61e: 'Disappointed face',
        emjD1f620: 'Angry face',
        emjD1f621: 'Pouting face',
        emjD1f622: 'Crying face',
        emjD1f623: 'Persevering face',
        emjD1f624: 'Face with look of triumph',
        emjD1f625: 'Disappointed but relieved face',
        emjD1f628: 'Fearful face',
        emjD1f629: 'Weary face',
        emjD1f62a: 'Sleepy face',
        emjD1f62b: 'Tired face',
        emjD1f62d: 'Loudly crying face',
        emjD1f630: 'Face with open mouth and cold sweat',
        emjD1f631: 'Face screaming in fear',
        emjD1f632: 'Astonished face',
        emjD1f633: 'Flushed face',
        emjD1f635: 'Dizzy face',
        emjD1f636: 'Face without mouth',
        emjD1f637: 'Face with medical mask',
        emjD1f645: 'Face with No Good gesture',
        emjD1f646: 'Face with OK gesture',
        emjD1f647: 'Person bowing deeply',
        emjD1f648: 'See-no-evil monkey',
        emjD1f649: 'Hear-no-evil monkey',
        emjD1f641: 'Slightly frowning face',
        emjD1f642: 'Slightly smiling face',
        emjD1f64a: 'Speak-no-evil monkey',
        emjD1f64b: 'Happy person raising one hand',
        emjD1f64c: 'Person raising both hands in celebration',
        emjD1f64d: 'Person frowning',
        emjD1f64e: 'Person with pouting face',
        emjD1f64f: 'Person with folded hands',
        emjD02600: 'Sun with rays',
        emjD02601: 'Cloud',
        emjD02614: 'Umbrella with rain drops',
        emjD0267b: 'Recycling symbol',
        emjD026c4: 'Snowman without snow',
        emjD026c5: 'Sun behind cloud',
        emjD02728: 'Sparkles',
        emjD02733: 'Eight-spoked asterisk',
        emjD02734: 'Eight-pointed star',
        emjD02744: 'Snowflake',
        emjD02747: 'Sparkle',
        emjD02b50: 'White medium star',
        emjD1f300: 'Cyclone',
        emjD1f301: 'Foggy',
        emjD1f302: 'Closed umbrella',
        emjD1f303: 'Night with stars',
        emjD1f304: 'Sunrise over mountains',
        emjD1f305: 'Sunrise',
        emjD1f306: 'Cityscape at dusk',
        emjD1f307: 'Sunset over buildings',
        emjD1f308: 'Rainbow',
        emjD1f309: 'Bridge at night',
        emjD1f30a: 'Water wave',
        emjD1f30b: 'Volcano',
        emjD1f30c: 'Milky Way',
        emjD1f311: 'New moon',
        emjD1f313: 'First quarter moon',
        emjD1f314: 'Waxing gibbous moon',
        emjD1f315: 'Full moon',
        emjD1f319: 'Crescent moon',
        emjD1f31b: 'First quarter moon with face',
        emjD1f31f: 'Glowing star',
        emjD1f320: 'Shooting star',
        emjD1f330: 'Chestnut',
        emjD1f331: 'Seedling',
        emjD1f334: 'Palm tree',
        emjD1f335: 'Cactus',
        emjD1f337: 'Tulip',
        emjD1f338: 'Cherry blossom',
        emjD1f339: 'Rose',
        emjD1f33a: 'Hibiscus',
        emjD1f33b: 'Sunflower',
        emjD1f33c: 'Blossom',
        emjD1f33d: 'Ear of corn',
        emjD1f33e: 'Ear of rice',
        emjD1f33f: 'Herb',
        emjD1f340: 'Four leaf clover',
        emjD1f341: 'Maple leaf',
        emjD1f342: 'Fallen leaf',
        emjD1f343: 'Leaf fluttering in wind',
        emjD1f344: 'Mushroom',
        emjD1f40c: 'Snail',
        emjD1f40d: 'Snake',
        emjD1f40e: 'Horse',
        emjD1f411: 'Sheep',
        emjD1f412: 'Monkey',
        emjD1f414: 'Chicken',
        emjD1f417: 'Boar',
        emjD1f418: 'Elephant',
        emjD1f419: 'Octopus',
        emjD1f41a: 'Spiral shell',
        emjD1f41b: 'Bug',
        emjD1f41c: 'Ant',
        emjD1f41d: 'Honeybee',
        emjD1f41e: 'Ladybug',
        emjD1f41f: 'Fish',
        emjD1f420: 'Tropical fish',
        emjD1f421: 'Blowfish',
        emjD1f422: 'Turtle',
        emjD1f423: 'Hatching chick',
        emjD1f424: 'Baby chick',
        emjD1f425: 'Front-facing baby chick',
        emjD1f426: 'Bird',
        emjD1f427: 'Penguin',
        emjD1f428: 'Koala',
        emjD1f429: 'Poodle',
        emjD1f42b: 'Bactrian camel',
        emjD1f42c: 'Dolphin',
        emjD1f42d: 'Mouse face',
        emjD1f42e: 'Cow face',
        emjD1f42f: 'Tiger face',
        emjD1f430: 'Rabbit face',
        emjD1f431: 'Cat face',
        emjD1f432: 'Dragon face',
        emjD1f433: 'Spouting whale',
        emjD1f434: 'Horse face',
        emjD1f435: 'Monkey face',
        emjD1f436: 'Dog face',
        emjD1f437: 'Pig face',
        emjD1f438: 'Frog face',
        emjD1f439: 'Hamster face',
        emjD1f43a: 'Wolf face',
        emjD1f43b: 'Bear face',
        emjD1f43c: 'Panda face',
        emjD1f43d: 'Pig nose',
        emjD1f43e: 'Paw prints',
        emjD1f638: 'Grinning cat face with smiling eyes',
        emjD1f639: 'Cat face with tears of joy',
        emjD1f63a: 'Smiling cat face with open mouth',
        emjD1f63b: 'Smiling cat face with heart-shaped eyes',
        emjD1f63c: 'Cat face with wry smile',
        emjD1f63d: 'Kissing cat face with closed eyes',
        emjD1f63e: 'Pouting cat face',
        emjD1f63f: 'Crying cat face',
        emjD1f640: 'Weary cat face',
        emjD0260e: 'Telephone',
        emjD026bd: 'Soccer ball',
        emjD026be: 'Baseball',
        emjD1f004: 'Mahjong tile red dragon',
        emjD1f380: 'Ribbon',
        emjD1f381: 'Wrapped present',
        emjD1f382: 'Birthday cake',
        emjD1f383: 'Jack-o-lantern',
        emjD1f384: 'Christmas tree',
        emjD1f385: 'Father Christmas',
        emjD1f386: 'Fireworks',
        emjD1f387: 'Firework sparkler',
        emjD1f388: 'Balloon',
        emjD1f389: 'Party popper',
        emjD1f38a: 'Confetti ball',
        emjD1f38b: 'Tanabata tree',
        emjD1f38c: 'Crossed flags',
        emjD1f38d: 'Pine decoration',
        emjD1f38e: 'Japanese dolls',
        emjD1f38f: 'Carp streamer',
        emjD1f390: 'Wind chime',
        emjD1f391: 'Moon-viewing ceremony',
        emjD1f392: 'School backpack',
        emjD1f393: 'Graduation cap',
        emjD1f3a0: 'Carousel horse',
        emjD1f3a1: 'Ferris wheel',
        emjD1f3a2: 'Roller coaster',
        emjD1f3a3: 'Fishing pole and fish',
        emjD1f3a4: 'Microphone',
        emjD1f3a5: 'Movie camera',
        emjD1f3a6: 'Cinema',
        emjD1f3a7: 'Headphones',
        emjD1f3a8: 'Artist palette',
        emjD1f3a9: 'Top hat',
        emjD1f3aa: 'Circus tent',
        emjD1f3ab: 'Ticket',
        emjD1f3ac: 'Clapper board',
        emjD1f3ad: 'Performing arts',
        emjD1f3ae: 'Video game',
        emjD1f3af: 'Direct hit',
        emjD1f3b0: 'Slot machine',
        emjD1f3b1: 'Billiards',
        emjD1f3b2: 'Game die',
        emjD1f3b3: 'Bowling',
        emjD1f3b4: 'Flower playing cards',
        emjD1f3b5: 'Musical note',
        emjD1f3b6: 'Multiple musical notes',
        emjD1f3b7: 'Saxophone',
        emjD1f3b8: 'Guitar',
        emjD1f3b9: 'Musical keyboard',
        emjD1f3ba: 'Trumpet',
        emjD1f3bb: 'Violin',
        emjD1f3bc: 'Musical score',
        emjD1f3bd: 'Running shirt with sash',
        emjD1f3be: 'Tennis racquet and ball',
        emjD1f3bf: 'Ski and ski boot',
        emjD1f3c0: 'Basketball and hoop',
        emjD1f3c1: 'Checkered flag',
        emjD1f3c2: 'Snowboarder',
        emjD1f3c3: 'Runner',
        emjD1f3c4: 'Surfer',
        emjD1f3c6: 'Trophy',
        emjD1f3c8: 'American football',
        emjD1f3ca: 'Swimmer',
        emjD1f478: 'Princess',
        emjD1f479: 'Japanese ogre',
        emjD1f47a: 'Japanese goblin',
        emjD1f47b: 'Ghost',
        emjD1f47c: 'Baby angel',
        emjD1f47d: 'Extraterrestrial alien',
        emjD1f47e: 'Alien monster',
        emjD1f47f: 'Imp',
        emjD1f480: 'Skull',
        emjD1f483: 'Dancer',
        emjD1f484: 'Lipstick',
        emjD1f485: 'Nail polish',
        emjD1f486: 'Face massage',
        emjD1f487: 'Haircut',
        emjD1f488: 'Barber pole',
        emjD1f489: 'Syringe',
        emjD1f48a: 'Pill',
        emjD1f48c: 'Love letter',
        emjD1f48d: 'Ring',
        emjD1f48e: 'Gemstone',
        emjD1f48f: 'Kiss',
        emjD1f490: 'Bouquet',
        emjD1f491: 'Couple with heart',
        emjD1f492: 'Wedding',
        emjD1f4f7: 'Camera',
        emjD1f4f9: 'Video camera',
        emjD1f4fa: 'Television',
        emjD1f4fb: 'Radio',
        emjD1f4fc: 'Videocassette',
        emjD02615: 'Hot beverage',
        emjD02702: 'Scissors',
        emjD02709: 'Envelope',
        emjD0270f: 'Pencil',
        emjD02712: 'Nib',
        emjD1f345: 'Tomato',
        emjD1f346: 'Eggplant',
        emjD1f347: 'Grapes',
        emjD1f348: 'Melon',
        emjD1f349: 'Watermelon',
        emjD1f34a: 'Tangerine',
        emjD1f34c: 'Banana',
        emjD1f34d: 'Pineapple',
        emjD1f34e: 'Red apple',
        emjD1f34f: 'Green apple',
        emjD1f351: 'Peach',
        emjD1f352: 'Cherries',
        emjD1f353: 'Strawberry',
        emjD1f354: 'Hamburger',
        emjD1f355: 'Slice of pizza',
        emjD1f356: 'Meat on bone',
        emjD1f357: 'Poultry leg',
        emjD1f358: 'Rice cracker',
        emjD1f359: 'Rice ball',
        emjD1f35a: 'Cooked rice',
        emjD1f35b: 'Curry and rice',
        emjD1f35c: 'Steaming bowl',
        emjD1f35d: 'Spaghetti',
        emjD1f35e: 'Bread',
        emjD1f35f: 'French fries',
        emjD1f360: 'Roasted sweet potato',
        emjD1f361: 'Dango',
        emjD1f362: 'Oden',
        emjD1f363: 'Sushi',
        emjD1f364: 'Fried shrimp',
        emjD1f365: 'Fish cake with swirl design',
        emjD1f366: 'Soft ice cream',
        emjD1f367: 'Shaved ice',
        emjD1f368: 'Ice cream',
        emjD1f369: 'Doughnut',
        emjD1f36a: 'Cookie',
        emjD1f36b: 'Chocolate bar',
        emjD1f36c: 'Candy',
        emjD1f36d: 'Lollipop',
        emjD1f36e: 'Custard',
        emjD1f36f: 'Honey pot',
        emjD1f370: 'Shortcake',
        emjD1f371: 'Bento box',
        emjD1f372: 'Pot of food',
        emjD1f373: 'Cooking',
        emjD1f374: 'Fork and knife',
        emjD1f375: 'Teacup without handle',
        emjD1f376: 'Sake bottle and cup',
        emjD1f377: 'Wine glass',
        emjD1f378: 'Cocktail glass',
        emjD1f379: 'Tropical drink',
        emjD1f37a: 'Beer mug',
        emjD1f37b: 'Clinking beer mugs',
        emjD1f451: 'Crown',
        emjD1f452: "Woman's hat",
        emjD1f453: 'Eyeglasses',
        emjD1f454: 'Necktie',
        emjD1f455: 'T-shirt',
        emjD1f456: 'Jeans',
        emjD1f457: 'Dress',
        emjD1f458: 'Kimono',
        emjD1f459: 'Bikini',
        emjD1f45a: "Woman's clothes",
        emjD1f45b: 'Purse',
        emjD1f45c: 'Handbag',
        emjD1f45d: 'Pouch',
        emjD1f45e: "Man's shoe",
        emjD1f45f: 'Athletic shoe',
        emjD1f460: 'High-heeled shoe',
        emjD1f461: "Woman's sandal",
        emjD1f462: "Woman's boots",
        emjD1f463: 'Footprints',
        emjD1f4ba: 'Seat',
        emjD1f4bb: 'Personal computer',
        emjD1f4bc: 'Briefcase',
        emjD1f4bd: 'Minidisc',
        emjD1f4be: 'Floppy disk',
        emjD1f4bf: 'Optical disc',
        emjD1f4c0: 'DVD',
        emjD1f4c1: 'File folder',
        emjD1f4c2: 'Open file folder',
        emjD1f4c3: 'Page with curl',
        emjD1f4c4: 'Page facing up',
        emjD1f4c5: 'Calendar',
        emjD1f4c6: 'Tear-off calendar',
        emjD1f4c7: 'Card index',
        emjD1f4c8: 'Chart with upward trend',
        emjD1f4c9: 'Chart with downward trend',
        emjD1f4ca: 'Bar chart',
        emjD1f4cb: 'Clipboard',
        emjD1f4cc: 'Pushpin',
        emjD1f4cd: 'Round pushpin',
        emjD1f4ce: 'Paper clip',
        emjD1f4cf: 'Straight ruler',
        emjD1f4d0: 'Triangular ruler',
        emjD1f4d1: 'Bookmark tabs',
        emjD1f4d2: 'Ledger',
        emjD1f4d3: 'Notebook',
        emjD1f4d4: 'Notebook with decorative cover',
        emjD1f4d5: 'Closed book',
        emjD1f4d6: 'Open book',
        emjD1f4d7: 'Green book',
        emjD1f4d8: 'Blue book',
        emjD1f4d9: 'Orange book',
        emjD1f4da: 'Books',
        emjD1f4db: 'Name badge',
        emjD1f4dc: 'Scroll',
        emjD1f4dd: 'Memo',
        emjD1f4de: 'Telephone receiver',
        emjD1f4df: 'Pager',
        emjD1f4e0: 'Fax machine',
        emjD1f4e1: 'Satellite antenna',
        emjD1f4e2: 'Public address loudspeaker',
        emjD1f4e3: 'Cheering megaphone',
        emjD1f4e4: 'Outbox tray',
        emjD1f4e5: 'Inbox tray',
        emjD1f4e6: 'Package',
        emjD1f4e7: 'Email',
        emjD1f4e8: 'Incoming envelope',
        emjD1f4e9: 'Envelope with downward-facing arrow above',
        emjD1f4ea: 'Closed mailbox with lowered flag',
        emjD1f4eb: 'Closed mailbox with raised flag',
        emjD1f4ee: 'Postbox',
        emjD1f4f0: 'Newspaper',
        emjD1f4f1: 'Mobile phone',
        emjD1f4f2: 'Mobile phone with right-facing arrow at left',
        emjD1f4f3: 'Vibration mode',
        emjD1f4f4: 'Mobile phone off',
        emjD1f4f6: 'Antenna with bars',
        emjD1f525: 'Fire',
        emjD1f526: 'Flashlight',
        emjD1f527: 'Wrench',
        emjD1f528: 'Hammer',
        emjD1f529: 'Nut and bolt',
        emjD1f52a: 'Hocho',
        emjD1f52b: 'Pistol',
        emjD1f52e: 'Crystal ball',
        emjD1f52f: 'Six-pointed star with middle dot',
        emjD1f531: 'Trident emblem',
        emjD1f550: "Clock face one o'clock",
        emjD1f551: "Clock face two o'clock",
        emjD1f552: "Clock face three o'clock",
        emjD1f553: "Clock face four o'clock",
        emjD1f554: "Clock face five o'clock",
        emjD1f555: "Clock face six o'clock",
        emjD1f556: "Clock face seven o'clock",
        emjD1f557: "Clock face eight o'clock",
        emjD1f558: "Clock face nine o'clock",
        emjD1f559: "Clock face ten o'clock",
        emjD1f55a: "Clock face eleven o'clock",
        emjD1f55b: "Clock face twelve o'clock",
        emjD02668: 'Hot springs',
        emjD0267f: 'Wheelchair',
        emjD02693: 'Anchor',
        emjD026a0: 'Warning',
        emjD026a1: 'High Voltage',
        emjD026d4: 'No Entry',
        emjD026ea: 'Church',
        emjD026f2: 'Fountain',
        emjD026f3: 'Flag in hole',
        emjD026f5: 'Sailboat',
        emjD026fa: 'Tent',
        emjD026fd: 'Fuel pump',
        emjD02708: 'Airplane',
        emjD1f17f: 'Squared Latin capital letter P',
        emjD1f3e0: 'House building',
        emjD1f3e1: 'House with garden',
        emjD1f3e2: 'Office building',
        emjD1f3e3: 'Japanese post office',
        emjD1f3e5: 'Hospital',
        emjD1f3e6: 'Bank',
        emjD1f3e7: 'Automated teller machine',
        emjD1f3e8: 'Hotel',
        emjD1f3e9: 'Love hotel',
        emjD1f3ea: 'Convenience store',
        emjD1f3eb: 'School',
        emjD1f3ec: 'Department store',
        emjD1f3ed: 'Factory',
        emjD1f3ee: 'Izakaya lantern',
        emjD1f3ef: 'Japanese castle',
        emjD1f3f0: 'European castle',
        emjD1f530: 'Japanese symbol for beginner',
        emjD1f680: 'Rocket',
        emjD1f683: 'Railway car',
        emjD1f684: 'High-speed train',
        emjD1f685: 'High-speed train with bullet nose',
        emjD1f687: 'Metro',
        emjD1f689: 'Station',
        emjD1f68c: 'Bus',
        emjD1f68f: 'Bus stop',
        emjD1f691: 'Ambulance',
        emjD1f692: 'Fire engine',
        emjD1f693: 'Police car',
        emjD1f695: 'Taxi',
        emjD1f697: 'Automobile',
        emjD1f699: 'Recreational vehicle',
        emjD1f69a: 'Delivery truck',
        emjD1f6a2: 'Ship',
        emjD1f6a4: 'Speedboat',
        emjD1f6a5: 'Horizontal traffic light',
        emjD1f6a7: 'Construction',
        emjD1f6a8: "Police car's revolving light",
        emjD1f6a9: 'Triangular flag on post',
        emjD1f6aa: 'Door',
        emjD1f6ab: 'No entry',
        emjD1f6ac: 'Smoking symbol',
        emjD1f6ad: 'No smoking symbol',
        emjD1f6b2: 'Bicycle',
        emjD1f6b6: 'Pedestrian',
        emjD1f6b9: "Men's symbol",
        emjD1f6ba: "Women's symbol",
        emjD1f6bb: 'Restroom',
        emjD1f6bc: 'Baby symbol',
        emjD1f6bd: 'Toilet',
        emjD1f6be: 'Water closet',
        emjD1f6c0: 'Bath',
        emjD02049: 'Exclamation question mark',
        emjD02139: 'Information source',
        emjD021a9: 'Left-facing arrow with hook',
        emjD021aa: 'Right-facing arrow with hook',
        emjD0231a: 'Watch',
        emjD0231b: 'Hourglass',
        emjD023e9: 'Right-pointing double triangle',
        emjD023ea: 'Left-pointing double triangle',
        emjD023eb: 'Up-pointing double triangle',
        emjD023ec: 'Down-pointing double triangle',
        emjD023f0: 'Alarm clock',
        emjD023f3: 'Hourglass with flowing sand',
        emjD024c2: 'Circled Latin capital letter M',
        emjD025b6: 'Black right-pointing triangle',
        emjD025c0: 'Black left-pointing triangle',
        emjD025fb: 'White medium square',
        emjD025fc: 'Black medium square',
        emjD026ce: 'Ophiuchus',
        emjD02611: 'Ballot box with check',
        emjD0261d: 'White up-pointing index',
        emjD02648: 'Aries',
        emjD02649: 'Taurus',
        emjD0264a: 'Gemini',
        emjD0264b: 'Cancer',
        emjD0264c: 'Leo',
        emjD0264d: 'Virgo',
        emjD0264e: 'Libra',
        emjD0264f: 'Scorpio',
        emjD02650: 'Sagittarius',
        emjD02651: 'Capricorn',
        emjD02652: 'Aquarius',
        emjD02653: 'Pisces',
        emjD026aa: 'Medium white circle',
        emjD026ab: 'Medium black circle',
        emjD02705: 'White heavy check mark',
        emjD02714: 'Heavy check mark',
        emjD02716: 'Heavy multiplication x',
        emjD0274c: 'Cross mark',
        emjD0274e: 'Squared cross mark',
        emjD02753: 'question mark ornament',
        emjD02754: 'White question mark ornament',
        emjD02755: 'White exclamation mark ornament',
        emjD02757: 'Heavy exclamation mark',
        emjD02795: 'Heavy plus sign',
        emjD02796: 'Heavy minus sign',
        emjD02797: 'Heavy division sign',
        emjD027a1: 'Black right-facing arrow',
        emjD027b0: 'Curly loop',
        emjD027bf: 'Double curly loop',
        emjD02934: 'Arrow pointing right then curving upward',
        emjD02935: 'Arrow pointing right then curving downward',
        emjD02b05: 'Black arrow pointing left',
        emjD02b06: 'Black arrow pointing right',
        emjD02b07: 'Downwards black arrow',
        emjD02b1b: 'Black large square',
        emjD02b1c: 'White large square',
        emjD02b55: 'Heavy large circle',
        emjD03030: 'Wavy dash',
        emjD0303d: 'Part alternation mark',
        emjD03297: 'Circled Ideograph congratulation',
        emjD03299: 'Circled Ideograph secret',
        emjD1f0cf: 'Playing card Joker',
        emjD1f170: 'Squared Latin capital letter A',
        emjD1f171: 'Squared Latin capital letter B',
        emjD1f17e: 'Squared Latin capital letter O',
        emjD1f18e: 'Squared AB',
        emjD1f191: 'Squared CL',
        emjD1f192: 'Squared COOL',
        emjD1f193: 'Squared FREE',
        emjD1f194: 'Squared ID',
        emjD1f195: 'Squared NEW',
        emjD1f196: 'Squared NG',
        emjD1f197: 'Squared OK',
        emjD1f198: 'Squared SOS',
        emjD1f199: 'Squared UP!',
        emjD1f19a: 'Squared VS',
        emjD1f201: 'Squared Katakana Koko',
        emjD1f202: 'Squared Katakana Sa',
        emjD1f21a: 'Squared CJK Unified Ideograph-7121',
        emjD1f22f: 'Squared CJK Unified Ideograph-6307',
        emjD1f232: 'Squared CJK Unified Ideograph-7981',
        emjD1f233: 'Squared CJK Unified Ideograph-7a7a',
        emjD1f234: 'Squared CJK Unified Ideograph-5408',
        emjD1f235: 'Squared CJK Unified Ideograph-6e80',
        emjD1f236: 'Squared CJK Unified Ideograph-6709',
        emjD1f237: 'Squared CJK Unified Ideograph-6708',
        emjD1f238: 'Squared CJK Unified Ideograph-7533',
        emjD1f239: 'Squared CJK Unified Ideograph-5272',
        emjD1f23a: 'Squared CJK Unified Ideograph-55b6',
        emjD1f250: 'Circled Ideograph advantage',
        emjD1f251: 'Circled Ideograph accept',
        emjD1f30f: 'Earth globe Asia-Australia',
        emjD1f4a0: 'Diamond shape with a dot inside',
        emjD1f4a1: 'Electric light bulb',
        emjD1f4a2: 'Anger',
        emjD1f4a3: 'Bomb',
        emjD1f4a4: 'Sleeping',
        emjD1f4a5: 'Collision',
        emjD1f4a6: 'Splashing sweat',
        emjD1f4a7: 'Droplet',
        emjD1f4a8: 'Dash',
        emjD1f4a9: 'Pile of poo',
        emjD1f4aa: 'Flexed biceps',
        emjD1f4ab: 'Dizzy',
        emjD1f4ac: 'Speech balloon',
        emjD1f4ae: 'White flower',
        emjD1f4af: 'Hundred points',
        emjD1f4b0: 'Money bag',
        emjD1f4b1: 'Currency exchange',
        emjD1f4b2: 'Heavy dollar sign',
        emjD1f4b3: 'Credit card',
        emjD1f4b4: 'Banknote with yen sign',
        emjD1f4b5: 'Banknote with dollar sign',
        emjD1f4b8: 'Money with wings',
        emjD1f4b9: 'Chart with upwards trend and yen sign',
        emjD1f503: 'Clockwise downward and upward open circle arrows',
        emjD1f50a: 'Speaker with three sound waves',
        emjD1f50b: 'Battery',
        emjD1f50c: 'Electric plug',
        emjD1f50d: 'Left-leaning magnifying glass',
        emjD1f50e: 'Right-leaning magnifying glass',
        emjD1f50f: 'Lock with ink pen',
        emjD1f510: 'Closed lock with key',
        emjD1f511: 'Key',
        emjD1f512: 'Lock',
        emjD1f513: 'Open lock',
        emjD1f514: 'Bell',
        emjD1f516: 'Bookmark',
        emjD1f517: 'Link',
        emjD1f518: 'Radio button',
        emjD1f519: 'Back with left-facing arrow above',
        emjD1f51a: 'End with left-facing arrow above',
        emjD1f51b: 'On with exclamation mark with left right arrow above',
        emjD1f51c: 'Soon with right-facing arrow above',
        emjD1f51d: 'Top with upward arrow above',
        emjD1f51e: 'No one under eighteen',
        emjD1f51f: 'Keycap ten',
        emjD1f520: 'Input Latin uppercase',
        emjD1f521: 'Input Latin lowercase',
        emjD1f522: 'Input numbers',
        emjD1f523: 'Input symbols',
        emjD1f524: 'Input Latin letters',
        emjD1f532: 'Black square button',
        emjD1f533: 'White square button',
        emjD1f534: 'Large red circle',
        emjD1f535: 'Large blue circle',
        emjD1f536: 'Large orange diamond',
        emjD1f537: 'Large blue diamond',
        emjD1f538: 'Small orange diamond',
        emjD1f539: 'Small blue diamond',
        emjD1f53a: 'Up-pointing red triangle',
        emjD1f53b: 'Down-pointing red triangle',
        emjD1f53c: 'Up-pointing small red triangle',
        emjD1f53d: 'Down-pointing small red triangle',
        emjD1f5fb: 'Mount Fuji',
        emjD1f5fc: 'Tokyo Tower',
        emjD1f5fd: 'Statue of Liberty',
        emjD1f5fe: 'Silhouette of Japan',
        emjD1f5ff: 'Moyai',
    };
    /**
     * @internal
     * Emoji Keywords
     */
    EmojiStrings.EmojiKeywordStrings = {
        emjK1f607: 'saint angel innocent',
        emjK1f47c: 'cherub angel',
        emjK1f34e: 'apple',
        emjK1f34f: 'apple',
        emjK1f477: 'construction',
        emjK1f6a7: 'construction detour',
        emjK1f491: 'couple engaged married marry marriage',
        emjK1f46b: 'couple engaged',
        emjK1f622: 'crying sad',
        emjK1f62d: 'crying sad',
        emjK1f525: 'fire',
        emjK1f692: 'fire truck fire engine',
        emjK1f386: 'fireworks sparkler july 4th',
        emjK1f387: 'fireworks sparkler july 4th',
        emjK1f44a: 'punch fist pump chuck norris bam',
        emjK0270a: 'fist pump punch',
        emjK1f498: 'heart love cupid',
        emjK1f496: 'heart love',
        emjK1f497: 'love heart',
        emjK1f493: 'heart love heartbeat',
        emjK1f368: 'ice cream dessert treat sundae sweets',
        emjK1f366: 'ice cream dessert treat sweets',
        emjK1f48b: 'kiss xoxo love kisses kissing mwah',
        emjK1f444: 'kiss mouth',
        emjK1f618: 'kiss love kisses kissing',
        emjK1f61a: 'kiss love kisses kissing smooch',
        emjK1f48f: 'kiss love',
        emjK1f435: 'monkey',
        emjK1f64a: 'monkey speak no evil',
        emjK1f649: 'monkey hear no evil',
        emjK1f648: 'monkey see no evil',
        emjK1f3b6: 'music melody song singing tune jingle',
        emjK1f3b5: 'music musical note melody musical',
        emjK1f44c: 'ok okay perfect',
        emjK1f646: 'ok awesome',
        emjK1f621: 'pouting sad pout',
        emjK1f64e: 'pouting sad depressed',
        emjK1f60c: 'relieved phew whew relief',
        emjK1f630: 'relieved phew whew',
        emjK1f605: 'relieved phew whew sheesh',
        emjK1f380: 'ribbon',
        emjK1f381: 'gift present presents ribbon',
        emjK1f613: 'scared yikes scary uh oh',
        emjK1f631: 'scared yikes fear whoa',
        emjK1f629: 'scared anxious uncertain unsure',
        emjK1f628: 'scared fearful',
        emjK1f45e: 'shoe shoes',
        emjK1f45f: 'shoe shoes',
        emjK1f60a: 'smile happy smiling yay',
        emjK1f642: 'smile happy smiling',
        emjK1f603: 'smiling happy excited woo woohoo woot',
        emjK1f604: 'smiling happy grin excited',
        emjK1f6bd: 'toilet bathroom potty restroom washroom',
        emjK1f6ba: 'toilet bathroom',
        emjK1f6b9: 'toilet bathroom',
        emjK1f684: 'train light rail monorail',
        emjK1f683: 'train caboose',
        emjK1f446: 'up click',
        emjK0261d: 'up',
        emjK1f64b: 'wave hi bye hey aloha',
        emjK1f44b: 'wave hi bye waving high five',
        emjK1f601: 'happy grin lol funny grinning hehe',
        emjK1f602: 'happy lol funny joy lmao rofl',
        emjK1f606: 'lol haha laughing lmao',
        emjK1f609: 'haha winking wink winky',
        emjK1f60f: 'haha winking wink smirking smirk heh',
        emjK1f645: 'bad',
        emjK1f44e: 'bad thumbs down wrong boo',
        emjK1f60d: 'love love you loving love u',
        emjK1f495: 'love hearts',
        emjK1f44d: 'ok thumbs up',
        emjK1f610: 'ok umm',
        emjK1f620: 'mad angry grrr',
        emjK1f612: 'mad angry unamused not funny amused bleh blah',
        emjK1f47b: 'scared halloween ghost boo',
        emjK1f480: 'scared skull danger die death poison',
        emjK1f47e: 'scared monster',
        emjK1f365: 'rice ball fish cake',
        emjK1f61e: 'disappointed sad',
        emjK1f64d: 'disappointed sad frown',
        emjK1f494: 'heartbroken sorrow sad broken heart brokenhearted',
        emjK1f625: 'relieved phew',
        emjK1f62b: 'sleepy tired yawn',
        emjK1f4a4: 'sleepy tired sleep zzz',
        emjK1f62a: 'sleepy tired',
        emjK1f632: 'wow astonished',
        emjK1f633: 'wow flushed',
        emjK1f3c4: 'wave surf surfer surfers surfs surfing',
        emjK1f44f: 'yay clapping applause clap',
        emjK1f64c: 'yay celebrate',
        emjK1f48d: 'ring marry fiance engaged engage engagement ring engagement diamond ring bling',
        emjK1f483: 'party dancer dance dancing',
        emjK1f389: 'party fun congratulations celebrate congrats',
        emjK1f388: 'party fun balloon',
        emjK1f38a: 'party confetti surprise',
        emjK1f383: 'happy halloween trick treat halloween pumpkin',
        emjK1f385: 'merry christmas santa claus father xmas',
        emjK1f384: 'merry christmas tree happy holidays',
        emjK1f3eb: 'school college study teacher learn studying',
        emjK1f392: 'backpack school bag back pack',
        emjK1f41f: 'fish goldfish',
        emjK1f3a3: 'fish fishing fishing pole',
        emjK1f3a5: 'video camera film movie movie camera',
        emjK1f4f9: 'video camera',
        emjK1f3a6: 'theatre theater cinema',
        emjK1f3ad: 'performing arts drama shakespeare theatre theater play actor actress',
        emjK1f3bc: 'treble clef sheet music music musical score',
        emjK1f3b9: 'music piano',
        emjK1f3a7: 'music headphones headphone',
        emjK1f3b7: 'music saxophone sax',
        emjK1f3ba: 'music trumpet',
        emjK1f3b8: 'music guitar',
        emjK1f3bb: 'music violin',
        emjK1f3ac: 'film action movie',
        emjK1f48e: 'diamond stone gem',
        emjK1f3be: 'wimbledon tennis raquet tennis sports racquet',
        emjK1f3c8: 'football superbowl sports nfl',
        emjK1f3bf: 'sports winter ski skiing skis',
        emjK1f3c2: 'sports winter snowboard snowboarder snowboarding snowboards',
        emjK026c4: 'winter snow snowman',
        emjK02744: 'winter snow snowflake snowing snowed christmas xmas blizzard',
        emjK1f3c1: 'race finish nascar',
        emjK1f3c3: 'race run marathon runner sprinting running late',
        emjK1f375: 'tea coffee',
        emjK02615: 'coffee tea',
        emjK1f377: 'alcohol wine',
        emjK1f378: 'alcohol cocktail drinks martini happy hour',
        emjK1f379: 'alcohol tropical drink',
        emjK1f68c: 'bus transit',
        emjK1f687: 'bus transit metro',
        emjK1f43b: 'bear teddy',
        emjK1f43c: 'bear panda',
        emjK1f340: "luck lucky st. patrick's day shamrock",
        emjK1f320: 'luck shooting star wish comet asteroid meteor meteroid',
        emjK1f303: 'skyline starry stars night',
        emjK1f307: 'skyline sunset',
        emjK1f31f: 'star twinkle',
        emjK02747: 'star sparkle glitter',
        emjK1f4b0: 'cash loot',
        emjK1f4b5: 'cash money dollar',
        emjK1f4b4: 'yen money',
        emjK1f4b3: 'money credit debt debit credit card',
        emjK1f60b: 'dinner hungry lunch food yummy yum delicious tasty mmmmm',
        emjK1f60e: 'cool',
        emjK1f614: 'alas thinking sigh',
        emjK1f616: 'confused confounded huh',
        emjK1f61c: 'goofy wassup nyah kidding',
        emjK1f61d: 'gross yuck eww blech',
        emjK1f623: 'persevering',
        emjK1f624: 'triumph congratulations grats congrats yahoo ftw woot wahoo',
        emjK1f635: 'dizzy drunk confused',
        emjK1f636: 'unsure',
        emjK1f637: 'sick flu',
        emjK1f440: 'eyes snoop',
        emjK1f442: 'ear listen',
        emjK1f443: 'nose smell',
        emjK1f445: 'tongue lick taste drool',
        emjK1f447: 'down',
        emjK1f448: 'left',
        emjK1f449: 'right',
        emjK1f64f: 'pray praying prayer',
        emjK0270b: 'hand',
        emjK0270c: 'peace victory',
        emjK1f466: 'boy',
        emjK1f467: 'girl',
        emjK1f468: 'man',
        emjK1f469: 'woman',
        emjK1f46a: 'family',
        emjK1f46e: 'police officer cop',
        emjK1f46f: 'bunny ears costume',
        emjK1f470: 'bride marriage bridezilla',
        emjK1f471: 'blond',
        emjK1f474: 'grandpa old man gramps grandfather',
        emjK1f475: 'grandma old lady old woman grandmother',
        emjK1f476: 'baby kid toddler newborn infant',
        emjK1f382: 'birthday cake happy cake',
        emjK1f390: 'chime',
        emjK1f393: 'graduation college high school graduated graduating graduate grad',
        emjK1f0cf: 'cards card joker blackjack poker',
        emjK1f3a0: 'carousel carnival',
        emjK1f3a1: 'ferris wheel amusement park',
        emjK1f3a2: 'roller coaster',
        emjK1f3a4: 'microphone sing karaoke singing',
        emjK1f3a8: 'paint artist palette artist',
        emjK1f3a9: 'top hat black tie',
        emjK1f3aa: 'circus',
        emjK1f3ab: 'ticket stub ticket stub admission',
        emjK1f3ae: 'xbox video game video games controller',
        emjK1f3af: 'bullseye archery darts arrow',
        emjK1f3b0: 'slot slots machine casino gamble gambling',
        emjK1f3b1: 'pool billiards',
        emjK1f3b2: 'die dice game craps gambling casino gamble',
        emjK1f3b3: 'bowling bowl',
        emjK1f4f7: 'camera picture photo',
        emjK1f4fa: 'tv television',
        emjK1f4fb: 'radio',
        emjK1f4fc: 'videotape videocassette cassette vcr',
        emjK1f478: 'princess',
        emjK1f47d: 'alien ufo',
        emjK1f47f: 'imp pixie loki leprechaun',
        emjK1f484: 'lipstick makeup',
        emjK1f485: 'nail polish manicure',
        emjK1f486: 'massage',
        emjK1f487: 'haircut',
        emjK1f488: 'barber barbershop',
        emjK1f489: 'syringe shot needle',
        emjK1f48a: 'pill pills drug drugs',
        emjK1f48c: 'love letter',
        emjK1f490: 'flowers bouquet love',
        emjK1f492: 'wedding marry church',
        emjK1f3c0: 'basketball bball hoops',
        emjK1f3c6: 'win trophy champions champion',
        emjK1f3ca: 'swim swimmer swimming swims',
        emjK026bd: 'soccer ball',
        emjK026be: 'baseball',
        emjK1f451: 'crown king queen',
        emjK1f453: 'glasses hipster',
        emjK1f454: 'tie',
        emjK1f455: 'tshirt tshirts',
        emjK1f456: 'jeans pants',
        emjK1f457: 'dress',
        emjK1f459: 'bikini bathing suit swimsuit swim',
        emjK1f45b: 'purse',
        emjK1f45c: 'handbag purse',
        emjK1f45d: 'pouch clutch',
        emjK1f461: 'sandal heels heel shoe shoes sandals pumps',
        emjK1f462: 'boots boot',
        emjK1f463: 'footprints barefoot',
        emjK1f4dd: 'memo note',
        emjK1f4de: 'telephone call phone',
        emjK1f4df: 'pager',
        emjK1f4e0: 'fax machine',
        emjK1f4e1: 'satellite antenna',
        emjK1f4e3: 'megaphone cheering',
        emjK1f4e6: 'present package parcel',
        emjK1f4e7: 'email mail',
        emjK1f4ee: 'mail post',
        emjK1f4f0: 'newspaper news',
        emjK1f4f1: 'phone cell call',
        emjK1f4f6: 'wifi signal',
        emjK1f526: 'flashlight',
        emjK1f527: 'wrench',
        emjK1f528: 'hammer hammers',
        emjK1f529: 'nuts bolts',
        emjK1f52a: 'knife',
        emjK1f52e: 'crystal ball clairvoyance clairvoyant psychic mystic',
        emjK1f531: 'trident',
        emjK1f354: 'hamburger fast burger hamburgers burgers food hungry',
        emjK1f355: 'pizza fast food hungry dinner lunch',
        emjK1f356: 'meat dinner lunch hungry food',
        emjK1f357: 'chicken leg turkey leg meat chicken turkey hungry dinner lunch food drumstick',
        emjK1f35a: 'rice dinner hungry lunch food',
        emjK1f35c: 'noodles ramen food dinner lunch',
        emjK1f35d: 'spaghetti dinner noodles food hungry',
        emjK1f35e: 'bread food',
        emjK1f35f: 'fries fast food french fries food',
        emjK1f360: 'potato potatoes vegetable food',
        emjK1f363: 'sushi food maki',
        emjK1f364: 'fried shrimp shrimp seafood food tempura',
        emjK1f369: 'doughnut doughnuts donut donuts food sweets',
        emjK1f36a: 'cookie cookies food sweets',
        emjK1f36b: 'chocolate chocolates candy bar chocolate bar sweets',
        emjK1f36c: 'candy sweet sweets treat',
        emjK1f36d: 'lollipop candy treat sucker',
        emjK1f36e: 'custard',
        emjK1f36f: 'honey pot',
        emjK1f370: 'pie food hungry cake dessert cheesecake shortcake sweets',
        emjK1f371: 'bento box',
        emjK1f372: 'soup pot of food stew',
        emjK1f374: 'food dinner fork knife eat hungry meal restaurant',
        emjK1f376: 'sake alcohol',
        emjK1f37a: 'beer alcohol',
        emjK1f37b: 'cheers beers alcohol',
        emjK1f345: 'food vegetable fruit tomato',
        emjK1f346: 'eggplant food vegetable',
        emjK1f347: 'grapes fruit food',
        emjK1f348: 'melon honeydew food fruit',
        emjK1f349: 'watermelon melon food fruit',
        emjK1f34a: 'tangerine fruit food orange mandarin clementine slice slices',
        emjK1f34c: 'banana fruit food',
        emjK1f34d: 'pineapple fruit food',
        emjK1f351: 'peach peaches fruit food',
        emjK1f352: 'cherry cherries fruit food',
        emjK1f353: 'strawberries stawberry fruit food berry berries',
        emjK1f4ba: 'seat',
        emjK1f4bb: 'pc computer laptop tablet',
        emjK1f4bc: 'briefcase brief case',
        emjK1f4be: 'floppy disk diskette',
        emjK1f4bf: 'cd compact disc',
        emjK1f4c0: 'dvd',
        emjK1f4c1: 'file folder',
        emjK1f4c5: 'calendar',
        emjK1f4cb: 'clipboard',
        emjK1f4cc: 'pushpin',
        emjK1f4cd: 'drawing pin',
        emjK1f4ce: 'paperclip clippy',
        emjK1f4cf: 'ruler measure',
        emjK1f4d2: 'ledger',
        emjK1f4d3: 'notebook',
        emjK1f4da: 'book books',
        emjK1f4db: 'name badge',
        emjK02702: 'scissors cut',
        emjK02709: 'envelope mail',
        emjK0270f: 'pencil',
        emjK1f3e0: 'house home',
        emjK1f3e1: 'garden greenhouse',
        emjK1f3e2: 'office work',
        emjK1f3e6: 'bank',
        emjK1f3e7: 'atm',
        emjK1f3e8: 'hotel motel bed sleep',
        emjK1f3ea: 'convenience store',
        emjK1f3ec: 'department store shopping',
        emjK1f3ed: 'factory',
        emjK1f3f0: 'castle',
        emjK02668: 'hot springs',
        emjK02693: 'anchor',
        emjK026ea: 'church temple',
        emjK026f2: 'fountain',
        emjK026f3: 'golf',
        emjK026f5: 'sailboat sailing sail',
        emjK026fd: 'gas fuel gasoline pump',
        emjK1f6aa: 'door',
        emjK1f6ac: 'smoke smoking',
        emjK1f6ad: 'no smoking',
        emjK1f6b2: 'bike bicycle biking',
        emjK1f6b6: 'walking pedestrian',
        emjK1f6c0: 'bath bathing bathtub tub',
        emjK0267f: 'accessible accessibility wheelchair',
        emjK026a0: 'warning attention caution hazzard',
        emjK026a1: 'high voltage zap lightning',
        emjK1f680: 'rocket spaceship space',
        emjK1f68f: 'bus stop',
        emjK1f693: 'cop police',
        emjK1f695: 'taxi cab',
        emjK1f697: 'car vehicle automobile',
        emjK1f6a2: 'ship cruise ferry yacht cruise travel vacation',
        emjK02708: 'airplane flight airline plane travel vacation',
        emjK1f42d: 'mouse eek mice squeak',
        emjK1f42e: 'cow moo',
        emjK1f42f: 'tiger roar rawr',
        emjK1f430: 'rabbit bunny easter',
        emjK1f431: 'cat kitty kitten meow',
        emjK1f432: 'dragon roar smaug',
        emjK1f433: 'whale moby dick',
        emjK1f434: 'horse',
        emjK1f436: 'dog woof puppy bark doggy',
        emjK1f437: 'pig oink piggy piglet',
        emjK1f438: 'frog croak ribbit',
        emjK1f439: 'hamster guinea pig',
        emjK1f43a: 'wolf howl',
        emjK1f341: 'maple leaf',
        emjK1f344: 'mushroom shroom',
        emjK1f308: 'rainbow love',
        emjK02601: 'cloud gloomy cloudy',
        emjK02614: 'drops raining rain rainy raindrops umbrella',
        emjK02728: 'sparkles twinkle twinkling glitter shiny sparkly glittery',
        emjK1f4a9: 'poop turd shit',
        emjK1f4aa: 'strong work out muscles biceps',
        emjK02648: 'aries zodiac',
        emjK02649: 'taurus zodiac',
        emjK0264a: 'gemini zodiac',
        emjK0264b: 'cancer zodiac',
        emjK0264c: 'leo zodiac',
        emjK0264d: 'virgo zodiac',
        emjK0264e: 'libra zodiac',
        emjK0264f: 'scorpio zodiac',
        emjK02650: 'sagittarius zodiac',
        emjK02651: 'capricorn zodiac',
        emjK02652: 'aquarius zodiac',
        emjK02653: 'pisces zodiac',
        emjK1f411: 'bah sheep',
        emjK1f300: 'cyclone typhoon hurricane',
        emjK1f301: 'foggy',
        emjK1f302: 'umbrella',
        emjK1f304: 'sunrise',
        emjK1f305: 'sunrise',
        emjK1f306: 'dusk',
        emjK1f309: 'bridge night',
        emjK1f30a: 'wave tsunami',
        emjK1f30c: 'milky way night sky galaxy universe',
        emjK1f311: 'moon',
        emjK1f313: 'moon',
        emjK1f314: 'moon',
        emjK1f315: 'moon full',
        emjK1f319: 'moon crescent',
        emjK1f31b: 'moon',
        emjK1f330: 'chestnut',
        emjK1f331: 'seed seedling planting',
        emjK1f334: 'palm tree vacation',
        emjK1f335: 'cactus hot desert',
        emjK1f337: 'tulip flower',
        emjK1f338: 'cherry blossom sakura flower',
        emjK1f339: 'rose love romance flower',
        emjK1f33a: 'hibiscus flower',
        emjK1f33b: 'sunflower',
        emjK1f33c: 'blossom daisy flower',
        emjK1f33d: 'maize corn',
        emjK1f33e: 'rice',
        emjK1f33f: 'herb herbs',
        emjK1f342: 'leaf autumn',
        emjK1f343: 'leaf windy',
        emjK1f358: 'onigiri',
        emjK1f359: 'onigiri',
        emjK1f35b: 'curry katsu',
        emjK1f361: 'dango',
        emjK1f362: 'oden',
        emjK1f373: 'frying cooking',
        emjK1f3bd: 'exercise exercising',
        emjK1f417: 'boar',
        emjK1f418: 'elephant',
        emjK1f419: 'octopus',
        emjK1f41a: 'seashell shell',
        emjK1f41b: 'bug insect centipede millipede',
        emjK1f41c: 'ant ants insect bug',
        emjK1f41d: 'bee bees honeybee honeybees',
        emjK1f41e: 'ladybug ladybugs',
        emjK1f420: 'fish',
        emjK1f421: 'blowfish fish',
        emjK1f422: 'turtle',
        emjK1f423: 'chick easter',
        emjK1f425: 'chick easter',
        emjK1f40c: 'snail slow',
        emjK1f40d: 'snake',
        emjK1f40e: 'horse horsey pony',
        emjK1f412: 'monkey',
        emjK1f414: 'chicken bawk rooster',
        emjK1f429: 'poodle dog',
        emjK1f42b: 'camel desert',
        emjK1f426: 'bird',
        emjK1f427: 'penguin',
        emjK1f42c: 'dolphin',
        emjK1f43d: 'pig pig noise smelly',
        emjK1f43e: 'paw prints paws',
        emjK1f452: 'hat sunday best',
        emjK1f458: 'kimono',
        emjK1f45a: 'clothes',
        emjK1f481: 'information desk support desk',
        emjK1f482: 'guardsman',
        emjK1f499: 'heart',
        emjK1f49a: 'heart',
        emjK1f49b: 'heart',
        emjK1f49c: 'heart',
        emjK1f49d: 'heart love',
        emjK1f49e: 'heart',
        emjK1f49f: 'heart',
        emjK1f4a5: 'collision bang traffic accident crash',
        emjK1f4a3: 'bomb',
        emjK1f4a1: 'light bulb idea',
        emjK1f4a8: 'dash gotta go gotta run',
        emjK1f503: 'reload refresh loading',
        emjK1f50c: 'plug plugged in',
        emjK1f50b: 'battery charged',
        emjK1f50d: 'search searching',
        emjK1f510: 'secure secret',
        emjK1f50f: 'privacy',
        emjK1f511: 'key',
        emjK1f512: 'lock locked',
        emjK1f513: 'unlock unlocked',
        emjK1f516: 'bookmark',
        emjK1f514: 'bell alarm',
        emjK1f550: '1pm 1am early afternoon',
        emjK1f551: '2pm 2am afternoon',
        emjK1f552: '3pm 3am',
        emjK1f553: '4pm 4am',
        emjK1f554: '5pm 5am late afternoon',
        emjK1f555: '6pm 6am',
        emjK1f556: '7pm 7am dinnertime',
        emjK1f557: '8pm 8am morning',
        emjK1f558: '9pm 9am',
        emjK1f559: '10pm 10am bedtime',
        emjK1f55a: '11pm 11am nighttime',
        emjK1f55b: '12pm 12am midnight noon lunchtime',
        emjK1f5fd: 'statue liberty nyc new york city',
        emjK1f638: 'cat grin happy',
        emjK1f639: 'cat rofl lol tears laughter tears joy funny',
        emjK1f63a: 'cat smile',
        emjK1f63b: 'cat love',
        emjK1f63c: 'cat heh',
        emjK1f63d: 'cat kiss kisses',
        emjK1f63e: 'cat pout pouting sad',
        emjK1f63f: 'cat cry cries sad',
        emjK1f4e8: 'incoming message mail email letter',
        emjK1f4e9: 'mail email letter sending send',
        emjK1f4eb: 'mail',
        emjK1f4ea: 'empty mailbox',
        emjK1f6bb: 'restroom toilet washroom bathroom',
        emjK1f6a5: 'traffic traffic light',
        emjK1f6ab: 'no entry no admittance',
        emjK1f689: 'station',
        emjK1f69a: 'delivery truck',
        emjK026fa: 'tent camp camping',
        emjK1f6a8: 'police siren emergency',
        emjK1f17f: 'parking parking spot',
        emjK02733: 'star asterisk',
        emjK02734: 'star',
        emjK02b50: 'star',
        emjK1f4c8: 'chart graph record profits trending up upwards skyrocketed',
        emjK1f4c9: 'chart graph record losses trending down downwards',
        emjK1f4ca: 'chart graph',
        emjK02764: 'love heart',
    };
    /**
     * @internal
     * Emoji Family
     */
    EmojiStrings.EmojiFamilyStrings = {
        People: 'People',
        Nature: 'Nature',
        Activities: 'Activities',
        Food: 'Food',
        Travel: 'Travel',
        Symbols: 'Symbols',
        Objects: 'Objects',
    };

    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    Object.defineProperty(createEmojiPlugin$1, "__esModule", { value: true });
    var showEmojiCallout_1 = showEmojiCallout$1;
    var roosterjs_editor_dom_1 = lib$3;
    var Utilities_1 = require$$2$2;
    var emojiList_1 = emojiList;
    var roosterjs_editor_api_1 = lib$1;
    var EmojiStrings_1 = EmojiStrings;
    var React = react.exports;
    var KEYCODE_COLON = 186;
    var KEYCODE_COLON_FIREFOX = 59;
    // Regex looks for an emoji right before the : to allow contextual search immediately following an emoji
    // MATCHES: 0: :r
    //          1: 
    //          2: :r
    var EMOJI_BEFORE_COLON_REGEX = /([\u0023-\u0039][\u20e3]|[\ud800-\udbff][\udc00-\udfff]|[\u00a9-\u00ae]|[\u2122-\u3299])*([:;][^:]*)/;
    var EmojiPlugin = /** @class */ (function () {
        function EmojiPlugin(searchBoxStrings) {
            var _this = this;
            this.searchBoxStrings = searchBoxStrings;
            this.editor = null;
            this.eventHandledOnKeyDown = false;
            this.canUndoEmoji = false;
            this.isSuggesting = false;
            this.paneRef = React.createRef();
            this.timer = null;
            this.uiUtilities = null;
            this.emojiCalloutRef = React.createRef();
            this.baseId = 0;
            this.onHideCallout = function () { return _this.setIsSuggesting(false); };
            this.onSelectFromPane = function (emoji, wordBeforeCursor) {
                var _a;
                if (emoji === emojiList_1.MoreEmoji) {
                    (_a = _this.paneRef.current) === null || _a === void 0 ? void 0 : _a.showFullPicker(wordBeforeCursor);
                    return;
                }
                _this.insertEmoji(emoji, wordBeforeCursor);
            };
            this.strings = __assign(__assign(__assign({}, EmojiStrings_1.EmojiDescriptionStrings), EmojiStrings_1.EmojiKeywordStrings), EmojiStrings_1.EmojiFamilyStrings);
        }
        EmojiPlugin.prototype.setUIUtilities = function (uiUtilities) {
            this.uiUtilities = uiUtilities;
        };
        EmojiPlugin.prototype.getName = function () {
            return 'Emoji';
        };
        EmojiPlugin.prototype.dispose = function () {
            var _a;
            this.setIsSuggesting(false);
            (_a = this.emojiCalloutRef.current) === null || _a === void 0 ? void 0 : _a.dismiss();
            this.editor = null;
            this.baseId = 0;
        };
        EmojiPlugin.prototype.initialize = function (editor) {
            this.editor = editor;
        };
        EmojiPlugin.prototype.onPluginEvent = function (event) {
            if (event.eventType === 0 /* KeyDown */) {
                this.eventHandledOnKeyDown = false;
                if (this.isSuggesting) {
                    this.onKeyDownSuggestingDomEvent(event);
                }
                else if (event.rawEvent.which === Utilities_1.KeyCodes.backspace && this.canUndoEmoji) {
                    //TODO: 1051
                    // If KeyDown is backspace and canUndoEmoji, call editor undo
                    this.editor.undo();
                    this.handleEventOnKeyDown(event);
                    this.canUndoEmoji = false;
                }
            }
            else if (event.eventType === 2 /* KeyUp */ && !(0, roosterjs_editor_dom_1.isModifierKey)(event.rawEvent)) {
                if (this.isSuggesting) {
                    this.onKeyUpSuggestingDomEvent(event);
                }
                else {
                    this.onKeyUpDomEvent(event);
                }
            }
            else if (event.eventType === 6 /* MouseUp */) {
                //TODO: 1052
                // If MouseUp, the emoji cannot be undone
                this.canUndoEmoji = false;
                this.setIsSuggesting(false);
            }
        };
        /**
         * On KeyDown suggesting DOM event
         * Try to insert emoji is possible
         * Intercept arrow keys to move selection if popup is shown
         */
        EmojiPlugin.prototype.onKeyDownSuggestingDomEvent = function (event) {
            // If key is enter, try insert emoji at selection
            // If key is space and selection is shortcut, try insert emoji
            var _a, _b;
            var wordBeforeCursor = this.getWordBeforeCursor(event);
            switch (event.rawEvent.which) {
                case Utilities_1.KeyCodes.enter:
                    var selectedEmoji = (_a = this.paneRef.current) === null || _a === void 0 ? void 0 : _a.getSelectedEmoji();
                    // check if selection is on the "..." and show full picker if so, otherwise try to apply emoji
                    if (!selectedEmoji ||
                        !wordBeforeCursor ||
                        this.tryShowFullPicker(event, selectedEmoji, wordBeforeCursor)) {
                        break;
                    }
                    else {
                        this.insertEmoji(selectedEmoji, wordBeforeCursor);
                        this.handleEventOnKeyDown(event);
                    }
                    break;
                case Utilities_1.KeyCodes.left:
                case Utilities_1.KeyCodes.right:
                    (_b = this.paneRef.current) === null || _b === void 0 ? void 0 : _b.navigate(event.rawEvent.which === Utilities_1.KeyCodes.left ? -1 : 1);
                    this.handleEventOnKeyDown(event);
                    break;
                case Utilities_1.KeyCodes.escape:
                    this.setIsSuggesting(false);
                    this.handleEventOnKeyDown(event);
            }
        };
        EmojiPlugin.prototype.tryShowFullPicker = function (event, selectedEmoji, wordBeforeCursor) {
            var _a;
            if (selectedEmoji !== emojiList_1.MoreEmoji) {
                return false;
            }
            this.handleEventOnKeyDown(event);
            (_a = this.paneRef.current) === null || _a === void 0 ? void 0 : _a.showFullPicker(wordBeforeCursor);
            return true;
        };
        /**
         * On KeyUp suggesting DOM event
         * If key is character, update search term
         * Otherwise set isSuggesting to false
         */
        EmojiPlugin.prototype.onKeyUpSuggestingDomEvent = function (event) {
            var _a, _b, _c, _d;
            if (this.eventHandledOnKeyDown) {
                return;
            }
            // If this is a character key or backspace
            // Clear the timer as we will either queue a new timer or stop suggesting
            if (this.timer &&
                ((event.rawEvent.key.length === 1 && event.rawEvent.which !== Utilities_1.KeyCodes.space) ||
                    event.rawEvent.which === Utilities_1.KeyCodes.backspace)) {
                (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getDocument().defaultView) === null || _b === void 0 ? void 0 : _b.clearTimeout(this.timer);
                this.timer = null;
                (_c = this.emojiCalloutRef.current) === null || _c === void 0 ? void 0 : _c.dismiss();
            }
            var wordBeforeCursor = this.getWordBeforeCursor(event);
            if (wordBeforeCursor) {
                if (this.paneRef) {
                    (_d = this.paneRef.current) === null || _d === void 0 ? void 0 : _d.setSearch(wordBeforeCursor);
                }
                else {
                    this.setIsSuggesting(false);
                }
            }
            else {
                this.setIsSuggesting(false);
            }
        };
        EmojiPlugin.prototype.onKeyUpDomEvent = function (event) {
            if (this.eventHandledOnKeyDown) {
                return;
            }
            var wordBeforeCursor = this.getWordBeforeCursor(event);
            if ((event.rawEvent.which === KEYCODE_COLON ||
                event.rawEvent.which === KEYCODE_COLON_FIREFOX) &&
                wordBeforeCursor === ':') {
                this.setIsSuggesting(true);
            }
        };
        EmojiPlugin.prototype.getCallout = function () {
            var _a;
            var rangeNode = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor();
            var rect = rangeNode === null || rangeNode === void 0 ? void 0 : rangeNode.getBoundingClientRect();
            if (this.uiUtilities && rect) {
                this.baseId++;
                (0, showEmojiCallout_1.default)(this.uiUtilities, rect, this.strings, this.onSelectFromPane, this.paneRef, this.emojiCalloutRef, this.onHideCallout, this.baseId, this.searchBoxStrings);
            }
        };
        EmojiPlugin.prototype.setIsSuggesting = function (isSuggesting) {
            var _a;
            if (this.isSuggesting === isSuggesting) {
                return;
            }
            this.isSuggesting = isSuggesting;
            if (this.isSuggesting) {
                this.getCallout();
            }
            else if (this.emojiCalloutRef) {
                (_a = this.emojiCalloutRef.current) === null || _a === void 0 ? void 0 : _a.dismiss();
            }
        };
        EmojiPlugin.prototype.insertEmoji = function (emoji, wordBeforeCursor) {
            var _this = this;
            var _a;
            if (!wordBeforeCursor || !this.editor || !emoji.codePoint) {
                return;
            }
            var node = this.editor.getDocument().createElement('span');
            node.innerText = emoji.codePoint;
            this.editor.addUndoSnapshot(function () {
                if (_this.editor) {
                    (0, roosterjs_editor_api_1.replaceWithNode)(_this.editor, wordBeforeCursor, node, true /*exactMatch*/);
                    _this.editor.select(node, -3 /* After */);
                }
            }, undefined /*changeSource*/, true /*canUndoByBackspace*/);
            (_a = this.emojiCalloutRef.current) === null || _a === void 0 ? void 0 : _a.dismiss();
        };
        EmojiPlugin.prototype.getWordBeforeCursor = function (event) {
            var _a;
            var cursorData = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getContentSearcherOfCursor(event);
            var wordBeforeCursor = cursorData ? cursorData.getWordBefore() : null;
            var matches = wordBeforeCursor ? EMOJI_BEFORE_COLON_REGEX.exec(wordBeforeCursor) : null;
            return matches && matches.length > 2 && matches[0] === wordBeforeCursor ? matches[2] : null;
        };
        EmojiPlugin.prototype.handleEventOnKeyDown = function (event) {
            this.eventHandledOnKeyDown = true;
            event.rawEvent.preventDefault();
            event.rawEvent.stopImmediatePropagation();
        };
        return EmojiPlugin;
    }());
    /**
     * Create a new instance of Emoji plugin with FluentUI components.
     */
    function createEmojiPlugin(searchBoxStrings) {
        return new EmojiPlugin(searchBoxStrings);
    }
    createEmojiPlugin$1.default = createEmojiPlugin;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEmojiPlugin = void 0;
    var createEmojiPlugin_1 = createEmojiPlugin$1;
    Object.defineProperty(exports, "createEmojiPlugin", { enumerable: true, get: function () { return createEmojiPlugin_1.default; } });

    }(emoji));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(common, exports);
    __exportStar(rooster, exports);
    __exportStar(ribbon, exports);
    __exportStar(contextMenu, exports);
    __exportStar(pasteOptions, exports);
    __exportStar(colorPicker, exports);
    __exportStar(emoji, exports);

    }(lib$4));

    var UrlPlaceholder = '$url$';

    // import {
    function getToggleablePlugins(initState) {
        var pluginList = initState.pluginList, linkTitle = initState.linkTitle;
        var imageEdit = pluginList.imageEdit
            ? new ImageEdit$3.ImageEdit({
                preserveRatio: initState.forcePreserveRatio
            })
            : null;
        var plugins = {
            contentEdit: pluginList.contentEdit
                ? new ContentEdit$3.ContentEdit(initState.contentEditFeatures)
                : null,
            hyperlink: pluginList.hyperlink
                ? new HyperLink$3.HyperLink((linkTitle === null || linkTitle === void 0 ? void 0 : linkTitle.indexOf(UrlPlaceholder)) >= 0
                    ? function (url) { return linkTitle.replace(UrlPlaceholder, url); }
                    : linkTitle
                        ? function () { return linkTitle; }
                        : undefined)
                : null,
            paste: pluginList.paste ? new Paste$3.Paste() : null,
            watermark: pluginList.watermark
                ? new Watermark$3.Watermark(initState.watermarkText)
                : null,
            imageEdit: imageEdit,
            cutPasteListChain: pluginList.cutPasteListChain
                ? new CutPasteListChain$3.CutPasteListChain()
                : null,
            tableCellSelection: pluginList.tableCellSelection
                ? new TableCellSelection$3.TableCellSelection()
                : null,
            tableResize: pluginList.tableResize ? new TableResize$3.TableResize() : null,
            customReplace: pluginList.customReplace
                ? new CustomReplace$2.CustomReplace()
                : null,
            autoFormat: pluginList.autoFormat ? new AutoFormat$3.AutoFormat() : null,
            listEditMenu: pluginList.contextMenu && pluginList.listEditMenu
                ? contextMenu.createListEditMenuProvider()
                : null,
            imageEditMenu: pluginList.contextMenu && pluginList.imageEditMenu && imageEdit
                ? contextMenu.createImageEditMenuProvider(imageEdit)
                : null,
            tableEditMenu: pluginList.contextMenu && pluginList.tableEditMenu
                ? contextMenu.createTableEditMenuProvider()
                : null,
            contextMenu: pluginList.contextMenu ? contextMenu.createContextMenuPlugin() : null
        };
        return Object.values(plugins);
    }

    function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
    var SvgInclusive = function SvgInclusive(props) {
      return /*#__PURE__*/react.exports.createElement("svg", _extends({
        xmlns: "http://www.w3.org/2000/svg",
        width: 16,
        height: 16
      }, props), /*#__PURE__*/react.exports.createElement("path", {
        d: "M4.89.05a2.483 2.483 0 0 0-.48.173c-.738.347-1.183 1-1.246 1.804A2.178 2.178 0 0 0 5.582 4.34c.55-.059.793-.195 1.68-.934.39-.324.726-.594.738-.594.012 0 .348.27.738.594.887.739 1.13.875 1.68.934a2.179 2.179 0 0 0 2.418-2.309A2.119 2.119 0 0 0 11.59.223 2.332 2.332 0 0 0 10.656 0c-.406 0-.898.156-1.219.387-.117.086-1.14.925-1.382 1.136-.047.043-.11 0-.688-.484A22.42 22.42 0 0 0 6.57.395 2.151 2.151 0 0 0 4.89.05Zm.895.977c.13.051.336.203.82.606.356.293.641.547.637.558-.023.067-1.246 1.04-1.394 1.114-.16.078-.207.086-.52.086-.32 0-.355-.008-.527-.094a1.294 1.294 0 0 1-.59-.602c-.094-.191-.102-.238-.102-.507.004-.372.079-.586.297-.82.16-.177.434-.345.645-.395.183-.047.535-.02.734.054Zm5.418.047c.281.137.512.38.613.637.059.14.07.242.075.476 0 .27-.008.317-.102.508a1.294 1.294 0 0 1-.59.602c-.172.086-.207.094-.527.094-.313 0-.36-.008-.524-.086-.152-.078-1.39-1.07-1.398-1.121 0-.02 1.164-.993 1.29-1.07.179-.122.433-.177.69-.165.204.012.286.035.473.125Zm0 0",
        style: {
          stroke: "none",
          fillRule: "nonzero",
          fill: "#000",
          fillOpacity: 1
        }
      }), /*#__PURE__*/react.exports.createElement("path", {
        d: "M1.078 2.918c-.262.066-.46.18-.66.379-.211.21-.332.433-.387.719-.023.132-.031.976-.023 3.046C.02 9.899.02 9.927.086 10.18c.039.144.121.37.18.5.062.133.59.96 1.171 1.836L2.5 14.109v.758c0 .703.008.77.063.883.039.082.105.148.187.188.117.058.18.062 2.25.062s2.133-.004 2.25-.063a.389.389 0 0 0 .188-.19c.066-.122.066-.157.054-2.364-.012-2.195-.012-2.25-.078-2.5a3.364 3.364 0 0 0-.402-.906c-.067-.106-.614-.676-1.317-1.391-1.328-1.332-1.363-1.36-1.812-1.434a1.38 1.38 0 0 0-.875.145l-.196.105v-1.62c0-1.09-.011-1.677-.035-1.79a1.403 1.403 0 0 0-.386-.699 1.374 1.374 0 0 0-1.313-.375Zm.547.957c.082.04.148.105.188.188.058.117.062.18.062 2.011 0 2.035.008 2.156.164 2.551.168.406.258.516 1.414 1.68.617.625 1.164 1.156 1.215 1.187.121.063.34.059.457-.015.195-.11.273-.364.184-.594-.016-.047-.489-.547-1.047-1.106-.848-.847-1.02-1.035-1.043-1.132a.474.474 0 0 1 .554-.567c.102.02.25.149 1.188 1.086 1.086 1.078 1.289 1.313 1.426 1.625.168.375.176.496.176 2.461v1.813H3.438v-.594c0-.492-.008-.617-.051-.696a95.954 95.954 0 0 0-1.114-1.691c-.586-.879-1.105-1.684-1.156-1.789-.18-.387-.18-.367-.176-3.371 0-3.09-.015-2.883.235-3.035.148-.09.285-.094.449-.012ZM14.266 2.918c-.262.066-.461.18-.66.379a1.326 1.326 0 0 0-.383.695c-.024.11-.036.719-.036 1.79v1.62l-.195-.105a1.394 1.394 0 0 0-.87-.145c-.442.075-.462.09-1.74 1.36-.64.636-1.234 1.246-1.308 1.343-.191.25-.398.696-.488 1.02-.066.262-.066.305-.078 2.508-.012 2.207-.012 2.242.055 2.363.039.086.105.152.187.191.117.06.18.063 2.25.063s2.133-.004 2.25-.063a.397.397 0 0 0 .188-.187c.054-.113.062-.18.062-.883v-.758l1.059-1.593c1.082-1.625 1.164-1.758 1.28-2.102.157-.457.161-.535.161-3.496 0-1.938-.008-2.809-.035-2.926a1.403 1.403 0 0 0-.387-.699 1.374 1.374 0 0 0-1.312-.375Zm.546.957c.083.04.149.105.188.188.063.125.066.156.055 2.96-.012 3.122 0 2.934-.203 3.332-.043.086-.57.891-1.172 1.797l-1.102 1.645-.008.633-.011.633H9.438V13.23c0-1.976.007-2.058.175-2.445.137-.308.344-.543 1.426-1.62.938-.938 1.086-1.067 1.188-1.087a.474.474 0 0 1 .554.567c-.023.097-.195.285-1.043 1.132-.558.559-1.031 1.059-1.047 1.106-.09.23-.011.484.184.594a.535.535 0 0 0 .457.015c.05-.031.598-.562 1.215-1.187 1.156-1.164 1.246-1.274 1.414-1.68.156-.395.164-.516.164-2.555.004-2.133-.008-2.035.238-2.183.149-.09.285-.094.45-.012Zm0 0",
        style: {
          stroke: "none",
          fillRule: "nonzero",
          fill: "#2e77d0",
          fillOpacity: 1
        }
      }));
    };

    // import { inclusiveCheck, InclusiveCheckButtonStringKey } from './inclusive';
    registerIcons({
        icons: {
            InclusiveCheck: react.exports.createElement(SvgInclusive, null)
        }
    });
    var morePlugins = getToggleablePlugins({
        "pluginList": {
            "contentEdit": true,
            "hyperlink": true,
            "paste": true,
            "watermark": false,
            "imageEdit": false,
            "cutPasteListChain": true,
            "tableCellSelection": true,
            "tableResize": true,
            "customReplace": true,
            "listEditMenu": true,
            "imageEditMenu": true,
            "tableEditMenu": true,
            "contextMenu": true,
            "autoFormat": true
        },
        "contentEditFeatures": {
            "autoBullet": true,
            "indentWhenTab": true,
            "outdentWhenShiftTab": true,
            "outdentWhenBackspaceOnEmptyFirstLine": true,
            "outdentWhenEnterOnEmptyLine": true,
            "mergeInNewLineWhenBackspaceOnFirstChar": false,
            "maintainListChain": true,
            "maintainListChainWhenDelete": true,
            "autoNumberingList": true,
            "autoBulletList": true,
            "mergeListOnBackspaceAfterList": true,
            "unquoteWhenBackspaceOnEmptyFirstLine": true,
            "unquoteWhenEnterOnEmptyLine": true,
            "tabInTable": true,
            "upDownInTable": true,
            "indentTableOnTab": true,
            "deleteTableWithBackspace": true,
            "insertLineBeforeStructuredNodeFeature": false,
            "autoLink": true,
            "unlinkWhenBackspaceAfterLink": false,
            "defaultShortcut": true,
            "noCycleCursorMove": true,
            "markdownBold": true,
            "markdownItalic": true,
            "markdownStrikethru": true,
            "markdownInlineCode": true,
            "clickOnEntity": true,
            "escapeFromEntity": true,
            "enterBeforeReadonlyEntity": true,
            "backspaceAfterEntity": true,
            "deleteBeforeEntity": true,
            "moveBetweenDelimitersFeature": true,
            "removeEntityBetweenDelimiters": true,
            "indentWhenTabText": true,
            "outdentWhenTabText": true,
            "autoHyphen": false
        },
        "defaultFormat": {},
        "linkTitle": "Ctrl+Click to follow the link:$url$",
        "watermarkText": "Type content here ...",
        "forcePreserveRatio": false,
        experimentalFeatures: [],
        "isRtl": true
    });
    var commandBarStyles = {
        root: {
            height: '40px',
            paddingBottom: '2px',
            '.ms-OverflowSet-item': {
                height: '32px'
            }
        },
        primarySet: {
            gridGap: '4px',
            minWidth: '32px',
            alignItems: 'center',
            '.ms-Button--commandBar': {
                borderRadius: '4px'
            }
        },
    };
    initializeIcons();
    var PiTextEditor = function (_a) {
        var initData = _a.initData;
        var _b = react.exports.useState(""), content = _b[0], setContent = _b[1];
        // const [state, setState] = React.useState({
        //     editorCreator: null
        // });
        var onUpdate = function (contentdata) {
            console.log(contentdata);
            console.log(content);
            setContent(contentdata);
        };
        react.exports.useEffect(function () {
            console.log('instance');
        }, []);
        var ribbonPlugin = react.exports.useRef(lib$4.createRibbonPlugin());
        var updateContentPlugin = lib$4.createUpdateContentPlugin(lib$4.UpdateMode.OnBlur, onUpdate);
        var buttonsList = lib$4.getButtons(__spreadArray$2([], lib$4.AllButtonKeys, true));
        var allPlugins = __spreadArray$2(__spreadArray$2([], (morePlugins || []), true), [
            ribbonPlugin.current,
            updateContentPlugin,
        ], false);
        return (react.exports.createElement("div", null,
            react.exports.createElement(lib$4.Ribbon, { styles: commandBarStyles, plugin: ribbonPlugin.current, buttons: buttonsList }),
            react.exports.createElement(lib$4.Rooster, { plugins: allPlugins, style: { border: '1px solid rgb(0, 120, 212)', height: 400 }, dir: 'ltr', initialContent: initData })));
    };
    // class PiTextEditorInstance {
    //     public rootElement: HTMLDivElement;
    //     public id: string;
    //     constructor(ele: HTMLDivElement, id: string) {
    //         this.rootElement = ele;
    //         this.id = id;
    //     }
    //     public ribbonPlugin: RibbonPlugin = createRibbonPlugin();
    //     public updateContentPlugin: UpdateContentPlugin = createUpdateContentPlugin(UpdateMode.OnContentChangedEvent, () => { console.log('yes'); });
    //     public buttonsList = getButtons([...AllButtonKeys]) as RibbonButton<RibbonStringKeys>[];
    //     public allPlugins = [
    //         ...(morePlugins || []),
    //         this.ribbonPlugin,
    //         this.updateContentPlugin,
    //     ];
    //     mount() {
    //         ReactDOM.render(<PiTextEditor plugins={this.allPlugins} ribbon={this.ribbonPlugin} buttons={this.buttonsList} />, this.rootElement);
    //     }
    // }
    // function PiTextEditorInstance(ele: HTMLDivElement) {
    //     ReactDOM.render(<PiTextEditor />, ele);
    // };
    // export default PiTextEditorInstance;
    //rootelement
    // config:
    // toolbarOptions
    // plugins
    // onChange
    //

    exports.PiTextEditor = PiTextEditor;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
//# sourceMappingURL=index.min.js.map
